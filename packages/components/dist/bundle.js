import * as Ne from "react";
import we, { createContext as Ve, useContext as ge, Children as at, forwardRef as ma, memo as me, useState as E, useRef as ht, useEffect as h, useMemo as un, isValidElement as di, cloneElement as fi, Component as au, PureComponent as pe, createRef as zn, useId as Kie, useCallback as Jn, useReducer as Jie, useLayoutEffect as Qie, useSyncExternalStore as ese } from "react";
import { Info as Y7, AlertTriangle as tse, XCircle as X7, CheckCircle2 as K7, Loader2 as va, Pause as nse, Play as rse, RefreshCw as J7, Check as RS, ChevronDown as Q7, X as NS, Search as eG, Image as ose, Heading1 as ise, Heading2 as sse, Quote as ase, Bold as lse, Italic as use, Underline as cse, Code as pse, AlignLeft as dse, AlignRight as fse, AlignCenter as hse, AlignJustify as gse, ChevronRight as WE, ChevronLeft as mse, Ellipsis as xj, MapPinned as vse } from "lucide-react";
import { useActionData as FS, useNavigation as tG, useFetchers as nG, useLocation as zS, Link as yse, useNavigate as rG } from "@remix-run/react";
import { InputMask as bse } from "@react-input/mask";
import * as hi from "react-dom";
import il, { createPortal as Un } from "react-dom";
import { AnimatePresence as oG, motion as Df } from "framer-motion";
var hr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function H0(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var HE = { exports: {} }, Vp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lj;
function wse() {
  if (Lj) return Vp;
  Lj = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Vp.Fragment = n, Vp.jsx = a, Vp.jsxs = a, Vp;
}
var $p = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ej;
function Cse() {
  return Ej || (Ej = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var A = f && g[f] || g[v];
      return typeof A == "function" ? A : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), te = 1; te < A; te++)
          G[te - 1] = arguments[te];
        D("error", g, G);
      }
    }
    function D(g, A, G) {
      {
        var te = L.ReactDebugCurrentFrame, ae = te.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function N(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function R(g, A, G) {
      var te = g.displayName;
      if (te)
        return te;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var A = g;
            return V(A) + ".Consumer";
          case a:
            var G = g;
            return V(G._context) + ".Provider";
          case l:
            return R(g, g.render, "ForwardRef");
          case p:
            var te = g.displayName || null;
            return te !== null ? te : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, Z = 0, X, K, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function H() {
      {
        if (Z === 0) {
          X = console.log, K = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, g, {
              value: X
            }),
            info: W({}, g, {
              value: K
            }),
            warn: W({}, g, {
              value: Q
            }),
            error: W({}, g, {
              value: J
            }),
            group: W({}, g, {
              value: P
            }),
            groupCollapsed: W({}, g, {
              value: _
            }),
            groupEnd: W({}, g, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = L.ReactCurrentDispatcher, F;
    function T(g, A, G) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var te = ae.stack.trim().match(/\n( *(at )?)/);
            F = te && te[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, B;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Y();
    }
    function I(g, A) {
      if (!g || q)
        return "";
      {
        var G = B.get(g);
        if (G !== void 0)
          return G;
      }
      var te;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, H();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              te = je;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              te = je;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            te = je;
          }
          g();
        }
      } catch (je) {
        if (je && te && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = te.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var Ue = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", g.displayName)), typeof g == "function" && B.set(g, Ue), Ue;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Lt = g ? g.displayName || g.name : "", vt = Lt ? T(Lt) : "";
      return typeof g == "function" && B.set(g, vt), vt;
    }
    function le(g, A, G) {
      return I(g, !1);
    }
    function he(g) {
      var A = g.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(g, A, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return I(g, he(g));
      if (typeof g == "string")
        return T(g);
      switch (g) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return oe(g.type, A, G);
          case d: {
            var te = g, ae = te._payload, ue = te._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, We = {}, He = L.ReactDebugCurrentFrame;
    function Ie(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(g, A, G, te, ae) {
      {
        var ue = Function.call.bind(Be);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var Oe = Error((te || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = g[se](A, se, te, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Ie(ae), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ce(g) {
      return $e(g);
    }
    function Qe(g) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function lt(g) {
      try {
        return be(g), !1;
      } catch {
        return !0;
      }
    }
    function be(g) {
      return "" + g;
    }
    function Ee(g) {
      if (lt(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(g)), be(g);
    }
    var Ae = L.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, ot, ve;
    ve = {};
    function yt(g) {
      if (Be.call(g, "ref")) {
        var A = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function it(g) {
      if (Be.call(g, "key")) {
        var A = Object.getOwnPropertyDescriptor(g, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function st(g, A) {
      if (typeof g.ref == "string" && Ae.current && A && Ae.current.stateNode !== A) {
        var G = $(Ae.current.type);
        ve[G] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ae.current.type), g.ref), ve[G] = !0);
      }
    }
    function ut(g, A) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function bt(g, A) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var ct = function(g, A, G, te, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function wt(g, A, G, te, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (Ee(G), ie = "" + G), it(A) && (Ee(A.key), ie = "" + A.key), yt(A) && (Oe = A.ref, st(A, ae));
        for (ue in A)
          Be.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && ut(se, fe), Oe && bt(se, fe);
        }
        return ct(g, ie, Oe, ae, te, Ae.current, se);
      }
    }
    var tt = L.ReactCurrentOwner, gt = L.ReactDebugCurrentFrame;
    function rt(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        gt.setExtraStackFrame(G);
      } else
        gt.setExtraStackFrame(null);
    }
    var Ct;
    Ct = !1;
    function pt(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Et() {
      {
        if (tt.current) {
          var g = $(tt.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Ot(g) {
      return "";
    }
    var kt = {};
    function xt(g) {
      {
        var A = Et();
        if (!A) {
          var G = typeof g == "string" ? g : g.displayName || g.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function Pt(g, A) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var G = xt(A);
        if (kt[G])
          return;
        kt[G] = !0;
        var te = "";
        g && g._owner && g._owner !== tt.current && (te = " It was passed a child from " + $(g._owner.type) + "."), rt(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, te), rt(null);
      }
    }
    function Vt(g, A) {
      {
        if (typeof g != "object")
          return;
        if (Ce(g))
          for (var G = 0; G < g.length; G++) {
            var te = g[G];
            pt(te) && Pt(te, A);
          }
        else if (pt(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              pt(se.value) && Pt(se.value, A);
        }
      }
    }
    function mt(g) {
      {
        var A = g.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var te = $(A);
          nt(G, g.props, "prop", te, g);
        } else if (A.PropTypes !== void 0 && !Ct) {
          Ct = !0;
          var ae = $(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ne(g) {
      {
        for (var A = Object.keys(g.props), G = 0; G < A.length; G++) {
          var te = A[G];
          if (te !== "children" && te !== "key") {
            rt(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), rt(null);
            break;
          }
        }
        g.ref !== null && (rt(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var so = {};
    function ao(g, A, G, te, ae, ue) {
      {
        var se = N(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ot();
          Oe ? ie += Oe : ie += Et();
          var de;
          g === null ? de = "null" : Ce(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = wt(g, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Ue = A.children;
          if (Ue !== void 0)
            if (te)
              if (Ce(Ue)) {
                for (var Lt = 0; Lt < Ue.length; Lt++)
                  Vt(Ue[Lt], g);
                Object.freeze && Object.freeze(Ue);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vt(Ue, g);
        }
        if (Be.call(A, "key")) {
          var vt = $(g), je = Object.keys(A).filter(function(wi) {
            return wi !== "key";
          }), Wn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[vt + Wn]) {
            var bi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wn, vt, bi, vt), so[vt + Wn] = !0;
          }
        }
        return g === r ? ne(fe) : mt(fe), fe;
      }
    }
    function gi(g, A, G) {
      return ao(g, A, G, !0);
    }
    function mi(g, A, G) {
      return ao(g, A, G, !1);
    }
    var vi = mi, yi = gi;
    $p.Fragment = r, $p.jsx = vi, $p.jsxs = yi;
  }()), $p;
}
process.env.NODE_ENV === "production" ? HE.exports = wse() : HE.exports = Cse();
var re = HE.exports;
function Ose(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: r.trim(), ...n });
}
const iG = Ve({});
function xse() {
  return ge(iG);
}
function jrt(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === Ose ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ re.jsx(iG.Provider, { value: e, children: /* @__PURE__ */ re.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function Art(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: r.trim(), ...n });
}
function Brt(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: r.trim(), ...n });
}
function Irt(e) {
  const { className: t, ...n } = e, { schema: r } = xse(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ re.jsx(K7, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ re.jsx(X7, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ re.jsx(tse, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ re.jsx(Y7, { className: o, ...n });
  }
}
function by(e, t) {
  return t ? /* @__PURE__ */ re.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function kj(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function oi(e) {
  var t, n;
  return kj(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(kj(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var sG = Symbol.for("immer-nothing"), Pj = Symbol.for("immer-draftable"), ys = Symbol.for("immer-state"), Lse = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ji(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Lse[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var cp = Object.getPrototypeOf;
function kc(e) {
  return !!e && !!e[ys];
}
function Pc(e) {
  var t;
  return e ? aG(e) || Array.isArray(e) || !!e[Pj] || !!((t = e.constructor) != null && t[Pj]) || $0(e) || q0(e) : !1;
}
var Ese = Object.prototype.constructor.toString();
function aG(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = cp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Ese;
}
function wy(e, t) {
  V0(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function V0(e) {
  const t = e[ys];
  return t ? t.type_ : Array.isArray(e) ? 1 : $0(e) ? 2 : q0(e) ? 3 : 0;
}
function VE(e, t) {
  return V0(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function lG(e, t, n) {
  const r = V0(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function kse(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function $0(e) {
  return e instanceof Map;
}
function q0(e) {
  return e instanceof Set;
}
function Xu(e) {
  return e.copy_ || e.base_;
}
function $E(e, t) {
  if ($0(e))
    return new Map(e);
  if (q0(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = aG(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ys];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(cp(e), r);
  } else {
    const r = cp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function US(e, t = !1) {
  return Z0(e) || kc(e) || !Pc(e) || (V0(e) > 1 && (e.set = e.add = e.clear = e.delete = Pse), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => US(r, !0))), e;
}
function Pse() {
  ji(2);
}
function Z0(e) {
  return Object.isFrozen(e);
}
var Sse = {};
function Sc(e) {
  const t = Sse[e];
  return t || ji(0, e), t;
}
var _f;
function uG() {
  return _f;
}
function Mse(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Sj(e, t) {
  t && (Sc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function qE(e) {
  ZE(e), e.drafts_.forEach(Dse), e.drafts_ = null;
}
function ZE(e) {
  e === _f && (_f = e.parent_);
}
function Mj(e) {
  return _f = Mse(_f, e);
}
function Dse(e) {
  const t = e[ys];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Dj(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ys].modified_ && (qE(t), ji(4)), Pc(e) && (e = Cy(t, e), t.parent_ || Oy(t, e)), t.patches_ && Sc("Patches").generateReplacementPatches_(
    n[ys].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Cy(t, n, []), qE(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== sG ? e : void 0;
}
function Cy(e, t, n) {
  if (Z0(t))
    return t;
  const r = t[ys];
  if (!r)
    return wy(
      t,
      (o, i) => _j(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Oy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), wy(
      i,
      (s, l) => _j(e, r, o, s, l, n, a)
    ), Oy(e, o, !1), n && e.patches_ && Sc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function _j(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ji(5), kc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !VE(t.assigned_, r) ? i.concat(r) : void 0, l = Cy(e, o, s);
    if (lG(n, r, l), kc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Pc(o) && !Z0(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Cy(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Oy(e, o);
  }
}
function Oy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && US(t, n);
}
function _se(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : uG(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = WS;
  n && (o = [r], i = Tf);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var WS = {
  get(e, t) {
    if (t === ys)
      return e;
    const n = Xu(e);
    if (!VE(n, t))
      return Tse(e, n, t);
    const r = n[t];
    return e.finalized_ || !Pc(r) ? r : r === QC(e.base_, t) ? (eO(e), e.copy_[t] = YE(r, e)) : r;
  },
  has(e, t) {
    return t in Xu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Xu(e));
  },
  set(e, t, n) {
    const r = cG(Xu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = QC(Xu(e), t), i = o == null ? void 0 : o[ys];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (kse(n, o) && (n !== void 0 || VE(e.base_, t)))
        return !0;
      eO(e), GE(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return QC(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, eO(e), GE(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Xu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ji(11);
  },
  getPrototypeOf(e) {
    return cp(e.base_);
  },
  setPrototypeOf() {
    ji(12);
  }
}, Tf = {};
wy(WS, (e, t) => {
  Tf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Tf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ji(13), Tf.set.call(this, e, t, void 0);
};
Tf.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ji(14), WS.set.call(this, e[0], t, n, e[0]);
};
function QC(e, t) {
  const n = e[ys];
  return (n ? Xu(n) : e)[t];
}
function Tse(e, t, n) {
  var o;
  const r = cG(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function cG(e, t) {
  if (!(t in e))
    return;
  let n = cp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = cp(n);
  }
}
function GE(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && GE(e.parent_));
}
function eO(e) {
  e.copy_ || (e.copy_ = $E(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var jse = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && ji(6), r !== void 0 && typeof r != "function" && ji(7);
      let o;
      if (Pc(t)) {
        const i = Mj(this), a = YE(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? qE(i) : ZE(i);
        }
        return Sj(i, r), Dj(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === sG && (o = void 0), this.autoFreeze_ && US(o, !0), r) {
          const i = [], a = [];
          Sc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ji(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Pc(e) || ji(8), kc(e) && (e = Ase(e));
    const t = Mj(this), n = YE(e, void 0);
    return n[ys].isManual_ = !0, ZE(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ys];
    (!n || !n.isManual_) && ji(9);
    const { scope_: r } = n;
    return Sj(r, t), Dj(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Sc("Patches").applyPatches_;
    return kc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function YE(e, t) {
  const n = $0(e) ? Sc("MapSet").proxyMap_(e, t) : q0(e) ? Sc("MapSet").proxySet_(e, t) : _se(e, t);
  return (t ? t.scope_ : uG()).drafts_.push(n), n;
}
function Ase(e) {
  return kc(e) || ji(10, e), pG(e);
}
function pG(e) {
  if (!Pc(e) || Z0(e))
    return e;
  const t = e[ys];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = $E(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = $E(e, !0);
  return wy(n, (r, o) => {
    lG(n, r, pG(o));
  }), t && (t.finalized_ = !1), n;
}
var bs = new jse(), HS = bs.produce;
bs.produceWithPatches.bind(
  bs
);
bs.setAutoFreeze.bind(bs);
bs.setUseStrictShallowCopy.bind(bs);
bs.applyPatches.bind(bs);
var Tj = bs.createDraft.bind(bs), jj = bs.finishDraft.bind(bs), Bse = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ce.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Ise = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = $t.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Rse = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ye.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, xy = /* @__PURE__ */ new WeakMap(), Ly = /* @__PURE__ */ new WeakMap(), Gd = /* @__PURE__ */ new WeakMap(), dG = /* @__PURE__ */ new WeakMap(), Aj = /* @__PURE__ */ new WeakMap(), Bj = /* @__PURE__ */ new WeakMap(), Ij = /* @__PURE__ */ new WeakMap(), ce = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ce.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ce.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ce.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ce.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ce.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ce.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ce.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ce.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ce.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ce.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ce.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ce.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ce.isAncestor(t, e) && !ce.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ce.equals(i, r) || ce.endsBefore(i, r) || ce.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (ce.equals(a, r) || ce.isAncestor(a, r))
          return null;
        ce.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        ce.equals(s, r) || ce.endsBefore(s, r) ? r[s.length - 1] -= 1 : ce.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ce.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ce.endsBefore(u, r) ? r[u.length - 1] += 1 : ce.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ce.equals(p, d))
          return r;
        if (ce.isAncestor(p, r) || ce.equals(p, r)) {
          var y = d.slice();
          return ce.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else ce.isSibling(p, d) && (ce.isAncestor(d, r) || ce.equals(d, r)) ? ce.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ce.endsBefore(d, r) || ce.equals(d, r) || ce.isAncestor(d, r) ? (ce.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ce.endsBefore(p, r) && (ce.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function jf(e) {
  "@babel/helpers - typeof";
  return jf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jf(e);
}
function Nse(e, t) {
  if (jf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (jf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Fse(e) {
  var t = Nse(e, "string");
  return jf(t) === "symbol" ? t : String(t);
}
function xi(e, t, n) {
  return t = Fse(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Rj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zse = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = et.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of ye.points(t))
          t[l] = $t.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = et.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of ye.points(t))
          t[b] = $t.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = et.get(e, L), D = ce.previous(L), x = et.get(e, D), m = et.parent(e, L), C = L[L.length - 1];
      if (ft.isText(w) && ft.isText(x))
        x.text += w.text;
      else if (!ft.isText(w) && !ft.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(Yo.stringify(w), " ").concat(Yo.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of ye.points(t))
          t[U] = $t.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: N
      } = n;
      if (ce.isAncestor(k, N))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = et.get(e, k), V = et.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var W = ce.transform(k, n), Z = et.get(e, ce.parent(W)), X = W[W.length - 1];
      if (Z.children.splice(X, 0, R), t)
        for (var [K, Q] of ye.points(t))
          t[Q] = $t.transform(K, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = et.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of ye.points(t)) {
          var H = $t.transform(z, n);
          if (t != null && H != null)
            t[M] = H;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of et.texts(e))
              if (ce.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var q = !1;
            O && j && (ce.equals(j[1], J) ? q = !ce.hasPrevious(j[1]) : q = ce.common(O[1], J).length < ce.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Y,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = et.leaf(e, B), he = le.text.slice(0, Y), oe = le.text.slice(Y + I.length);
      if (le.text = he + oe, t)
        for (var [Be, We] of ye.points(t))
          t[We] = $t.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Ie,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var $e = et.get(e, He);
      for (var Ce in nt) {
        if (Ce === "children" || Ce === "text")
          throw new Error('Cannot set the "'.concat(Ce, '" property of nodes!'));
        var Qe = nt[Ce];
        Qe == null ? delete $e[Ce] : $e[Ce] = Qe;
      }
      for (var lt in Ie)
        nt.hasOwnProperty(lt) || delete $e[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: be
      } = n;
      if (be == null)
        t = be;
      else {
        if (t == null) {
          if (!ye.isRange(be))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Yo.stringify(be), " when there is no current selection."));
          t = qp({}, be);
        }
        for (var Ee in be) {
          var Ae = be[Ee];
          if (Ae == null) {
            if (Ee === "anchor" || Ee === "focus")
              throw new Error('Cannot remove the "'.concat(Ee, '" selection property'));
            delete t[Ee];
          } else
            t[Ee] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Re,
        properties: ot
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var ve = et.get(e, ze), yt = et.parent(e, ze), it = ze[ze.length - 1], st;
      if (ft.isText(ve)) {
        var ut = ve.text.slice(0, Re), bt = ve.text.slice(Re);
        ve.text = ut, st = qp(qp({}, ot), {}, {
          text: bt
        });
      } else {
        var ct = ve.children.slice(0, Re), wt = ve.children.slice(Re);
        ve.children = ct, st = qp(qp({}, ot), {}, {
          children: wt
        });
      }
      if (yt.children.splice(it + 1, 0, st), t)
        for (var [tt, gt] of ye.points(t))
          t[gt] = $t.transform(tt, n);
      break;
    }
  }
  return t;
}, Use = {
  transform(e, t) {
    e.children = Tj(e.children);
    var n = e.selection && Tj(e.selection);
    try {
      n = zse(e, n, t);
    } finally {
      e.children = jj(e.children), n ? e.selection = kc(n) ? jj(n) : n : e.selection = null;
    }
  }
}, Wse = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Hse = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, fG = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (oi(r) && oi(o)) {
      if (!fG(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Vse(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Xa(e, t) {
  if (e == null) return {};
  var n = Vse(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var $se = ["anchor", "focus"];
function Nj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qse(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ye = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ye.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ye.edges(e);
    return t;
  },
  equals(e, t) {
    return $t.equals(e.anchor, t.anchor) && $t.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ye.isRange(t)) {
      if (ye.includes(e, t.anchor) || ye.includes(e, t.focus))
        return !0;
      var [n, r] = ye.edges(e), [o, i] = ye.edges(t);
      return $t.isBefore(n, o) && $t.isAfter(r, i);
    }
    var [a, s] = ye.edges(e), l = !1, u = !1;
    return $t.isPoint(t) ? (l = $t.compare(t, a) >= 0, u = $t.compare(t, s) <= 0) : (l = ce.compare(t, a.path) >= 0, u = ce.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Xa(e, $se), [r, o] = ye.edges(e), [i, a] = ye.edges(t), s = $t.isBefore(r, i) ? i : r, l = $t.isBefore(o, a) ? o : a;
    return $t.isBefore(l, s) ? null : qse({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return $t.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return $t.equals(t, n);
  },
  isExpanded(e) {
    return !ye.isCollapsed(e);
  },
  isForward(e) {
    return !ye.isBackward(e);
  },
  isRange(e) {
    return oi(e) && $t.isPoint(e.anchor) && $t.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ye.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return HS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = ye.isCollapsed(r);
        ye.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? ye.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = $t.transform(r.anchor, t, {
        affinity: i
      }), u = $t.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Fj = (e) => oi(e) && et.isNodeList(e.children) && !ee.isEditor(e), dt = {
  isAncestor(e) {
    return oi(e) && et.isNodeList(e.children);
  },
  isElement: Fj,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => dt.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Fj(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Zse = ["children"], Gse = ["text"], zj = /* @__PURE__ */ new WeakMap(), et = {
  ancestor(e, t) {
    var n = et.get(e, t);
    if (ft.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Yo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ce.ancestors(t, n)) {
        var o = et.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ft.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Yo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Yo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = et.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = et.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ce.common(t, n), o = et.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = et.get(e, t);
    if (ee.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Yo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        dt.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (dt.isAncestor(e)) {
      var t = Xa(e, Zse);
      return t;
    } else {
      var t = Xa(e, Gse);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = et.get(e, n); r && !(ft.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ft.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Yo.stringify(e)));
    var n = HS({
      children: e.children
    }, (r) => {
      var [o, i] = ye.edges(t), a = et.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !ye.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!ye.includes(t, s)) {
          var l = et.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ce.equals(s, i.path)) {
          var c = et.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ce.equals(s, o.path)) {
          var p = et.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      ee.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ft.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Yo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ft.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ft.isText(e) || dt.isElement(e) || ee.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = zj.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => et.isNode(r));
    return zj.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = et.get(e, n); r && !(ft.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = et.get(e, t);
    if (!ft.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Yo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ce.levels(t, n)) {
        var o = et.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return dt.isElement(e) && dt.isElementProps(t) && dt.matches(e, t) || ft.isText(e) && ft.isTextProps(t) && ft.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? ce.isBefore(s, i) : ce.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ft.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ce.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = et.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ce.next(s);
          if (et.has(e, c)) {
            s = c, l = et.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = ce.previous(s);
          s = p, l = et.get(e, s);
          continue;
        }
        s = ce.parent(s), l = et.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ce.parent(t), r = et.get(e, n);
    if (ft.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ft.isText(e) ? e.text : e.children.map(et.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        ft.isText(n) && (yield [n, r]);
    }();
  }
};
function Uj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ir(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Uj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Uj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ru = {
  isNodeOperation(e) {
    return ru.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!oi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ce.isPath(e.path) && et.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ce.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ce.isPath(e.path) && oi(e.properties);
      case "move_node":
        return ce.isPath(e.path) && ce.isPath(e.newPath);
      case "remove_node":
        return ce.isPath(e.path) && et.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ce.isPath(e.path);
      case "set_node":
        return ce.isPath(e.path) && oi(e.properties) && oi(e.newProperties);
      case "set_selection":
        return e.properties === null && ye.isRange(e.newProperties) || e.newProperties === null && ye.isRange(e.properties) || oi(e.properties) && oi(e.newProperties);
      case "split_node":
        return ce.isPath(e.path) && typeof e.position == "number" && oi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ru.isOperation(t));
  },
  isSelectionOperation(e) {
    return ru.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ru.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Ir(Ir({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Ir(Ir({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Ir(Ir({}, e), {}, {
          type: "split_node",
          path: ce.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ce.equals(t, n))
          return e;
        if (ce.isSibling(n, t))
          return Ir(Ir({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ce.transform(n, e), o = ce.transform(ce.next(n), e);
        return Ir(Ir({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Ir(Ir({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Ir(Ir({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Ir(Ir({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Ir(Ir({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Ir(Ir({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Ir(Ir({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Ir(Ir({}, e), {}, {
          type: "merge_node",
          path: ce.next(e.path)
        });
    }
  }
}, Wj = /* @__PURE__ */ new WeakMap(), Yse = (e) => {
  var t = Wj.get(e);
  if (t !== void 0)
    return t;
  if (!oi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || oi(e.marks)) && (e.selection === null || ye.isRange(e.selection)) && et.isNodeList(e.children) && ru.isOperationList(e.operations);
  return Wj.set(e, n), n;
}, ee = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Yse(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, Xse = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ce.isPath);
  }
};
function Hj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $t = {
  compare(e, t) {
    var n = ce.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return $t.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return $t.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ce.equals(e.path, t.path);
  },
  isPoint(e) {
    return oi(e) && typeof e.offset == "number" && ce.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return HS(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ce.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ce.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ce.equals(t.path, i) && (r.offset += t.position), r.path = ce.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ce.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ce.equals(t.path, i) || ce.isAncestor(t.path, i))
            return null;
          r.path = ce.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ce.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = ce.transform(i, t, Vj(Vj({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ce.transform(i, t, n);
          break;
        }
      }
    });
  }
}, $j = void 0, Yo = {
  setScrubber(e) {
    $j = e;
  },
  stringify(e) {
    return JSON.stringify(e, $j);
  }
}, Kse = ["text"], Jse = ["anchor", "focus"];
function qj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ka(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ft = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Xa(i, Kse);
      return a;
    }
    return fG(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return oi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ft.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ka({}, e)];
    for (var r of t) {
      var o = Xa(r, Jse), [i, a] = ye.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = ka(ka({}, f), {}, {
            text: f.text.slice(L)
          }), f = ka(ka({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = ka(ka({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ka(ka({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, VS = (e) => e.selection ? e.selection : e.children.length > 0 ? ee.end(e, []) : [0], wp = (e, t) => {
  var [n] = ee.node(e, t);
  return (r) => r === n;
}, $S = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? oae(t) : t, i = St.None, a = St.None, s = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = mae(c, p);
    if ([i, a] = r ? [a, d] : [d, i], Jc(i, St.ZWJ) && Jc(a, St.ExtPict) && (r ? l = Zj(t.substring(0, s)) : l = Zj(t.substring(0, t.length - s)), !l) || Jc(i, St.RI) && Jc(a, St.RI) && (u !== null ? u = !u : r ? u = !0 : u = Cae(t.substring(0, t.length - s)), !u) || i !== St.None && a !== St.None && yae(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, Qse = /\s/, eae = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, tae = /['\u2018\u2019]/, nae = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = $S(t, n), [a, s] = qS(t, i, n);
    if (rae(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, qS = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, rae = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (Qse.test(t))
    return !1;
  if (tae.test(t)) {
    var o = $S(n, r), [i, a] = qS(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !eae.test(t);
}, oae = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (sae(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (iae(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, iae = (e) => e >= 55296 && e <= 56319, sae = (e) => e >= 56320 && e <= 57343, St;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(St || (St = {}));
var aae = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, lae = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, uae = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, cae = /^[\u1100-\u115F\uA960-\uA97C]$/, pae = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, dae = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, fae = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, hae = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, gae = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, mae = (e, t) => {
  var n = St.Any;
  return e.search(aae) !== -1 && (n |= St.Extend), t === 8205 && (n |= St.ZWJ), t >= 127462 && t <= 127487 && (n |= St.RI), e.search(lae) !== -1 && (n |= St.Prepend), e.search(uae) !== -1 && (n |= St.SpacingMark), e.search(cae) !== -1 && (n |= St.L), e.search(pae) !== -1 && (n |= St.V), e.search(dae) !== -1 && (n |= St.T), e.search(fae) !== -1 && (n |= St.LV), e.search(hae) !== -1 && (n |= St.LVT), e.search(gae) !== -1 && (n |= St.ExtPict), n;
};
function Jc(e, t) {
  return (e & t) !== 0;
}
var vae = [
  // GB6
  [St.L, St.L | St.V | St.LV | St.LVT],
  // GB7
  [St.LV | St.V, St.V | St.T],
  // GB8
  [St.LVT | St.T, St.T],
  // GB9
  [St.Any, St.Extend | St.ZWJ],
  // GB9a
  [St.Any, St.SpacingMark],
  // GB9b
  [St.Prepend, St.Any],
  // GB11
  [St.ZWJ, St.ExtPict],
  // GB12 and GB13
  [St.RI, St.RI]
];
function yae(e, t) {
  return vae.findIndex((n) => Jc(e, n[0]) && Jc(t, n[1])) === -1;
}
var bae = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, Zj = (e) => e.search(bae) !== -1, wae = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, Cae = (e) => {
  var t = e.match(wae);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, Oae = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    ee.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = VS(e)
      } = n;
      if (ce.isPath(o) && (o = ee.range(e, o)), ye.isRange(o))
        if (ye.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ye.end(o);
          if (!r && ee.void(e, {
            at: i
          }))
            return;
          var a = ye.start(o), s = ee.pointRef(e, a), l = ee.pointRef(e, i);
          Fe.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Fe.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && ee.void(e, {
        at: o
      }) || ee.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function Gj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Gj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Gj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fe = Dg(Dg(Dg(Dg({}, Use), Wse), Hse), Oae), ry = /* @__PURE__ */ new WeakMap(), xae = (e) => ry.get(e) || !1, Lae = (e, t, n) => {
  var r = ry.get(e) || !1;
  ry.set(e, !0);
  try {
    t(), n();
  } finally {
    ry.set(e, r);
  }
};
function hG(e, t, n) {
  var r = xy.get(e) || [], o = Ly.get(e) || /* @__PURE__ */ new Set(), i, a, s = (p) => {
    if (p) {
      var d = p.join(",");
      a.has(d) || (a.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  xy.set(e, i), Ly.set(e, a);
}
var Eae = (e, t) => {
  for (var n of ee.pathRefs(e))
    Bse.transform(n, t);
  for (var r of ee.pointRefs(e))
    Ise.transform(r, t);
  for (var o of ee.rangeRefs(e))
    Rse.transform(o, t);
  if (!xae(e)) {
    var i = ce.operationCanTransformPath(t) ? (a) => ce.transform(a, t) : void 0;
    hG(e, e.getDirtyPaths(t), i);
  }
  Fe.transform(e, t), e.operations.push(t), ee.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), Gd.get(e) || (Gd.set(e, !0), Promise.resolve().then(() => {
    Gd.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, kae = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ce.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ce.levels(o), a = ft.isText(r) ? [] : Array.from(et.nodes(r), (N) => {
        var [, R] = N;
        return o.concat(R);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, l = ce.ancestors(s), u = ce.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (ce.equals(c, p))
        return [];
      var d = [], y = [];
      for (var f of ce.ancestors(c)) {
        var v = ce.transform(f, t);
        d.push(v);
      }
      for (var b of ce.ancestors(p)) {
        var L = ce.transform(b, t);
        y.push(L);
      }
      var w = y[y.length - 1], D = p[p.length - 1], x = w.concat(D);
      return [...d, ...y, x];
    }
    case "remove_node": {
      var {
        path: m
      } = t, C = ce.ancestors(m);
      return [...C];
    }
    case "split_node": {
      var {
        path: S
      } = t, U = ce.levels(S), k = ce.next(S);
      return [...U, k];
    }
    default:
      return [];
  }
}, Pae = (e) => {
  var {
    selection: t
  } = e;
  return t ? et.fragment(e, t) : [];
}, Sae = (e, t) => {
  var [n, r] = t;
  if (!ft.isText(n)) {
    if (dt.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      Fe.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = ee.isEditor(n) ? !1 : dt.isElement(n) && (e.isInline(n) || n.children.length === 0 || ft.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = et.get(e, r);
      if (!ft.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], p = s === n.children.length - 1, d = ft.isText(u) || dt.isElement(u) && e.isInline(u);
        if (d !== i)
          Fe.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (dt.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !ft.isText(c)) {
              var y = {
                text: ""
              };
              Fe.insertNodes(e, y, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (p) {
              var f = {
                text: ""
              };
              Fe.insertNodes(e, f, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!ft.isText(u) && !("children" in u)) {
            var v = u;
            v.children = [];
          }
          c != null && ft.isText(c) && (ft.equals(u, c, {
            loose: !0
          }) ? (Fe.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? (Fe.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && (Fe.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, Mae = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, Dae = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = ee.path(t, i), l = o === "lowest";
    for (var [u, c] of ee.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!ft.isText(u)) {
        if (ye.isRange(i)) {
          if (ce.isAncestor(c, i.anchor.path) && ce.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ce.equals(s, c))
          return [u, c];
      }
  }
};
function Yj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _ae = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!ft.isText(p))
        return !1;
      var [y, f] = ee.parent(e, d);
      return !e.isVoid(y) || e.markableVoid(y);
    }, i = ye.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = ee.node(e, r);
      if (s && o(s, l)) {
        var [u] = ee.parent(e, l);
        a = u && e.markableVoid(u);
      }
    }
    if (i || a)
      Fe.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = Xj(Xj({}, ee.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, Gd.get(e) || e.onChange();
    }
  }
};
function Kj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Kj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Kj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tae = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.point(t, n, {
    edge: "end"
  }), i = ee.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of ee.positions(t, Jj(Jj({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function Qj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qj(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jae = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.start(t, []), i = ee.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of ee.positions(t, eA(eA({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, Aae = (e, t) => {
  var {
    selection: n
  } = e;
  n && ye.isCollapsed(n) && Fe.delete(e, {
    unit: t,
    reverse: !0
  });
}, Bae = (e, t) => {
  var {
    selection: n
  } = e;
  n && ye.isCollapsed(n) && Fe.delete(e, {
    unit: t
  });
}, Iae = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && ye.isExpanded(r) && Fe.delete(t, {
    reverse: n === "backward"
  });
}, Rae = (e, t) => [ee.start(e, t), ee.end(e, t)];
function tA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tA(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nae = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return ee.above(t, nA(nA({}, n), {}, {
    match: (r) => dt.isElement(r) && ee.isElementReadOnly(t, r)
  }));
}, Fae = (e, t) => ee.point(e, t, {
  edge: "end"
}), zae = (e, t) => {
  var n = ee.path(e, t, {
    edge: "start"
  });
  return ee.node(e, n);
}, Uae = (e, t) => {
  var n = ee.range(e, t);
  return et.fragment(e, n);
};
function rA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rA(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wae = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return ee.above(t, oA(oA({}, n), {}, {
    match: (r) => dt.isElement(r) && ee.isVoid(t, r)
  }));
}, Hae = (e, t) => t.children.some((n) => dt.isElement(n) && ee.isBlock(e, n)), Vae = (e, t) => t.children.some((n) => ft.isText(n) || ee.isInline(e, n)), $ae = (e, t) => et.has(e, t), qae = (e, t) => t.children.every((n) => ft.isText(n)), Zae = (e) => {
  Fe.splitNodes(e, {
    always: !0
  });
}, Gae = (e, t, n) => {
  Fe.insertNodes(e, t, n);
}, Yae = (e) => {
  Fe.splitNodes(e, {
    always: !0
  });
};
function iA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iA(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kae = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = Xae({
        text: n
      }, i);
      Fe.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      Fe.insertText(t, n, r);
    t.marks = null;
  }
}, Jae = (e, t) => !e.isInline(t), Qae = (e, t, n) => ee.isStart(e, t, n) || ee.isEnd(e, t, n), ele = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && ft.isText(r) && r.text === "" && !e.isVoid(t);
}, tle = (e, t, n) => {
  var r = ee.end(e, n);
  return $t.equals(t, r);
}, nle = (e) => {
  var t = dG.get(e);
  return t === void 0 ? !0 : t;
}, rle = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = ee.start(e, n);
  return $t.equals(t, r);
}, ole = (e, t) => {
  var n = ee.path(e, t, {
    edge: "end"
  });
  return ee.node(e, n);
}, ile = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.path(t, n, r), i = et.leaf(t, o);
  return [i, o];
};
function sle(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = ee.path(e, n);
      for (var [l, u] of et.levels(e, s))
        if (i(l, u) && (a.push([l, u]), !o && dt.isElement(l) && ee.isVoid(e, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var ale = ["text"], lle = ["text"], ule = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (ye.isExpanded(r)) {
    var a = ee.isEnd(t, o, o.path);
    if (a) {
      var s = ee.after(t, o);
      s && (o = s);
    }
    var [l] = ee.nodes(t, {
      match: ft.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Xa(u, ale);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = ee.leaf(t, p);
  if (o.offset === 0) {
    var y = ee.previous(t, {
      at: p,
      match: ft.isText
    }), f = ee.above(t, {
      match: (x) => dt.isElement(x) && ee.isVoid(t, x) && t.markableVoid(x)
    });
    if (!f) {
      var v = ee.above(t, {
        match: (x) => dt.isElement(x) && ee.isBlock(t, x)
      });
      if (y && v) {
        var [b, L] = y, [, w] = v;
        ce.isAncestor(w, L) && (d = b);
      }
    }
  }
  var D = Xa(d, lle);
  return D;
}, cle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = ee.after(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = ee.last(t, []), u = [s.path, l];
      if (ce.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ce.isPath(a)) {
          var [c] = ee.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = ee.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, ple = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.path(t, n, r), i = et.get(t, o);
  return [i, o];
};
function dle(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (Xse.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = ee.path(e, n, {
          edge: "start"
        }), d = ee.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var y = et.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (x) => {
          var [m] = x;
          return dt.isElement(m) ? !!(!a && (ee.isVoid(e, m) || ee.isElementReadOnly(e, m)) || s && !ee.isSelectable(e, m)) : !1;
        }
      }), f = [], v;
      for (var [b, L] of y)
        if (!(s && dt.isElement(b) && !ee.isSelectable(e, b))) {
          var w = v && ce.compare(L, v[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(b, L)) {
              if (o && !w && ft.isText(b))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              v = [b, L];
              continue;
            }
            var D = r === "lowest" ? v : [b, L];
            D && (o ? f.push(D) : yield D), v = [b, L];
          }
        }
      r === "lowest" && v && (o ? f.push(v) : yield v), o && (yield* f);
    }
  }();
}
var fle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => xy.get(c) || [], a = (c) => Ly.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return a(c).delete(d), p;
  };
  if (ee.isNormalizing(t)) {
    if (r) {
      var l = Array.from(et.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      xy.set(t, l), Ly.set(t, u);
    }
    i(t).length !== 0 && ee.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (et.has(t, c)) {
          var p = ee.node(t, c), [d, y] = p;
          dt.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), v = f.length, b = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: b,
          initialDirtyPathsLength: v,
          operation: o
        }))
          return;
        var L = s(t);
        if (et.has(t, L)) {
          var w = ee.node(t, L);
          t.normalizeNode(w, {
            operation: o
          });
        }
        b++, f = i(t);
      }
    });
  }
}, hle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = ee.path(t, n, r), i = ce.parent(o), a = ee.node(t, i);
  return a;
}, gle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ee.pathRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ee.pathRefs(t);
  return a.add(i), i;
}, mle = (e) => {
  var t = Aj.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Aj.set(e, t)), t;
}, vle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ce.isPath(n)) {
    if (i === "start") {
      var [, a] = et.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = et.last(t, n);
      n = s;
    }
  }
  return ye.isRange(n) && (i === "start" ? n = ye.start(n) : i === "end" ? n = ye.end(n) : n = ce.common(n.anchor.path, n.focus.path)), $t.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, yle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ee.pointRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ee.pointRefs(t);
  return a.add(i), i;
}, ble = (e) => {
  var t = Bj.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Bj.set(e, t)), t;
}, wle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ce.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = et.last(t, n);
      i = a;
    } else {
      var [, s] = et.first(t, n);
      i = s;
    }
    var l = et.get(t, i);
    if (!ft.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (ye.isRange(n)) {
    var [u, c] = ye.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function Cle(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = ee.range(e, n), [l, u] = ye.edges(s), c = o ? u : l, p = !1, d = "", y = 0, f = 0, v = 0;
    for (var [b, L] of ee.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (dt.isElement(b)) {
        if (!i && (e.isVoid(b) || e.isElementReadOnly(b))) {
          yield ee.start(e, L);
          continue;
        }
        if (e.isInline(b)) continue;
        if (ee.hasInlines(e, b)) {
          var w = ce.isAncestor(L, u.path) ? u : ee.end(e, L), D = ce.isAncestor(L, l.path) ? l : ee.start(e, L);
          d = ee.string(e, {
            anchor: D,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (ft.isText(b)) {
        var x = ce.equals(L, c.path);
        for (x ? (f = o ? c.offset : b.text.length - c.offset, v = c.offset) : (f = b.text.length, v = o ? f : 0), (x || p || r === "offset") && (yield {
          path: L,
          offset: v
        }, p = !1); ; ) {
          if (y === 0) {
            if (d === "") break;
            y = m(d, r, o), d = qS(d, y, o)[1];
          }
          if (v = o ? v - y : v + y, f = f - y, f < 0) {
            y = -f;
            break;
          }
          y = 0, yield {
            path: L,
            offset: v
          };
        }
      }
    }
    function m(C, S, U) {
      return S === "character" ? $S(C, U) : S === "word" ? nae(C, U) : S === "line" || S === "block" ? C.length : 1;
    }
  }();
}
var Ole = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = ee.before(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = ee.first(t, []), u = [s.path, l];
      if (ce.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ce.isPath(a)) {
          var [c] = ee.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = ee.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, xle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = ee.rangeRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = ee.rangeRefs(t);
  return a.add(i), i;
}, Lle = (e) => {
  var t = Ij.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Ij.set(e, t)), t;
}, Ele = (e, t, n) => {
  if (ye.isRange(t) && !n)
    return t;
  var r = ee.start(e, t), o = ee.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function sA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kle(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sA(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ple = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!ft.isText(c))
        return !1;
      var [d, y] = ee.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = ye.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = ee.node(e, n);
      if (a && r(a, s)) {
        var [l] = ee.parent(e, s);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      Fe.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = kle({}, ee.marks(e) || {});
      delete u[t], e.marks = u, Gd.get(e) || e.onChange();
    }
  }
}, Sle = (e, t) => {
  dG.set(e, t);
}, Mle = (e, t) => ee.point(e, t, {
  edge: "start"
}), Dle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = ee.range(t, n), [a, s] = ye.edges(i), l = "";
  for (var [u, c] of ee.nodes(t, {
    at: i,
    match: ft.isText,
    voids: o
  })) {
    var p = u.text;
    ce.equals(c, s.path) && (p = p.slice(0, s.offset)), ce.equals(c, a.path) && (p = p.slice(a.offset)), l += p;
  }
  return l;
}, _le = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = ye.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || ye.isCollapsed(n) || ce.hasPrevious(a.path))
    return n;
  var s = ee.above(t, {
    at: a,
    match: (f) => dt.isElement(f) && ee.isBlock(t, f),
    voids: o
  }), l = s ? s[1] : [], u = ee.start(t, i), c = {
    anchor: u,
    focus: a
  }, p = !0;
  for (var [d, y] of ee.nodes(t, {
    at: c,
    match: ft.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || ce.isBefore(y, l)) {
      a = {
        path: y,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, Tle = (e, t) => {
  var n = ee.isNormalizing(e);
  ee.setNormalizing(e, !1);
  try {
    t();
  } finally {
    ee.setNormalizing(e, n);
  }
  ee.normalize(e);
}, jle = (e, t, n) => {
  var [r, o] = t;
  return dt.isElement(r) && ee.isEmpty(e, r) || ft.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, Ale = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (ye.isRange(u) && ye.isCollapsed(u) && (p = !0, u = u.anchor), $t.isPoint(u)) {
        var d = ee.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, y] = d;
          u = y;
        } else {
          var f = {
            unit: a,
            distance: s
          }, v = i ? ee.before(t, u, f) || ee.start(t, []) : ee.after(t, u, f) || ee.end(t, []);
          u = {
            anchor: u,
            focus: v
          }, c = !0;
        }
      }
      if (ce.isPath(u)) {
        Fe.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!ye.isCollapsed(u)) {
        if (!c) {
          var [, b] = ye.edges(u), L = ee.end(t, []);
          $t.equals(b, L) || (u = ee.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, D] = ye.edges(u), x = ee.above(t, {
          match: (he) => dt.isElement(he) && ee.isBlock(t, he),
          at: w,
          voids: l
        }), m = ee.above(t, {
          match: (he) => dt.isElement(he) && ee.isBlock(t, he),
          at: D,
          voids: l
        }), C = x && m && !ce.equals(x[1], m[1]), S = ce.equals(w.path, D.path), U = l ? null : (r = ee.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : ee.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), k = l ? null : (o = ee.void(t, {
          at: D,
          mode: "highest"
        })) !== null && o !== void 0 ? o : ee.elementReadOnly(t, {
          at: D,
          mode: "highest"
        });
        if (U) {
          var N = ee.before(t, w);
          N && x && ce.isAncestor(x[1], N.path) && (w = N);
        }
        if (k) {
          var R = ee.after(t, D);
          R && m && ce.isAncestor(m[1], R.path) && (D = R);
        }
        var V = [], $;
        for (var W of ee.nodes(t, {
          at: u,
          voids: l
        })) {
          var [Z, X] = W;
          $ && ce.compare(X, $) === 0 || (!l && dt.isElement(Z) && (ee.isVoid(t, Z) || ee.isElementReadOnly(t, Z)) || !ce.isCommon(X, w.path) && !ce.isCommon(X, D.path)) && (V.push(W), $ = X);
        }
        var K = Array.from(V, (he) => {
          var [, oe] = he;
          return ee.pathRef(t, oe);
        }), Q = ee.pointRef(t, w), J = ee.pointRef(t, D), P = "";
        if (!S && !U) {
          var _ = Q.current, [z] = ee.leaf(t, _), {
            path: M
          } = _, {
            offset: H
          } = w, O = z.text.slice(H);
          O.length > 0 && (t.apply({
            type: "remove_text",
            path: M,
            offset: H,
            text: O
          }), P = O);
        }
        if (K.reverse().map((he) => he.unref()).filter((he) => he !== null).forEach((he) => Fe.removeNodes(t, {
          at: he,
          voids: l
        })), !k) {
          var j = J.current, [F] = ee.leaf(t, j), {
            path: T
          } = j, q = S ? w.offset : 0, B = F.text.slice(q, D.offset);
          B.length > 0 && (t.apply({
            type: "remove_text",
            path: T,
            offset: q,
            text: B
          }), P = B);
        }
        !S && C && J.current && Q.current && Fe.mergeNodes(t, {
          at: J.current,
          hanging: !0,
          voids: l
        }), p && i && a === "character" && P.length > 1 && P.match(/[\u0E00-\u0E7F]+/) && Fe.insertText(t, P.slice(0, P.length - s));
        var Y = Q.unref(), I = J.unref(), le = i ? Y || I : I || Y;
        n.at == null && le && Fe.select(t, le);
      }
    }
  });
}, Ble = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ee.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = VS(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (ye.isRange(a))
        if (o || (a = ee.unhangRange(t, a, {
          voids: i
        })), ye.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = ye.edges(a);
          if (!i && ee.void(t, {
            at: l
          }))
            return;
          var u = ee.pointRef(t, l);
          Fe.delete(t, {
            at: a
          }), a = u.unref();
        }
      else ce.isPath(a) && (a = ee.start(t, a));
      if (!(!i && ee.void(t, {
        at: a
      }))) {
        var c = ee.above(t, {
          at: a,
          match: (O) => dt.isElement(O) && ee.isInline(t, O),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (ee.isEnd(t, a, p)) {
            var d = ee.after(t, p);
            a = d;
          } else if (ee.isStart(t, a, p)) {
            var y = ee.before(t, p);
            a = y;
          }
        }
        var f = ee.above(t, {
          match: (O) => dt.isElement(O) && ee.isBlock(t, O),
          at: a,
          voids: i
        }), [, v] = f, b = ee.isStart(t, a, v), L = ee.isEnd(t, a, v), w = b && L, D = !b || b && L, x = !L, [, m] = et.first({
          children: n
        }, []), [, C] = et.last({
          children: n
        }, []), S = [], U = (O) => {
          var [j, F] = O, T = F.length === 0;
          return T ? !1 : w ? !0 : !(D && ce.isAncestor(F, m) && dt.isElement(j) && !t.isVoid(j) && !t.isInline(j) || x && ce.isAncestor(F, C) && dt.isElement(j) && !t.isVoid(j) && !t.isInline(j));
        };
        for (var k of et.nodes({
          children: n
        }, {
          pass: U
        }))
          U(k) && S.push(k);
        var N = [], R = [], V = [], $ = !0, W = !1;
        for (var [Z] of S)
          dt.isElement(Z) && !t.isInline(Z) ? ($ = !1, W = !0, R.push(Z)) : $ ? N.push(Z) : V.push(Z);
        var [X] = ee.nodes(t, {
          at: a,
          match: (O) => ft.isText(O) || ee.isInline(t, O),
          mode: "highest",
          voids: i
        }), [, K] = X, Q = ee.isStart(t, a, K), J = ee.isEnd(t, a, K), P = ee.pathRef(t, L && !V.length ? ce.next(v) : v), _ = ee.pathRef(t, J ? ce.next(K) : K);
        Fe.splitNodes(t, {
          at: a,
          match: (O) => W ? dt.isElement(O) && ee.isBlock(t, O) : ft.isText(O) || ee.isInline(t, O),
          mode: W ? "lowest" : "highest",
          always: W && (!b || N.length > 0) && (!L || V.length > 0),
          voids: i
        });
        var z = ee.pathRef(t, !Q || Q && J ? ce.next(K) : K);
        if (Fe.insertNodes(t, N, {
          at: z.current,
          match: (O) => ft.isText(O) || ee.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), w && !N.length && R.length && !V.length && Fe.delete(t, {
          at: v,
          voids: i
        }), Fe.insertNodes(t, R, {
          at: P.current,
          match: (O) => dt.isElement(O) && ee.isBlock(t, O),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), Fe.insertNodes(t, V, {
          at: _.current,
          match: (O) => ft.isText(O) || ee.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var M;
          if (V.length > 0 && _.current ? M = ce.previous(_.current) : R.length > 0 && P.current ? M = ce.previous(P.current) : z.current && (M = ce.previous(z.current)), M) {
            var H = ee.end(t, M);
            Fe.select(t, H);
          }
        }
        z.unref(), P.unref(), _.unref();
      }
    }
  });
}, Ile = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      Fe.select(t, o.anchor);
    else if (r === "focus")
      Fe.select(t, o.focus);
    else if (r === "start") {
      var [i] = ye.edges(o);
      Fe.select(t, i);
    } else if (r === "end") {
      var [, a] = ye.edges(o);
      Fe.select(t, a);
    }
  } else return;
}, Rle = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, Nle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = ye.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = ye.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (s == null || s === "anchor") {
      var d = a ? ee.before(t, l, c) : ee.after(t, l, c);
      d && (p.anchor = d);
    }
    if (s == null || s === "focus") {
      var y = a ? ee.before(t, u, c) : ee.after(t, u, c);
      y && (p.focus = y);
    }
    Fe.setSelection(t, p);
  }
}, Fle = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = ee.range(e, t), n) {
    Fe.setSelection(e, t);
    return;
  }
  if (!ye.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Yo.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function aA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aA(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = ye.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = ye.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    Fe.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: lA(lA({}, l), n)
    });
  }
}, Ule = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !$t.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !$t.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, Wle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ee.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (et.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = VS(t), c !== !1 && (c = !0)), c == null && (c = !1), ye.isRange(l))
        if (o || (l = ee.unhangRange(t, l, {
          voids: i
        })), ye.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = ye.edges(l), y = ee.pointRef(t, d);
          Fe.delete(t, {
            at: l
          }), l = y.unref();
        }
      if ($t.isPoint(l)) {
        u == null && (ft.isText(p) ? u = (N) => ft.isText(N) : t.isInline(p) ? u = (N) => ft.isText(N) || ee.isInline(t, N) : u = (N) => dt.isElement(N) && ee.isBlock(t, N));
        var [f] = ee.nodes(t, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (f) {
          var [, v] = f, b = ee.pathRef(t, v), L = ee.isEnd(t, l, v);
          Fe.splitNodes(t, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var w = b.unref();
          l = L ? ce.next(w) : w;
        } else
          return;
      }
      var D = ce.parent(l), x = l[l.length - 1];
      if (!(!i && ee.void(t, {
        at: D
      }))) {
        if (s) {
          var m = [], C = ce.levels(D);
          Lae(t, () => {
            var N = function() {
              var $ = D.concat(x);
              x++;
              var W = {
                type: "insert_node",
                path: $,
                node: R
              };
              t.apply(W), l = ce.next(l), m.push(W), ft.isText ? C.push(...Array.from(et.nodes(R), (Z) => {
                var [, X] = Z;
                return $.concat(X);
              })) : C.push($);
            };
            for (var R of n)
              N();
          }, () => {
            hG(t, C, (N) => {
              var R = N;
              for (var V of m)
                if (ce.operationCanTransformPath(V) && (R = ce.transform(R, V), !R))
                  return null;
              return R;
            });
          });
        } else
          for (var S of n) {
            var U = D.concat(x);
            x++, t.apply({
              type: "insert_node",
              path: U,
              node: S
            }), l = ce.next(l);
          }
        if (l = ce.previous(l), c) {
          var k = ee.end(t, l);
          k && Fe.select(t, k);
        }
      }
    }
  });
}, Hle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = ce.isPath(r) ? wp(t, r) : (x) => dt.isElement(x) && ee.isBlock(t, x)), !!r) {
      var s = ee.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (x) => {
        var [, m] = x;
        return ee.pathRef(t, m);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = ee.node(t, ce.parent(c)), [d, y] = p, f = c[c.length - 1], {
          length: v
        } = d.children;
        if (v === 1) {
          var b = ce.next(y);
          Fe.moveNodes(t, {
            at: c,
            to: b,
            voids: i
          }), Fe.removeNodes(t, {
            at: y,
            voids: i
          });
        } else if (f === 0)
          Fe.moveNodes(t, {
            at: c,
            to: y,
            voids: i
          });
        else if (f === v - 1) {
          var L = ce.next(y);
          Fe.moveNodes(t, {
            at: c,
            to: L,
            voids: i
          });
        } else {
          var w = ce.next(c), D = ce.next(y);
          Fe.splitNodes(t, {
            at: w,
            voids: i
          }), Fe.moveNodes(t, {
            at: c,
            to: D,
            voids: i
          });
        }
      }
    }
  });
}, Vle = ["text"], $le = ["children"], gG = (e, t) => {
  if (dt.isElement(t)) {
    var n = t;
    return ee.isVoid(e, t) ? !0 : n.children.length === 1 ? gG(e, n.children[0]) : !1;
  } else return !ee.isEditor(t);
}, qle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ce.isPath(o)) {
          var [l] = ee.parent(t, o);
          r = (N) => l.children.includes(N);
        } else
          r = (N) => dt.isElement(N) && ee.isBlock(t, N);
      if (!i && ye.isRange(o) && (o = ee.unhangRange(t, o, {
        voids: a
      })), ye.isRange(o))
        if (ye.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = ye.edges(o), c = ee.pointRef(t, u);
          Fe.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && Fe.select(t, o);
        }
      var [p] = ee.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), d = ee.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!p || !d)) {
        var [y, f] = p, [v, b] = d;
        if (!(f.length === 0 || b.length === 0)) {
          var L = ce.next(b), w = ce.common(f, b), D = ce.isSibling(f, b), x = Array.from(ee.levels(t, {
            at: f
          }), (N) => {
            var [R] = N;
            return R;
          }).slice(w.length).slice(0, -1), m = ee.above(t, {
            at: f,
            mode: "highest",
            match: (N) => x.includes(N) && gG(t, N)
          }), C = m && ee.pathRef(t, m[1]), S, U;
          if (ft.isText(y) && ft.isText(v)) {
            var k = Xa(y, Vle);
            U = v.text.length, S = k;
          } else if (dt.isElement(y) && dt.isElement(v)) {
            var k = Xa(y, $le);
            U = v.children.length, S = k;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(Yo.stringify(y), " ").concat(Yo.stringify(v)));
          D || Fe.moveNodes(t, {
            at: f,
            to: L,
            voids: a
          }), C && Fe.removeNodes(t, {
            at: C.current,
            voids: a
          }), ee.shouldMergeNodesRemovePrevNode(t, d, p) ? Fe.removeNodes(t, {
            at: b,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: L,
            position: U,
            properties: S
          }), C && C.unref();
        }
      }
    }
  });
}, Zle = (e, t) => {
  ee.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = ce.isPath(r) ? wp(e, r) : (y) => dt.isElement(y) && ee.isBlock(e, y));
      var s = ee.pathRef(e, n), l = ee.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (y) => {
        var [, f] = y;
        return ee.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = s.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), s.current && ce.isSibling(d, p) && ce.isAfter(d, p) && (s.current = ce.next(s.current));
      }
      s.unref();
    }
  });
}, Gle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ce.isPath(a) ? wp(t, a) : (y) => dt.isElement(y) && ee.isBlock(t, y)), !r && ye.isRange(a) && (a = ee.unhangRange(t, a, {
        voids: o
      }));
      var l = ee.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (y) => {
        var [, f] = y;
        return ee.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = ee.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, Yle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ee.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = ce.isPath(i) ? wp(t, i) : (U) => dt.isElement(U) && ee.isBlock(t, U)), !l && ye.isRange(i) && (i = ee.unhangRange(t, i, {
        voids: p
      })), c && ye.isRange(i)) {
        if (ye.isCollapsed(i) && ee.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = ee.rangeRef(t, i, {
          affinity: "inward"
        }), [y, f] = ye.edges(i), v = u === "lowest" ? "lowest" : "highest", b = ee.isEnd(t, f, f.path);
        Fe.splitNodes(t, {
          at: f,
          match: o,
          mode: v,
          voids: p,
          always: !b
        });
        var L = ee.isStart(t, y, y.path);
        Fe.splitNodes(t, {
          at: y,
          match: o,
          mode: v,
          voids: p,
          always: !L
        }), i = d.unref(), r.at == null && Fe.select(t, i);
      }
      a || (a = (U, k) => U !== k);
      for (var [w, D] of ee.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var x = {}, m = {};
        if (D.length !== 0) {
          var C = !1;
          for (var S in n)
            S === "children" || S === "text" || a(n[S], w[S]) && (C = !0, w.hasOwnProperty(S) && (x[S] = w[S]), s ? n[S] != null && (m[S] = s(w[S], n[S])) : n[S] != null && (m[S] = n[S]));
          C && t.apply({
            type: "set_node",
            path: D,
            properties: x,
            newProperties: m
          });
        }
      }
    }
  });
}, Xle = (e, t) => {
  if (ye.isCollapsed(t))
    return t.anchor;
  var [, n] = ye.edges(t), r = ee.pointRef(e, n);
  return Fe.delete(e, {
    at: t
  }), r.unref();
}, Kle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (J) => dt.isElement(J) && ee.isBlock(t, J)), ye.isRange(a) && (a = Xle(t, a)), ce.isPath(a)) {
      var u = a, c = ee.point(t, u), [p] = ee.parent(t, u);
      i = (J) => J === p, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var d = ee.pointRef(t, a, {
        affinity: "backward"
      }), y;
      try {
        var [f] = ee.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var v = ee.void(t, {
          at: a,
          mode: "highest"
        }), b = 0;
        if (!o && v) {
          var [L, w] = v;
          if (dt.isElement(L) && t.isInline(L)) {
            var D = ee.after(t, w);
            if (!D) {
              var x = {
                text: ""
              }, m = ce.next(w);
              Fe.insertNodes(t, x, {
                at: m,
                voids: o
              }), D = ee.point(t, m);
            }
            a = D, l = !0;
          }
          var C = a.path.length - w.length;
          s = C + 1, l = !0;
        }
        y = ee.pointRef(t, a);
        var S = a.path.length - s, [, U] = f, k = a.path.slice(0, S), N = s === 0 ? a.offset : a.path[S] + b;
        for (var [R, V] of ee.levels(t, {
          at: k,
          reverse: !0,
          voids: o
        })) {
          var $ = !1;
          if (V.length < U.length || V.length === 0 || !o && dt.isElement(R) && ee.isVoid(t, R))
            break;
          var W = d.current, Z = ee.isEnd(t, W, V);
          if (l || !d || !ee.isEdge(t, W, V)) {
            $ = !0;
            var X = et.extractProps(R);
            t.apply({
              type: "split_node",
              path: V,
              position: N,
              properties: X
            });
          }
          N = V[V.length - 1] + ($ || Z ? 1 : 0);
        }
        if (n.at == null) {
          var K = y.current || ee.end(t, []);
          Fe.select(t, K);
        }
      } finally {
        var Q;
        d.unref(), (Q = y) === null || Q === void 0 || Q.unref();
      }
    }
  });
}, Jle = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  Fe.setNodes(t, o, r);
}, Qle = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ee.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = ce.isPath(a) ? wp(t, a) : (y) => dt.isElement(y) && ee.isBlock(t, y)), ce.isPath(a) && (a = ee.range(t, a));
      var l = ye.isRange(a) ? ee.rangeRef(t, a) : null, u = ee.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (y) => {
          var [, f] = y;
          return ee.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [v] = ee.node(t, f), b = ee.range(t, f);
        o && l && (b = ye.intersection(l.current, b)), Fe.liftNodes(t, {
          at: b,
          match: (L) => dt.isAncestor(v) && v.children.includes(L),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function uA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uA(Object(n), !0).forEach(function(r) {
      xi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eue = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  ee.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = t.selection
    } = r;
    if (l) {
      if (s == null && (ce.isPath(l) ? s = wp(t, l) : t.isInline(n) ? s = (b) => dt.isElement(b) && ee.isInline(t, b) || ft.isText(b) : s = (b) => dt.isElement(b) && ee.isBlock(t, b)), i && ye.isRange(l)) {
        var [u, c] = ye.edges(l), p = ee.rangeRef(t, l, {
          affinity: "inward"
        });
        Fe.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), Fe.splitNodes(t, {
          at: u,
          match: s,
          voids: a
        }), l = p.unref(), r.at == null && Fe.select(t, l);
      }
      var d = Array.from(ee.nodes(t, {
        at: l,
        match: t.isInline(n) ? (b) => dt.isElement(b) && ee.isBlock(t, b) : (b) => ee.isEditor(b),
        mode: "lowest",
        voids: a
      })), y = function() {
        var L = ye.isRange(l) ? ye.intersection(l, ee.range(t, v)) : l;
        if (!L)
          return 0;
        var w = Array.from(ee.nodes(t, {
          at: L,
          match: s,
          mode: o,
          voids: a
        }));
        if (w.length > 0) {
          var [D] = w, x = w[w.length - 1], [, m] = D, [, C] = x;
          if (m.length === 0 && C.length === 0)
            return 0;
          var S = ce.equals(m, C) ? ce.parent(m) : ce.common(m, C), U = ee.range(t, m, C), k = ee.node(t, S), [N] = k, R = S.length + 1, V = ce.next(C.slice(0, R)), $ = cA(cA({}, n), {}, {
            children: []
          });
          Fe.insertNodes(t, $, {
            at: V,
            voids: a
          }), Fe.moveNodes(t, {
            at: U,
            match: (W) => dt.isAncestor(N) && N.children.includes(W),
            to: V.concat(0),
            voids: a
          });
        }
      }, f;
      for (var [, v] of d)
        f = y();
    }
  });
}, tue = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Eae(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _ae(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Aae(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bae(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Iae(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pae(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zae(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yae(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ble(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gae(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kae(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sae(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ple(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kae(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mae(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dae(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tae(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jae(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ile(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ale(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rle(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rae(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nae(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fae(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zae(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uae(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ule(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hae(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vae(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $ae(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qae(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wle(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jae(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qae(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ele(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tle(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nle(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rle(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ole(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ile(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sle(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hle(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qle(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nle(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zle(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cle(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ple(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dle(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fle(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hle(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vle(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gle(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mle(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wle(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yle(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ble(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cle(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ole(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ele(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xle(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lle(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gle(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fle(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yle(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sle(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zle(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ule(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kle(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mle(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dle(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _le(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jle(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qle(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wae(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tle(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eue(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jle(e, ...r);
    }
  };
  return e;
};
const mG = (e) => {
  if (ft.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (dt.isElement(e)) {
    const t = e.children.map((r) => mG(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, Rrt = (e) => e.map((t) => mG(t)).join("");
var vG = {}, ZS = {}, GS = {};
Object.defineProperty(GS, "__esModule", { value: !0 });
GS.default = iue;
var pA = "html", dA = "head", _g = "body", nue = /<([a-zA-Z]+[0-9]?)/, fA = /<head[^]*>/i, hA = /<body[^]*>/i, Ey = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, XE = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, gA = typeof window == "object" && window.DOMParser;
if (typeof gA == "function") {
  var rue = new gA(), oue = "text/html";
  XE = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), rue.parseFromString(e, oue);
  }, Ey = XE;
}
if (typeof document == "object" && document.implementation) {
  var Tg = document.implementation.createHTMLDocument();
  Ey = function(e, t) {
    if (t) {
      var n = Tg.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Tg;
    }
    return Tg.documentElement.innerHTML = e, Tg;
  };
}
var jg = typeof document == "object" && document.createElement("template"), KE;
jg && jg.content && (KE = function(e) {
  return jg.innerHTML = e, jg.content.childNodes;
});
function iue(e) {
  var t, n, r = e.match(nue), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case pA: {
      var i = XE(e);
      if (!fA.test(e)) {
        var a = i.querySelector(dA);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!hA.test(e)) {
        var a = i.querySelector(_g);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(pA);
    }
    case dA:
    case _g: {
      var s = Ey(e).querySelectorAll(o);
      return hA.test(e) && fA.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (KE)
        return KE(e);
      var a = Ey(e, _g).querySelector(_g);
      return a.childNodes;
    }
  }
}
var G0 = {}, YS = {}, XS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(XS);
var en = {}, lu = hr && hr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Yd = hr && hr.__assign || function() {
  return Yd = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Yd.apply(this, arguments);
};
Object.defineProperty(en, "__esModule", { value: !0 });
en.cloneNode = en.hasChildren = en.isDocument = en.isDirective = en.isComment = en.isText = en.isCDATA = en.isTag = en.Element = en.Document = en.CDATA = en.NodeWithChildren = en.ProcessingInstruction = en.Comment = en.Text = en.DataNode = en.Node = void 0;
var Zi = XS, KS = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), JS(this, t);
    }, e;
  }()
);
en.Node = KS;
var Y0 = (
  /** @class */
  function(e) {
    lu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(KS)
);
en.DataNode = Y0;
var yG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Zi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Y0)
);
en.Text = yG;
var bG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Zi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Y0)
);
en.Comment = bG;
var wG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Zi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Y0)
);
en.ProcessingInstruction = wG;
var X0 = (
  /** @class */
  function(e) {
    lu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(KS)
);
en.NodeWithChildren = X0;
var CG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Zi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(X0)
);
en.CDATA = CG;
var OG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Zi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(X0)
);
en.Document = OG;
var xG = (
  /** @class */
  function(e) {
    lu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Zi.ElementType.Script : n === "style" ? Zi.ElementType.Style : Zi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(X0)
);
en.Element = xG;
function LG(e) {
  return (0, Zi.isTag)(e);
}
en.isTag = LG;
function EG(e) {
  return e.type === Zi.ElementType.CDATA;
}
en.isCDATA = EG;
function kG(e) {
  return e.type === Zi.ElementType.Text;
}
en.isText = kG;
function PG(e) {
  return e.type === Zi.ElementType.Comment;
}
en.isComment = PG;
function SG(e) {
  return e.type === Zi.ElementType.Directive;
}
en.isDirective = SG;
function MG(e) {
  return e.type === Zi.ElementType.Root;
}
en.isDocument = MG;
function sue(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
en.hasChildren = sue;
function JS(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (kG(e))
    n = new yG(e.data);
  else if (PG(e))
    n = new bG(e.data);
  else if (LG(e)) {
    var r = t ? tO(e.children) : [], o = new xG(e.name, Yd({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Yd({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Yd({}, e["x-attribsPrefix"])), n = o;
  } else if (EG(e)) {
    var r = t ? tO(e.children) : [], i = new CG(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (MG(e)) {
    var r = t ? tO(e.children) : [], a = new OG(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (SG(e)) {
    var s = new wG(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
en.cloneNode = JS;
function tO(e) {
  for (var t = e.map(function(r) {
    return JS(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = hr && hr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = hr && hr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = XS, o = en;
  n(en, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(YS);
var DG = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(DG);
Object.defineProperty(G0, "__esModule", { value: !0 });
G0.formatAttributes = _G;
G0.formatDOM = TG;
var Ag = YS, aue = DG;
function lue(e) {
  return aue.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function _G(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function uue(e) {
  e = e.toLowerCase();
  var t = lue(e);
  return t || e;
}
function TG(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = uue(s.nodeName);
        o = new Ag.Element(l, _G(s.attributes)), o.children = TG(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ag.Text(s.nodeValue);
        break;
      case 8:
        o = new Ag.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ag.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var cue = hr && hr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ZS, "__esModule", { value: !0 });
ZS.default = hue;
var pue = cue(GS), due = G0, fue = /<(![a-zA-Z\s]+)>/;
function hue(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(fue), n = t ? t[1] : void 0;
  return (0, due.formatDOM)((0, pue.default)(e), null, n);
}
var K0 = {}, $s = {}, J0 = {}, gue = 0;
J0.SAME = gue;
var mue = 1;
J0.CAMELCASE = mue;
J0.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const jG = 0, uu = 1, Q0 = 2, ew = 3, QS = 4, AG = 5, BG = 6;
function vue(e) {
  return Xo.hasOwnProperty(e) ? Xo[e] : null;
}
function Li(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Q0 || t === ew || t === QS, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Xo = {}, yue = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
yue.forEach((e) => {
  Xo[e] = new Li(
    e,
    jG,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Xo[e] = new Li(
    e,
    uu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Xo[e] = new Li(
    e,
    Q0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Xo[e] = new Li(
    e,
    Q0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Xo[e] = new Li(
    e,
    ew,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Xo[e] = new Li(
    e,
    ew,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Xo[e] = new Li(
    e,
    QS,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Xo[e] = new Li(
    e,
    BG,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Xo[e] = new Li(
    e,
    AG,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const eM = /[\-\:]([a-z])/g, tM = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(eM, tM);
  Xo[t] = new Li(
    t,
    uu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(eM, tM);
  Xo[t] = new Li(
    t,
    uu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(eM, tM);
  Xo[t] = new Li(
    t,
    uu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Xo[e] = new Li(
    e,
    uu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const bue = "xlinkHref";
Xo[bue] = new Li(
  "xlinkHref",
  uu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Xo[e] = new Li(
    e,
    uu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: wue,
  SAME: Cue,
  possibleStandardNames: mA
} = J0, Oue = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", xue = Oue + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Lue = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + xue + "]*$")
), Eue = Object.keys(
  mA
).reduce((e, t) => {
  const n = mA[t];
  return n === Cue ? e[t] = t : n === wue ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
$s.BOOLEAN = ew;
$s.BOOLEANISH_STRING = Q0;
$s.NUMERIC = AG;
$s.OVERLOADED_BOOLEAN = QS;
$s.POSITIVE_NUMERIC = BG;
$s.RESERVED = jG;
$s.STRING = uu;
$s.getPropertyInfo = vue;
$s.isCustomAttribute = Lue;
$s.possibleStandardNames = Eue;
var nM = {}, rM = {}, vA = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, kue = /\n/g, Pue = /^\s*/, Sue = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Mue = /^:\s*/, Due = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, _ue = /^[;\s]*/, Tue = /^\s+|\s+$/g, jue = `
`, yA = "/", bA = "*", ic = "", Aue = "comment", Bue = "declaration", Iue = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(kue);
    v && (n += v.length);
    var b = f.lastIndexOf(jue);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(Pue);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(yA != e.charAt(0) || bA != e.charAt(1))) {
      for (var v = 2; ic != e.charAt(v) && (bA != e.charAt(v) || yA != e.charAt(v + 1)); )
        ++v;
      if (v += 2, ic === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: Aue,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(Sue);
    if (v) {
      if (p(), !l(Mue)) return s("property missing ':'");
      var b = l(Due), L = f({
        type: Bue,
        property: wA(v[0].replace(vA, ic)),
        value: b ? wA(b[0].replace(vA, ic)) : ic
      });
      return l(_ue), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function wA(e) {
  return e ? e.replace(Tue, ic) : ic;
}
var Rue = hr && hr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(rM, "__esModule", { value: !0 });
rM.default = Fue;
var Nue = Rue(Iue);
function Fue(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Nue.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var tw = {};
Object.defineProperty(tw, "__esModule", { value: !0 });
tw.camelCase = void 0;
var zue = /^--[a-zA-Z0-9_-]+$/, Uue = /-([a-z])/g, Wue = /^[^-]+$/, Hue = /^-(webkit|moz|ms|o|khtml)-/, Vue = /^-(ms)-/, $ue = function(e) {
  return !e || Wue.test(e) || zue.test(e);
}, que = function(e, t) {
  return t.toUpperCase();
}, CA = function(e, t) {
  return "".concat(t, "-");
}, Zue = function(e, t) {
  return t === void 0 && (t = {}), $ue(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Vue, CA) : e = e.replace(Hue, CA), e.replace(Uue, que));
};
tw.camelCase = Zue;
var Gue = hr && hr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Yue = Gue(rM), Xue = tw;
function JE(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Yue.default)(e, function(r, o) {
    r && o && (n[(0, Xue.camelCase)(r, t)] = o);
  }), n;
}
JE.default = JE;
var Kue = JE;
(function(e) {
  var t = hr && hr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Kue), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(nM);
Object.defineProperty(K0, "__esModule", { value: !0 });
K0.default = tce;
var jd = $s, OA = nM, Jue = ["checked", "value"], Que = ["input", "select", "textarea"], ece = {
  reset: !0,
  submit: !0
};
function tce(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && ece[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, jd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = xA(a);
    if (s) {
      var l = (0, jd.getPropertyInfo)(s);
      switch (Jue.includes(s) && Que.includes(t) && !r && (s = xA("default" + a)), n[s] = i, l && l.type) {
        case jd.BOOLEAN:
          n[s] = !0;
          break;
        case jd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    OA.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, OA.setStyleProp)(e.style, n), n;
}
function xA(e) {
  return jd.possibleStandardNames[e];
}
var oM = {}, nce = hr && hr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(oM, "__esModule", { value: !0 });
oM.default = IG;
var nO = we, rce = nce(K0), Xd = nM, oce = {
  cloneElement: nO.cloneElement,
  createElement: nO.createElement,
  isValidElement: nO.isValidElement
};
function IG(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Xd.returnFirstArg, i = t.library || oce, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Xd.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    ice(f) ? ((0, Xd.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, rce.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = IG(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function ice(e) {
  return Xd.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Xd.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = hr && hr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(ZS);
  e.htmlToDOM = n.default;
  var r = t(K0);
  e.attributesToProps = r.default;
  var o = t(oM);
  e.domToReact = o.default;
  var i = YS;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(vG);
const LA = /* @__PURE__ */ H0(vG), sce = LA.default || LA, QE = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => QE(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, Nrt = (e) => {
  const t = sce(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : QE(n)) : typeof t == "string" ? [{ text: t }] : [QE(t)];
}, Frt = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function RG(e, t, n) {
  if (!e) return /* @__PURE__ */ re.jsx(re.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ re.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ re.jsx("p", { className: n, children: /* @__PURE__ */ re.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function zrt(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ re.jsxs("div", { className: p.trim(), ...l, children: [
    by(c, o),
    s,
    by(c, i)
  ] });
}
function Urt(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: r.trim(), ...n });
}
function Wrt(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ re.jsx("div", { className: o.trim(), ...r });
}
function Hrt(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ re.jsx("aside", { className: r.trim(), ...n });
}
function Vrt(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = at.count(r) === 0;
  return /* @__PURE__ */ re.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ re.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ re.jsx("td", { colSpan: 100, children: /* @__PURE__ */ re.jsx("div", { children: t }) }) }) : r });
}
function $rt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ re.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ re.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function qrt(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ re.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ re.jsx("table", { children: t }) });
}
function Zrt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ re.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ re.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ re.jsx("tr", { children: /* @__PURE__ */ re.jsx("th", { colSpan: 100, children: /* @__PURE__ */ re.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function Grt(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ re.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ re.jsx("tr", { children: n }),
    /* @__PURE__ */ re.jsx("tr", { className: "spacingRow" })
  ] });
}
var gr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ace(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ek = { exports: {} }, Zp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EA;
function lce() {
  if (EA) return Zp;
  EA = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Zp.Fragment = n, Zp.jsx = a, Zp.jsxs = a, Zp;
}
var Bg = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kA;
function uce() {
  return kA || (kA = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var A = f && g[f] || g[v];
      return typeof A == "function" ? A : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), te = 1; te < A; te++)
          G[te - 1] = arguments[te];
        D("error", g, G);
      }
    }
    function D(g, A, G) {
      {
        var te = L.ReactDebugCurrentFrame, ae = te.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function N(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function R(g, A, G) {
      var te = g.displayName;
      if (te)
        return te;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var A = g;
            return V(A) + ".Consumer";
          case a:
            var G = g;
            return V(G._context) + ".Provider";
          case l:
            return R(g, g.render, "ForwardRef");
          case p:
            var te = g.displayName || null;
            return te !== null ? te : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, Z = 0, X, K, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function H() {
      {
        if (Z === 0) {
          X = console.log, K = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, g, {
              value: X
            }),
            info: W({}, g, {
              value: K
            }),
            warn: W({}, g, {
              value: Q
            }),
            error: W({}, g, {
              value: J
            }),
            group: W({}, g, {
              value: P
            }),
            groupCollapsed: W({}, g, {
              value: _
            }),
            groupEnd: W({}, g, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = L.ReactCurrentDispatcher, F;
    function T(g, A, G) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var te = ae.stack.trim().match(/\n( *(at )?)/);
            F = te && te[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, B;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Y();
    }
    function I(g, A) {
      if (!g || q)
        return "";
      {
        var G = B.get(g);
        if (G !== void 0)
          return G;
      }
      var te;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, H();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              te = je;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              te = je;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            te = je;
          }
          g();
        }
      } catch (je) {
        if (je && te && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = te.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var Ue = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", g.displayName)), typeof g == "function" && B.set(g, Ue), Ue;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Lt = g ? g.displayName || g.name : "", vt = Lt ? T(Lt) : "";
      return typeof g == "function" && B.set(g, vt), vt;
    }
    function le(g, A, G) {
      return I(g, !1);
    }
    function he(g) {
      var A = g.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(g, A, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return I(g, he(g));
      if (typeof g == "string")
        return T(g);
      switch (g) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return oe(g.type, A, G);
          case d: {
            var te = g, ae = te._payload, ue = te._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, We = {}, He = L.ReactDebugCurrentFrame;
    function Ie(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(g, A, G, te, ae) {
      {
        var ue = Function.call.bind(Be);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var Oe = Error((te || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = g[se](A, se, te, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Ie(ae), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ce(g) {
      return $e(g);
    }
    function Qe(g) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function lt(g) {
      try {
        return be(g), !1;
      } catch {
        return !0;
      }
    }
    function be(g) {
      return "" + g;
    }
    function Ee(g) {
      if (lt(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(g)), be(g);
    }
    var Ae = L.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, ot, ve;
    ve = {};
    function yt(g) {
      if (Be.call(g, "ref")) {
        var A = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function it(g) {
      if (Be.call(g, "key")) {
        var A = Object.getOwnPropertyDescriptor(g, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function st(g, A) {
      if (typeof g.ref == "string" && Ae.current && A && Ae.current.stateNode !== A) {
        var G = $(Ae.current.type);
        ve[G] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ae.current.type), g.ref), ve[G] = !0);
      }
    }
    function ut(g, A) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function bt(g, A) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var ct = function(g, A, G, te, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function wt(g, A, G, te, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (Ee(G), ie = "" + G), it(A) && (Ee(A.key), ie = "" + A.key), yt(A) && (Oe = A.ref, st(A, ae));
        for (ue in A)
          Be.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && ut(se, fe), Oe && bt(se, fe);
        }
        return ct(g, ie, Oe, ae, te, Ae.current, se);
      }
    }
    var tt = L.ReactCurrentOwner, gt = L.ReactDebugCurrentFrame;
    function rt(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        gt.setExtraStackFrame(G);
      } else
        gt.setExtraStackFrame(null);
    }
    var Ct;
    Ct = !1;
    function pt(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Et() {
      {
        if (tt.current) {
          var g = $(tt.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Ot(g) {
      return "";
    }
    var kt = {};
    function xt(g) {
      {
        var A = Et();
        if (!A) {
          var G = typeof g == "string" ? g : g.displayName || g.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function Pt(g, A) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var G = xt(A);
        if (kt[G])
          return;
        kt[G] = !0;
        var te = "";
        g && g._owner && g._owner !== tt.current && (te = " It was passed a child from " + $(g._owner.type) + "."), rt(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, te), rt(null);
      }
    }
    function Vt(g, A) {
      {
        if (typeof g != "object")
          return;
        if (Ce(g))
          for (var G = 0; G < g.length; G++) {
            var te = g[G];
            pt(te) && Pt(te, A);
          }
        else if (pt(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              pt(se.value) && Pt(se.value, A);
        }
      }
    }
    function mt(g) {
      {
        var A = g.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var te = $(A);
          nt(G, g.props, "prop", te, g);
        } else if (A.PropTypes !== void 0 && !Ct) {
          Ct = !0;
          var ae = $(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ne(g) {
      {
        for (var A = Object.keys(g.props), G = 0; G < A.length; G++) {
          var te = A[G];
          if (te !== "children" && te !== "key") {
            rt(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), rt(null);
            break;
          }
        }
        g.ref !== null && (rt(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var so = {};
    function ao(g, A, G, te, ae, ue) {
      {
        var se = N(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ot();
          Oe ? ie += Oe : ie += Et();
          var de;
          g === null ? de = "null" : Ce(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = wt(g, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Ue = A.children;
          if (Ue !== void 0)
            if (te)
              if (Ce(Ue)) {
                for (var Lt = 0; Lt < Ue.length; Lt++)
                  Vt(Ue[Lt], g);
                Object.freeze && Object.freeze(Ue);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vt(Ue, g);
        }
        if (Be.call(A, "key")) {
          var vt = $(g), je = Object.keys(A).filter(function(wi) {
            return wi !== "key";
          }), Wn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[vt + Wn]) {
            var bi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wn, vt, bi, vt), so[vt + Wn] = !0;
          }
        }
        return g === r ? ne(fe) : mt(fe), fe;
      }
    }
    function gi(g, A, G) {
      return ao(g, A, G, !0);
    }
    function mi(g, A, G) {
      return ao(g, A, G, !1);
    }
    var vi = mi, yi = gi;
    Bg.Fragment = r, Bg.jsx = vi, Bg.jsxs = yi;
  }()), Bg;
}
process.env.NODE_ENV === "production" ? ek.exports = lce() : ek.exports = uce();
var sr = ek.exports;
Ve({});
function PA(e, t) {
  return t ? /* @__PURE__ */ sr.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ sr.jsx(sr.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function SA(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ii(e) {
  var t, n;
  return SA(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(SA(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var NG = Symbol.for("immer-nothing"), MA = Symbol.for("immer-draftable"), ws = Symbol.for("immer-state"), cce = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Ai(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = cce[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var pp = Object.getPrototypeOf;
function Mc(e) {
  return !!e && !!e[ws];
}
function Dc(e) {
  var t;
  return e ? FG(e) || Array.isArray(e) || !!e[MA] || !!((t = e.constructor) != null && t[MA]) || rw(e) || ow(e) : !1;
}
var pce = Object.prototype.constructor.toString();
function FG(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = pp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === pce;
}
function ky(e, t) {
  nw(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function nw(e) {
  const t = e[ws];
  return t ? t.type_ : Array.isArray(e) ? 1 : rw(e) ? 2 : ow(e) ? 3 : 0;
}
function tk(e, t) {
  return nw(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function zG(e, t, n) {
  const r = nw(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function dce(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function rw(e) {
  return e instanceof Map;
}
function ow(e) {
  return e instanceof Set;
}
function Ku(e) {
  return e.copy_ || e.base_;
}
function nk(e, t) {
  if (rw(e))
    return new Map(e);
  if (ow(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = FG(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ws];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(pp(e), r);
  } else {
    const r = pp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function iM(e, t = !1) {
  return iw(e) || Mc(e) || !Dc(e) || (nw(e) > 1 && (e.set = e.add = e.clear = e.delete = fce), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => iM(r, !0))), e;
}
function fce() {
  Ai(2);
}
function iw(e) {
  return Object.isFrozen(e);
}
var hce = {};
function _c(e) {
  const t = hce[e];
  return t || Ai(0, e), t;
}
var Af;
function UG() {
  return Af;
}
function gce(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function DA(e, t) {
  t && (_c("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function rk(e) {
  ok(e), e.drafts_.forEach(mce), e.drafts_ = null;
}
function ok(e) {
  e === Af && (Af = e.parent_);
}
function _A(e) {
  return Af = gce(Af, e);
}
function mce(e) {
  const t = e[ws];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function TA(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ws].modified_ && (rk(t), Ai(4)), Dc(e) && (e = Py(t, e), t.parent_ || Sy(t, e)), t.patches_ && _c("Patches").generateReplacementPatches_(
    n[ws].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Py(t, n, []), rk(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== NG ? e : void 0;
}
function Py(e, t, n) {
  if (iw(t))
    return t;
  const r = t[ws];
  if (!r)
    return ky(
      t,
      (o, i) => jA(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Sy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), ky(
      i,
      (s, l) => jA(e, r, o, s, l, n, a)
    ), Sy(e, o, !1), n && e.patches_ && _c("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function jA(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Ai(5), Mc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !tk(t.assigned_, r) ? i.concat(r) : void 0, l = Py(e, o, s);
    if (zG(n, r, l), Mc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Dc(o) && !iw(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Py(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Sy(e, o);
  }
}
function Sy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && iM(t, n);
}
function vce(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : UG(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = sM;
  n && (o = [r], i = Bf);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var sM = {
  get(e, t) {
    if (t === ws)
      return e;
    const n = Ku(e);
    if (!tk(n, t))
      return yce(e, n, t);
    const r = n[t];
    return e.finalized_ || !Dc(r) ? r : r === rO(e.base_, t) ? (oO(e), e.copy_[t] = sk(r, e)) : r;
  },
  has(e, t) {
    return t in Ku(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ku(e));
  },
  set(e, t, n) {
    const r = WG(Ku(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = rO(Ku(e), t), i = o == null ? void 0 : o[ws];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (dce(n, o) && (n !== void 0 || tk(e.base_, t)))
        return !0;
      oO(e), ik(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return rO(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, oO(e), ik(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ku(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Ai(11);
  },
  getPrototypeOf(e) {
    return pp(e.base_);
  },
  setPrototypeOf() {
    Ai(12);
  }
}, Bf = {};
ky(sM, (e, t) => {
  Bf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Bf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Ai(13), Bf.set.call(this, e, t, void 0);
};
Bf.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Ai(14), sM.set.call(this, e[0], t, n, e[0]);
};
function rO(e, t) {
  const n = e[ws];
  return (n ? Ku(n) : e)[t];
}
function yce(e, t, n) {
  var r;
  const o = WG(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function WG(e, t) {
  if (!(t in e))
    return;
  let n = pp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = pp(n);
  }
}
function ik(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && ik(e.parent_));
}
function oO(e) {
  e.copy_ || (e.copy_ = nk(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var bce = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Ai(6), r !== void 0 && typeof r != "function" && Ai(7);
      let o;
      if (Dc(t)) {
        const i = _A(this), a = sk(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? rk(i) : ok(i);
        }
        return DA(i, r), TA(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === NG && (o = void 0), this.autoFreeze_ && iM(o, !0), r) {
          const i = [], a = [];
          _c("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Ai(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Dc(e) || Ai(8), Mc(e) && (e = wce(e));
    const t = _A(this), n = sk(e, void 0);
    return n[ws].isManual_ = !0, ok(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ws];
    (!n || !n.isManual_) && Ai(9);
    const { scope_: r } = n;
    return DA(r, t), TA(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = _c("Patches").applyPatches_;
    return Mc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function sk(e, t) {
  const n = rw(e) ? _c("MapSet").proxyMap_(e, t) : ow(e) ? _c("MapSet").proxySet_(e, t) : vce(e, t);
  return (t ? t.scope_ : UG()).drafts_.push(n), n;
}
function wce(e) {
  return Mc(e) || Ai(10, e), HG(e);
}
function HG(e) {
  if (!Dc(e) || iw(e))
    return e;
  const t = e[ws];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = nk(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = nk(e, !0);
  return ky(n, (r, o) => {
    zG(n, r, HG(o));
  }), t && (t.finalized_ = !1), n;
}
var Cs = new bce(), aM = Cs.produce;
Cs.produceWithPatches.bind(
  Cs
);
Cs.setAutoFreeze.bind(Cs);
Cs.setUseStrictShallowCopy.bind(Cs);
Cs.applyPatches.bind(Cs);
var AA = Cs.createDraft.bind(Cs), BA = Cs.finishDraft.bind(Cs), qe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = qe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return qe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return qe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return qe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return qe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && qe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return qe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && qe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && qe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && qe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && qe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && qe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!qe.isAncestor(t, e) && !qe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (qe.equals(i, r) || qe.endsBefore(i, r) || qe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (qe.equals(a, r) || qe.isAncestor(a, r))
          return null;
        qe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        qe.equals(s, r) || qe.endsBefore(s, r) ? r[s.length - 1] -= 1 : qe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (qe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else qe.endsBefore(u, r) ? r[u.length - 1] += 1 : qe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (qe.equals(p, d))
          return r;
        if (qe.isAncestor(p, r) || qe.equals(p, r)) {
          var y = d.slice();
          return qe.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else qe.isSibling(p, d) && (qe.isAncestor(d, r) || qe.equals(d, r)) ? qe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : qe.endsBefore(d, r) || qe.equals(d, r) || qe.isAncestor(d, r) ? (qe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : qe.endsBefore(p, r) && (qe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function If(e) {
  "@babel/helpers - typeof";
  return If = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, If(e);
}
function Cce(e, t) {
  if (If(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (If(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Oce(e) {
  var t = Cce(e, "string");
  return If(t) === "symbol" ? t : String(t);
}
function Cp(e, t, n) {
  return t = Oce(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function IA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IA(Object(n), !0).forEach(function(r) {
      Cp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xce = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Mt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of qt.points(t))
          t[l] = Mr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Mt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of qt.points(t))
          t[b] = Mr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Mt.get(e, L), D = qe.previous(L), x = Mt.get(e, D), m = Mt.parent(e, L), C = L[L.length - 1];
      if (ko.isText(w) && ko.isText(x))
        x.text += w.text;
      else if (!ko.isText(w) && !ko.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(ns.stringify(w), " ").concat(ns.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of qt.points(t))
          t[U] = Mr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: N
      } = n;
      if (qe.isAncestor(k, N))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Mt.get(e, k), V = Mt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var W = qe.transform(k, n), Z = Mt.get(e, qe.parent(W)), X = W[W.length - 1];
      if (Z.children.splice(X, 0, R), t)
        for (var [K, Q] of qt.points(t))
          t[Q] = Mr.transform(K, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Mt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of qt.points(t)) {
          var H = Mr.transform(z, n);
          if (t != null && H != null)
            t[M] = H;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Mt.texts(e))
              if (qe.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var q = !1;
            O && j && (qe.equals(j[1], J) ? q = !qe.hasPrevious(j[1]) : q = qe.common(O[1], J).length < qe.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Y,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = Mt.leaf(e, B), he = le.text.slice(0, Y), oe = le.text.slice(Y + I.length);
      if (le.text = he + oe, t)
        for (var [Be, We] of qt.points(t))
          t[We] = Mr.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Ie,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var $e = Mt.get(e, He);
      for (var Ce in nt) {
        if (Ce === "children" || Ce === "text")
          throw new Error('Cannot set the "'.concat(Ce, '" property of nodes!'));
        var Qe = nt[Ce];
        Qe == null ? delete $e[Ce] : $e[Ce] = Qe;
      }
      for (var lt in Ie)
        nt.hasOwnProperty(lt) || delete $e[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: be
      } = n;
      if (be == null)
        t = be;
      else {
        if (t == null) {
          if (!qt.isRange(be))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ns.stringify(be), " when there is no current selection."));
          t = Gp({}, be);
        }
        for (var Ee in be) {
          var Ae = be[Ee];
          if (Ae == null) {
            if (Ee === "anchor" || Ee === "focus")
              throw new Error('Cannot remove the "'.concat(Ee, '" selection property'));
            delete t[Ee];
          } else
            t[Ee] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Re,
        properties: ot
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var ve = Mt.get(e, ze), yt = Mt.parent(e, ze), it = ze[ze.length - 1], st;
      if (ko.isText(ve)) {
        var ut = ve.text.slice(0, Re), bt = ve.text.slice(Re);
        ve.text = ut, st = Gp(Gp({}, ot), {}, {
          text: bt
        });
      } else {
        var ct = ve.children.slice(0, Re), wt = ve.children.slice(Re);
        ve.children = ct, st = Gp(Gp({}, ot), {}, {
          children: wt
        });
      }
      if (yt.children.splice(it + 1, 0, st), t)
        for (var [tt, gt] of qt.points(t))
          t[gt] = Mr.transform(tt, n);
      break;
    }
  }
  return t;
}, Lce = {
  transform(e, t) {
    e.children = AA(e.children);
    var n = e.selection && AA(e.selection);
    try {
      n = xce(e, n, t);
    } finally {
      e.children = BA(e.children), n ? e.selection = Mc(n) ? BA(n) : n : e.selection = null;
    }
  }
}, Ece = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, kce = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, VG = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (ii(r) && ii(o)) {
      if (!VG(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Pce(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Rf(e, t) {
  if (e == null) return {};
  var n = Pce(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Sce = ["anchor", "focus"];
function RA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mce(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RA(Object(n), !0).forEach(function(r) {
      Cp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return qt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = qt.edges(e);
    return t;
  },
  equals(e, t) {
    return Mr.equals(e.anchor, t.anchor) && Mr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (qt.isRange(t)) {
      if (qt.includes(e, t.anchor) || qt.includes(e, t.focus))
        return !0;
      var [n, r] = qt.edges(e), [o, i] = qt.edges(t);
      return Mr.isBefore(n, o) && Mr.isAfter(r, i);
    }
    var [a, s] = qt.edges(e), l = !1, u = !1;
    return Mr.isPoint(t) ? (l = Mr.compare(t, a) >= 0, u = Mr.compare(t, s) <= 0) : (l = qe.compare(t, a.path) >= 0, u = qe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Rf(e, Sce), [r, o] = qt.edges(e), [i, a] = qt.edges(t), s = Mr.isBefore(r, i) ? i : r, l = Mr.isBefore(o, a) ? o : a;
    return Mr.isBefore(l, s) ? null : Mce({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Mr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Mr.equals(t, n);
  },
  isExpanded(e) {
    return !qt.isCollapsed(e);
  },
  isForward(e) {
    return !qt.isBackward(e);
  },
  isRange(e) {
    return ii(e) && Mr.isPoint(e.anchor) && Mr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = qt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return aM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = qt.isCollapsed(r);
        qt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? qt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Mr.transform(r.anchor, t, {
        affinity: i
      }), u = Mr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, NA = (e) => ii(e) && Mt.isNodeList(e.children) && !ar.isEditor(e), Wa = {
  isAncestor(e) {
    return ii(e) && Mt.isNodeList(e.children);
  },
  isElement: NA,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Wa.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return NA(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Dce = ["children"], _ce = ["text"], FA = /* @__PURE__ */ new WeakMap(), Mt = {
  ancestor(e, t) {
    var n = Mt.get(e, t);
    if (ko.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ns.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of qe.ancestors(t, n)) {
        var o = Mt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ko.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ns.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ns.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Mt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Mt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = qe.common(t, n), o = Mt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Mt.get(e, t);
    if (ar.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ns.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        Wa.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Wa.isAncestor(e)) {
      var t = Rf(e, Dce);
      return t;
    } else {
      var t = Rf(e, _ce);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Mt.get(e, n); r && !(ko.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ko.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ns.stringify(e)));
    var n = aM({
      children: e.children
    }, (r) => {
      var [o, i] = qt.edges(t), a = Mt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !qt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!qt.includes(t, s)) {
          var l = Mt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (qe.equals(s, i.path)) {
          var c = Mt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (qe.equals(s, o.path)) {
          var p = Mt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      ar.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ko.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ns.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ko.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ko.isText(e) || Wa.isElement(e) || ar.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = FA.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Mt.isNode(r));
    return FA.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Mt.get(e, n); r && !(ko.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Mt.get(e, t);
    if (!ko.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ns.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of qe.levels(t, n)) {
        var o = Mt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Wa.isElement(e) && Wa.isElementProps(t) && Wa.matches(e, t) || ko.isText(e) && ko.isTextProps(t) && ko.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? qe.isBefore(s, i) : qe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ko.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          qe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Mt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = qe.next(s);
          if (Mt.has(e, c)) {
            s = c, l = Mt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = qe.previous(s);
          s = p, l = Mt.get(e, s);
          continue;
        }
        s = qe.parent(s), l = Mt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = qe.parent(t), r = Mt.get(e, n);
    if (ko.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ko.isText(e) ? e.text : e.children.map(Mt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        ko.isText(n) && (yield [n, r]);
    }();
  }
};
function zA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zA(Object(n), !0).forEach(function(r) {
      Cp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ad = {
  isNodeOperation(e) {
    return Ad.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!ii(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return qe.isPath(e.path) && Mt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && qe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && qe.isPath(e.path) && ii(e.properties);
      case "move_node":
        return qe.isPath(e.path) && qe.isPath(e.newPath);
      case "remove_node":
        return qe.isPath(e.path) && Mt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && qe.isPath(e.path);
      case "set_node":
        return qe.isPath(e.path) && ii(e.properties) && ii(e.newProperties);
      case "set_selection":
        return e.properties === null && qt.isRange(e.newProperties) || e.newProperties === null && qt.isRange(e.properties) || ii(e.properties) && ii(e.newProperties);
      case "split_node":
        return qe.isPath(e.path) && typeof e.position == "number" && ii(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Ad.isOperation(t));
  },
  isSelectionOperation(e) {
    return Ad.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Ad.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Rr(Rr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Rr(Rr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Rr(Rr({}, e), {}, {
          type: "split_node",
          path: qe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (qe.equals(t, n))
          return e;
        if (qe.isSibling(n, t))
          return Rr(Rr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = qe.transform(n, e), o = qe.transform(qe.next(n), e);
        return Rr(Rr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Rr(Rr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Rr(Rr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Rr(Rr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Rr(Rr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Rr(Rr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Rr(Rr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Rr(Rr({}, e), {}, {
          type: "merge_node",
          path: qe.next(e.path)
        });
    }
  }
}, UA = /* @__PURE__ */ new WeakMap(), Tce = (e) => {
  var t = UA.get(e);
  if (t !== void 0)
    return t;
  if (!ii(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || ii(e.marks)) && (e.selection === null || qt.isRange(e.selection)) && Mt.isNodeList(e.children) && Ad.isOperationList(e.operations);
  return UA.set(e, n), n;
}, ar = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Tce(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function WA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WA(Object(n), !0).forEach(function(r) {
      Cp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mr = {
  compare(e, t) {
    var n = qe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Mr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Mr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && qe.equals(e.path, t.path);
  },
  isPoint(e) {
    return ii(e) && typeof e.offset == "number" && qe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return aM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = qe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          qe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          qe.equals(t.path, i) && (r.offset += t.position), r.path = qe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          qe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (qe.equals(t.path, i) || qe.isAncestor(t.path, i))
            return null;
          r.path = qe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (qe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = qe.transform(i, t, HA(HA({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = qe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, VA = void 0, ns = {
  setScrubber(e) {
    VA = e;
  },
  stringify(e) {
    return JSON.stringify(e, VA);
  }
}, jce = ["text"], Ace = ["anchor", "focus"];
function $A(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $A(Object(n), !0).forEach(function(r) {
      Cp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $A(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ko = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Rf(i, jce);
      return a;
    }
    return VG(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return ii(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ko.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Pa({}, e)];
    for (var r of t) {
      var o = Rf(r, Ace), [i, a] = qt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = Pa(Pa({}, f), {}, {
            text: f.text.slice(L)
          }), f = Pa(Pa({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Pa(Pa({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Pa(Pa({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Bce = (e) => e.selection ? e.selection : e.children.length > 0 ? ar.end(e, []) : [0], Or;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Or || (Or = {}));
Or.L, Or.L | Or.V | Or.LV | Or.LVT, Or.LV | Or.V, Or.V | Or.T, Or.LVT | Or.T, Or.T, Or.Any, Or.Extend | Or.ZWJ, Or.Any, Or.SpacingMark, Or.Prepend, Or.Any, Or.ZWJ, Or.ExtPict, Or.RI, Or.RI;
var Ice = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    ar.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Bce(e)
      } = n;
      if (qe.isPath(o) && (o = ar.range(e, o)), qt.isRange(o))
        if (qt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = qt.end(o);
          if (!r && ar.void(e, {
            at: i
          }))
            return;
          var a = qt.start(o), s = ar.pointRef(e, a), l = ar.pointRef(e, i);
          My.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, My.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && ar.void(e, {
        at: o
      }) || ar.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function qA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ig(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qA(Object(n), !0).forEach(function(r) {
      Cp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var My = Ig(Ig(Ig(Ig({}, Lce), Ece), kce), Ice), $G = {}, lM = {}, uM = {};
Object.defineProperty(uM, "__esModule", { value: !0 });
uM.default = zce;
var ZA = "html", GA = "head", Rg = "body", Rce = /<([a-zA-Z]+[0-9]?)/, YA = /<head[^]*>/i, XA = /<body[^]*>/i, Dy = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, ak = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, KA = typeof window == "object" && window.DOMParser;
if (typeof KA == "function") {
  var Nce = new KA(), Fce = "text/html";
  ak = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Nce.parseFromString(e, Fce);
  }, Dy = ak;
}
if (typeof document == "object" && document.implementation) {
  var Ng = document.implementation.createHTMLDocument();
  Dy = function(e, t) {
    if (t) {
      var n = Ng.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Ng;
    }
    return Ng.documentElement.innerHTML = e, Ng;
  };
}
var Fg = typeof document == "object" && document.createElement("template"), lk;
Fg && Fg.content && (lk = function(e) {
  return Fg.innerHTML = e, Fg.content.childNodes;
});
function zce(e) {
  var t, n, r = e.match(Rce), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case ZA: {
      var i = ak(e);
      if (!YA.test(e)) {
        var a = i.querySelector(GA);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!XA.test(e)) {
        var a = i.querySelector(Rg);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(ZA);
    }
    case GA:
    case Rg: {
      var s = Dy(e).querySelectorAll(o);
      return XA.test(e) && YA.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (lk)
        return lk(e);
      var a = Dy(e, Rg).querySelector(Rg);
      return a.childNodes;
    }
  }
}
var sw = {}, cM = {}, pM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(pM);
var tn = {}, cu = gr && gr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Kd = gr && gr.__assign || function() {
  return Kd = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Kd.apply(this, arguments);
};
Object.defineProperty(tn, "__esModule", { value: !0 });
tn.cloneNode = tn.hasChildren = tn.isDocument = tn.isDirective = tn.isComment = tn.isText = tn.isCDATA = tn.isTag = tn.Element = tn.Document = tn.CDATA = tn.NodeWithChildren = tn.ProcessingInstruction = tn.Comment = tn.Text = tn.DataNode = tn.Node = void 0;
var Gi = pM, dM = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), fM(this, t);
    }, e;
  }()
);
tn.Node = dM;
var aw = (
  /** @class */
  function(e) {
    cu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(dM)
);
tn.DataNode = aw;
var qG = (
  /** @class */
  function(e) {
    cu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Gi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(aw)
);
tn.Text = qG;
var ZG = (
  /** @class */
  function(e) {
    cu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Gi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(aw)
);
tn.Comment = ZG;
var GG = (
  /** @class */
  function(e) {
    cu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Gi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(aw)
);
tn.ProcessingInstruction = GG;
var lw = (
  /** @class */
  function(e) {
    cu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(dM)
);
tn.NodeWithChildren = lw;
var YG = (
  /** @class */
  function(e) {
    cu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Gi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(lw)
);
tn.CDATA = YG;
var XG = (
  /** @class */
  function(e) {
    cu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Gi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(lw)
);
tn.Document = XG;
var KG = (
  /** @class */
  function(e) {
    cu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Gi.ElementType.Script : n === "style" ? Gi.ElementType.Style : Gi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(lw)
);
tn.Element = KG;
function JG(e) {
  return (0, Gi.isTag)(e);
}
tn.isTag = JG;
function QG(e) {
  return e.type === Gi.ElementType.CDATA;
}
tn.isCDATA = QG;
function eY(e) {
  return e.type === Gi.ElementType.Text;
}
tn.isText = eY;
function tY(e) {
  return e.type === Gi.ElementType.Comment;
}
tn.isComment = tY;
function nY(e) {
  return e.type === Gi.ElementType.Directive;
}
tn.isDirective = nY;
function rY(e) {
  return e.type === Gi.ElementType.Root;
}
tn.isDocument = rY;
function Uce(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
tn.hasChildren = Uce;
function fM(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (eY(e))
    n = new qG(e.data);
  else if (tY(e))
    n = new ZG(e.data);
  else if (JG(e)) {
    var r = t ? iO(e.children) : [], o = new KG(e.name, Kd({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Kd({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Kd({}, e["x-attribsPrefix"])), n = o;
  } else if (QG(e)) {
    var r = t ? iO(e.children) : [], i = new YG(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (rY(e)) {
    var r = t ? iO(e.children) : [], a = new XG(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (nY(e)) {
    var s = new GG(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
tn.cloneNode = fM;
function iO(e) {
  for (var t = e.map(function(r) {
    return fM(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = gr && gr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = gr && gr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = pM, o = tn;
  n(tn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(cM);
var oY = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(oY);
Object.defineProperty(sw, "__esModule", { value: !0 });
sw.formatAttributes = iY;
sw.formatDOM = sY;
var zg = cM, Wce = oY;
function Hce(e) {
  return Wce.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function iY(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Vce(e) {
  e = e.toLowerCase();
  var t = Hce(e);
  return t || e;
}
function sY(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Vce(s.nodeName);
        o = new zg.Element(l, iY(s.attributes)), o.children = sY(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new zg.Text(s.nodeValue);
        break;
      case 8:
        o = new zg.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new zg.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var $ce = gr && gr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(lM, "__esModule", { value: !0 });
lM.default = Yce;
var qce = $ce(uM), Zce = sw, Gce = /<(![a-zA-Z\s]+)>/;
function Yce(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Gce), n = t ? t[1] : void 0;
  return (0, Zce.formatDOM)((0, qce.default)(e), null, n);
}
var uw = {}, qs = {}, cw = {}, Xce = 0;
cw.SAME = Xce;
var Kce = 1;
cw.CAMELCASE = Kce;
cw.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const aY = 0, pu = 1, pw = 2, dw = 3, hM = 4, lY = 5, uY = 6;
function Jce(e) {
  return Ko.hasOwnProperty(e) ? Ko[e] : null;
}
function Ei(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === pw || t === dw || t === hM, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Ko = {}, Qce = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Qce.forEach((e) => {
  Ko[e] = new Ei(
    e,
    aY,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Ko[e] = new Ei(
    e,
    pu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Ko[e] = new Ei(
    e,
    pw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Ko[e] = new Ei(
    e,
    pw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Ko[e] = new Ei(
    e,
    dw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ko[e] = new Ei(
    e,
    dw,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ko[e] = new Ei(
    e,
    hM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Ko[e] = new Ei(
    e,
    uY,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Ko[e] = new Ei(
    e,
    lY,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const gM = /[\-\:]([a-z])/g, mM = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(gM, mM);
  Ko[t] = new Ei(
    t,
    pu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(gM, mM);
  Ko[t] = new Ei(
    t,
    pu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(gM, mM);
  Ko[t] = new Ei(
    t,
    pu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Ko[e] = new Ei(
    e,
    pu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const epe = "xlinkHref";
Ko[epe] = new Ei(
  "xlinkHref",
  pu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Ko[e] = new Ei(
    e,
    pu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: tpe,
  SAME: npe,
  possibleStandardNames: JA
} = cw, rpe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ope = rpe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ipe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + ope + "]*$")
), spe = Object.keys(
  JA
).reduce((e, t) => {
  const n = JA[t];
  return n === npe ? e[t] = t : n === tpe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
qs.BOOLEAN = dw;
qs.BOOLEANISH_STRING = pw;
qs.NUMERIC = lY;
qs.OVERLOADED_BOOLEAN = hM;
qs.POSITIVE_NUMERIC = uY;
qs.RESERVED = aY;
qs.STRING = pu;
qs.getPropertyInfo = Jce;
qs.isCustomAttribute = ipe;
qs.possibleStandardNames = spe;
var vM = {}, yM = {}, QA = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, ape = /\n/g, lpe = /^\s*/, upe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, cpe = /^:\s*/, ppe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, dpe = /^[;\s]*/, fpe = /^\s+|\s+$/g, hpe = `
`, eB = "/", tB = "*", sc = "", gpe = "comment", mpe = "declaration", vpe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(ape);
    v && (n += v.length);
    var b = f.lastIndexOf(hpe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(lpe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(eB != e.charAt(0) || tB != e.charAt(1))) {
      for (var v = 2; sc != e.charAt(v) && (tB != e.charAt(v) || eB != e.charAt(v + 1)); )
        ++v;
      if (v += 2, sc === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: gpe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(upe);
    if (v) {
      if (p(), !l(cpe)) return s("property missing ':'");
      var b = l(ppe), L = f({
        type: mpe,
        property: nB(v[0].replace(QA, sc)),
        value: b ? nB(b[0].replace(QA, sc)) : sc
      });
      return l(dpe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function nB(e) {
  return e ? e.replace(fpe, sc) : sc;
}
var ype = gr && gr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(yM, "__esModule", { value: !0 });
yM.default = wpe;
var bpe = ype(vpe);
function wpe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, bpe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var fw = {};
Object.defineProperty(fw, "__esModule", { value: !0 });
fw.camelCase = void 0;
var Cpe = /^--[a-zA-Z0-9_-]+$/, Ope = /-([a-z])/g, xpe = /^[^-]+$/, Lpe = /^-(webkit|moz|ms|o|khtml)-/, Epe = /^-(ms)-/, kpe = function(e) {
  return !e || xpe.test(e) || Cpe.test(e);
}, Ppe = function(e, t) {
  return t.toUpperCase();
}, rB = function(e, t) {
  return "".concat(t, "-");
}, Spe = function(e, t) {
  return t === void 0 && (t = {}), kpe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Epe, rB) : e = e.replace(Lpe, rB), e.replace(Ope, Ppe));
};
fw.camelCase = Spe;
var Mpe = gr && gr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Dpe = Mpe(yM), _pe = fw;
function uk(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Dpe.default)(e, function(r, o) {
    r && o && (n[(0, _pe.camelCase)(r, t)] = o);
  }), n;
}
uk.default = uk;
var Tpe = uk;
(function(e) {
  var t = gr && gr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Tpe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(vM);
Object.defineProperty(uw, "__esModule", { value: !0 });
uw.default = Ipe;
var Bd = qs, oB = vM, jpe = ["checked", "value"], Ape = ["input", "select", "textarea"], Bpe = {
  reset: !0,
  submit: !0
};
function Ipe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Bpe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Bd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = iB(a);
    if (s) {
      var l = (0, Bd.getPropertyInfo)(s);
      switch (jpe.includes(s) && Ape.includes(t) && !r && (s = iB("default" + a)), n[s] = i, l && l.type) {
        case Bd.BOOLEAN:
          n[s] = !0;
          break;
        case Bd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    oB.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, oB.setStyleProp)(e.style, n), n;
}
function iB(e) {
  return Bd.possibleStandardNames[e];
}
var bM = {}, Rpe = gr && gr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(bM, "__esModule", { value: !0 });
bM.default = cY;
var sO = we, Npe = Rpe(uw), Jd = vM, Fpe = {
  cloneElement: sO.cloneElement,
  createElement: sO.createElement,
  isValidElement: sO.isValidElement
};
function cY(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Jd.returnFirstArg, i = t.library || Fpe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Jd.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    zpe(f) ? ((0, Jd.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Npe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = cY(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function zpe(e) {
  return Jd.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Jd.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = gr && gr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(lM);
  e.htmlToDOM = n.default;
  var r = t(uw);
  e.attributesToProps = r.default;
  var o = t(bM);
  e.domToReact = o.default;
  var i = cM;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})($G);
const sB = /* @__PURE__ */ ace($G);
sB.default;
function Upe(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ sr.jsx("div", { className: o.trim(), ...r });
}
var mr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Wpe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ck = { exports: {} }, Yp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aB;
function Hpe() {
  if (aB) return Yp;
  aB = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Yp.Fragment = n, Yp.jsx = a, Yp.jsxs = a, Yp;
}
var Ug = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lB;
function Vpe() {
  return lB || (lB = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var A = f && g[f] || g[v];
      return typeof A == "function" ? A : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), te = 1; te < A; te++)
          G[te - 1] = arguments[te];
        D("error", g, G);
      }
    }
    function D(g, A, G) {
      {
        var te = L.ReactDebugCurrentFrame, ae = te.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function N(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function R(g, A, G) {
      var te = g.displayName;
      if (te)
        return te;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var A = g;
            return V(A) + ".Consumer";
          case a:
            var G = g;
            return V(G._context) + ".Provider";
          case l:
            return R(g, g.render, "ForwardRef");
          case p:
            var te = g.displayName || null;
            return te !== null ? te : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, Z = 0, X, K, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function H() {
      {
        if (Z === 0) {
          X = console.log, K = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, g, {
              value: X
            }),
            info: W({}, g, {
              value: K
            }),
            warn: W({}, g, {
              value: Q
            }),
            error: W({}, g, {
              value: J
            }),
            group: W({}, g, {
              value: P
            }),
            groupCollapsed: W({}, g, {
              value: _
            }),
            groupEnd: W({}, g, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = L.ReactCurrentDispatcher, F;
    function T(g, A, G) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var te = ae.stack.trim().match(/\n( *(at )?)/);
            F = te && te[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, B;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Y();
    }
    function I(g, A) {
      if (!g || q)
        return "";
      {
        var G = B.get(g);
        if (G !== void 0)
          return G;
      }
      var te;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, H();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              te = je;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              te = je;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            te = je;
          }
          g();
        }
      } catch (je) {
        if (je && te && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = te.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var Ue = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", g.displayName)), typeof g == "function" && B.set(g, Ue), Ue;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Lt = g ? g.displayName || g.name : "", vt = Lt ? T(Lt) : "";
      return typeof g == "function" && B.set(g, vt), vt;
    }
    function le(g, A, G) {
      return I(g, !1);
    }
    function he(g) {
      var A = g.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(g, A, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return I(g, he(g));
      if (typeof g == "string")
        return T(g);
      switch (g) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return oe(g.type, A, G);
          case d: {
            var te = g, ae = te._payload, ue = te._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, We = {}, He = L.ReactDebugCurrentFrame;
    function Ie(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(g, A, G, te, ae) {
      {
        var ue = Function.call.bind(Be);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var Oe = Error((te || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = g[se](A, se, te, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Ie(ae), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ce(g) {
      return $e(g);
    }
    function Qe(g) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function lt(g) {
      try {
        return be(g), !1;
      } catch {
        return !0;
      }
    }
    function be(g) {
      return "" + g;
    }
    function Ee(g) {
      if (lt(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(g)), be(g);
    }
    var Ae = L.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, ot, ve;
    ve = {};
    function yt(g) {
      if (Be.call(g, "ref")) {
        var A = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function it(g) {
      if (Be.call(g, "key")) {
        var A = Object.getOwnPropertyDescriptor(g, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function st(g, A) {
      if (typeof g.ref == "string" && Ae.current && A && Ae.current.stateNode !== A) {
        var G = $(Ae.current.type);
        ve[G] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ae.current.type), g.ref), ve[G] = !0);
      }
    }
    function ut(g, A) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function bt(g, A) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var ct = function(g, A, G, te, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function wt(g, A, G, te, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (Ee(G), ie = "" + G), it(A) && (Ee(A.key), ie = "" + A.key), yt(A) && (Oe = A.ref, st(A, ae));
        for (ue in A)
          Be.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && ut(se, fe), Oe && bt(se, fe);
        }
        return ct(g, ie, Oe, ae, te, Ae.current, se);
      }
    }
    var tt = L.ReactCurrentOwner, gt = L.ReactDebugCurrentFrame;
    function rt(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        gt.setExtraStackFrame(G);
      } else
        gt.setExtraStackFrame(null);
    }
    var Ct;
    Ct = !1;
    function pt(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Et() {
      {
        if (tt.current) {
          var g = $(tt.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Ot(g) {
      return "";
    }
    var kt = {};
    function xt(g) {
      {
        var A = Et();
        if (!A) {
          var G = typeof g == "string" ? g : g.displayName || g.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function Pt(g, A) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var G = xt(A);
        if (kt[G])
          return;
        kt[G] = !0;
        var te = "";
        g && g._owner && g._owner !== tt.current && (te = " It was passed a child from " + $(g._owner.type) + "."), rt(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, te), rt(null);
      }
    }
    function Vt(g, A) {
      {
        if (typeof g != "object")
          return;
        if (Ce(g))
          for (var G = 0; G < g.length; G++) {
            var te = g[G];
            pt(te) && Pt(te, A);
          }
        else if (pt(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              pt(se.value) && Pt(se.value, A);
        }
      }
    }
    function mt(g) {
      {
        var A = g.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var te = $(A);
          nt(G, g.props, "prop", te, g);
        } else if (A.PropTypes !== void 0 && !Ct) {
          Ct = !0;
          var ae = $(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ne(g) {
      {
        for (var A = Object.keys(g.props), G = 0; G < A.length; G++) {
          var te = A[G];
          if (te !== "children" && te !== "key") {
            rt(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), rt(null);
            break;
          }
        }
        g.ref !== null && (rt(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var so = {};
    function ao(g, A, G, te, ae, ue) {
      {
        var se = N(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ot();
          Oe ? ie += Oe : ie += Et();
          var de;
          g === null ? de = "null" : Ce(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = wt(g, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Ue = A.children;
          if (Ue !== void 0)
            if (te)
              if (Ce(Ue)) {
                for (var Lt = 0; Lt < Ue.length; Lt++)
                  Vt(Ue[Lt], g);
                Object.freeze && Object.freeze(Ue);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vt(Ue, g);
        }
        if (Be.call(A, "key")) {
          var vt = $(g), je = Object.keys(A).filter(function(wi) {
            return wi !== "key";
          }), Wn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[vt + Wn]) {
            var bi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wn, vt, bi, vt), so[vt + Wn] = !0;
          }
        }
        return g === r ? ne(fe) : mt(fe), fe;
      }
    }
    function gi(g, A, G) {
      return ao(g, A, G, !0);
    }
    function mi(g, A, G) {
      return ao(g, A, G, !1);
    }
    var vi = mi, yi = gi;
    Ug.Fragment = r, Ug.jsx = vi, Ug.jsxs = yi;
  }()), Ug;
}
process.env.NODE_ENV === "production" ? ck.exports = Hpe() : ck.exports = Vpe();
var Ui = ck.exports;
Ve({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function uB(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function si(e) {
  var t, n;
  return uB(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(uB(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var pY = Symbol.for("immer-nothing"), cB = Symbol.for("immer-draftable"), Os = Symbol.for("immer-state"), $pe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Bi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = $pe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var dp = Object.getPrototypeOf;
function Tc(e) {
  return !!e && !!e[Os];
}
function jc(e) {
  var t;
  return e ? dY(e) || Array.isArray(e) || !!e[cB] || !!((t = e.constructor) != null && t[cB]) || gw(e) || mw(e) : !1;
}
var qpe = Object.prototype.constructor.toString();
function dY(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = dp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === qpe;
}
function _y(e, t) {
  hw(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function hw(e) {
  const t = e[Os];
  return t ? t.type_ : Array.isArray(e) ? 1 : gw(e) ? 2 : mw(e) ? 3 : 0;
}
function pk(e, t) {
  return hw(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function fY(e, t, n) {
  const r = hw(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Zpe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function gw(e) {
  return e instanceof Map;
}
function mw(e) {
  return e instanceof Set;
}
function Ju(e) {
  return e.copy_ || e.base_;
}
function dk(e, t) {
  if (gw(e))
    return new Map(e);
  if (mw(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = dY(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Os];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(dp(e), r);
  } else {
    const r = dp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function wM(e, t = !1) {
  return vw(e) || Tc(e) || !jc(e) || (hw(e) > 1 && (e.set = e.add = e.clear = e.delete = Gpe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => wM(r, !0))), e;
}
function Gpe() {
  Bi(2);
}
function vw(e) {
  return Object.isFrozen(e);
}
var Ype = {};
function Ac(e) {
  const t = Ype[e];
  return t || Bi(0, e), t;
}
var Nf;
function hY() {
  return Nf;
}
function Xpe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function pB(e, t) {
  t && (Ac("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function fk(e) {
  hk(e), e.drafts_.forEach(Kpe), e.drafts_ = null;
}
function hk(e) {
  e === Nf && (Nf = e.parent_);
}
function dB(e) {
  return Nf = Xpe(Nf, e);
}
function Kpe(e) {
  const t = e[Os];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function fB(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Os].modified_ && (fk(t), Bi(4)), jc(e) && (e = Ty(t, e), t.parent_ || jy(t, e)), t.patches_ && Ac("Patches").generateReplacementPatches_(
    n[Os].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Ty(t, n, []), fk(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== pY ? e : void 0;
}
function Ty(e, t, n) {
  if (vw(t))
    return t;
  const r = t[Os];
  if (!r)
    return _y(
      t,
      (o, i) => hB(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return jy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), _y(
      i,
      (s, l) => hB(e, r, o, s, l, n, a)
    ), jy(e, o, !1), n && e.patches_ && Ac("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function hB(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Bi(5), Tc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !pk(t.assigned_, r) ? i.concat(r) : void 0, l = Ty(e, o, s);
    if (fY(n, r, l), Tc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (jc(o) && !vw(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Ty(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && jy(e, o);
  }
}
function jy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && wM(t, n);
}
function Jpe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : hY(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = CM;
  n && (o = [r], i = Ff);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var CM = {
  get(e, t) {
    if (t === Os)
      return e;
    const n = Ju(e);
    if (!pk(n, t))
      return Qpe(e, n, t);
    const r = n[t];
    return e.finalized_ || !jc(r) ? r : r === aO(e.base_, t) ? (lO(e), e.copy_[t] = mk(r, e)) : r;
  },
  has(e, t) {
    return t in Ju(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ju(e));
  },
  set(e, t, n) {
    const r = gY(Ju(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = aO(Ju(e), t), i = o == null ? void 0 : o[Os];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Zpe(n, o) && (n !== void 0 || pk(e.base_, t)))
        return !0;
      lO(e), gk(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return aO(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, lO(e), gk(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ju(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Bi(11);
  },
  getPrototypeOf(e) {
    return dp(e.base_);
  },
  setPrototypeOf() {
    Bi(12);
  }
}, Ff = {};
_y(CM, (e, t) => {
  Ff[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ff.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Bi(13), Ff.set.call(this, e, t, void 0);
};
Ff.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Bi(14), CM.set.call(this, e[0], t, n, e[0]);
};
function aO(e, t) {
  const n = e[Os];
  return (n ? Ju(n) : e)[t];
}
function Qpe(e, t, n) {
  var r;
  const o = gY(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function gY(e, t) {
  if (!(t in e))
    return;
  let n = dp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = dp(n);
  }
}
function gk(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && gk(e.parent_));
}
function lO(e) {
  e.copy_ || (e.copy_ = dk(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var ede = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Bi(6), r !== void 0 && typeof r != "function" && Bi(7);
      let o;
      if (jc(t)) {
        const i = dB(this), a = mk(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? fk(i) : hk(i);
        }
        return pB(i, r), fB(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === pY && (o = void 0), this.autoFreeze_ && wM(o, !0), r) {
          const i = [], a = [];
          Ac("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Bi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    jc(e) || Bi(8), Tc(e) && (e = tde(e));
    const t = dB(this), n = mk(e, void 0);
    return n[Os].isManual_ = !0, hk(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Os];
    (!n || !n.isManual_) && Bi(9);
    const { scope_: r } = n;
    return pB(r, t), fB(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ac("Patches").applyPatches_;
    return Tc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function mk(e, t) {
  const n = gw(e) ? Ac("MapSet").proxyMap_(e, t) : mw(e) ? Ac("MapSet").proxySet_(e, t) : Jpe(e, t);
  return (t ? t.scope_ : hY()).drafts_.push(n), n;
}
function tde(e) {
  return Tc(e) || Bi(10, e), mY(e);
}
function mY(e) {
  if (!jc(e) || vw(e))
    return e;
  const t = e[Os];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = dk(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = dk(e, !0);
  return _y(n, (r, o) => {
    fY(n, r, mY(o));
  }), t && (t.finalized_ = !1), n;
}
var xs = new ede(), OM = xs.produce;
xs.produceWithPatches.bind(
  xs
);
xs.setAutoFreeze.bind(xs);
xs.setUseStrictShallowCopy.bind(xs);
xs.applyPatches.bind(xs);
var gB = xs.createDraft.bind(xs), mB = xs.finishDraft.bind(xs), Ze = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ze.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ze.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ze.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ze.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ze.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ze.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ze.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ze.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ze.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ze.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ze.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ze.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ze.isAncestor(t, e) && !Ze.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ze.equals(i, r) || Ze.endsBefore(i, r) || Ze.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ze.equals(a, r) || Ze.isAncestor(a, r))
          return null;
        Ze.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ze.equals(s, r) || Ze.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ze.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ze.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ze.endsBefore(u, r) ? r[u.length - 1] += 1 : Ze.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ze.equals(p, d))
          return r;
        if (Ze.isAncestor(p, r) || Ze.equals(p, r)) {
          var y = d.slice();
          return Ze.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Ze.isSibling(p, d) && (Ze.isAncestor(d, r) || Ze.equals(d, r)) ? Ze.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ze.endsBefore(d, r) || Ze.equals(d, r) || Ze.isAncestor(d, r) ? (Ze.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ze.endsBefore(p, r) && (Ze.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function zf(e) {
  "@babel/helpers - typeof";
  return zf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zf(e);
}
function nde(e, t) {
  if (zf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (zf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function rde(e) {
  var t = nde(e, "string");
  return zf(t) === "symbol" ? t : String(t);
}
function Op(e, t, n) {
  return t = rde(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function vB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vB(Object(n), !0).forEach(function(r) {
      Op(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ode = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Dt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Zt.points(t))
          t[l] = Dr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Dt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Zt.points(t))
          t[b] = Dr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Dt.get(e, L), D = Ze.previous(L), x = Dt.get(e, D), m = Dt.parent(e, L), C = L[L.length - 1];
      if (Po.isText(w) && Po.isText(x))
        x.text += w.text;
      else if (!Po.isText(w) && !Po.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(rs.stringify(w), " ").concat(rs.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Zt.points(t))
          t[U] = Dr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: N
      } = n;
      if (Ze.isAncestor(k, N))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Dt.get(e, k), V = Dt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var W = Ze.transform(k, n), Z = Dt.get(e, Ze.parent(W)), X = W[W.length - 1];
      if (Z.children.splice(X, 0, R), t)
        for (var [K, Q] of Zt.points(t))
          t[Q] = Dr.transform(K, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Dt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Zt.points(t)) {
          var H = Dr.transform(z, n);
          if (t != null && H != null)
            t[M] = H;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Dt.texts(e))
              if (Ze.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var q = !1;
            O && j && (Ze.equals(j[1], J) ? q = !Ze.hasPrevious(j[1]) : q = Ze.common(O[1], J).length < Ze.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Y,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = Dt.leaf(e, B), he = le.text.slice(0, Y), oe = le.text.slice(Y + I.length);
      if (le.text = he + oe, t)
        for (var [Be, We] of Zt.points(t))
          t[We] = Dr.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Ie,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var $e = Dt.get(e, He);
      for (var Ce in nt) {
        if (Ce === "children" || Ce === "text")
          throw new Error('Cannot set the "'.concat(Ce, '" property of nodes!'));
        var Qe = nt[Ce];
        Qe == null ? delete $e[Ce] : $e[Ce] = Qe;
      }
      for (var lt in Ie)
        nt.hasOwnProperty(lt) || delete $e[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: be
      } = n;
      if (be == null)
        t = be;
      else {
        if (t == null) {
          if (!Zt.isRange(be))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(rs.stringify(be), " when there is no current selection."));
          t = Xp({}, be);
        }
        for (var Ee in be) {
          var Ae = be[Ee];
          if (Ae == null) {
            if (Ee === "anchor" || Ee === "focus")
              throw new Error('Cannot remove the "'.concat(Ee, '" selection property'));
            delete t[Ee];
          } else
            t[Ee] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Re,
        properties: ot
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var ve = Dt.get(e, ze), yt = Dt.parent(e, ze), it = ze[ze.length - 1], st;
      if (Po.isText(ve)) {
        var ut = ve.text.slice(0, Re), bt = ve.text.slice(Re);
        ve.text = ut, st = Xp(Xp({}, ot), {}, {
          text: bt
        });
      } else {
        var ct = ve.children.slice(0, Re), wt = ve.children.slice(Re);
        ve.children = ct, st = Xp(Xp({}, ot), {}, {
          children: wt
        });
      }
      if (yt.children.splice(it + 1, 0, st), t)
        for (var [tt, gt] of Zt.points(t))
          t[gt] = Dr.transform(tt, n);
      break;
    }
  }
  return t;
}, ide = {
  transform(e, t) {
    e.children = gB(e.children);
    var n = e.selection && gB(e.selection);
    try {
      n = ode(e, n, t);
    } finally {
      e.children = mB(e.children), n ? e.selection = Tc(n) ? mB(n) : n : e.selection = null;
    }
  }
}, sde = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, ade = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, vY = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (si(r) && si(o)) {
      if (!vY(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function lde(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Uf(e, t) {
  if (e == null) return {};
  var n = lde(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var ude = ["anchor", "focus"];
function yB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cde(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yB(Object(n), !0).forEach(function(r) {
      Op(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Zt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Zt.edges(e);
    return t;
  },
  equals(e, t) {
    return Dr.equals(e.anchor, t.anchor) && Dr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Zt.isRange(t)) {
      if (Zt.includes(e, t.anchor) || Zt.includes(e, t.focus))
        return !0;
      var [n, r] = Zt.edges(e), [o, i] = Zt.edges(t);
      return Dr.isBefore(n, o) && Dr.isAfter(r, i);
    }
    var [a, s] = Zt.edges(e), l = !1, u = !1;
    return Dr.isPoint(t) ? (l = Dr.compare(t, a) >= 0, u = Dr.compare(t, s) <= 0) : (l = Ze.compare(t, a.path) >= 0, u = Ze.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Uf(e, ude), [r, o] = Zt.edges(e), [i, a] = Zt.edges(t), s = Dr.isBefore(r, i) ? i : r, l = Dr.isBefore(o, a) ? o : a;
    return Dr.isBefore(l, s) ? null : cde({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Dr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Dr.equals(t, n);
  },
  isExpanded(e) {
    return !Zt.isCollapsed(e);
  },
  isForward(e) {
    return !Zt.isBackward(e);
  },
  isRange(e) {
    return si(e) && Dr.isPoint(e.anchor) && Dr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Zt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return OM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Zt.isCollapsed(r);
        Zt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Zt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Dr.transform(r.anchor, t, {
        affinity: i
      }), u = Dr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, bB = (e) => si(e) && Dt.isNodeList(e.children) && !lr.isEditor(e), Ha = {
  isAncestor(e) {
    return si(e) && Dt.isNodeList(e.children);
  },
  isElement: bB,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ha.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return bB(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, pde = ["children"], dde = ["text"], wB = /* @__PURE__ */ new WeakMap(), Dt = {
  ancestor(e, t) {
    var n = Dt.get(e, t);
    if (Po.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(rs.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ze.ancestors(t, n)) {
        var o = Dt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Po.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(rs.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(rs.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Dt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Dt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ze.common(t, n), o = Dt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Dt.get(e, t);
    if (lr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(rs.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        Ha.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ha.isAncestor(e)) {
      var t = Uf(e, pde);
      return t;
    } else {
      var t = Uf(e, dde);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Dt.get(e, n); r && !(Po.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Po.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(rs.stringify(e)));
    var n = OM({
      children: e.children
    }, (r) => {
      var [o, i] = Zt.edges(t), a = Dt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Zt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Zt.includes(t, s)) {
          var l = Dt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ze.equals(s, i.path)) {
          var c = Dt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ze.equals(s, o.path)) {
          var p = Dt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      lr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Po.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(rs.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Po.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Po.isText(e) || Ha.isElement(e) || lr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = wB.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Dt.isNode(r));
    return wB.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Dt.get(e, n); r && !(Po.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Dt.get(e, t);
    if (!Po.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(rs.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ze.levels(t, n)) {
        var o = Dt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ha.isElement(e) && Ha.isElementProps(t) && Ha.matches(e, t) || Po.isText(e) && Po.isTextProps(t) && Po.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ze.isBefore(s, i) : Ze.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Po.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ze.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Dt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ze.next(s);
          if (Dt.has(e, c)) {
            s = c, l = Dt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ze.previous(s);
          s = p, l = Dt.get(e, s);
          continue;
        }
        s = Ze.parent(s), l = Dt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ze.parent(t), r = Dt.get(e, n);
    if (Po.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Po.isText(e) ? e.text : e.children.map(Dt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Dt.nodes(e, t))
        Po.isText(n) && (yield [n, r]);
    }();
  }
};
function CB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CB(Object(n), !0).forEach(function(r) {
      Op(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Id = {
  isNodeOperation(e) {
    return Id.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!si(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ze.isPath(e.path) && Dt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ze.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ze.isPath(e.path) && si(e.properties);
      case "move_node":
        return Ze.isPath(e.path) && Ze.isPath(e.newPath);
      case "remove_node":
        return Ze.isPath(e.path) && Dt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ze.isPath(e.path);
      case "set_node":
        return Ze.isPath(e.path) && si(e.properties) && si(e.newProperties);
      case "set_selection":
        return e.properties === null && Zt.isRange(e.newProperties) || e.newProperties === null && Zt.isRange(e.properties) || si(e.properties) && si(e.newProperties);
      case "split_node":
        return Ze.isPath(e.path) && typeof e.position == "number" && si(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Id.isOperation(t));
  },
  isSelectionOperation(e) {
    return Id.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Id.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Nr(Nr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Nr(Nr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Nr(Nr({}, e), {}, {
          type: "split_node",
          path: Ze.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ze.equals(t, n))
          return e;
        if (Ze.isSibling(n, t))
          return Nr(Nr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ze.transform(n, e), o = Ze.transform(Ze.next(n), e);
        return Nr(Nr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Nr(Nr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Nr(Nr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Nr(Nr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Nr(Nr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Nr(Nr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Nr(Nr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Nr(Nr({}, e), {}, {
          type: "merge_node",
          path: Ze.next(e.path)
        });
    }
  }
}, OB = /* @__PURE__ */ new WeakMap(), fde = (e) => {
  var t = OB.get(e);
  if (t !== void 0)
    return t;
  if (!si(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || si(e.marks)) && (e.selection === null || Zt.isRange(e.selection)) && Dt.isNodeList(e.children) && Id.isOperationList(e.operations);
  return OB.set(e, n), n;
}, lr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return fde(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function xB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xB(Object(n), !0).forEach(function(r) {
      Op(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Dr = {
  compare(e, t) {
    var n = Ze.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Dr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Dr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ze.equals(e.path, t.path);
  },
  isPoint(e) {
    return si(e) && typeof e.offset == "number" && Ze.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return OM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ze.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ze.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ze.equals(t.path, i) && (r.offset += t.position), r.path = Ze.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ze.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ze.equals(t.path, i) || Ze.isAncestor(t.path, i))
            return null;
          r.path = Ze.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ze.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ze.transform(i, t, LB(LB({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ze.transform(i, t, n);
          break;
        }
      }
    });
  }
}, EB = void 0, rs = {
  setScrubber(e) {
    EB = e;
  },
  stringify(e) {
    return JSON.stringify(e, EB);
  }
}, hde = ["text"], gde = ["anchor", "focus"];
function kB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kB(Object(n), !0).forEach(function(r) {
      Op(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Po = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Uf(i, hde);
      return a;
    }
    return vY(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return si(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Po.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Sa({}, e)];
    for (var r of t) {
      var o = Uf(r, gde), [i, a] = Zt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = Sa(Sa({}, f), {}, {
            text: f.text.slice(L)
          }), f = Sa(Sa({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Sa(Sa({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Sa(Sa({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, mde = (e) => e.selection ? e.selection : e.children.length > 0 ? lr.end(e, []) : [0], xr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(xr || (xr = {}));
xr.L, xr.L | xr.V | xr.LV | xr.LVT, xr.LV | xr.V, xr.V | xr.T, xr.LVT | xr.T, xr.T, xr.Any, xr.Extend | xr.ZWJ, xr.Any, xr.SpacingMark, xr.Prepend, xr.Any, xr.ZWJ, xr.ExtPict, xr.RI, xr.RI;
var vde = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    lr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = mde(e)
      } = n;
      if (Ze.isPath(o) && (o = lr.range(e, o)), Zt.isRange(o))
        if (Zt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Zt.end(o);
          if (!r && lr.void(e, {
            at: i
          }))
            return;
          var a = Zt.start(o), s = lr.pointRef(e, a), l = lr.pointRef(e, i);
          Ay.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Ay.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && lr.void(e, {
        at: o
      }) || lr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function PB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PB(Object(n), !0).forEach(function(r) {
      Op(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ay = Wg(Wg(Wg(Wg({}, ide), sde), ade), vde), yY = {}, xM = {}, LM = {};
Object.defineProperty(LM, "__esModule", { value: !0 });
LM.default = Cde;
var SB = "html", MB = "head", Hg = "body", yde = /<([a-zA-Z]+[0-9]?)/, DB = /<head[^]*>/i, _B = /<body[^]*>/i, By = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, vk = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, TB = typeof window == "object" && window.DOMParser;
if (typeof TB == "function") {
  var bde = new TB(), wde = "text/html";
  vk = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), bde.parseFromString(e, wde);
  }, By = vk;
}
if (typeof document == "object" && document.implementation) {
  var Vg = document.implementation.createHTMLDocument();
  By = function(e, t) {
    if (t) {
      var n = Vg.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Vg;
    }
    return Vg.documentElement.innerHTML = e, Vg;
  };
}
var $g = typeof document == "object" && document.createElement("template"), yk;
$g && $g.content && (yk = function(e) {
  return $g.innerHTML = e, $g.content.childNodes;
});
function Cde(e) {
  var t, n, r = e.match(yde), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case SB: {
      var i = vk(e);
      if (!DB.test(e)) {
        var a = i.querySelector(MB);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!_B.test(e)) {
        var a = i.querySelector(Hg);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(SB);
    }
    case MB:
    case Hg: {
      var s = By(e).querySelectorAll(o);
      return _B.test(e) && DB.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (yk)
        return yk(e);
      var a = By(e, Hg).querySelector(Hg);
      return a.childNodes;
    }
  }
}
var yw = {}, EM = {}, kM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(kM);
var nn = {}, du = mr && mr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Qd = mr && mr.__assign || function() {
  return Qd = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Qd.apply(this, arguments);
};
Object.defineProperty(nn, "__esModule", { value: !0 });
nn.cloneNode = nn.hasChildren = nn.isDocument = nn.isDirective = nn.isComment = nn.isText = nn.isCDATA = nn.isTag = nn.Element = nn.Document = nn.CDATA = nn.NodeWithChildren = nn.ProcessingInstruction = nn.Comment = nn.Text = nn.DataNode = nn.Node = void 0;
var Yi = kM, PM = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), SM(this, t);
    }, e;
  }()
);
nn.Node = PM;
var bw = (
  /** @class */
  function(e) {
    du(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(PM)
);
nn.DataNode = bw;
var bY = (
  /** @class */
  function(e) {
    du(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bw)
);
nn.Text = bY;
var wY = (
  /** @class */
  function(e) {
    du(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bw)
);
nn.Comment = wY;
var CY = (
  /** @class */
  function(e) {
    du(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Yi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(bw)
);
nn.ProcessingInstruction = CY;
var ww = (
  /** @class */
  function(e) {
    du(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(PM)
);
nn.NodeWithChildren = ww;
var OY = (
  /** @class */
  function(e) {
    du(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ww)
);
nn.CDATA = OY;
var xY = (
  /** @class */
  function(e) {
    du(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ww)
);
nn.Document = xY;
var LY = (
  /** @class */
  function(e) {
    du(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Yi.ElementType.Script : n === "style" ? Yi.ElementType.Style : Yi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ww)
);
nn.Element = LY;
function EY(e) {
  return (0, Yi.isTag)(e);
}
nn.isTag = EY;
function kY(e) {
  return e.type === Yi.ElementType.CDATA;
}
nn.isCDATA = kY;
function PY(e) {
  return e.type === Yi.ElementType.Text;
}
nn.isText = PY;
function SY(e) {
  return e.type === Yi.ElementType.Comment;
}
nn.isComment = SY;
function MY(e) {
  return e.type === Yi.ElementType.Directive;
}
nn.isDirective = MY;
function DY(e) {
  return e.type === Yi.ElementType.Root;
}
nn.isDocument = DY;
function Ode(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
nn.hasChildren = Ode;
function SM(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (PY(e))
    n = new bY(e.data);
  else if (SY(e))
    n = new wY(e.data);
  else if (EY(e)) {
    var r = t ? uO(e.children) : [], o = new LY(e.name, Qd({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Qd({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Qd({}, e["x-attribsPrefix"])), n = o;
  } else if (kY(e)) {
    var r = t ? uO(e.children) : [], i = new OY(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (DY(e)) {
    var r = t ? uO(e.children) : [], a = new xY(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (MY(e)) {
    var s = new CY(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
nn.cloneNode = SM;
function uO(e) {
  for (var t = e.map(function(r) {
    return SM(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = mr && mr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = mr && mr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = kM, o = nn;
  n(nn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(EM);
var _Y = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(_Y);
Object.defineProperty(yw, "__esModule", { value: !0 });
yw.formatAttributes = TY;
yw.formatDOM = jY;
var qg = EM, xde = _Y;
function Lde(e) {
  return xde.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function TY(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Ede(e) {
  e = e.toLowerCase();
  var t = Lde(e);
  return t || e;
}
function jY(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Ede(s.nodeName);
        o = new qg.Element(l, TY(s.attributes)), o.children = jY(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new qg.Text(s.nodeValue);
        break;
      case 8:
        o = new qg.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new qg.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var kde = mr && mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(xM, "__esModule", { value: !0 });
xM.default = Dde;
var Pde = kde(LM), Sde = yw, Mde = /<(![a-zA-Z\s]+)>/;
function Dde(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Mde), n = t ? t[1] : void 0;
  return (0, Sde.formatDOM)((0, Pde.default)(e), null, n);
}
var Cw = {}, Zs = {}, Ow = {}, _de = 0;
Ow.SAME = _de;
var Tde = 1;
Ow.CAMELCASE = Tde;
Ow.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const AY = 0, fu = 1, xw = 2, Lw = 3, MM = 4, BY = 5, IY = 6;
function jde(e) {
  return Jo.hasOwnProperty(e) ? Jo[e] : null;
}
function ki(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === xw || t === Lw || t === MM, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Jo = {}, Ade = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Ade.forEach((e) => {
  Jo[e] = new ki(
    e,
    AY,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Jo[e] = new ki(
    e,
    fu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Jo[e] = new ki(
    e,
    xw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Jo[e] = new ki(
    e,
    xw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Jo[e] = new ki(
    e,
    Lw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Jo[e] = new ki(
    e,
    Lw,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Jo[e] = new ki(
    e,
    MM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Jo[e] = new ki(
    e,
    IY,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Jo[e] = new ki(
    e,
    BY,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const DM = /[\-\:]([a-z])/g, _M = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DM, _M);
  Jo[t] = new ki(
    t,
    fu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DM, _M);
  Jo[t] = new ki(
    t,
    fu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DM, _M);
  Jo[t] = new ki(
    t,
    fu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Jo[e] = new ki(
    e,
    fu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Bde = "xlinkHref";
Jo[Bde] = new ki(
  "xlinkHref",
  fu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Jo[e] = new ki(
    e,
    fu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Ide,
  SAME: Rde,
  possibleStandardNames: jB
} = Ow, Nde = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Fde = Nde + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", zde = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Fde + "]*$")
), Ude = Object.keys(
  jB
).reduce((e, t) => {
  const n = jB[t];
  return n === Rde ? e[t] = t : n === Ide ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Zs.BOOLEAN = Lw;
Zs.BOOLEANISH_STRING = xw;
Zs.NUMERIC = BY;
Zs.OVERLOADED_BOOLEAN = MM;
Zs.POSITIVE_NUMERIC = IY;
Zs.RESERVED = AY;
Zs.STRING = fu;
Zs.getPropertyInfo = jde;
Zs.isCustomAttribute = zde;
Zs.possibleStandardNames = Ude;
var TM = {}, jM = {}, AB = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Wde = /\n/g, Hde = /^\s*/, Vde = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, $de = /^:\s*/, qde = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Zde = /^[;\s]*/, Gde = /^\s+|\s+$/g, Yde = `
`, BB = "/", IB = "*", ac = "", Xde = "comment", Kde = "declaration", Jde = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(Wde);
    v && (n += v.length);
    var b = f.lastIndexOf(Yde);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(Hde);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(BB != e.charAt(0) || IB != e.charAt(1))) {
      for (var v = 2; ac != e.charAt(v) && (IB != e.charAt(v) || BB != e.charAt(v + 1)); )
        ++v;
      if (v += 2, ac === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: Xde,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(Vde);
    if (v) {
      if (p(), !l($de)) return s("property missing ':'");
      var b = l(qde), L = f({
        type: Kde,
        property: RB(v[0].replace(AB, ac)),
        value: b ? RB(b[0].replace(AB, ac)) : ac
      });
      return l(Zde), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function RB(e) {
  return e ? e.replace(Gde, ac) : ac;
}
var Qde = mr && mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(jM, "__esModule", { value: !0 });
jM.default = tfe;
var efe = Qde(Jde);
function tfe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, efe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Ew = {};
Object.defineProperty(Ew, "__esModule", { value: !0 });
Ew.camelCase = void 0;
var nfe = /^--[a-zA-Z0-9_-]+$/, rfe = /-([a-z])/g, ofe = /^[^-]+$/, ife = /^-(webkit|moz|ms|o|khtml)-/, sfe = /^-(ms)-/, afe = function(e) {
  return !e || ofe.test(e) || nfe.test(e);
}, lfe = function(e, t) {
  return t.toUpperCase();
}, NB = function(e, t) {
  return "".concat(t, "-");
}, ufe = function(e, t) {
  return t === void 0 && (t = {}), afe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(sfe, NB) : e = e.replace(ife, NB), e.replace(rfe, lfe));
};
Ew.camelCase = ufe;
var cfe = mr && mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, pfe = cfe(jM), dfe = Ew;
function bk(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, pfe.default)(e, function(r, o) {
    r && o && (n[(0, dfe.camelCase)(r, t)] = o);
  }), n;
}
bk.default = bk;
var ffe = bk;
(function(e) {
  var t = mr && mr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(ffe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(TM);
Object.defineProperty(Cw, "__esModule", { value: !0 });
Cw.default = vfe;
var Rd = Zs, FB = TM, hfe = ["checked", "value"], gfe = ["input", "select", "textarea"], mfe = {
  reset: !0,
  submit: !0
};
function vfe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && mfe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Rd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = zB(a);
    if (s) {
      var l = (0, Rd.getPropertyInfo)(s);
      switch (hfe.includes(s) && gfe.includes(t) && !r && (s = zB("default" + a)), n[s] = i, l && l.type) {
        case Rd.BOOLEAN:
          n[s] = !0;
          break;
        case Rd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    FB.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, FB.setStyleProp)(e.style, n), n;
}
function zB(e) {
  return Rd.possibleStandardNames[e];
}
var AM = {}, yfe = mr && mr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(AM, "__esModule", { value: !0 });
AM.default = RY;
var cO = we, bfe = yfe(Cw), ef = TM, wfe = {
  cloneElement: cO.cloneElement,
  createElement: cO.createElement,
  isValidElement: cO.isValidElement
};
function RY(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || ef.returnFirstArg, i = t.library || wfe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, ef.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Cfe(f) ? ((0, ef.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, bfe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = RY(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Cfe(e) {
  return ef.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, ef.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = mr && mr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(xM);
  e.htmlToDOM = n.default;
  var r = t(Cw);
  e.attributesToProps = r.default;
  var o = t(AM);
  e.domToReact = o.default;
  var i = EM;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(yY);
const Ofe = /* @__PURE__ */ Wpe(yY);
Ofe.default;
var vr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xfe(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var wk = { exports: {} }, Kp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UB;
function Lfe() {
  if (UB) return Kp;
  UB = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Kp.Fragment = n, Kp.jsx = a, Kp.jsxs = a, Kp;
}
var Zg = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WB;
function Efe() {
  return WB || (WB = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var A = f && g[f] || g[v];
      return typeof A == "function" ? A : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), te = 1; te < A; te++)
          G[te - 1] = arguments[te];
        D("error", g, G);
      }
    }
    function D(g, A, G) {
      {
        var te = L.ReactDebugCurrentFrame, ae = te.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function N(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function R(g, A, G) {
      var te = g.displayName;
      if (te)
        return te;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var A = g;
            return V(A) + ".Consumer";
          case a:
            var G = g;
            return V(G._context) + ".Provider";
          case l:
            return R(g, g.render, "ForwardRef");
          case p:
            var te = g.displayName || null;
            return te !== null ? te : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, Z = 0, X, K, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function H() {
      {
        if (Z === 0) {
          X = console.log, K = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, g, {
              value: X
            }),
            info: W({}, g, {
              value: K
            }),
            warn: W({}, g, {
              value: Q
            }),
            error: W({}, g, {
              value: J
            }),
            group: W({}, g, {
              value: P
            }),
            groupCollapsed: W({}, g, {
              value: _
            }),
            groupEnd: W({}, g, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = L.ReactCurrentDispatcher, F;
    function T(g, A, G) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var te = ae.stack.trim().match(/\n( *(at )?)/);
            F = te && te[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, B;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Y();
    }
    function I(g, A) {
      if (!g || q)
        return "";
      {
        var G = B.get(g);
        if (G !== void 0)
          return G;
      }
      var te;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, H();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              te = je;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              te = je;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            te = je;
          }
          g();
        }
      } catch (je) {
        if (je && te && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = te.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var Ue = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", g.displayName)), typeof g == "function" && B.set(g, Ue), Ue;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Lt = g ? g.displayName || g.name : "", vt = Lt ? T(Lt) : "";
      return typeof g == "function" && B.set(g, vt), vt;
    }
    function le(g, A, G) {
      return I(g, !1);
    }
    function he(g) {
      var A = g.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(g, A, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return I(g, he(g));
      if (typeof g == "string")
        return T(g);
      switch (g) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return oe(g.type, A, G);
          case d: {
            var te = g, ae = te._payload, ue = te._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, We = {}, He = L.ReactDebugCurrentFrame;
    function Ie(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(g, A, G, te, ae) {
      {
        var ue = Function.call.bind(Be);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var Oe = Error((te || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = g[se](A, se, te, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Ie(ae), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ce(g) {
      return $e(g);
    }
    function Qe(g) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function lt(g) {
      try {
        return be(g), !1;
      } catch {
        return !0;
      }
    }
    function be(g) {
      return "" + g;
    }
    function Ee(g) {
      if (lt(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(g)), be(g);
    }
    var Ae = L.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, ot, ve;
    ve = {};
    function yt(g) {
      if (Be.call(g, "ref")) {
        var A = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function it(g) {
      if (Be.call(g, "key")) {
        var A = Object.getOwnPropertyDescriptor(g, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function st(g, A) {
      if (typeof g.ref == "string" && Ae.current && A && Ae.current.stateNode !== A) {
        var G = $(Ae.current.type);
        ve[G] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ae.current.type), g.ref), ve[G] = !0);
      }
    }
    function ut(g, A) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function bt(g, A) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var ct = function(g, A, G, te, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function wt(g, A, G, te, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (Ee(G), ie = "" + G), it(A) && (Ee(A.key), ie = "" + A.key), yt(A) && (Oe = A.ref, st(A, ae));
        for (ue in A)
          Be.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && ut(se, fe), Oe && bt(se, fe);
        }
        return ct(g, ie, Oe, ae, te, Ae.current, se);
      }
    }
    var tt = L.ReactCurrentOwner, gt = L.ReactDebugCurrentFrame;
    function rt(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        gt.setExtraStackFrame(G);
      } else
        gt.setExtraStackFrame(null);
    }
    var Ct;
    Ct = !1;
    function pt(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Et() {
      {
        if (tt.current) {
          var g = $(tt.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Ot(g) {
      return "";
    }
    var kt = {};
    function xt(g) {
      {
        var A = Et();
        if (!A) {
          var G = typeof g == "string" ? g : g.displayName || g.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function Pt(g, A) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var G = xt(A);
        if (kt[G])
          return;
        kt[G] = !0;
        var te = "";
        g && g._owner && g._owner !== tt.current && (te = " It was passed a child from " + $(g._owner.type) + "."), rt(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, te), rt(null);
      }
    }
    function Vt(g, A) {
      {
        if (typeof g != "object")
          return;
        if (Ce(g))
          for (var G = 0; G < g.length; G++) {
            var te = g[G];
            pt(te) && Pt(te, A);
          }
        else if (pt(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              pt(se.value) && Pt(se.value, A);
        }
      }
    }
    function mt(g) {
      {
        var A = g.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var te = $(A);
          nt(G, g.props, "prop", te, g);
        } else if (A.PropTypes !== void 0 && !Ct) {
          Ct = !0;
          var ae = $(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ne(g) {
      {
        for (var A = Object.keys(g.props), G = 0; G < A.length; G++) {
          var te = A[G];
          if (te !== "children" && te !== "key") {
            rt(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), rt(null);
            break;
          }
        }
        g.ref !== null && (rt(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var so = {};
    function ao(g, A, G, te, ae, ue) {
      {
        var se = N(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ot();
          Oe ? ie += Oe : ie += Et();
          var de;
          g === null ? de = "null" : Ce(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = wt(g, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Ue = A.children;
          if (Ue !== void 0)
            if (te)
              if (Ce(Ue)) {
                for (var Lt = 0; Lt < Ue.length; Lt++)
                  Vt(Ue[Lt], g);
                Object.freeze && Object.freeze(Ue);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vt(Ue, g);
        }
        if (Be.call(A, "key")) {
          var vt = $(g), je = Object.keys(A).filter(function(wi) {
            return wi !== "key";
          }), Wn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[vt + Wn]) {
            var bi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wn, vt, bi, vt), so[vt + Wn] = !0;
          }
        }
        return g === r ? ne(fe) : mt(fe), fe;
      }
    }
    function gi(g, A, G) {
      return ao(g, A, G, !0);
    }
    function mi(g, A, G) {
      return ao(g, A, G, !1);
    }
    var vi = mi, yi = gi;
    Zg.Fragment = r, Zg.jsx = vi, Zg.jsxs = yi;
  }()), Zg;
}
process.env.NODE_ENV === "production" ? wk.exports = Lfe() : wk.exports = Efe();
var Wi = wk.exports;
Ve({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function HB(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ai(e) {
  var t, n;
  return HB(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(HB(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var NY = Symbol.for("immer-nothing"), VB = Symbol.for("immer-draftable"), Ls = Symbol.for("immer-state"), kfe = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Ii(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = kfe[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var fp = Object.getPrototypeOf;
function Bc(e) {
  return !!e && !!e[Ls];
}
function Ic(e) {
  var t;
  return e ? FY(e) || Array.isArray(e) || !!e[VB] || !!((t = e.constructor) != null && t[VB]) || Pw(e) || Sw(e) : !1;
}
var Pfe = Object.prototype.constructor.toString();
function FY(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = fp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Pfe;
}
function Iy(e, t) {
  kw(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function kw(e) {
  const t = e[Ls];
  return t ? t.type_ : Array.isArray(e) ? 1 : Pw(e) ? 2 : Sw(e) ? 3 : 0;
}
function Ck(e, t) {
  return kw(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function zY(e, t, n) {
  const r = kw(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Sfe(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Pw(e) {
  return e instanceof Map;
}
function Sw(e) {
  return e instanceof Set;
}
function Qu(e) {
  return e.copy_ || e.base_;
}
function Ok(e, t) {
  if (Pw(e))
    return new Map(e);
  if (Sw(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = FY(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ls];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(fp(e), r);
  } else {
    const r = fp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function BM(e, t = !1) {
  return Mw(e) || Bc(e) || !Ic(e) || (kw(e) > 1 && (e.set = e.add = e.clear = e.delete = Mfe), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => BM(r, !0))), e;
}
function Mfe() {
  Ii(2);
}
function Mw(e) {
  return Object.isFrozen(e);
}
var Dfe = {};
function Rc(e) {
  const t = Dfe[e];
  return t || Ii(0, e), t;
}
var Wf;
function UY() {
  return Wf;
}
function _fe(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function $B(e, t) {
  t && (Rc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function xk(e) {
  Lk(e), e.drafts_.forEach(Tfe), e.drafts_ = null;
}
function Lk(e) {
  e === Wf && (Wf = e.parent_);
}
function qB(e) {
  return Wf = _fe(Wf, e);
}
function Tfe(e) {
  const t = e[Ls];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function ZB(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ls].modified_ && (xk(t), Ii(4)), Ic(e) && (e = Ry(t, e), t.parent_ || Ny(t, e)), t.patches_ && Rc("Patches").generateReplacementPatches_(
    n[Ls].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Ry(t, n, []), xk(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== NY ? e : void 0;
}
function Ry(e, t, n) {
  if (Mw(t))
    return t;
  const r = t[Ls];
  if (!r)
    return Iy(
      t,
      (o, i) => GB(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Ny(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Iy(
      i,
      (s, l) => GB(e, r, o, s, l, n, a)
    ), Ny(e, o, !1), n && e.patches_ && Rc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function GB(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Ii(5), Bc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Ck(t.assigned_, r) ? i.concat(r) : void 0, l = Ry(e, o, s);
    if (zY(n, r, l), Bc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Ic(o) && !Mw(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Ry(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Ny(e, o);
  }
}
function Ny(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && BM(t, n);
}
function jfe(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : UY(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = IM;
  n && (o = [r], i = Hf);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var IM = {
  get(e, t) {
    if (t === Ls)
      return e;
    const n = Qu(e);
    if (!Ck(n, t))
      return Afe(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ic(r) ? r : r === pO(e.base_, t) ? (dO(e), e.copy_[t] = kk(r, e)) : r;
  },
  has(e, t) {
    return t in Qu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Qu(e));
  },
  set(e, t, n) {
    const r = WY(Qu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = pO(Qu(e), t), i = o == null ? void 0 : o[Ls];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Sfe(n, o) && (n !== void 0 || Ck(e.base_, t)))
        return !0;
      dO(e), Ek(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return pO(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, dO(e), Ek(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Qu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Ii(11);
  },
  getPrototypeOf(e) {
    return fp(e.base_);
  },
  setPrototypeOf() {
    Ii(12);
  }
}, Hf = {};
Iy(IM, (e, t) => {
  Hf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Hf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Ii(13), Hf.set.call(this, e, t, void 0);
};
Hf.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Ii(14), IM.set.call(this, e[0], t, n, e[0]);
};
function pO(e, t) {
  const n = e[Ls];
  return (n ? Qu(n) : e)[t];
}
function Afe(e, t, n) {
  var r;
  const o = WY(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function WY(e, t) {
  if (!(t in e))
    return;
  let n = fp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = fp(n);
  }
}
function Ek(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Ek(e.parent_));
}
function dO(e) {
  e.copy_ || (e.copy_ = Ok(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Bfe = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Ii(6), r !== void 0 && typeof r != "function" && Ii(7);
      let o;
      if (Ic(t)) {
        const i = qB(this), a = kk(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? xk(i) : Lk(i);
        }
        return $B(i, r), ZB(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === NY && (o = void 0), this.autoFreeze_ && BM(o, !0), r) {
          const i = [], a = [];
          Rc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Ii(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ic(e) || Ii(8), Bc(e) && (e = Ife(e));
    const t = qB(this), n = kk(e, void 0);
    return n[Ls].isManual_ = !0, Lk(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ls];
    (!n || !n.isManual_) && Ii(9);
    const { scope_: r } = n;
    return $B(r, t), ZB(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Rc("Patches").applyPatches_;
    return Bc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function kk(e, t) {
  const n = Pw(e) ? Rc("MapSet").proxyMap_(e, t) : Sw(e) ? Rc("MapSet").proxySet_(e, t) : jfe(e, t);
  return (t ? t.scope_ : UY()).drafts_.push(n), n;
}
function Ife(e) {
  return Bc(e) || Ii(10, e), HY(e);
}
function HY(e) {
  if (!Ic(e) || Mw(e))
    return e;
  const t = e[Ls];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Ok(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Ok(e, !0);
  return Iy(n, (r, o) => {
    zY(n, r, HY(o));
  }), t && (t.finalized_ = !1), n;
}
var Es = new Bfe(), RM = Es.produce;
Es.produceWithPatches.bind(
  Es
);
Es.setAutoFreeze.bind(Es);
Es.setUseStrictShallowCopy.bind(Es);
Es.applyPatches.bind(Es);
var YB = Es.createDraft.bind(Es), XB = Es.finishDraft.bind(Es), Ge = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ge.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ge.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ge.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ge.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ge.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ge.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ge.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ge.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ge.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ge.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ge.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ge.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ge.isAncestor(t, e) && !Ge.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ge.equals(i, r) || Ge.endsBefore(i, r) || Ge.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ge.equals(a, r) || Ge.isAncestor(a, r))
          return null;
        Ge.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ge.equals(s, r) || Ge.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ge.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ge.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ge.endsBefore(u, r) ? r[u.length - 1] += 1 : Ge.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ge.equals(p, d))
          return r;
        if (Ge.isAncestor(p, r) || Ge.equals(p, r)) {
          var y = d.slice();
          return Ge.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Ge.isSibling(p, d) && (Ge.isAncestor(d, r) || Ge.equals(d, r)) ? Ge.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ge.endsBefore(d, r) || Ge.equals(d, r) || Ge.isAncestor(d, r) ? (Ge.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ge.endsBefore(p, r) && (Ge.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Vf(e) {
  "@babel/helpers - typeof";
  return Vf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vf(e);
}
function Rfe(e, t) {
  if (Vf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Vf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Nfe(e) {
  var t = Rfe(e, "string");
  return Vf(t) === "symbol" ? t : String(t);
}
function xp(e, t, n) {
  return t = Nfe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function KB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KB(Object(n), !0).forEach(function(r) {
      xp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ffe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = _t.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Gt.points(t))
          t[l] = _r.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = _t.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Gt.points(t))
          t[b] = _r.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = _t.get(e, L), D = Ge.previous(L), x = _t.get(e, D), m = _t.parent(e, L), C = L[L.length - 1];
      if (So.isText(w) && So.isText(x))
        x.text += w.text;
      else if (!So.isText(w) && !So.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(os.stringify(w), " ").concat(os.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Gt.points(t))
          t[U] = _r.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: N
      } = n;
      if (Ge.isAncestor(k, N))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = _t.get(e, k), V = _t.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var W = Ge.transform(k, n), Z = _t.get(e, Ge.parent(W)), X = W[W.length - 1];
      if (Z.children.splice(X, 0, R), t)
        for (var [K, Q] of Gt.points(t))
          t[Q] = _r.transform(K, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = _t.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Gt.points(t)) {
          var H = _r.transform(z, n);
          if (t != null && H != null)
            t[M] = H;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of _t.texts(e))
              if (Ge.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var q = !1;
            O && j && (Ge.equals(j[1], J) ? q = !Ge.hasPrevious(j[1]) : q = Ge.common(O[1], J).length < Ge.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Y,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = _t.leaf(e, B), he = le.text.slice(0, Y), oe = le.text.slice(Y + I.length);
      if (le.text = he + oe, t)
        for (var [Be, We] of Gt.points(t))
          t[We] = _r.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Ie,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var $e = _t.get(e, He);
      for (var Ce in nt) {
        if (Ce === "children" || Ce === "text")
          throw new Error('Cannot set the "'.concat(Ce, '" property of nodes!'));
        var Qe = nt[Ce];
        Qe == null ? delete $e[Ce] : $e[Ce] = Qe;
      }
      for (var lt in Ie)
        nt.hasOwnProperty(lt) || delete $e[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: be
      } = n;
      if (be == null)
        t = be;
      else {
        if (t == null) {
          if (!Gt.isRange(be))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(os.stringify(be), " when there is no current selection."));
          t = Jp({}, be);
        }
        for (var Ee in be) {
          var Ae = be[Ee];
          if (Ae == null) {
            if (Ee === "anchor" || Ee === "focus")
              throw new Error('Cannot remove the "'.concat(Ee, '" selection property'));
            delete t[Ee];
          } else
            t[Ee] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Re,
        properties: ot
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var ve = _t.get(e, ze), yt = _t.parent(e, ze), it = ze[ze.length - 1], st;
      if (So.isText(ve)) {
        var ut = ve.text.slice(0, Re), bt = ve.text.slice(Re);
        ve.text = ut, st = Jp(Jp({}, ot), {}, {
          text: bt
        });
      } else {
        var ct = ve.children.slice(0, Re), wt = ve.children.slice(Re);
        ve.children = ct, st = Jp(Jp({}, ot), {}, {
          children: wt
        });
      }
      if (yt.children.splice(it + 1, 0, st), t)
        for (var [tt, gt] of Gt.points(t))
          t[gt] = _r.transform(tt, n);
      break;
    }
  }
  return t;
}, zfe = {
  transform(e, t) {
    e.children = YB(e.children);
    var n = e.selection && YB(e.selection);
    try {
      n = Ffe(e, n, t);
    } finally {
      e.children = XB(e.children), n ? e.selection = Bc(n) ? XB(n) : n : e.selection = null;
    }
  }
}, Ufe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Wfe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, VY = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (ai(r) && ai(o)) {
      if (!VY(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Hfe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function $f(e, t) {
  if (e == null) return {};
  var n = Hfe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Vfe = ["anchor", "focus"];
function JB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $fe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JB(Object(n), !0).forEach(function(r) {
      xp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Gt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Gt.edges(e);
    return t;
  },
  equals(e, t) {
    return _r.equals(e.anchor, t.anchor) && _r.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Gt.isRange(t)) {
      if (Gt.includes(e, t.anchor) || Gt.includes(e, t.focus))
        return !0;
      var [n, r] = Gt.edges(e), [o, i] = Gt.edges(t);
      return _r.isBefore(n, o) && _r.isAfter(r, i);
    }
    var [a, s] = Gt.edges(e), l = !1, u = !1;
    return _r.isPoint(t) ? (l = _r.compare(t, a) >= 0, u = _r.compare(t, s) <= 0) : (l = Ge.compare(t, a.path) >= 0, u = Ge.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = $f(e, Vfe), [r, o] = Gt.edges(e), [i, a] = Gt.edges(t), s = _r.isBefore(r, i) ? i : r, l = _r.isBefore(o, a) ? o : a;
    return _r.isBefore(l, s) ? null : $fe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return _r.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return _r.equals(t, n);
  },
  isExpanded(e) {
    return !Gt.isCollapsed(e);
  },
  isForward(e) {
    return !Gt.isBackward(e);
  },
  isRange(e) {
    return ai(e) && _r.isPoint(e.anchor) && _r.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Gt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return RM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Gt.isCollapsed(r);
        Gt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Gt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = _r.transform(r.anchor, t, {
        affinity: i
      }), u = _r.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, QB = (e) => ai(e) && _t.isNodeList(e.children) && !ur.isEditor(e), Va = {
  isAncestor(e) {
    return ai(e) && _t.isNodeList(e.children);
  },
  isElement: QB,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Va.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return QB(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, qfe = ["children"], Zfe = ["text"], eI = /* @__PURE__ */ new WeakMap(), _t = {
  ancestor(e, t) {
    var n = _t.get(e, t);
    if (So.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(os.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ge.ancestors(t, n)) {
        var o = _t.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (So.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(os.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(os.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = _t.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = _t.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ge.common(t, n), o = _t.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = _t.get(e, t);
    if (ur.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(os.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        Va.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Va.isAncestor(e)) {
      var t = $f(e, qfe);
      return t;
    } else {
      var t = $f(e, Zfe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = _t.get(e, n); r && !(So.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (So.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(os.stringify(e)));
    var n = RM({
      children: e.children
    }, (r) => {
      var [o, i] = Gt.edges(t), a = _t.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Gt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Gt.includes(t, s)) {
          var l = _t.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ge.equals(s, i.path)) {
          var c = _t.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ge.equals(s, o.path)) {
          var p = _t.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      ur.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (So.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(os.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (So.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return So.isText(e) || Va.isElement(e) || ur.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = eI.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => _t.isNode(r));
    return eI.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = _t.get(e, n); r && !(So.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = _t.get(e, t);
    if (!So.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(os.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ge.levels(t, n)) {
        var o = _t.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Va.isElement(e) && Va.isElementProps(t) && Va.matches(e, t) || So.isText(e) && So.isTextProps(t) && So.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ge.isBefore(s, i) : Ge.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !So.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ge.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = _t.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ge.next(s);
          if (_t.has(e, c)) {
            s = c, l = _t.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ge.previous(s);
          s = p, l = _t.get(e, s);
          continue;
        }
        s = Ge.parent(s), l = _t.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ge.parent(t), r = _t.get(e, n);
    if (So.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return So.isText(e) ? e.text : e.children.map(_t.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of _t.nodes(e, t))
        So.isText(n) && (yield [n, r]);
    }();
  }
};
function tI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tI(Object(n), !0).forEach(function(r) {
      xp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nd = {
  isNodeOperation(e) {
    return Nd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!ai(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ge.isPath(e.path) && _t.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ge.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ge.isPath(e.path) && ai(e.properties);
      case "move_node":
        return Ge.isPath(e.path) && Ge.isPath(e.newPath);
      case "remove_node":
        return Ge.isPath(e.path) && _t.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ge.isPath(e.path);
      case "set_node":
        return Ge.isPath(e.path) && ai(e.properties) && ai(e.newProperties);
      case "set_selection":
        return e.properties === null && Gt.isRange(e.newProperties) || e.newProperties === null && Gt.isRange(e.properties) || ai(e.properties) && ai(e.newProperties);
      case "split_node":
        return Ge.isPath(e.path) && typeof e.position == "number" && ai(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Nd.isOperation(t));
  },
  isSelectionOperation(e) {
    return Nd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Nd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Fr(Fr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Fr(Fr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Fr(Fr({}, e), {}, {
          type: "split_node",
          path: Ge.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ge.equals(t, n))
          return e;
        if (Ge.isSibling(n, t))
          return Fr(Fr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ge.transform(n, e), o = Ge.transform(Ge.next(n), e);
        return Fr(Fr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Fr(Fr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Fr(Fr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Fr(Fr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Fr(Fr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Fr(Fr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Fr(Fr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Fr(Fr({}, e), {}, {
          type: "merge_node",
          path: Ge.next(e.path)
        });
    }
  }
}, nI = /* @__PURE__ */ new WeakMap(), Gfe = (e) => {
  var t = nI.get(e);
  if (t !== void 0)
    return t;
  if (!ai(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || ai(e.marks)) && (e.selection === null || Gt.isRange(e.selection)) && _t.isNodeList(e.children) && Nd.isOperationList(e.operations);
  return nI.set(e, n), n;
}, ur = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Gfe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function rI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rI(Object(n), !0).forEach(function(r) {
      xp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _r = {
  compare(e, t) {
    var n = Ge.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return _r.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return _r.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ge.equals(e.path, t.path);
  },
  isPoint(e) {
    return ai(e) && typeof e.offset == "number" && Ge.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return RM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ge.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ge.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ge.equals(t.path, i) && (r.offset += t.position), r.path = Ge.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ge.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ge.equals(t.path, i) || Ge.isAncestor(t.path, i))
            return null;
          r.path = Ge.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ge.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ge.transform(i, t, oI(oI({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ge.transform(i, t, n);
          break;
        }
      }
    });
  }
}, iI = void 0, os = {
  setScrubber(e) {
    iI = e;
  },
  stringify(e) {
    return JSON.stringify(e, iI);
  }
}, Yfe = ["text"], Xfe = ["anchor", "focus"];
function sI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ma(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sI(Object(n), !0).forEach(function(r) {
      xp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var So = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = $f(i, Yfe);
      return a;
    }
    return VY(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return ai(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => So.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Ma({}, e)];
    for (var r of t) {
      var o = $f(r, Xfe), [i, a] = Gt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = Ma(Ma({}, f), {}, {
            text: f.text.slice(L)
          }), f = Ma(Ma({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Ma(Ma({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Ma(Ma({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Kfe = (e) => e.selection ? e.selection : e.children.length > 0 ? ur.end(e, []) : [0], Lr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Lr || (Lr = {}));
Lr.L, Lr.L | Lr.V | Lr.LV | Lr.LVT, Lr.LV | Lr.V, Lr.V | Lr.T, Lr.LVT | Lr.T, Lr.T, Lr.Any, Lr.Extend | Lr.ZWJ, Lr.Any, Lr.SpacingMark, Lr.Prepend, Lr.Any, Lr.ZWJ, Lr.ExtPict, Lr.RI, Lr.RI;
var Jfe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    ur.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Kfe(e)
      } = n;
      if (Ge.isPath(o) && (o = ur.range(e, o)), Gt.isRange(o))
        if (Gt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Gt.end(o);
          if (!r && ur.void(e, {
            at: i
          }))
            return;
          var a = Gt.start(o), s = ur.pointRef(e, a), l = ur.pointRef(e, i);
          Fy.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Fy.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && ur.void(e, {
        at: o
      }) || ur.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function aI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aI(Object(n), !0).forEach(function(r) {
      xp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fy = Gg(Gg(Gg(Gg({}, zfe), Ufe), Wfe), Jfe), $Y = {}, NM = {}, FM = {};
Object.defineProperty(FM, "__esModule", { value: !0 });
FM.default = nhe;
var lI = "html", uI = "head", Yg = "body", Qfe = /<([a-zA-Z]+[0-9]?)/, cI = /<head[^]*>/i, pI = /<body[^]*>/i, zy = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Pk = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, dI = typeof window == "object" && window.DOMParser;
if (typeof dI == "function") {
  var ehe = new dI(), the = "text/html";
  Pk = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), ehe.parseFromString(e, the);
  }, zy = Pk;
}
if (typeof document == "object" && document.implementation) {
  var Xg = document.implementation.createHTMLDocument();
  zy = function(e, t) {
    if (t) {
      var n = Xg.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Xg;
    }
    return Xg.documentElement.innerHTML = e, Xg;
  };
}
var Kg = typeof document == "object" && document.createElement("template"), Sk;
Kg && Kg.content && (Sk = function(e) {
  return Kg.innerHTML = e, Kg.content.childNodes;
});
function nhe(e) {
  var t, n, r = e.match(Qfe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case lI: {
      var i = Pk(e);
      if (!cI.test(e)) {
        var a = i.querySelector(uI);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!pI.test(e)) {
        var a = i.querySelector(Yg);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(lI);
    }
    case uI:
    case Yg: {
      var s = zy(e).querySelectorAll(o);
      return pI.test(e) && cI.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Sk)
        return Sk(e);
      var a = zy(e, Yg).querySelector(Yg);
      return a.childNodes;
    }
  }
}
var Dw = {}, zM = {}, UM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(UM);
var rn = {}, hu = vr && vr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), tf = vr && vr.__assign || function() {
  return tf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, tf.apply(this, arguments);
};
Object.defineProperty(rn, "__esModule", { value: !0 });
rn.cloneNode = rn.hasChildren = rn.isDocument = rn.isDirective = rn.isComment = rn.isText = rn.isCDATA = rn.isTag = rn.Element = rn.Document = rn.CDATA = rn.NodeWithChildren = rn.ProcessingInstruction = rn.Comment = rn.Text = rn.DataNode = rn.Node = void 0;
var Xi = UM, WM = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), HM(this, t);
    }, e;
  }()
);
rn.Node = WM;
var _w = (
  /** @class */
  function(e) {
    hu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WM)
);
rn.DataNode = _w;
var qY = (
  /** @class */
  function(e) {
    hu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_w)
);
rn.Text = qY;
var ZY = (
  /** @class */
  function(e) {
    hu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_w)
);
rn.Comment = ZY;
var GY = (
  /** @class */
  function(e) {
    hu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Xi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(_w)
);
rn.ProcessingInstruction = GY;
var Tw = (
  /** @class */
  function(e) {
    hu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WM)
);
rn.NodeWithChildren = Tw;
var YY = (
  /** @class */
  function(e) {
    hu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tw)
);
rn.CDATA = YY;
var XY = (
  /** @class */
  function(e) {
    hu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tw)
);
rn.Document = XY;
var KY = (
  /** @class */
  function(e) {
    hu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Xi.ElementType.Script : n === "style" ? Xi.ElementType.Style : Xi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tw)
);
rn.Element = KY;
function JY(e) {
  return (0, Xi.isTag)(e);
}
rn.isTag = JY;
function QY(e) {
  return e.type === Xi.ElementType.CDATA;
}
rn.isCDATA = QY;
function eX(e) {
  return e.type === Xi.ElementType.Text;
}
rn.isText = eX;
function tX(e) {
  return e.type === Xi.ElementType.Comment;
}
rn.isComment = tX;
function nX(e) {
  return e.type === Xi.ElementType.Directive;
}
rn.isDirective = nX;
function rX(e) {
  return e.type === Xi.ElementType.Root;
}
rn.isDocument = rX;
function rhe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
rn.hasChildren = rhe;
function HM(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (eX(e))
    n = new qY(e.data);
  else if (tX(e))
    n = new ZY(e.data);
  else if (JY(e)) {
    var r = t ? fO(e.children) : [], o = new KY(e.name, tf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = tf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = tf({}, e["x-attribsPrefix"])), n = o;
  } else if (QY(e)) {
    var r = t ? fO(e.children) : [], i = new YY(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (rX(e)) {
    var r = t ? fO(e.children) : [], a = new XY(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (nX(e)) {
    var s = new GY(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
rn.cloneNode = HM;
function fO(e) {
  for (var t = e.map(function(r) {
    return HM(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = vr && vr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = vr && vr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = UM, o = rn;
  n(rn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(zM);
var oX = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(oX);
Object.defineProperty(Dw, "__esModule", { value: !0 });
Dw.formatAttributes = iX;
Dw.formatDOM = sX;
var Jg = zM, ohe = oX;
function ihe(e) {
  return ohe.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function iX(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function she(e) {
  e = e.toLowerCase();
  var t = ihe(e);
  return t || e;
}
function sX(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = she(s.nodeName);
        o = new Jg.Element(l, iX(s.attributes)), o.children = sX(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Jg.Text(s.nodeValue);
        break;
      case 8:
        o = new Jg.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Jg.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var ahe = vr && vr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(NM, "__esModule", { value: !0 });
NM.default = phe;
var lhe = ahe(FM), uhe = Dw, che = /<(![a-zA-Z\s]+)>/;
function phe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(che), n = t ? t[1] : void 0;
  return (0, uhe.formatDOM)((0, lhe.default)(e), null, n);
}
var jw = {}, Gs = {}, Aw = {}, dhe = 0;
Aw.SAME = dhe;
var fhe = 1;
Aw.CAMELCASE = fhe;
Aw.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const aX = 0, gu = 1, Bw = 2, Iw = 3, VM = 4, lX = 5, uX = 6;
function hhe(e) {
  return Qo.hasOwnProperty(e) ? Qo[e] : null;
}
function Pi(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Bw || t === Iw || t === VM, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Qo = {}, ghe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
ghe.forEach((e) => {
  Qo[e] = new Pi(
    e,
    aX,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Qo[e] = new Pi(
    e,
    gu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Qo[e] = new Pi(
    e,
    Bw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Qo[e] = new Pi(
    e,
    Bw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Qo[e] = new Pi(
    e,
    Iw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Qo[e] = new Pi(
    e,
    Iw,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Qo[e] = new Pi(
    e,
    VM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Qo[e] = new Pi(
    e,
    uX,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Qo[e] = new Pi(
    e,
    lX,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const $M = /[\-\:]([a-z])/g, qM = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace($M, qM);
  Qo[t] = new Pi(
    t,
    gu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace($M, qM);
  Qo[t] = new Pi(
    t,
    gu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace($M, qM);
  Qo[t] = new Pi(
    t,
    gu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Qo[e] = new Pi(
    e,
    gu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const mhe = "xlinkHref";
Qo[mhe] = new Pi(
  "xlinkHref",
  gu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Qo[e] = new Pi(
    e,
    gu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: vhe,
  SAME: yhe,
  possibleStandardNames: fI
} = Aw, bhe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", whe = bhe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Che = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + whe + "]*$")
), Ohe = Object.keys(
  fI
).reduce((e, t) => {
  const n = fI[t];
  return n === yhe ? e[t] = t : n === vhe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Gs.BOOLEAN = Iw;
Gs.BOOLEANISH_STRING = Bw;
Gs.NUMERIC = lX;
Gs.OVERLOADED_BOOLEAN = VM;
Gs.POSITIVE_NUMERIC = uX;
Gs.RESERVED = aX;
Gs.STRING = gu;
Gs.getPropertyInfo = hhe;
Gs.isCustomAttribute = Che;
Gs.possibleStandardNames = Ohe;
var ZM = {}, GM = {}, hI = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, xhe = /\n/g, Lhe = /^\s*/, Ehe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, khe = /^:\s*/, Phe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, She = /^[;\s]*/, Mhe = /^\s+|\s+$/g, Dhe = `
`, gI = "/", mI = "*", lc = "", _he = "comment", The = "declaration", jhe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(xhe);
    v && (n += v.length);
    var b = f.lastIndexOf(Dhe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(Lhe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(gI != e.charAt(0) || mI != e.charAt(1))) {
      for (var v = 2; lc != e.charAt(v) && (mI != e.charAt(v) || gI != e.charAt(v + 1)); )
        ++v;
      if (v += 2, lc === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: _he,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(Ehe);
    if (v) {
      if (p(), !l(khe)) return s("property missing ':'");
      var b = l(Phe), L = f({
        type: The,
        property: vI(v[0].replace(hI, lc)),
        value: b ? vI(b[0].replace(hI, lc)) : lc
      });
      return l(She), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function vI(e) {
  return e ? e.replace(Mhe, lc) : lc;
}
var Ahe = vr && vr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(GM, "__esModule", { value: !0 });
GM.default = Ihe;
var Bhe = Ahe(jhe);
function Ihe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Bhe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Rw = {};
Object.defineProperty(Rw, "__esModule", { value: !0 });
Rw.camelCase = void 0;
var Rhe = /^--[a-zA-Z0-9_-]+$/, Nhe = /-([a-z])/g, Fhe = /^[^-]+$/, zhe = /^-(webkit|moz|ms|o|khtml)-/, Uhe = /^-(ms)-/, Whe = function(e) {
  return !e || Fhe.test(e) || Rhe.test(e);
}, Hhe = function(e, t) {
  return t.toUpperCase();
}, yI = function(e, t) {
  return "".concat(t, "-");
}, Vhe = function(e, t) {
  return t === void 0 && (t = {}), Whe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Uhe, yI) : e = e.replace(zhe, yI), e.replace(Nhe, Hhe));
};
Rw.camelCase = Vhe;
var $he = vr && vr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, qhe = $he(GM), Zhe = Rw;
function Mk(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, qhe.default)(e, function(r, o) {
    r && o && (n[(0, Zhe.camelCase)(r, t)] = o);
  }), n;
}
Mk.default = Mk;
var Ghe = Mk;
(function(e) {
  var t = vr && vr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Ghe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(ZM);
Object.defineProperty(jw, "__esModule", { value: !0 });
jw.default = Jhe;
var Fd = Gs, bI = ZM, Yhe = ["checked", "value"], Xhe = ["input", "select", "textarea"], Khe = {
  reset: !0,
  submit: !0
};
function Jhe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Khe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Fd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = wI(a);
    if (s) {
      var l = (0, Fd.getPropertyInfo)(s);
      switch (Yhe.includes(s) && Xhe.includes(t) && !r && (s = wI("default" + a)), n[s] = i, l && l.type) {
        case Fd.BOOLEAN:
          n[s] = !0;
          break;
        case Fd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    bI.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, bI.setStyleProp)(e.style, n), n;
}
function wI(e) {
  return Fd.possibleStandardNames[e];
}
var YM = {}, Qhe = vr && vr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(YM, "__esModule", { value: !0 });
YM.default = cX;
var hO = we, ege = Qhe(jw), nf = ZM, tge = {
  cloneElement: hO.cloneElement,
  createElement: hO.createElement,
  isValidElement: hO.isValidElement
};
function cX(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || nf.returnFirstArg, i = t.library || tge, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, nf.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    nge(f) ? ((0, nf.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, ege.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = cX(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function nge(e) {
  return nf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, nf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = vr && vr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(NM);
  e.htmlToDOM = n.default;
  var r = t(jw);
  e.attributesToProps = r.default;
  var o = t(YM);
  e.domToReact = o.default;
  var i = zM;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})($Y);
const rge = /* @__PURE__ */ xfe($Y);
rge.default;
var yr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function oge(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Dk = { exports: {} }, Qp = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CI;
function ige() {
  if (CI) return Qp;
  CI = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Qp.Fragment = n, Qp.jsx = a, Qp.jsxs = a, Qp;
}
var Qg = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OI;
function sge() {
  return OI || (OI = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var A = f && g[f] || g[v];
      return typeof A == "function" ? A : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), te = 1; te < A; te++)
          G[te - 1] = arguments[te];
        D("error", g, G);
      }
    }
    function D(g, A, G) {
      {
        var te = L.ReactDebugCurrentFrame, ae = te.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function N(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function R(g, A, G) {
      var te = g.displayName;
      if (te)
        return te;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var A = g;
            return V(A) + ".Consumer";
          case a:
            var G = g;
            return V(G._context) + ".Provider";
          case l:
            return R(g, g.render, "ForwardRef");
          case p:
            var te = g.displayName || null;
            return te !== null ? te : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, Z = 0, X, K, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function H() {
      {
        if (Z === 0) {
          X = console.log, K = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, g, {
              value: X
            }),
            info: W({}, g, {
              value: K
            }),
            warn: W({}, g, {
              value: Q
            }),
            error: W({}, g, {
              value: J
            }),
            group: W({}, g, {
              value: P
            }),
            groupCollapsed: W({}, g, {
              value: _
            }),
            groupEnd: W({}, g, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = L.ReactCurrentDispatcher, F;
    function T(g, A, G) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var te = ae.stack.trim().match(/\n( *(at )?)/);
            F = te && te[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, B;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Y();
    }
    function I(g, A) {
      if (!g || q)
        return "";
      {
        var G = B.get(g);
        if (G !== void 0)
          return G;
      }
      var te;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, H();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              te = je;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              te = je;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            te = je;
          }
          g();
        }
      } catch (je) {
        if (je && te && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = te.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var Ue = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", g.displayName)), typeof g == "function" && B.set(g, Ue), Ue;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Lt = g ? g.displayName || g.name : "", vt = Lt ? T(Lt) : "";
      return typeof g == "function" && B.set(g, vt), vt;
    }
    function le(g, A, G) {
      return I(g, !1);
    }
    function he(g) {
      var A = g.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(g, A, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return I(g, he(g));
      if (typeof g == "string")
        return T(g);
      switch (g) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return oe(g.type, A, G);
          case d: {
            var te = g, ae = te._payload, ue = te._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, We = {}, He = L.ReactDebugCurrentFrame;
    function Ie(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(g, A, G, te, ae) {
      {
        var ue = Function.call.bind(Be);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var Oe = Error((te || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = g[se](A, se, te, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Ie(ae), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ce(g) {
      return $e(g);
    }
    function Qe(g) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function lt(g) {
      try {
        return be(g), !1;
      } catch {
        return !0;
      }
    }
    function be(g) {
      return "" + g;
    }
    function Ee(g) {
      if (lt(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(g)), be(g);
    }
    var Ae = L.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, ot, ve;
    ve = {};
    function yt(g) {
      if (Be.call(g, "ref")) {
        var A = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function it(g) {
      if (Be.call(g, "key")) {
        var A = Object.getOwnPropertyDescriptor(g, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function st(g, A) {
      if (typeof g.ref == "string" && Ae.current && A && Ae.current.stateNode !== A) {
        var G = $(Ae.current.type);
        ve[G] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ae.current.type), g.ref), ve[G] = !0);
      }
    }
    function ut(g, A) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function bt(g, A) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var ct = function(g, A, G, te, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function wt(g, A, G, te, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (Ee(G), ie = "" + G), it(A) && (Ee(A.key), ie = "" + A.key), yt(A) && (Oe = A.ref, st(A, ae));
        for (ue in A)
          Be.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && ut(se, fe), Oe && bt(se, fe);
        }
        return ct(g, ie, Oe, ae, te, Ae.current, se);
      }
    }
    var tt = L.ReactCurrentOwner, gt = L.ReactDebugCurrentFrame;
    function rt(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        gt.setExtraStackFrame(G);
      } else
        gt.setExtraStackFrame(null);
    }
    var Ct;
    Ct = !1;
    function pt(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Et() {
      {
        if (tt.current) {
          var g = $(tt.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Ot(g) {
      return "";
    }
    var kt = {};
    function xt(g) {
      {
        var A = Et();
        if (!A) {
          var G = typeof g == "string" ? g : g.displayName || g.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function Pt(g, A) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var G = xt(A);
        if (kt[G])
          return;
        kt[G] = !0;
        var te = "";
        g && g._owner && g._owner !== tt.current && (te = " It was passed a child from " + $(g._owner.type) + "."), rt(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, te), rt(null);
      }
    }
    function Vt(g, A) {
      {
        if (typeof g != "object")
          return;
        if (Ce(g))
          for (var G = 0; G < g.length; G++) {
            var te = g[G];
            pt(te) && Pt(te, A);
          }
        else if (pt(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              pt(se.value) && Pt(se.value, A);
        }
      }
    }
    function mt(g) {
      {
        var A = g.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var te = $(A);
          nt(G, g.props, "prop", te, g);
        } else if (A.PropTypes !== void 0 && !Ct) {
          Ct = !0;
          var ae = $(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ne(g) {
      {
        for (var A = Object.keys(g.props), G = 0; G < A.length; G++) {
          var te = A[G];
          if (te !== "children" && te !== "key") {
            rt(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), rt(null);
            break;
          }
        }
        g.ref !== null && (rt(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var so = {};
    function ao(g, A, G, te, ae, ue) {
      {
        var se = N(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ot();
          Oe ? ie += Oe : ie += Et();
          var de;
          g === null ? de = "null" : Ce(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = wt(g, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Ue = A.children;
          if (Ue !== void 0)
            if (te)
              if (Ce(Ue)) {
                for (var Lt = 0; Lt < Ue.length; Lt++)
                  Vt(Ue[Lt], g);
                Object.freeze && Object.freeze(Ue);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vt(Ue, g);
        }
        if (Be.call(A, "key")) {
          var vt = $(g), je = Object.keys(A).filter(function(wi) {
            return wi !== "key";
          }), Wn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[vt + Wn]) {
            var bi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wn, vt, bi, vt), so[vt + Wn] = !0;
          }
        }
        return g === r ? ne(fe) : mt(fe), fe;
      }
    }
    function gi(g, A, G) {
      return ao(g, A, G, !0);
    }
    function mi(g, A, G) {
      return ao(g, A, G, !1);
    }
    var vi = mi, yi = gi;
    Qg.Fragment = r, Qg.jsx = vi, Qg.jsxs = yi;
  }()), Qg;
}
process.env.NODE_ENV === "production" ? Dk.exports = ige() : Dk.exports = sge();
var Hi = Dk.exports;
Ve({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function xI(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function li(e) {
  var t, n;
  return xI(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(xI(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var pX = Symbol.for("immer-nothing"), LI = Symbol.for("immer-draftable"), ks = Symbol.for("immer-state"), age = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Ri(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = age[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var hp = Object.getPrototypeOf;
function Nc(e) {
  return !!e && !!e[ks];
}
function Fc(e) {
  var t;
  return e ? dX(e) || Array.isArray(e) || !!e[LI] || !!((t = e.constructor) != null && t[LI]) || Fw(e) || zw(e) : !1;
}
var lge = Object.prototype.constructor.toString();
function dX(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = hp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === lge;
}
function Uy(e, t) {
  Nw(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Nw(e) {
  const t = e[ks];
  return t ? t.type_ : Array.isArray(e) ? 1 : Fw(e) ? 2 : zw(e) ? 3 : 0;
}
function _k(e, t) {
  return Nw(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function fX(e, t, n) {
  const r = Nw(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function uge(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Fw(e) {
  return e instanceof Map;
}
function zw(e) {
  return e instanceof Set;
}
function ec(e) {
  return e.copy_ || e.base_;
}
function Tk(e, t) {
  if (Fw(e))
    return new Map(e);
  if (zw(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = dX(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ks];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(hp(e), r);
  } else {
    const r = hp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function XM(e, t = !1) {
  return Uw(e) || Nc(e) || !Fc(e) || (Nw(e) > 1 && (e.set = e.add = e.clear = e.delete = cge), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => XM(r, !0))), e;
}
function cge() {
  Ri(2);
}
function Uw(e) {
  return Object.isFrozen(e);
}
var pge = {};
function zc(e) {
  const t = pge[e];
  return t || Ri(0, e), t;
}
var qf;
function hX() {
  return qf;
}
function dge(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function EI(e, t) {
  t && (zc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function jk(e) {
  Ak(e), e.drafts_.forEach(fge), e.drafts_ = null;
}
function Ak(e) {
  e === qf && (qf = e.parent_);
}
function kI(e) {
  return qf = dge(qf, e);
}
function fge(e) {
  const t = e[ks];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function PI(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ks].modified_ && (jk(t), Ri(4)), Fc(e) && (e = Wy(t, e), t.parent_ || Hy(t, e)), t.patches_ && zc("Patches").generateReplacementPatches_(
    n[ks].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Wy(t, n, []), jk(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== pX ? e : void 0;
}
function Wy(e, t, n) {
  if (Uw(t))
    return t;
  const r = t[ks];
  if (!r)
    return Uy(
      t,
      (o, i) => SI(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Hy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Uy(
      i,
      (s, l) => SI(e, r, o, s, l, n, a)
    ), Hy(e, o, !1), n && e.patches_ && zc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function SI(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Ri(5), Nc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !_k(t.assigned_, r) ? i.concat(r) : void 0, l = Wy(e, o, s);
    if (fX(n, r, l), Nc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Fc(o) && !Uw(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Wy(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Hy(e, o);
  }
}
function Hy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && XM(t, n);
}
function hge(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : hX(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = KM;
  n && (o = [r], i = Zf);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var KM = {
  get(e, t) {
    if (t === ks)
      return e;
    const n = ec(e);
    if (!_k(n, t))
      return gge(e, n, t);
    const r = n[t];
    return e.finalized_ || !Fc(r) ? r : r === gO(e.base_, t) ? (mO(e), e.copy_[t] = Ik(r, e)) : r;
  },
  has(e, t) {
    return t in ec(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(ec(e));
  },
  set(e, t, n) {
    const r = gX(ec(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = gO(ec(e), t), i = o == null ? void 0 : o[ks];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (uge(n, o) && (n !== void 0 || _k(e.base_, t)))
        return !0;
      mO(e), Bk(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return gO(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, mO(e), Bk(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = ec(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Ri(11);
  },
  getPrototypeOf(e) {
    return hp(e.base_);
  },
  setPrototypeOf() {
    Ri(12);
  }
}, Zf = {};
Uy(KM, (e, t) => {
  Zf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Zf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Ri(13), Zf.set.call(this, e, t, void 0);
};
Zf.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Ri(14), KM.set.call(this, e[0], t, n, e[0]);
};
function gO(e, t) {
  const n = e[ks];
  return (n ? ec(n) : e)[t];
}
function gge(e, t, n) {
  var r;
  const o = gX(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function gX(e, t) {
  if (!(t in e))
    return;
  let n = hp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = hp(n);
  }
}
function Bk(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Bk(e.parent_));
}
function mO(e) {
  e.copy_ || (e.copy_ = Tk(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var mge = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Ri(6), r !== void 0 && typeof r != "function" && Ri(7);
      let o;
      if (Fc(t)) {
        const i = kI(this), a = Ik(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? jk(i) : Ak(i);
        }
        return EI(i, r), PI(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === pX && (o = void 0), this.autoFreeze_ && XM(o, !0), r) {
          const i = [], a = [];
          zc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Ri(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Fc(e) || Ri(8), Nc(e) && (e = vge(e));
    const t = kI(this), n = Ik(e, void 0);
    return n[ks].isManual_ = !0, Ak(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ks];
    (!n || !n.isManual_) && Ri(9);
    const { scope_: r } = n;
    return EI(r, t), PI(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = zc("Patches").applyPatches_;
    return Nc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Ik(e, t) {
  const n = Fw(e) ? zc("MapSet").proxyMap_(e, t) : zw(e) ? zc("MapSet").proxySet_(e, t) : hge(e, t);
  return (t ? t.scope_ : hX()).drafts_.push(n), n;
}
function vge(e) {
  return Nc(e) || Ri(10, e), mX(e);
}
function mX(e) {
  if (!Fc(e) || Uw(e))
    return e;
  const t = e[ks];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Tk(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Tk(e, !0);
  return Uy(n, (r, o) => {
    fX(n, r, mX(o));
  }), t && (t.finalized_ = !1), n;
}
var Ps = new mge(), JM = Ps.produce;
Ps.produceWithPatches.bind(
  Ps
);
Ps.setAutoFreeze.bind(Ps);
Ps.setUseStrictShallowCopy.bind(Ps);
Ps.applyPatches.bind(Ps);
var MI = Ps.createDraft.bind(Ps), DI = Ps.finishDraft.bind(Ps), Ye = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ye.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ye.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ye.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ye.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ye.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ye.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ye.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ye.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ye.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ye.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ye.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ye.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ye.isAncestor(t, e) && !Ye.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ye.equals(i, r) || Ye.endsBefore(i, r) || Ye.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ye.equals(a, r) || Ye.isAncestor(a, r))
          return null;
        Ye.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ye.equals(s, r) || Ye.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ye.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ye.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ye.endsBefore(u, r) ? r[u.length - 1] += 1 : Ye.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ye.equals(p, d))
          return r;
        if (Ye.isAncestor(p, r) || Ye.equals(p, r)) {
          var y = d.slice();
          return Ye.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Ye.isSibling(p, d) && (Ye.isAncestor(d, r) || Ye.equals(d, r)) ? Ye.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ye.endsBefore(d, r) || Ye.equals(d, r) || Ye.isAncestor(d, r) ? (Ye.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ye.endsBefore(p, r) && (Ye.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Gf(e) {
  "@babel/helpers - typeof";
  return Gf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gf(e);
}
function yge(e, t) {
  if (Gf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Gf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function bge(e) {
  var t = yge(e, "string");
  return Gf(t) === "symbol" ? t : String(t);
}
function Lp(e, t, n) {
  return t = bge(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function _I(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ed(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _I(Object(n), !0).forEach(function(r) {
      Lp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _I(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wge = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Tt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Yt.points(t))
          t[l] = Tr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Tt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Yt.points(t))
          t[b] = Tr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Tt.get(e, L), D = Ye.previous(L), x = Tt.get(e, D), m = Tt.parent(e, L), C = L[L.length - 1];
      if (Mo.isText(w) && Mo.isText(x))
        x.text += w.text;
      else if (!Mo.isText(w) && !Mo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(is.stringify(w), " ").concat(is.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Yt.points(t))
          t[U] = Tr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: N
      } = n;
      if (Ye.isAncestor(k, N))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Tt.get(e, k), V = Tt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var W = Ye.transform(k, n), Z = Tt.get(e, Ye.parent(W)), X = W[W.length - 1];
      if (Z.children.splice(X, 0, R), t)
        for (var [K, Q] of Yt.points(t))
          t[Q] = Tr.transform(K, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Tt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Yt.points(t)) {
          var H = Tr.transform(z, n);
          if (t != null && H != null)
            t[M] = H;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Tt.texts(e))
              if (Ye.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var q = !1;
            O && j && (Ye.equals(j[1], J) ? q = !Ye.hasPrevious(j[1]) : q = Ye.common(O[1], J).length < Ye.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Y,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = Tt.leaf(e, B), he = le.text.slice(0, Y), oe = le.text.slice(Y + I.length);
      if (le.text = he + oe, t)
        for (var [Be, We] of Yt.points(t))
          t[We] = Tr.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Ie,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var $e = Tt.get(e, He);
      for (var Ce in nt) {
        if (Ce === "children" || Ce === "text")
          throw new Error('Cannot set the "'.concat(Ce, '" property of nodes!'));
        var Qe = nt[Ce];
        Qe == null ? delete $e[Ce] : $e[Ce] = Qe;
      }
      for (var lt in Ie)
        nt.hasOwnProperty(lt) || delete $e[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: be
      } = n;
      if (be == null)
        t = be;
      else {
        if (t == null) {
          if (!Yt.isRange(be))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(is.stringify(be), " when there is no current selection."));
          t = ed({}, be);
        }
        for (var Ee in be) {
          var Ae = be[Ee];
          if (Ae == null) {
            if (Ee === "anchor" || Ee === "focus")
              throw new Error('Cannot remove the "'.concat(Ee, '" selection property'));
            delete t[Ee];
          } else
            t[Ee] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Re,
        properties: ot
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var ve = Tt.get(e, ze), yt = Tt.parent(e, ze), it = ze[ze.length - 1], st;
      if (Mo.isText(ve)) {
        var ut = ve.text.slice(0, Re), bt = ve.text.slice(Re);
        ve.text = ut, st = ed(ed({}, ot), {}, {
          text: bt
        });
      } else {
        var ct = ve.children.slice(0, Re), wt = ve.children.slice(Re);
        ve.children = ct, st = ed(ed({}, ot), {}, {
          children: wt
        });
      }
      if (yt.children.splice(it + 1, 0, st), t)
        for (var [tt, gt] of Yt.points(t))
          t[gt] = Tr.transform(tt, n);
      break;
    }
  }
  return t;
}, Cge = {
  transform(e, t) {
    e.children = MI(e.children);
    var n = e.selection && MI(e.selection);
    try {
      n = wge(e, n, t);
    } finally {
      e.children = DI(e.children), n ? e.selection = Nc(n) ? DI(n) : n : e.selection = null;
    }
  }
}, Oge = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, xge = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, vX = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (li(r) && li(o)) {
      if (!vX(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Lge(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Yf(e, t) {
  if (e == null) return {};
  var n = Lge(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Ege = ["anchor", "focus"];
function TI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kge(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TI(Object(n), !0).forEach(function(r) {
      Lp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Yt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Yt.edges(e);
    return t;
  },
  equals(e, t) {
    return Tr.equals(e.anchor, t.anchor) && Tr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Yt.isRange(t)) {
      if (Yt.includes(e, t.anchor) || Yt.includes(e, t.focus))
        return !0;
      var [n, r] = Yt.edges(e), [o, i] = Yt.edges(t);
      return Tr.isBefore(n, o) && Tr.isAfter(r, i);
    }
    var [a, s] = Yt.edges(e), l = !1, u = !1;
    return Tr.isPoint(t) ? (l = Tr.compare(t, a) >= 0, u = Tr.compare(t, s) <= 0) : (l = Ye.compare(t, a.path) >= 0, u = Ye.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Yf(e, Ege), [r, o] = Yt.edges(e), [i, a] = Yt.edges(t), s = Tr.isBefore(r, i) ? i : r, l = Tr.isBefore(o, a) ? o : a;
    return Tr.isBefore(l, s) ? null : kge({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Tr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Tr.equals(t, n);
  },
  isExpanded(e) {
    return !Yt.isCollapsed(e);
  },
  isForward(e) {
    return !Yt.isBackward(e);
  },
  isRange(e) {
    return li(e) && Tr.isPoint(e.anchor) && Tr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Yt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return JM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Yt.isCollapsed(r);
        Yt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Yt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Tr.transform(r.anchor, t, {
        affinity: i
      }), u = Tr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, jI = (e) => li(e) && Tt.isNodeList(e.children) && !cr.isEditor(e), $a = {
  isAncestor(e) {
    return li(e) && Tt.isNodeList(e.children);
  },
  isElement: jI,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => $a.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return jI(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Pge = ["children"], Sge = ["text"], AI = /* @__PURE__ */ new WeakMap(), Tt = {
  ancestor(e, t) {
    var n = Tt.get(e, t);
    if (Mo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(is.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ye.ancestors(t, n)) {
        var o = Tt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Mo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(is.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(is.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Tt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Tt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ye.common(t, n), o = Tt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Tt.get(e, t);
    if (cr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(is.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        $a.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if ($a.isAncestor(e)) {
      var t = Yf(e, Pge);
      return t;
    } else {
      var t = Yf(e, Sge);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Tt.get(e, n); r && !(Mo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Mo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(is.stringify(e)));
    var n = JM({
      children: e.children
    }, (r) => {
      var [o, i] = Yt.edges(t), a = Tt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Yt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Yt.includes(t, s)) {
          var l = Tt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ye.equals(s, i.path)) {
          var c = Tt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ye.equals(s, o.path)) {
          var p = Tt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      cr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Mo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(is.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Mo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Mo.isText(e) || $a.isElement(e) || cr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = AI.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Tt.isNode(r));
    return AI.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Tt.get(e, n); r && !(Mo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Tt.get(e, t);
    if (!Mo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(is.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ye.levels(t, n)) {
        var o = Tt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return $a.isElement(e) && $a.isElementProps(t) && $a.matches(e, t) || Mo.isText(e) && Mo.isTextProps(t) && Mo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ye.isBefore(s, i) : Ye.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Mo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ye.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Tt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ye.next(s);
          if (Tt.has(e, c)) {
            s = c, l = Tt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ye.previous(s);
          s = p, l = Tt.get(e, s);
          continue;
        }
        s = Ye.parent(s), l = Tt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ye.parent(t), r = Tt.get(e, n);
    if (Mo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Mo.isText(e) ? e.text : e.children.map(Tt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Tt.nodes(e, t))
        Mo.isText(n) && (yield [n, r]);
    }();
  }
};
function BI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BI(Object(n), !0).forEach(function(r) {
      Lp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zd = {
  isNodeOperation(e) {
    return zd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!li(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ye.isPath(e.path) && Tt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ye.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ye.isPath(e.path) && li(e.properties);
      case "move_node":
        return Ye.isPath(e.path) && Ye.isPath(e.newPath);
      case "remove_node":
        return Ye.isPath(e.path) && Tt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ye.isPath(e.path);
      case "set_node":
        return Ye.isPath(e.path) && li(e.properties) && li(e.newProperties);
      case "set_selection":
        return e.properties === null && Yt.isRange(e.newProperties) || e.newProperties === null && Yt.isRange(e.properties) || li(e.properties) && li(e.newProperties);
      case "split_node":
        return Ye.isPath(e.path) && typeof e.position == "number" && li(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => zd.isOperation(t));
  },
  isSelectionOperation(e) {
    return zd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return zd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return zr(zr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return zr(zr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return zr(zr({}, e), {}, {
          type: "split_node",
          path: Ye.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ye.equals(t, n))
          return e;
        if (Ye.isSibling(n, t))
          return zr(zr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ye.transform(n, e), o = Ye.transform(Ye.next(n), e);
        return zr(zr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return zr(zr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return zr(zr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return zr(zr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? zr(zr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? zr(zr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : zr(zr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return zr(zr({}, e), {}, {
          type: "merge_node",
          path: Ye.next(e.path)
        });
    }
  }
}, II = /* @__PURE__ */ new WeakMap(), Mge = (e) => {
  var t = II.get(e);
  if (t !== void 0)
    return t;
  if (!li(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || li(e.marks)) && (e.selection === null || Yt.isRange(e.selection)) && Tt.isNodeList(e.children) && zd.isOperationList(e.operations);
  return II.set(e, n), n;
}, cr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Mge(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function RI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RI(Object(n), !0).forEach(function(r) {
      Lp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tr = {
  compare(e, t) {
    var n = Ye.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Tr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Tr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ye.equals(e.path, t.path);
  },
  isPoint(e) {
    return li(e) && typeof e.offset == "number" && Ye.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return JM(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ye.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ye.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ye.equals(t.path, i) && (r.offset += t.position), r.path = Ye.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ye.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ye.equals(t.path, i) || Ye.isAncestor(t.path, i))
            return null;
          r.path = Ye.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ye.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ye.transform(i, t, NI(NI({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ye.transform(i, t, n);
          break;
        }
      }
    });
  }
}, FI = void 0, is = {
  setScrubber(e) {
    FI = e;
  },
  stringify(e) {
    return JSON.stringify(e, FI);
  }
}, Dge = ["text"], _ge = ["anchor", "focus"];
function zI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Da(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zI(Object(n), !0).forEach(function(r) {
      Lp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Yf(i, Dge);
      return a;
    }
    return vX(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return li(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Mo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Da({}, e)];
    for (var r of t) {
      var o = Yf(r, _ge), [i, a] = Yt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = Da(Da({}, f), {}, {
            text: f.text.slice(L)
          }), f = Da(Da({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Da(Da({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Da(Da({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Tge = (e) => e.selection ? e.selection : e.children.length > 0 ? cr.end(e, []) : [0], Er;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Er || (Er = {}));
Er.L, Er.L | Er.V | Er.LV | Er.LVT, Er.LV | Er.V, Er.V | Er.T, Er.LVT | Er.T, Er.T, Er.Any, Er.Extend | Er.ZWJ, Er.Any, Er.SpacingMark, Er.Prepend, Er.Any, Er.ZWJ, Er.ExtPict, Er.RI, Er.RI;
var jge = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    cr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Tge(e)
      } = n;
      if (Ye.isPath(o) && (o = cr.range(e, o)), Yt.isRange(o))
        if (Yt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Yt.end(o);
          if (!r && cr.void(e, {
            at: i
          }))
            return;
          var a = Yt.start(o), s = cr.pointRef(e, a), l = cr.pointRef(e, i);
          Vy.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Vy.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && cr.void(e, {
        at: o
      }) || cr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function UI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function em(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UI(Object(n), !0).forEach(function(r) {
      Lp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vy = em(em(em(em({}, Cge), Oge), xge), jge), yX = {}, QM = {}, eD = {};
Object.defineProperty(eD, "__esModule", { value: !0 });
eD.default = Rge;
var WI = "html", HI = "head", tm = "body", Age = /<([a-zA-Z]+[0-9]?)/, VI = /<head[^]*>/i, $I = /<body[^]*>/i, $y = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Rk = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, qI = typeof window == "object" && window.DOMParser;
if (typeof qI == "function") {
  var Bge = new qI(), Ige = "text/html";
  Rk = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Bge.parseFromString(e, Ige);
  }, $y = Rk;
}
if (typeof document == "object" && document.implementation) {
  var nm = document.implementation.createHTMLDocument();
  $y = function(e, t) {
    if (t) {
      var n = nm.documentElement.querySelector(t);
      return n && (n.innerHTML = e), nm;
    }
    return nm.documentElement.innerHTML = e, nm;
  };
}
var rm = typeof document == "object" && document.createElement("template"), Nk;
rm && rm.content && (Nk = function(e) {
  return rm.innerHTML = e, rm.content.childNodes;
});
function Rge(e) {
  var t, n, r = e.match(Age), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case WI: {
      var i = Rk(e);
      if (!VI.test(e)) {
        var a = i.querySelector(HI);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!$I.test(e)) {
        var a = i.querySelector(tm);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(WI);
    }
    case HI:
    case tm: {
      var s = $y(e).querySelectorAll(o);
      return $I.test(e) && VI.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Nk)
        return Nk(e);
      var a = $y(e, tm).querySelector(tm);
      return a.childNodes;
    }
  }
}
var Ww = {}, tD = {}, nD = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(nD);
var on = {}, mu = yr && yr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), rf = yr && yr.__assign || function() {
  return rf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, rf.apply(this, arguments);
};
Object.defineProperty(on, "__esModule", { value: !0 });
on.cloneNode = on.hasChildren = on.isDocument = on.isDirective = on.isComment = on.isText = on.isCDATA = on.isTag = on.Element = on.Document = on.CDATA = on.NodeWithChildren = on.ProcessingInstruction = on.Comment = on.Text = on.DataNode = on.Node = void 0;
var Ki = nD, rD = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), oD(this, t);
    }, e;
  }()
);
on.Node = rD;
var Hw = (
  /** @class */
  function(e) {
    mu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rD)
);
on.DataNode = Hw;
var bX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ki.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hw)
);
on.Text = bX;
var wX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ki.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hw)
);
on.Comment = wX;
var CX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ki.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Hw)
);
on.ProcessingInstruction = CX;
var Vw = (
  /** @class */
  function(e) {
    mu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rD)
);
on.NodeWithChildren = Vw;
var OX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ki.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vw)
);
on.CDATA = OX;
var xX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ki.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vw)
);
on.Document = xX;
var LX = (
  /** @class */
  function(e) {
    mu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ki.ElementType.Script : n === "style" ? Ki.ElementType.Style : Ki.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vw)
);
on.Element = LX;
function EX(e) {
  return (0, Ki.isTag)(e);
}
on.isTag = EX;
function kX(e) {
  return e.type === Ki.ElementType.CDATA;
}
on.isCDATA = kX;
function PX(e) {
  return e.type === Ki.ElementType.Text;
}
on.isText = PX;
function SX(e) {
  return e.type === Ki.ElementType.Comment;
}
on.isComment = SX;
function MX(e) {
  return e.type === Ki.ElementType.Directive;
}
on.isDirective = MX;
function DX(e) {
  return e.type === Ki.ElementType.Root;
}
on.isDocument = DX;
function Nge(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
on.hasChildren = Nge;
function oD(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (PX(e))
    n = new bX(e.data);
  else if (SX(e))
    n = new wX(e.data);
  else if (EX(e)) {
    var r = t ? vO(e.children) : [], o = new LX(e.name, rf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = rf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = rf({}, e["x-attribsPrefix"])), n = o;
  } else if (kX(e)) {
    var r = t ? vO(e.children) : [], i = new OX(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (DX(e)) {
    var r = t ? vO(e.children) : [], a = new xX(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (MX(e)) {
    var s = new CX(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
on.cloneNode = oD;
function vO(e) {
  for (var t = e.map(function(r) {
    return oD(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = yr && yr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = yr && yr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = nD, o = on;
  n(on, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(tD);
var _X = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(_X);
Object.defineProperty(Ww, "__esModule", { value: !0 });
Ww.formatAttributes = TX;
Ww.formatDOM = jX;
var om = tD, Fge = _X;
function zge(e) {
  return Fge.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function TX(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Uge(e) {
  e = e.toLowerCase();
  var t = zge(e);
  return t || e;
}
function jX(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Uge(s.nodeName);
        o = new om.Element(l, TX(s.attributes)), o.children = jX(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new om.Text(s.nodeValue);
        break;
      case 8:
        o = new om.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new om.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Wge = yr && yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(QM, "__esModule", { value: !0 });
QM.default = qge;
var Hge = Wge(eD), Vge = Ww, $ge = /<(![a-zA-Z\s]+)>/;
function qge(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match($ge), n = t ? t[1] : void 0;
  return (0, Vge.formatDOM)((0, Hge.default)(e), null, n);
}
var $w = {}, Ys = {}, qw = {}, Zge = 0;
qw.SAME = Zge;
var Gge = 1;
qw.CAMELCASE = Gge;
qw.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const AX = 0, vu = 1, Zw = 2, Gw = 3, iD = 4, BX = 5, IX = 6;
function Yge(e) {
  return ei.hasOwnProperty(e) ? ei[e] : null;
}
function Si(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Zw || t === Gw || t === iD, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ei = {}, Xge = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Xge.forEach((e) => {
  ei[e] = new Si(
    e,
    AX,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ei[e] = new Si(
    e,
    vu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ei[e] = new Si(
    e,
    Zw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ei[e] = new Si(
    e,
    Zw,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ei[e] = new Si(
    e,
    Gw,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ei[e] = new Si(
    e,
    Gw,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ei[e] = new Si(
    e,
    iD,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ei[e] = new Si(
    e,
    IX,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ei[e] = new Si(
    e,
    BX,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const sD = /[\-\:]([a-z])/g, aD = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sD, aD);
  ei[t] = new Si(
    t,
    vu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sD, aD);
  ei[t] = new Si(
    t,
    vu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sD, aD);
  ei[t] = new Si(
    t,
    vu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ei[e] = new Si(
    e,
    vu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Kge = "xlinkHref";
ei[Kge] = new Si(
  "xlinkHref",
  vu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ei[e] = new Si(
    e,
    vu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Jge,
  SAME: Qge,
  possibleStandardNames: ZI
} = qw, eme = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", tme = eme + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", nme = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + tme + "]*$")
), rme = Object.keys(
  ZI
).reduce((e, t) => {
  const n = ZI[t];
  return n === Qge ? e[t] = t : n === Jge ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ys.BOOLEAN = Gw;
Ys.BOOLEANISH_STRING = Zw;
Ys.NUMERIC = BX;
Ys.OVERLOADED_BOOLEAN = iD;
Ys.POSITIVE_NUMERIC = IX;
Ys.RESERVED = AX;
Ys.STRING = vu;
Ys.getPropertyInfo = Yge;
Ys.isCustomAttribute = nme;
Ys.possibleStandardNames = rme;
var lD = {}, uD = {}, GI = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, ome = /\n/g, ime = /^\s*/, sme = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, ame = /^:\s*/, lme = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, ume = /^[;\s]*/, cme = /^\s+|\s+$/g, pme = `
`, YI = "/", XI = "*", uc = "", dme = "comment", fme = "declaration", hme = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(ome);
    v && (n += v.length);
    var b = f.lastIndexOf(pme);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(ime);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(YI != e.charAt(0) || XI != e.charAt(1))) {
      for (var v = 2; uc != e.charAt(v) && (XI != e.charAt(v) || YI != e.charAt(v + 1)); )
        ++v;
      if (v += 2, uc === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: dme,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(sme);
    if (v) {
      if (p(), !l(ame)) return s("property missing ':'");
      var b = l(lme), L = f({
        type: fme,
        property: KI(v[0].replace(GI, uc)),
        value: b ? KI(b[0].replace(GI, uc)) : uc
      });
      return l(ume), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function KI(e) {
  return e ? e.replace(cme, uc) : uc;
}
var gme = yr && yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uD, "__esModule", { value: !0 });
uD.default = vme;
var mme = gme(hme);
function vme(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, mme.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Yw = {};
Object.defineProperty(Yw, "__esModule", { value: !0 });
Yw.camelCase = void 0;
var yme = /^--[a-zA-Z0-9_-]+$/, bme = /-([a-z])/g, wme = /^[^-]+$/, Cme = /^-(webkit|moz|ms|o|khtml)-/, Ome = /^-(ms)-/, xme = function(e) {
  return !e || wme.test(e) || yme.test(e);
}, Lme = function(e, t) {
  return t.toUpperCase();
}, JI = function(e, t) {
  return "".concat(t, "-");
}, Eme = function(e, t) {
  return t === void 0 && (t = {}), xme(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Ome, JI) : e = e.replace(Cme, JI), e.replace(bme, Lme));
};
Yw.camelCase = Eme;
var kme = yr && yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Pme = kme(uD), Sme = Yw;
function Fk(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Pme.default)(e, function(r, o) {
    r && o && (n[(0, Sme.camelCase)(r, t)] = o);
  }), n;
}
Fk.default = Fk;
var Mme = Fk;
(function(e) {
  var t = yr && yr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(Mme), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(lD);
Object.defineProperty($w, "__esModule", { value: !0 });
$w.default = jme;
var Ud = Ys, QI = lD, Dme = ["checked", "value"], _me = ["input", "select", "textarea"], Tme = {
  reset: !0,
  submit: !0
};
function jme(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Tme[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ud.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = eR(a);
    if (s) {
      var l = (0, Ud.getPropertyInfo)(s);
      switch (Dme.includes(s) && _me.includes(t) && !r && (s = eR("default" + a)), n[s] = i, l && l.type) {
        case Ud.BOOLEAN:
          n[s] = !0;
          break;
        case Ud.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    QI.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, QI.setStyleProp)(e.style, n), n;
}
function eR(e) {
  return Ud.possibleStandardNames[e];
}
var cD = {}, Ame = yr && yr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(cD, "__esModule", { value: !0 });
cD.default = RX;
var yO = we, Bme = Ame($w), of = lD, Ime = {
  cloneElement: yO.cloneElement,
  createElement: yO.createElement,
  isValidElement: yO.isValidElement
};
function RX(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || of.returnFirstArg, i = t.library || Ime, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, of.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Rme(f) ? ((0, of.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Bme.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = RX(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Rme(e) {
  return of.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, of.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = yr && yr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(QM);
  e.htmlToDOM = n.default;
  var r = t($w);
  e.attributesToProps = r.default;
  var o = t(cD);
  e.domToReact = o.default;
  var i = tD;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(yX);
const Nme = /* @__PURE__ */ oge(yX);
Nme.default;
var br = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fme(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var zk = { exports: {} }, td = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tR;
function zme() {
  if (tR) return td;
  tR = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return td.Fragment = n, td.jsx = a, td.jsxs = a, td;
}
var im = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nR;
function Ume() {
  return nR || (nR = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var A = f && g[f] || g[v];
      return typeof A == "function" ? A : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), te = 1; te < A; te++)
          G[te - 1] = arguments[te];
        D("error", g, G);
      }
    }
    function D(g, A, G) {
      {
        var te = L.ReactDebugCurrentFrame, ae = te.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function N(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function R(g, A, G) {
      var te = g.displayName;
      if (te)
        return te;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var A = g;
            return V(A) + ".Consumer";
          case a:
            var G = g;
            return V(G._context) + ".Provider";
          case l:
            return R(g, g.render, "ForwardRef");
          case p:
            var te = g.displayName || null;
            return te !== null ? te : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, Z = 0, X, K, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function H() {
      {
        if (Z === 0) {
          X = console.log, K = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, g, {
              value: X
            }),
            info: W({}, g, {
              value: K
            }),
            warn: W({}, g, {
              value: Q
            }),
            error: W({}, g, {
              value: J
            }),
            group: W({}, g, {
              value: P
            }),
            groupCollapsed: W({}, g, {
              value: _
            }),
            groupEnd: W({}, g, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = L.ReactCurrentDispatcher, F;
    function T(g, A, G) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var te = ae.stack.trim().match(/\n( *(at )?)/);
            F = te && te[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, B;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Y();
    }
    function I(g, A) {
      if (!g || q)
        return "";
      {
        var G = B.get(g);
        if (G !== void 0)
          return G;
      }
      var te;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, H();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              te = je;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              te = je;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            te = je;
          }
          g();
        }
      } catch (je) {
        if (je && te && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = te.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var Ue = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", g.displayName)), typeof g == "function" && B.set(g, Ue), Ue;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Lt = g ? g.displayName || g.name : "", vt = Lt ? T(Lt) : "";
      return typeof g == "function" && B.set(g, vt), vt;
    }
    function le(g, A, G) {
      return I(g, !1);
    }
    function he(g) {
      var A = g.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(g, A, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return I(g, he(g));
      if (typeof g == "string")
        return T(g);
      switch (g) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return oe(g.type, A, G);
          case d: {
            var te = g, ae = te._payload, ue = te._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, We = {}, He = L.ReactDebugCurrentFrame;
    function Ie(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(g, A, G, te, ae) {
      {
        var ue = Function.call.bind(Be);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var Oe = Error((te || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = g[se](A, se, te, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Ie(ae), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ce(g) {
      return $e(g);
    }
    function Qe(g) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function lt(g) {
      try {
        return be(g), !1;
      } catch {
        return !0;
      }
    }
    function be(g) {
      return "" + g;
    }
    function Ee(g) {
      if (lt(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(g)), be(g);
    }
    var Ae = L.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, ot, ve;
    ve = {};
    function yt(g) {
      if (Be.call(g, "ref")) {
        var A = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function it(g) {
      if (Be.call(g, "key")) {
        var A = Object.getOwnPropertyDescriptor(g, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function st(g, A) {
      if (typeof g.ref == "string" && Ae.current && A && Ae.current.stateNode !== A) {
        var G = $(Ae.current.type);
        ve[G] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ae.current.type), g.ref), ve[G] = !0);
      }
    }
    function ut(g, A) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function bt(g, A) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var ct = function(g, A, G, te, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function wt(g, A, G, te, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (Ee(G), ie = "" + G), it(A) && (Ee(A.key), ie = "" + A.key), yt(A) && (Oe = A.ref, st(A, ae));
        for (ue in A)
          Be.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && ut(se, fe), Oe && bt(se, fe);
        }
        return ct(g, ie, Oe, ae, te, Ae.current, se);
      }
    }
    var tt = L.ReactCurrentOwner, gt = L.ReactDebugCurrentFrame;
    function rt(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        gt.setExtraStackFrame(G);
      } else
        gt.setExtraStackFrame(null);
    }
    var Ct;
    Ct = !1;
    function pt(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Et() {
      {
        if (tt.current) {
          var g = $(tt.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Ot(g) {
      return "";
    }
    var kt = {};
    function xt(g) {
      {
        var A = Et();
        if (!A) {
          var G = typeof g == "string" ? g : g.displayName || g.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function Pt(g, A) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var G = xt(A);
        if (kt[G])
          return;
        kt[G] = !0;
        var te = "";
        g && g._owner && g._owner !== tt.current && (te = " It was passed a child from " + $(g._owner.type) + "."), rt(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, te), rt(null);
      }
    }
    function Vt(g, A) {
      {
        if (typeof g != "object")
          return;
        if (Ce(g))
          for (var G = 0; G < g.length; G++) {
            var te = g[G];
            pt(te) && Pt(te, A);
          }
        else if (pt(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              pt(se.value) && Pt(se.value, A);
        }
      }
    }
    function mt(g) {
      {
        var A = g.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var te = $(A);
          nt(G, g.props, "prop", te, g);
        } else if (A.PropTypes !== void 0 && !Ct) {
          Ct = !0;
          var ae = $(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ne(g) {
      {
        for (var A = Object.keys(g.props), G = 0; G < A.length; G++) {
          var te = A[G];
          if (te !== "children" && te !== "key") {
            rt(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), rt(null);
            break;
          }
        }
        g.ref !== null && (rt(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var so = {};
    function ao(g, A, G, te, ae, ue) {
      {
        var se = N(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ot();
          Oe ? ie += Oe : ie += Et();
          var de;
          g === null ? de = "null" : Ce(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = wt(g, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Ue = A.children;
          if (Ue !== void 0)
            if (te)
              if (Ce(Ue)) {
                for (var Lt = 0; Lt < Ue.length; Lt++)
                  Vt(Ue[Lt], g);
                Object.freeze && Object.freeze(Ue);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vt(Ue, g);
        }
        if (Be.call(A, "key")) {
          var vt = $(g), je = Object.keys(A).filter(function(wi) {
            return wi !== "key";
          }), Wn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[vt + Wn]) {
            var bi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wn, vt, bi, vt), so[vt + Wn] = !0;
          }
        }
        return g === r ? ne(fe) : mt(fe), fe;
      }
    }
    function gi(g, A, G) {
      return ao(g, A, G, !0);
    }
    function mi(g, A, G) {
      return ao(g, A, G, !1);
    }
    var vi = mi, yi = gi;
    im.Fragment = r, im.jsx = vi, im.jsxs = yi;
  }()), im;
}
process.env.NODE_ENV === "production" ? zk.exports = zme() : zk.exports = Ume();
var Vi = zk.exports;
Ve({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function rR(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ui(e) {
  var t, n;
  return rR(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(rR(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var NX = Symbol.for("immer-nothing"), oR = Symbol.for("immer-draftable"), Ss = Symbol.for("immer-state"), Wme = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Ni(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Wme[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var gp = Object.getPrototypeOf;
function Uc(e) {
  return !!e && !!e[Ss];
}
function Wc(e) {
  var t;
  return e ? FX(e) || Array.isArray(e) || !!e[oR] || !!((t = e.constructor) != null && t[oR]) || Kw(e) || Jw(e) : !1;
}
var Hme = Object.prototype.constructor.toString();
function FX(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = gp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Hme;
}
function qy(e, t) {
  Xw(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Xw(e) {
  const t = e[Ss];
  return t ? t.type_ : Array.isArray(e) ? 1 : Kw(e) ? 2 : Jw(e) ? 3 : 0;
}
function Uk(e, t) {
  return Xw(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function zX(e, t, n) {
  const r = Xw(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Vme(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Kw(e) {
  return e instanceof Map;
}
function Jw(e) {
  return e instanceof Set;
}
function tc(e) {
  return e.copy_ || e.base_;
}
function Wk(e, t) {
  if (Kw(e))
    return new Map(e);
  if (Jw(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = FX(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ss];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(gp(e), r);
  } else {
    const r = gp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function pD(e, t = !1) {
  return Qw(e) || Uc(e) || !Wc(e) || (Xw(e) > 1 && (e.set = e.add = e.clear = e.delete = $me), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => pD(r, !0))), e;
}
function $me() {
  Ni(2);
}
function Qw(e) {
  return Object.isFrozen(e);
}
var qme = {};
function Hc(e) {
  const t = qme[e];
  return t || Ni(0, e), t;
}
var Xf;
function UX() {
  return Xf;
}
function Zme(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function iR(e, t) {
  t && (Hc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Hk(e) {
  Vk(e), e.drafts_.forEach(Gme), e.drafts_ = null;
}
function Vk(e) {
  e === Xf && (Xf = e.parent_);
}
function sR(e) {
  return Xf = Zme(Xf, e);
}
function Gme(e) {
  const t = e[Ss];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function aR(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ss].modified_ && (Hk(t), Ni(4)), Wc(e) && (e = Zy(t, e), t.parent_ || Gy(t, e)), t.patches_ && Hc("Patches").generateReplacementPatches_(
    n[Ss].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Zy(t, n, []), Hk(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== NX ? e : void 0;
}
function Zy(e, t, n) {
  if (Qw(t))
    return t;
  const r = t[Ss];
  if (!r)
    return qy(
      t,
      (o, i) => lR(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Gy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), qy(
      i,
      (s, l) => lR(e, r, o, s, l, n, a)
    ), Gy(e, o, !1), n && e.patches_ && Hc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function lR(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Ni(5), Uc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Uk(t.assigned_, r) ? i.concat(r) : void 0, l = Zy(e, o, s);
    if (zX(n, r, l), Uc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Wc(o) && !Qw(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Zy(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Gy(e, o);
  }
}
function Gy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && pD(t, n);
}
function Yme(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : UX(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = dD;
  n && (o = [r], i = Kf);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var dD = {
  get(e, t) {
    if (t === Ss)
      return e;
    const n = tc(e);
    if (!Uk(n, t))
      return Xme(e, n, t);
    const r = n[t];
    return e.finalized_ || !Wc(r) ? r : r === bO(e.base_, t) ? (wO(e), e.copy_[t] = qk(r, e)) : r;
  },
  has(e, t) {
    return t in tc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(tc(e));
  },
  set(e, t, n) {
    const r = WX(tc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = bO(tc(e), t), i = o == null ? void 0 : o[Ss];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Vme(n, o) && (n !== void 0 || Uk(e.base_, t)))
        return !0;
      wO(e), $k(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return bO(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, wO(e), $k(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = tc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Ni(11);
  },
  getPrototypeOf(e) {
    return gp(e.base_);
  },
  setPrototypeOf() {
    Ni(12);
  }
}, Kf = {};
qy(dD, (e, t) => {
  Kf[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Kf.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Ni(13), Kf.set.call(this, e, t, void 0);
};
Kf.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Ni(14), dD.set.call(this, e[0], t, n, e[0]);
};
function bO(e, t) {
  const n = e[Ss];
  return (n ? tc(n) : e)[t];
}
function Xme(e, t, n) {
  var r;
  const o = WX(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function WX(e, t) {
  if (!(t in e))
    return;
  let n = gp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = gp(n);
  }
}
function $k(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && $k(e.parent_));
}
function wO(e) {
  e.copy_ || (e.copy_ = Wk(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Kme = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Ni(6), r !== void 0 && typeof r != "function" && Ni(7);
      let o;
      if (Wc(t)) {
        const i = sR(this), a = qk(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? Hk(i) : Vk(i);
        }
        return iR(i, r), aR(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === NX && (o = void 0), this.autoFreeze_ && pD(o, !0), r) {
          const i = [], a = [];
          Hc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Ni(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Wc(e) || Ni(8), Uc(e) && (e = Jme(e));
    const t = sR(this), n = qk(e, void 0);
    return n[Ss].isManual_ = !0, Vk(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ss];
    (!n || !n.isManual_) && Ni(9);
    const { scope_: r } = n;
    return iR(r, t), aR(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Hc("Patches").applyPatches_;
    return Uc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function qk(e, t) {
  const n = Kw(e) ? Hc("MapSet").proxyMap_(e, t) : Jw(e) ? Hc("MapSet").proxySet_(e, t) : Yme(e, t);
  return (t ? t.scope_ : UX()).drafts_.push(n), n;
}
function Jme(e) {
  return Uc(e) || Ni(10, e), HX(e);
}
function HX(e) {
  if (!Wc(e) || Qw(e))
    return e;
  const t = e[Ss];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Wk(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Wk(e, !0);
  return qy(n, (r, o) => {
    zX(n, r, HX(o));
  }), t && (t.finalized_ = !1), n;
}
var Ms = new Kme(), fD = Ms.produce;
Ms.produceWithPatches.bind(
  Ms
);
Ms.setAutoFreeze.bind(Ms);
Ms.setUseStrictShallowCopy.bind(Ms);
Ms.applyPatches.bind(Ms);
var uR = Ms.createDraft.bind(Ms), cR = Ms.finishDraft.bind(Ms), Xe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Xe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Xe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Xe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Xe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Xe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Xe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Xe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Xe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Xe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Xe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Xe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Xe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Xe.isAncestor(t, e) && !Xe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Xe.equals(i, r) || Xe.endsBefore(i, r) || Xe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Xe.equals(a, r) || Xe.isAncestor(a, r))
          return null;
        Xe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Xe.equals(s, r) || Xe.endsBefore(s, r) ? r[s.length - 1] -= 1 : Xe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Xe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Xe.endsBefore(u, r) ? r[u.length - 1] += 1 : Xe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Xe.equals(p, d))
          return r;
        if (Xe.isAncestor(p, r) || Xe.equals(p, r)) {
          var y = d.slice();
          return Xe.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Xe.isSibling(p, d) && (Xe.isAncestor(d, r) || Xe.equals(d, r)) ? Xe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Xe.endsBefore(d, r) || Xe.equals(d, r) || Xe.isAncestor(d, r) ? (Xe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Xe.endsBefore(p, r) && (Xe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Jf(e) {
  "@babel/helpers - typeof";
  return Jf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Jf(e);
}
function Qme(e, t) {
  if (Jf(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Jf(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function eve(e) {
  var t = Qme(e, "string");
  return Jf(t) === "symbol" ? t : String(t);
}
function Ep(e, t, n) {
  return t = eve(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function pR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pR(Object(n), !0).forEach(function(r) {
      Ep(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tve = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = jt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Xt.points(t))
          t[l] = jr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = jt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Xt.points(t))
          t[b] = jr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = jt.get(e, L), D = Xe.previous(L), x = jt.get(e, D), m = jt.parent(e, L), C = L[L.length - 1];
      if (Do.isText(w) && Do.isText(x))
        x.text += w.text;
      else if (!Do.isText(w) && !Do.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(ss.stringify(w), " ").concat(ss.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Xt.points(t))
          t[U] = jr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: N
      } = n;
      if (Xe.isAncestor(k, N))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = jt.get(e, k), V = jt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var W = Xe.transform(k, n), Z = jt.get(e, Xe.parent(W)), X = W[W.length - 1];
      if (Z.children.splice(X, 0, R), t)
        for (var [K, Q] of Xt.points(t))
          t[Q] = jr.transform(K, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = jt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Xt.points(t)) {
          var H = jr.transform(z, n);
          if (t != null && H != null)
            t[M] = H;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of jt.texts(e))
              if (Xe.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var q = !1;
            O && j && (Xe.equals(j[1], J) ? q = !Xe.hasPrevious(j[1]) : q = Xe.common(O[1], J).length < Xe.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Y,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = jt.leaf(e, B), he = le.text.slice(0, Y), oe = le.text.slice(Y + I.length);
      if (le.text = he + oe, t)
        for (var [Be, We] of Xt.points(t))
          t[We] = jr.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Ie,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var $e = jt.get(e, He);
      for (var Ce in nt) {
        if (Ce === "children" || Ce === "text")
          throw new Error('Cannot set the "'.concat(Ce, '" property of nodes!'));
        var Qe = nt[Ce];
        Qe == null ? delete $e[Ce] : $e[Ce] = Qe;
      }
      for (var lt in Ie)
        nt.hasOwnProperty(lt) || delete $e[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: be
      } = n;
      if (be == null)
        t = be;
      else {
        if (t == null) {
          if (!Xt.isRange(be))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ss.stringify(be), " when there is no current selection."));
          t = nd({}, be);
        }
        for (var Ee in be) {
          var Ae = be[Ee];
          if (Ae == null) {
            if (Ee === "anchor" || Ee === "focus")
              throw new Error('Cannot remove the "'.concat(Ee, '" selection property'));
            delete t[Ee];
          } else
            t[Ee] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Re,
        properties: ot
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var ve = jt.get(e, ze), yt = jt.parent(e, ze), it = ze[ze.length - 1], st;
      if (Do.isText(ve)) {
        var ut = ve.text.slice(0, Re), bt = ve.text.slice(Re);
        ve.text = ut, st = nd(nd({}, ot), {}, {
          text: bt
        });
      } else {
        var ct = ve.children.slice(0, Re), wt = ve.children.slice(Re);
        ve.children = ct, st = nd(nd({}, ot), {}, {
          children: wt
        });
      }
      if (yt.children.splice(it + 1, 0, st), t)
        for (var [tt, gt] of Xt.points(t))
          t[gt] = jr.transform(tt, n);
      break;
    }
  }
  return t;
}, nve = {
  transform(e, t) {
    e.children = uR(e.children);
    var n = e.selection && uR(e.selection);
    try {
      n = tve(e, n, t);
    } finally {
      e.children = cR(e.children), n ? e.selection = Uc(n) ? cR(n) : n : e.selection = null;
    }
  }
}, rve = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, ove = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, VX = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (ui(r) && ui(o)) {
      if (!VX(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function ive(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Qf(e, t) {
  if (e == null) return {};
  var n = ive(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var sve = ["anchor", "focus"];
function dR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ave(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dR(Object(n), !0).forEach(function(r) {
      Ep(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Xt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Xt.edges(e);
    return t;
  },
  equals(e, t) {
    return jr.equals(e.anchor, t.anchor) && jr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Xt.isRange(t)) {
      if (Xt.includes(e, t.anchor) || Xt.includes(e, t.focus))
        return !0;
      var [n, r] = Xt.edges(e), [o, i] = Xt.edges(t);
      return jr.isBefore(n, o) && jr.isAfter(r, i);
    }
    var [a, s] = Xt.edges(e), l = !1, u = !1;
    return jr.isPoint(t) ? (l = jr.compare(t, a) >= 0, u = jr.compare(t, s) <= 0) : (l = Xe.compare(t, a.path) >= 0, u = Xe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Qf(e, sve), [r, o] = Xt.edges(e), [i, a] = Xt.edges(t), s = jr.isBefore(r, i) ? i : r, l = jr.isBefore(o, a) ? o : a;
    return jr.isBefore(l, s) ? null : ave({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return jr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return jr.equals(t, n);
  },
  isExpanded(e) {
    return !Xt.isCollapsed(e);
  },
  isForward(e) {
    return !Xt.isBackward(e);
  },
  isRange(e) {
    return ui(e) && jr.isPoint(e.anchor) && jr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Xt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fD(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Xt.isCollapsed(r);
        Xt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Xt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = jr.transform(r.anchor, t, {
        affinity: i
      }), u = jr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, fR = (e) => ui(e) && jt.isNodeList(e.children) && !pr.isEditor(e), qa = {
  isAncestor(e) {
    return ui(e) && jt.isNodeList(e.children);
  },
  isElement: fR,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => qa.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return fR(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, lve = ["children"], uve = ["text"], hR = /* @__PURE__ */ new WeakMap(), jt = {
  ancestor(e, t) {
    var n = jt.get(e, t);
    if (Do.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ss.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Xe.ancestors(t, n)) {
        var o = jt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Do.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ss.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ss.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = jt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = jt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Xe.common(t, n), o = jt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = jt.get(e, t);
    if (pr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ss.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        qa.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (qa.isAncestor(e)) {
      var t = Qf(e, lve);
      return t;
    } else {
      var t = Qf(e, uve);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = jt.get(e, n); r && !(Do.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Do.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ss.stringify(e)));
    var n = fD({
      children: e.children
    }, (r) => {
      var [o, i] = Xt.edges(t), a = jt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Xt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Xt.includes(t, s)) {
          var l = jt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Xe.equals(s, i.path)) {
          var c = jt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Xe.equals(s, o.path)) {
          var p = jt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      pr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Do.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ss.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Do.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Do.isText(e) || qa.isElement(e) || pr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = hR.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => jt.isNode(r));
    return hR.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = jt.get(e, n); r && !(Do.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = jt.get(e, t);
    if (!Do.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ss.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Xe.levels(t, n)) {
        var o = jt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return qa.isElement(e) && qa.isElementProps(t) && qa.matches(e, t) || Do.isText(e) && Do.isTextProps(t) && Do.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Xe.isBefore(s, i) : Xe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Do.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Xe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = jt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Xe.next(s);
          if (jt.has(e, c)) {
            s = c, l = jt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Xe.previous(s);
          s = p, l = jt.get(e, s);
          continue;
        }
        s = Xe.parent(s), l = jt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Xe.parent(t), r = jt.get(e, n);
    if (Do.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Do.isText(e) ? e.text : e.children.map(jt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of jt.nodes(e, t))
        Do.isText(n) && (yield [n, r]);
    }();
  }
};
function gR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ur(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gR(Object(n), !0).forEach(function(r) {
      Ep(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wd = {
  isNodeOperation(e) {
    return Wd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!ui(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Xe.isPath(e.path) && jt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Xe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Xe.isPath(e.path) && ui(e.properties);
      case "move_node":
        return Xe.isPath(e.path) && Xe.isPath(e.newPath);
      case "remove_node":
        return Xe.isPath(e.path) && jt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Xe.isPath(e.path);
      case "set_node":
        return Xe.isPath(e.path) && ui(e.properties) && ui(e.newProperties);
      case "set_selection":
        return e.properties === null && Xt.isRange(e.newProperties) || e.newProperties === null && Xt.isRange(e.properties) || ui(e.properties) && ui(e.newProperties);
      case "split_node":
        return Xe.isPath(e.path) && typeof e.position == "number" && ui(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Wd.isOperation(t));
  },
  isSelectionOperation(e) {
    return Wd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Wd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Ur(Ur({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Ur(Ur({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Ur(Ur({}, e), {}, {
          type: "split_node",
          path: Xe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Xe.equals(t, n))
          return e;
        if (Xe.isSibling(n, t))
          return Ur(Ur({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Xe.transform(n, e), o = Xe.transform(Xe.next(n), e);
        return Ur(Ur({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Ur(Ur({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Ur(Ur({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Ur(Ur({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Ur(Ur({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Ur(Ur({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Ur(Ur({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Ur(Ur({}, e), {}, {
          type: "merge_node",
          path: Xe.next(e.path)
        });
    }
  }
}, mR = /* @__PURE__ */ new WeakMap(), cve = (e) => {
  var t = mR.get(e);
  if (t !== void 0)
    return t;
  if (!ui(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || ui(e.marks)) && (e.selection === null || Xt.isRange(e.selection)) && jt.isNodeList(e.children) && Wd.isOperationList(e.operations);
  return mR.set(e, n), n;
}, pr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return cve(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function vR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vR(Object(n), !0).forEach(function(r) {
      Ep(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jr = {
  compare(e, t) {
    var n = Xe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return jr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return jr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Xe.equals(e.path, t.path);
  },
  isPoint(e) {
    return ui(e) && typeof e.offset == "number" && Xe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fD(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Xe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Xe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Xe.equals(t.path, i) && (r.offset += t.position), r.path = Xe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Xe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Xe.equals(t.path, i) || Xe.isAncestor(t.path, i))
            return null;
          r.path = Xe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Xe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Xe.transform(i, t, yR(yR({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Xe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, bR = void 0, ss = {
  setScrubber(e) {
    bR = e;
  },
  stringify(e) {
    return JSON.stringify(e, bR);
  }
}, pve = ["text"], dve = ["anchor", "focus"];
function wR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _a(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wR(Object(n), !0).forEach(function(r) {
      Ep(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Do = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Qf(i, pve);
      return a;
    }
    return VX(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return ui(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Do.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [_a({}, e)];
    for (var r of t) {
      var o = Qf(r, dve), [i, a] = Xt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = _a(_a({}, f), {}, {
            text: f.text.slice(L)
          }), f = _a(_a({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = _a(_a({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = _a(_a({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, fve = (e) => e.selection ? e.selection : e.children.length > 0 ? pr.end(e, []) : [0], kr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(kr || (kr = {}));
kr.L, kr.L | kr.V | kr.LV | kr.LVT, kr.LV | kr.V, kr.V | kr.T, kr.LVT | kr.T, kr.T, kr.Any, kr.Extend | kr.ZWJ, kr.Any, kr.SpacingMark, kr.Prepend, kr.Any, kr.ZWJ, kr.ExtPict, kr.RI, kr.RI;
var hve = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    pr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = fve(e)
      } = n;
      if (Xe.isPath(o) && (o = pr.range(e, o)), Xt.isRange(o))
        if (Xt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Xt.end(o);
          if (!r && pr.void(e, {
            at: i
          }))
            return;
          var a = Xt.start(o), s = pr.pointRef(e, a), l = pr.pointRef(e, i);
          Yy.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Yy.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && pr.void(e, {
        at: o
      }) || pr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function CR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CR(Object(n), !0).forEach(function(r) {
      Ep(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yy = sm(sm(sm(sm({}, nve), rve), ove), hve), $X = {}, hD = {}, gD = {};
Object.defineProperty(gD, "__esModule", { value: !0 });
gD.default = yve;
var OR = "html", xR = "head", am = "body", gve = /<([a-zA-Z]+[0-9]?)/, LR = /<head[^]*>/i, ER = /<body[^]*>/i, Xy = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Zk = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, kR = typeof window == "object" && window.DOMParser;
if (typeof kR == "function") {
  var mve = new kR(), vve = "text/html";
  Zk = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), mve.parseFromString(e, vve);
  }, Xy = Zk;
}
if (typeof document == "object" && document.implementation) {
  var lm = document.implementation.createHTMLDocument();
  Xy = function(e, t) {
    if (t) {
      var n = lm.documentElement.querySelector(t);
      return n && (n.innerHTML = e), lm;
    }
    return lm.documentElement.innerHTML = e, lm;
  };
}
var um = typeof document == "object" && document.createElement("template"), Gk;
um && um.content && (Gk = function(e) {
  return um.innerHTML = e, um.content.childNodes;
});
function yve(e) {
  var t, n, r = e.match(gve), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case OR: {
      var i = Zk(e);
      if (!LR.test(e)) {
        var a = i.querySelector(xR);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!ER.test(e)) {
        var a = i.querySelector(am);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(OR);
    }
    case xR:
    case am: {
      var s = Xy(e).querySelectorAll(o);
      return ER.test(e) && LR.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Gk)
        return Gk(e);
      var a = Xy(e, am).querySelector(am);
      return a.childNodes;
    }
  }
}
var e1 = {}, mD = {}, vD = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(vD);
var sn = {}, yu = br && br.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), sf = br && br.__assign || function() {
  return sf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, sf.apply(this, arguments);
};
Object.defineProperty(sn, "__esModule", { value: !0 });
sn.cloneNode = sn.hasChildren = sn.isDocument = sn.isDirective = sn.isComment = sn.isText = sn.isCDATA = sn.isTag = sn.Element = sn.Document = sn.CDATA = sn.NodeWithChildren = sn.ProcessingInstruction = sn.Comment = sn.Text = sn.DataNode = sn.Node = void 0;
var Ji = vD, yD = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), bD(this, t);
    }, e;
  }()
);
sn.Node = yD;
var t1 = (
  /** @class */
  function(e) {
    yu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yD)
);
sn.DataNode = t1;
var qX = (
  /** @class */
  function(e) {
    yu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ji.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(t1)
);
sn.Text = qX;
var ZX = (
  /** @class */
  function(e) {
    yu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ji.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(t1)
);
sn.Comment = ZX;
var GX = (
  /** @class */
  function(e) {
    yu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Ji.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(t1)
);
sn.ProcessingInstruction = GX;
var n1 = (
  /** @class */
  function(e) {
    yu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yD)
);
sn.NodeWithChildren = n1;
var YX = (
  /** @class */
  function(e) {
    yu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ji.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(n1)
);
sn.CDATA = YX;
var XX = (
  /** @class */
  function(e) {
    yu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Ji.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(n1)
);
sn.Document = XX;
var KX = (
  /** @class */
  function(e) {
    yu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Ji.ElementType.Script : n === "style" ? Ji.ElementType.Style : Ji.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(n1)
);
sn.Element = KX;
function JX(e) {
  return (0, Ji.isTag)(e);
}
sn.isTag = JX;
function QX(e) {
  return e.type === Ji.ElementType.CDATA;
}
sn.isCDATA = QX;
function eK(e) {
  return e.type === Ji.ElementType.Text;
}
sn.isText = eK;
function tK(e) {
  return e.type === Ji.ElementType.Comment;
}
sn.isComment = tK;
function nK(e) {
  return e.type === Ji.ElementType.Directive;
}
sn.isDirective = nK;
function rK(e) {
  return e.type === Ji.ElementType.Root;
}
sn.isDocument = rK;
function bve(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
sn.hasChildren = bve;
function bD(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (eK(e))
    n = new qX(e.data);
  else if (tK(e))
    n = new ZX(e.data);
  else if (JX(e)) {
    var r = t ? CO(e.children) : [], o = new KX(e.name, sf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = sf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = sf({}, e["x-attribsPrefix"])), n = o;
  } else if (QX(e)) {
    var r = t ? CO(e.children) : [], i = new YX(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (rK(e)) {
    var r = t ? CO(e.children) : [], a = new XX(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (nK(e)) {
    var s = new GX(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
sn.cloneNode = bD;
function CO(e) {
  for (var t = e.map(function(r) {
    return bD(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = br && br.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = br && br.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = vD, o = sn;
  n(sn, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(mD);
var oK = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(oK);
Object.defineProperty(e1, "__esModule", { value: !0 });
e1.formatAttributes = iK;
e1.formatDOM = sK;
var cm = mD, wve = oK;
function Cve(e) {
  return wve.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function iK(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Ove(e) {
  e = e.toLowerCase();
  var t = Cve(e);
  return t || e;
}
function sK(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Ove(s.nodeName);
        o = new cm.Element(l, iK(s.attributes)), o.children = sK(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new cm.Text(s.nodeValue);
        break;
      case 8:
        o = new cm.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new cm.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var xve = br && br.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(hD, "__esModule", { value: !0 });
hD.default = Pve;
var Lve = xve(gD), Eve = e1, kve = /<(![a-zA-Z\s]+)>/;
function Pve(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(kve), n = t ? t[1] : void 0;
  return (0, Eve.formatDOM)((0, Lve.default)(e), null, n);
}
var r1 = {}, Xs = {}, o1 = {}, Sve = 0;
o1.SAME = Sve;
var Mve = 1;
o1.CAMELCASE = Mve;
o1.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const aK = 0, bu = 1, i1 = 2, s1 = 3, wD = 4, lK = 5, uK = 6;
function Dve(e) {
  return ti.hasOwnProperty(e) ? ti[e] : null;
}
function Mi(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === i1 || t === s1 || t === wD, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ti = {}, _ve = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
_ve.forEach((e) => {
  ti[e] = new Mi(
    e,
    aK,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ti[e] = new Mi(
    e,
    bu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ti[e] = new Mi(
    e,
    i1,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ti[e] = new Mi(
    e,
    i1,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ti[e] = new Mi(
    e,
    s1,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ti[e] = new Mi(
    e,
    s1,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ti[e] = new Mi(
    e,
    wD,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ti[e] = new Mi(
    e,
    uK,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ti[e] = new Mi(
    e,
    lK,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const CD = /[\-\:]([a-z])/g, OD = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CD, OD);
  ti[t] = new Mi(
    t,
    bu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CD, OD);
  ti[t] = new Mi(
    t,
    bu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CD, OD);
  ti[t] = new Mi(
    t,
    bu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ti[e] = new Mi(
    e,
    bu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Tve = "xlinkHref";
ti[Tve] = new Mi(
  "xlinkHref",
  bu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ti[e] = new Mi(
    e,
    bu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: jve,
  SAME: Ave,
  possibleStandardNames: PR
} = o1, Bve = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ive = Bve + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Rve = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Ive + "]*$")
), Nve = Object.keys(
  PR
).reduce((e, t) => {
  const n = PR[t];
  return n === Ave ? e[t] = t : n === jve ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Xs.BOOLEAN = s1;
Xs.BOOLEANISH_STRING = i1;
Xs.NUMERIC = lK;
Xs.OVERLOADED_BOOLEAN = wD;
Xs.POSITIVE_NUMERIC = uK;
Xs.RESERVED = aK;
Xs.STRING = bu;
Xs.getPropertyInfo = Dve;
Xs.isCustomAttribute = Rve;
Xs.possibleStandardNames = Nve;
var xD = {}, LD = {}, SR = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Fve = /\n/g, zve = /^\s*/, Uve = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Wve = /^:\s*/, Hve = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Vve = /^[;\s]*/, $ve = /^\s+|\s+$/g, qve = `
`, MR = "/", DR = "*", cc = "", Zve = "comment", Gve = "declaration", Yve = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(Fve);
    v && (n += v.length);
    var b = f.lastIndexOf(qve);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(zve);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(MR != e.charAt(0) || DR != e.charAt(1))) {
      for (var v = 2; cc != e.charAt(v) && (DR != e.charAt(v) || MR != e.charAt(v + 1)); )
        ++v;
      if (v += 2, cc === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: Zve,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(Uve);
    if (v) {
      if (p(), !l(Wve)) return s("property missing ':'");
      var b = l(Hve), L = f({
        type: Gve,
        property: _R(v[0].replace(SR, cc)),
        value: b ? _R(b[0].replace(SR, cc)) : cc
      });
      return l(Vve), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function _R(e) {
  return e ? e.replace($ve, cc) : cc;
}
var Xve = br && br.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(LD, "__esModule", { value: !0 });
LD.default = Jve;
var Kve = Xve(Yve);
function Jve(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Kve.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var a1 = {};
Object.defineProperty(a1, "__esModule", { value: !0 });
a1.camelCase = void 0;
var Qve = /^--[a-zA-Z0-9_-]+$/, eye = /-([a-z])/g, tye = /^[^-]+$/, nye = /^-(webkit|moz|ms|o|khtml)-/, rye = /^-(ms)-/, oye = function(e) {
  return !e || tye.test(e) || Qve.test(e);
}, iye = function(e, t) {
  return t.toUpperCase();
}, TR = function(e, t) {
  return "".concat(t, "-");
}, sye = function(e, t) {
  return t === void 0 && (t = {}), oye(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(rye, TR) : e = e.replace(nye, TR), e.replace(eye, iye));
};
a1.camelCase = sye;
var aye = br && br.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, lye = aye(LD), uye = a1;
function Yk(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, lye.default)(e, function(r, o) {
    r && o && (n[(0, uye.camelCase)(r, t)] = o);
  }), n;
}
Yk.default = Yk;
var cye = Yk;
(function(e) {
  var t = br && br.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(cye), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(xD);
Object.defineProperty(r1, "__esModule", { value: !0 });
r1.default = hye;
var Hd = Xs, jR = xD, pye = ["checked", "value"], dye = ["input", "select", "textarea"], fye = {
  reset: !0,
  submit: !0
};
function hye(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && fye[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Hd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = AR(a);
    if (s) {
      var l = (0, Hd.getPropertyInfo)(s);
      switch (pye.includes(s) && dye.includes(t) && !r && (s = AR("default" + a)), n[s] = i, l && l.type) {
        case Hd.BOOLEAN:
          n[s] = !0;
          break;
        case Hd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    jR.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, jR.setStyleProp)(e.style, n), n;
}
function AR(e) {
  return Hd.possibleStandardNames[e];
}
var ED = {}, gye = br && br.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ED, "__esModule", { value: !0 });
ED.default = cK;
var OO = we, mye = gye(r1), af = xD, vye = {
  cloneElement: OO.cloneElement,
  createElement: OO.createElement,
  isValidElement: OO.isValidElement
};
function cK(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || af.returnFirstArg, i = t.library || vye, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, af.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    yye(f) ? ((0, af.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, mye.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = cK(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function yye(e) {
  return af.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, af.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = br && br.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(hD);
  e.htmlToDOM = n.default;
  var r = t(r1);
  e.attributesToProps = r.default;
  var o = t(ED);
  e.domToReact = o.default;
  var i = mD;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})($X);
const bye = /* @__PURE__ */ Fme($X);
bye.default;
var wr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function wye(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Xk = { exports: {} }, rd = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BR;
function Cye() {
  if (BR) return rd;
  BR = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return rd.Fragment = n, rd.jsx = a, rd.jsxs = a, rd;
}
var pm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IR;
function Oye() {
  return IR || (IR = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var A = f && g[f] || g[v];
      return typeof A == "function" ? A : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), te = 1; te < A; te++)
          G[te - 1] = arguments[te];
        D("error", g, G);
      }
    }
    function D(g, A, G) {
      {
        var te = L.ReactDebugCurrentFrame, ae = te.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function N(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function R(g, A, G) {
      var te = g.displayName;
      if (te)
        return te;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var A = g;
            return V(A) + ".Consumer";
          case a:
            var G = g;
            return V(G._context) + ".Provider";
          case l:
            return R(g, g.render, "ForwardRef");
          case p:
            var te = g.displayName || null;
            return te !== null ? te : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, Z = 0, X, K, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function H() {
      {
        if (Z === 0) {
          X = console.log, K = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, g, {
              value: X
            }),
            info: W({}, g, {
              value: K
            }),
            warn: W({}, g, {
              value: Q
            }),
            error: W({}, g, {
              value: J
            }),
            group: W({}, g, {
              value: P
            }),
            groupCollapsed: W({}, g, {
              value: _
            }),
            groupEnd: W({}, g, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = L.ReactCurrentDispatcher, F;
    function T(g, A, G) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var te = ae.stack.trim().match(/\n( *(at )?)/);
            F = te && te[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, B;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Y();
    }
    function I(g, A) {
      if (!g || q)
        return "";
      {
        var G = B.get(g);
        if (G !== void 0)
          return G;
      }
      var te;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, H();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              te = je;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              te = je;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            te = je;
          }
          g();
        }
      } catch (je) {
        if (je && te && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = te.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var Ue = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", g.displayName)), typeof g == "function" && B.set(g, Ue), Ue;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Lt = g ? g.displayName || g.name : "", vt = Lt ? T(Lt) : "";
      return typeof g == "function" && B.set(g, vt), vt;
    }
    function le(g, A, G) {
      return I(g, !1);
    }
    function he(g) {
      var A = g.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(g, A, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return I(g, he(g));
      if (typeof g == "string")
        return T(g);
      switch (g) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return oe(g.type, A, G);
          case d: {
            var te = g, ae = te._payload, ue = te._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, We = {}, He = L.ReactDebugCurrentFrame;
    function Ie(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(g, A, G, te, ae) {
      {
        var ue = Function.call.bind(Be);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var Oe = Error((te || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = g[se](A, se, te, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Ie(ae), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ce(g) {
      return $e(g);
    }
    function Qe(g) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function lt(g) {
      try {
        return be(g), !1;
      } catch {
        return !0;
      }
    }
    function be(g) {
      return "" + g;
    }
    function Ee(g) {
      if (lt(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(g)), be(g);
    }
    var Ae = L.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, ot, ve;
    ve = {};
    function yt(g) {
      if (Be.call(g, "ref")) {
        var A = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function it(g) {
      if (Be.call(g, "key")) {
        var A = Object.getOwnPropertyDescriptor(g, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function st(g, A) {
      if (typeof g.ref == "string" && Ae.current && A && Ae.current.stateNode !== A) {
        var G = $(Ae.current.type);
        ve[G] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ae.current.type), g.ref), ve[G] = !0);
      }
    }
    function ut(g, A) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function bt(g, A) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var ct = function(g, A, G, te, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function wt(g, A, G, te, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (Ee(G), ie = "" + G), it(A) && (Ee(A.key), ie = "" + A.key), yt(A) && (Oe = A.ref, st(A, ae));
        for (ue in A)
          Be.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && ut(se, fe), Oe && bt(se, fe);
        }
        return ct(g, ie, Oe, ae, te, Ae.current, se);
      }
    }
    var tt = L.ReactCurrentOwner, gt = L.ReactDebugCurrentFrame;
    function rt(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        gt.setExtraStackFrame(G);
      } else
        gt.setExtraStackFrame(null);
    }
    var Ct;
    Ct = !1;
    function pt(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Et() {
      {
        if (tt.current) {
          var g = $(tt.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Ot(g) {
      return "";
    }
    var kt = {};
    function xt(g) {
      {
        var A = Et();
        if (!A) {
          var G = typeof g == "string" ? g : g.displayName || g.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function Pt(g, A) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var G = xt(A);
        if (kt[G])
          return;
        kt[G] = !0;
        var te = "";
        g && g._owner && g._owner !== tt.current && (te = " It was passed a child from " + $(g._owner.type) + "."), rt(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, te), rt(null);
      }
    }
    function Vt(g, A) {
      {
        if (typeof g != "object")
          return;
        if (Ce(g))
          for (var G = 0; G < g.length; G++) {
            var te = g[G];
            pt(te) && Pt(te, A);
          }
        else if (pt(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              pt(se.value) && Pt(se.value, A);
        }
      }
    }
    function mt(g) {
      {
        var A = g.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var te = $(A);
          nt(G, g.props, "prop", te, g);
        } else if (A.PropTypes !== void 0 && !Ct) {
          Ct = !0;
          var ae = $(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ne(g) {
      {
        for (var A = Object.keys(g.props), G = 0; G < A.length; G++) {
          var te = A[G];
          if (te !== "children" && te !== "key") {
            rt(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), rt(null);
            break;
          }
        }
        g.ref !== null && (rt(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var so = {};
    function ao(g, A, G, te, ae, ue) {
      {
        var se = N(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ot();
          Oe ? ie += Oe : ie += Et();
          var de;
          g === null ? de = "null" : Ce(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = wt(g, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Ue = A.children;
          if (Ue !== void 0)
            if (te)
              if (Ce(Ue)) {
                for (var Lt = 0; Lt < Ue.length; Lt++)
                  Vt(Ue[Lt], g);
                Object.freeze && Object.freeze(Ue);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vt(Ue, g);
        }
        if (Be.call(A, "key")) {
          var vt = $(g), je = Object.keys(A).filter(function(wi) {
            return wi !== "key";
          }), Wn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[vt + Wn]) {
            var bi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wn, vt, bi, vt), so[vt + Wn] = !0;
          }
        }
        return g === r ? ne(fe) : mt(fe), fe;
      }
    }
    function gi(g, A, G) {
      return ao(g, A, G, !0);
    }
    function mi(g, A, G) {
      return ao(g, A, G, !1);
    }
    var vi = mi, yi = gi;
    pm.Fragment = r, pm.jsx = vi, pm.jsxs = yi;
  }()), pm;
}
process.env.NODE_ENV === "production" ? Xk.exports = Cye() : Xk.exports = Oye();
var $i = Xk.exports;
Ve({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function RR(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ci(e) {
  var t, n;
  return RR(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(RR(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var pK = Symbol.for("immer-nothing"), NR = Symbol.for("immer-draftable"), Ds = Symbol.for("immer-state"), xye = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Fi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = xye[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var mp = Object.getPrototypeOf;
function Vc(e) {
  return !!e && !!e[Ds];
}
function $c(e) {
  var t;
  return e ? dK(e) || Array.isArray(e) || !!e[NR] || !!((t = e.constructor) != null && t[NR]) || u1(e) || c1(e) : !1;
}
var Lye = Object.prototype.constructor.toString();
function dK(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = mp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Lye;
}
function Ky(e, t) {
  l1(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function l1(e) {
  const t = e[Ds];
  return t ? t.type_ : Array.isArray(e) ? 1 : u1(e) ? 2 : c1(e) ? 3 : 0;
}
function Kk(e, t) {
  return l1(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function fK(e, t, n) {
  const r = l1(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Eye(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function u1(e) {
  return e instanceof Map;
}
function c1(e) {
  return e instanceof Set;
}
function nc(e) {
  return e.copy_ || e.base_;
}
function Jk(e, t) {
  if (u1(e))
    return new Map(e);
  if (c1(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = dK(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ds];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(mp(e), r);
  } else {
    const r = mp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function kD(e, t = !1) {
  return p1(e) || Vc(e) || !$c(e) || (l1(e) > 1 && (e.set = e.add = e.clear = e.delete = kye), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => kD(r, !0))), e;
}
function kye() {
  Fi(2);
}
function p1(e) {
  return Object.isFrozen(e);
}
var Pye = {};
function qc(e) {
  const t = Pye[e];
  return t || Fi(0, e), t;
}
var eh;
function hK() {
  return eh;
}
function Sye(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function FR(e, t) {
  t && (qc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Qk(e) {
  eP(e), e.drafts_.forEach(Mye), e.drafts_ = null;
}
function eP(e) {
  e === eh && (eh = e.parent_);
}
function zR(e) {
  return eh = Sye(eh, e);
}
function Mye(e) {
  const t = e[Ds];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function UR(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ds].modified_ && (Qk(t), Fi(4)), $c(e) && (e = Jy(t, e), t.parent_ || Qy(t, e)), t.patches_ && qc("Patches").generateReplacementPatches_(
    n[Ds].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Jy(t, n, []), Qk(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== pK ? e : void 0;
}
function Jy(e, t, n) {
  if (p1(t))
    return t;
  const r = t[Ds];
  if (!r)
    return Ky(
      t,
      (o, i) => WR(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Qy(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Ky(
      i,
      (s, l) => WR(e, r, o, s, l, n, a)
    ), Qy(e, o, !1), n && e.patches_ && qc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function WR(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Fi(5), Vc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Kk(t.assigned_, r) ? i.concat(r) : void 0, l = Jy(e, o, s);
    if (fK(n, r, l), Vc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if ($c(o) && !p1(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Jy(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Qy(e, o);
  }
}
function Qy(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && kD(t, n);
}
function Dye(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : hK(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = PD;
  n && (o = [r], i = th);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var PD = {
  get(e, t) {
    if (t === Ds)
      return e;
    const n = nc(e);
    if (!Kk(n, t))
      return _ye(e, n, t);
    const r = n[t];
    return e.finalized_ || !$c(r) ? r : r === xO(e.base_, t) ? (LO(e), e.copy_[t] = nP(r, e)) : r;
  },
  has(e, t) {
    return t in nc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(nc(e));
  },
  set(e, t, n) {
    const r = gK(nc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = xO(nc(e), t), i = o == null ? void 0 : o[Ds];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Eye(n, o) && (n !== void 0 || Kk(e.base_, t)))
        return !0;
      LO(e), tP(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return xO(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, LO(e), tP(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = nc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Fi(11);
  },
  getPrototypeOf(e) {
    return mp(e.base_);
  },
  setPrototypeOf() {
    Fi(12);
  }
}, th = {};
Ky(PD, (e, t) => {
  th[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
th.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Fi(13), th.set.call(this, e, t, void 0);
};
th.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Fi(14), PD.set.call(this, e[0], t, n, e[0]);
};
function xO(e, t) {
  const n = e[Ds];
  return (n ? nc(n) : e)[t];
}
function _ye(e, t, n) {
  var r;
  const o = gK(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function gK(e, t) {
  if (!(t in e))
    return;
  let n = mp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = mp(n);
  }
}
function tP(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && tP(e.parent_));
}
function LO(e) {
  e.copy_ || (e.copy_ = Jk(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Tye = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Fi(6), r !== void 0 && typeof r != "function" && Fi(7);
      let o;
      if ($c(t)) {
        const i = zR(this), a = nP(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? Qk(i) : eP(i);
        }
        return FR(i, r), UR(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === pK && (o = void 0), this.autoFreeze_ && kD(o, !0), r) {
          const i = [], a = [];
          qc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Fi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    $c(e) || Fi(8), Vc(e) && (e = jye(e));
    const t = zR(this), n = nP(e, void 0);
    return n[Ds].isManual_ = !0, eP(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ds];
    (!n || !n.isManual_) && Fi(9);
    const { scope_: r } = n;
    return FR(r, t), UR(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = qc("Patches").applyPatches_;
    return Vc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function nP(e, t) {
  const n = u1(e) ? qc("MapSet").proxyMap_(e, t) : c1(e) ? qc("MapSet").proxySet_(e, t) : Dye(e, t);
  return (t ? t.scope_ : hK()).drafts_.push(n), n;
}
function jye(e) {
  return Vc(e) || Fi(10, e), mK(e);
}
function mK(e) {
  if (!$c(e) || p1(e))
    return e;
  const t = e[Ds];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Jk(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Jk(e, !0);
  return Ky(n, (r, o) => {
    fK(n, r, mK(o));
  }), t && (t.finalized_ = !1), n;
}
var _s = new Tye(), SD = _s.produce;
_s.produceWithPatches.bind(
  _s
);
_s.setAutoFreeze.bind(_s);
_s.setUseStrictShallowCopy.bind(_s);
_s.applyPatches.bind(_s);
var HR = _s.createDraft.bind(_s), VR = _s.finishDraft.bind(_s), Ke = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ke.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ke.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ke.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ke.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ke.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ke.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ke.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ke.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ke.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ke.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ke.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ke.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ke.isAncestor(t, e) && !Ke.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ke.equals(i, r) || Ke.endsBefore(i, r) || Ke.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ke.equals(a, r) || Ke.isAncestor(a, r))
          return null;
        Ke.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ke.equals(s, r) || Ke.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ke.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ke.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ke.endsBefore(u, r) ? r[u.length - 1] += 1 : Ke.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ke.equals(p, d))
          return r;
        if (Ke.isAncestor(p, r) || Ke.equals(p, r)) {
          var y = d.slice();
          return Ke.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Ke.isSibling(p, d) && (Ke.isAncestor(d, r) || Ke.equals(d, r)) ? Ke.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ke.endsBefore(d, r) || Ke.equals(d, r) || Ke.isAncestor(d, r) ? (Ke.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ke.endsBefore(p, r) && (Ke.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function nh(e) {
  "@babel/helpers - typeof";
  return nh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nh(e);
}
function Aye(e, t) {
  if (nh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (nh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Bye(e) {
  var t = Aye(e, "string");
  return nh(t) === "symbol" ? t : String(t);
}
function kp(e, t, n) {
  return t = Bye(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function $R(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function od(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $R(Object(n), !0).forEach(function(r) {
      kp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $R(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Iye = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = At.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Kt.points(t))
          t[l] = Ar.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = At.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Kt.points(t))
          t[b] = Ar.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = At.get(e, L), D = Ke.previous(L), x = At.get(e, D), m = At.parent(e, L), C = L[L.length - 1];
      if (_o.isText(w) && _o.isText(x))
        x.text += w.text;
      else if (!_o.isText(w) && !_o.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(as.stringify(w), " ").concat(as.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Kt.points(t))
          t[U] = Ar.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: N
      } = n;
      if (Ke.isAncestor(k, N))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = At.get(e, k), V = At.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var W = Ke.transform(k, n), Z = At.get(e, Ke.parent(W)), X = W[W.length - 1];
      if (Z.children.splice(X, 0, R), t)
        for (var [K, Q] of Kt.points(t))
          t[Q] = Ar.transform(K, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = At.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Kt.points(t)) {
          var H = Ar.transform(z, n);
          if (t != null && H != null)
            t[M] = H;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of At.texts(e))
              if (Ke.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var q = !1;
            O && j && (Ke.equals(j[1], J) ? q = !Ke.hasPrevious(j[1]) : q = Ke.common(O[1], J).length < Ke.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Y,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = At.leaf(e, B), he = le.text.slice(0, Y), oe = le.text.slice(Y + I.length);
      if (le.text = he + oe, t)
        for (var [Be, We] of Kt.points(t))
          t[We] = Ar.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Ie,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var $e = At.get(e, He);
      for (var Ce in nt) {
        if (Ce === "children" || Ce === "text")
          throw new Error('Cannot set the "'.concat(Ce, '" property of nodes!'));
        var Qe = nt[Ce];
        Qe == null ? delete $e[Ce] : $e[Ce] = Qe;
      }
      for (var lt in Ie)
        nt.hasOwnProperty(lt) || delete $e[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: be
      } = n;
      if (be == null)
        t = be;
      else {
        if (t == null) {
          if (!Kt.isRange(be))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(as.stringify(be), " when there is no current selection."));
          t = od({}, be);
        }
        for (var Ee in be) {
          var Ae = be[Ee];
          if (Ae == null) {
            if (Ee === "anchor" || Ee === "focus")
              throw new Error('Cannot remove the "'.concat(Ee, '" selection property'));
            delete t[Ee];
          } else
            t[Ee] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Re,
        properties: ot
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var ve = At.get(e, ze), yt = At.parent(e, ze), it = ze[ze.length - 1], st;
      if (_o.isText(ve)) {
        var ut = ve.text.slice(0, Re), bt = ve.text.slice(Re);
        ve.text = ut, st = od(od({}, ot), {}, {
          text: bt
        });
      } else {
        var ct = ve.children.slice(0, Re), wt = ve.children.slice(Re);
        ve.children = ct, st = od(od({}, ot), {}, {
          children: wt
        });
      }
      if (yt.children.splice(it + 1, 0, st), t)
        for (var [tt, gt] of Kt.points(t))
          t[gt] = Ar.transform(tt, n);
      break;
    }
  }
  return t;
}, Rye = {
  transform(e, t) {
    e.children = HR(e.children);
    var n = e.selection && HR(e.selection);
    try {
      n = Iye(e, n, t);
    } finally {
      e.children = VR(e.children), n ? e.selection = Vc(n) ? VR(n) : n : e.selection = null;
    }
  }
}, Nye = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Fye = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, vK = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (ci(r) && ci(o)) {
      if (!vK(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function zye(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function rh(e, t) {
  if (e == null) return {};
  var n = zye(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Uye = ["anchor", "focus"];
function qR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wye(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qR(Object(n), !0).forEach(function(r) {
      kp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Kt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Kt.edges(e);
    return t;
  },
  equals(e, t) {
    return Ar.equals(e.anchor, t.anchor) && Ar.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Kt.isRange(t)) {
      if (Kt.includes(e, t.anchor) || Kt.includes(e, t.focus))
        return !0;
      var [n, r] = Kt.edges(e), [o, i] = Kt.edges(t);
      return Ar.isBefore(n, o) && Ar.isAfter(r, i);
    }
    var [a, s] = Kt.edges(e), l = !1, u = !1;
    return Ar.isPoint(t) ? (l = Ar.compare(t, a) >= 0, u = Ar.compare(t, s) <= 0) : (l = Ke.compare(t, a.path) >= 0, u = Ke.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = rh(e, Uye), [r, o] = Kt.edges(e), [i, a] = Kt.edges(t), s = Ar.isBefore(r, i) ? i : r, l = Ar.isBefore(o, a) ? o : a;
    return Ar.isBefore(l, s) ? null : Wye({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Ar.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Ar.equals(t, n);
  },
  isExpanded(e) {
    return !Kt.isCollapsed(e);
  },
  isForward(e) {
    return !Kt.isBackward(e);
  },
  isRange(e) {
    return ci(e) && Ar.isPoint(e.anchor) && Ar.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Kt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return SD(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Kt.isCollapsed(r);
        Kt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Kt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Ar.transform(r.anchor, t, {
        affinity: i
      }), u = Ar.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, ZR = (e) => ci(e) && At.isNodeList(e.children) && !dr.isEditor(e), Za = {
  isAncestor(e) {
    return ci(e) && At.isNodeList(e.children);
  },
  isElement: ZR,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Za.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return ZR(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Hye = ["children"], Vye = ["text"], GR = /* @__PURE__ */ new WeakMap(), At = {
  ancestor(e, t) {
    var n = At.get(e, t);
    if (_o.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(as.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ke.ancestors(t, n)) {
        var o = At.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (_o.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(as.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(as.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = At.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = At.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ke.common(t, n), o = At.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = At.get(e, t);
    if (dr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(as.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        Za.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Za.isAncestor(e)) {
      var t = rh(e, Hye);
      return t;
    } else {
      var t = rh(e, Vye);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = At.get(e, n); r && !(_o.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (_o.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(as.stringify(e)));
    var n = SD({
      children: e.children
    }, (r) => {
      var [o, i] = Kt.edges(t), a = At.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Kt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Kt.includes(t, s)) {
          var l = At.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ke.equals(s, i.path)) {
          var c = At.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ke.equals(s, o.path)) {
          var p = At.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      dr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (_o.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(as.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (_o.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return _o.isText(e) || Za.isElement(e) || dr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = GR.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => At.isNode(r));
    return GR.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = At.get(e, n); r && !(_o.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = At.get(e, t);
    if (!_o.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(as.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ke.levels(t, n)) {
        var o = At.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Za.isElement(e) && Za.isElementProps(t) && Za.matches(e, t) || _o.isText(e) && _o.isTextProps(t) && _o.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ke.isBefore(s, i) : Ke.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !_o.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ke.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = At.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ke.next(s);
          if (At.has(e, c)) {
            s = c, l = At.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ke.previous(s);
          s = p, l = At.get(e, s);
          continue;
        }
        s = Ke.parent(s), l = At.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ke.parent(t), r = At.get(e, n);
    if (_o.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return _o.isText(e) ? e.text : e.children.map(At.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of At.nodes(e, t))
        _o.isText(n) && (yield [n, r]);
    }();
  }
};
function YR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YR(Object(n), !0).forEach(function(r) {
      kp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vd = {
  isNodeOperation(e) {
    return Vd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!ci(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ke.isPath(e.path) && At.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ke.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ke.isPath(e.path) && ci(e.properties);
      case "move_node":
        return Ke.isPath(e.path) && Ke.isPath(e.newPath);
      case "remove_node":
        return Ke.isPath(e.path) && At.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ke.isPath(e.path);
      case "set_node":
        return Ke.isPath(e.path) && ci(e.properties) && ci(e.newProperties);
      case "set_selection":
        return e.properties === null && Kt.isRange(e.newProperties) || e.newProperties === null && Kt.isRange(e.properties) || ci(e.properties) && ci(e.newProperties);
      case "split_node":
        return Ke.isPath(e.path) && typeof e.position == "number" && ci(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Vd.isOperation(t));
  },
  isSelectionOperation(e) {
    return Vd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Vd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Wr(Wr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Wr(Wr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Wr(Wr({}, e), {}, {
          type: "split_node",
          path: Ke.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ke.equals(t, n))
          return e;
        if (Ke.isSibling(n, t))
          return Wr(Wr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ke.transform(n, e), o = Ke.transform(Ke.next(n), e);
        return Wr(Wr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Wr(Wr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Wr(Wr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Wr(Wr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Wr(Wr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Wr(Wr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Wr(Wr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Wr(Wr({}, e), {}, {
          type: "merge_node",
          path: Ke.next(e.path)
        });
    }
  }
}, XR = /* @__PURE__ */ new WeakMap(), $ye = (e) => {
  var t = XR.get(e);
  if (t !== void 0)
    return t;
  if (!ci(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || ci(e.marks)) && (e.selection === null || Kt.isRange(e.selection)) && At.isNodeList(e.children) && Vd.isOperationList(e.operations);
  return XR.set(e, n), n;
}, dr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return $ye(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function KR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KR(Object(n), !0).forEach(function(r) {
      kp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ar = {
  compare(e, t) {
    var n = Ke.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Ar.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Ar.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ke.equals(e.path, t.path);
  },
  isPoint(e) {
    return ci(e) && typeof e.offset == "number" && Ke.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return SD(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ke.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ke.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ke.equals(t.path, i) && (r.offset += t.position), r.path = Ke.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ke.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ke.equals(t.path, i) || Ke.isAncestor(t.path, i))
            return null;
          r.path = Ke.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ke.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ke.transform(i, t, JR(JR({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ke.transform(i, t, n);
          break;
        }
      }
    });
  }
}, QR = void 0, as = {
  setScrubber(e) {
    QR = e;
  },
  stringify(e) {
    return JSON.stringify(e, QR);
  }
}, qye = ["text"], Zye = ["anchor", "focus"];
function eN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ta(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eN(Object(n), !0).forEach(function(r) {
      kp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _o = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = rh(i, qye);
      return a;
    }
    return vK(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return ci(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => _o.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Ta({}, e)];
    for (var r of t) {
      var o = rh(r, Zye), [i, a] = Kt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = Ta(Ta({}, f), {}, {
            text: f.text.slice(L)
          }), f = Ta(Ta({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Ta(Ta({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Ta(Ta({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, Gye = (e) => e.selection ? e.selection : e.children.length > 0 ? dr.end(e, []) : [0], Pr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Pr || (Pr = {}));
Pr.L, Pr.L | Pr.V | Pr.LV | Pr.LVT, Pr.LV | Pr.V, Pr.V | Pr.T, Pr.LVT | Pr.T, Pr.T, Pr.Any, Pr.Extend | Pr.ZWJ, Pr.Any, Pr.SpacingMark, Pr.Prepend, Pr.Any, Pr.ZWJ, Pr.ExtPict, Pr.RI, Pr.RI;
var Yye = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    dr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Gye(e)
      } = n;
      if (Ke.isPath(o) && (o = dr.range(e, o)), Kt.isRange(o))
        if (Kt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Kt.end(o);
          if (!r && dr.void(e, {
            at: i
          }))
            return;
          var a = Kt.start(o), s = dr.pointRef(e, a), l = dr.pointRef(e, i);
          eb.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, eb.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && dr.void(e, {
        at: o
      }) || dr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function tN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tN(Object(n), !0).forEach(function(r) {
      kp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eb = dm(dm(dm(dm({}, Rye), Nye), Fye), Yye), yK = {}, MD = {}, DD = {};
Object.defineProperty(DD, "__esModule", { value: !0 });
DD.default = Qye;
var nN = "html", rN = "head", fm = "body", Xye = /<([a-zA-Z]+[0-9]?)/, oN = /<head[^]*>/i, iN = /<body[^]*>/i, tb = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, rP = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, sN = typeof window == "object" && window.DOMParser;
if (typeof sN == "function") {
  var Kye = new sN(), Jye = "text/html";
  rP = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Kye.parseFromString(e, Jye);
  }, tb = rP;
}
if (typeof document == "object" && document.implementation) {
  var hm = document.implementation.createHTMLDocument();
  tb = function(e, t) {
    if (t) {
      var n = hm.documentElement.querySelector(t);
      return n && (n.innerHTML = e), hm;
    }
    return hm.documentElement.innerHTML = e, hm;
  };
}
var gm = typeof document == "object" && document.createElement("template"), oP;
gm && gm.content && (oP = function(e) {
  return gm.innerHTML = e, gm.content.childNodes;
});
function Qye(e) {
  var t, n, r = e.match(Xye), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case nN: {
      var i = rP(e);
      if (!oN.test(e)) {
        var a = i.querySelector(rN);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!iN.test(e)) {
        var a = i.querySelector(fm);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(nN);
    }
    case rN:
    case fm: {
      var s = tb(e).querySelectorAll(o);
      return iN.test(e) && oN.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (oP)
        return oP(e);
      var a = tb(e, fm).querySelector(fm);
      return a.childNodes;
    }
  }
}
var d1 = {}, _D = {}, TD = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(TD);
var an = {}, wu = wr && wr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), lf = wr && wr.__assign || function() {
  return lf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, lf.apply(this, arguments);
};
Object.defineProperty(an, "__esModule", { value: !0 });
an.cloneNode = an.hasChildren = an.isDocument = an.isDirective = an.isComment = an.isText = an.isCDATA = an.isTag = an.Element = an.Document = an.CDATA = an.NodeWithChildren = an.ProcessingInstruction = an.Comment = an.Text = an.DataNode = an.Node = void 0;
var Qi = TD, jD = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), AD(this, t);
    }, e;
  }()
);
an.Node = jD;
var f1 = (
  /** @class */
  function(e) {
    wu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jD)
);
an.DataNode = f1;
var bK = (
  /** @class */
  function(e) {
    wu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(f1)
);
an.Text = bK;
var wK = (
  /** @class */
  function(e) {
    wu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(f1)
);
an.Comment = wK;
var CK = (
  /** @class */
  function(e) {
    wu(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Qi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(f1)
);
an.ProcessingInstruction = CK;
var h1 = (
  /** @class */
  function(e) {
    wu(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(jD)
);
an.NodeWithChildren = h1;
var OK = (
  /** @class */
  function(e) {
    wu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(h1)
);
an.CDATA = OK;
var xK = (
  /** @class */
  function(e) {
    wu(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Qi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(h1)
);
an.Document = xK;
var LK = (
  /** @class */
  function(e) {
    wu(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Qi.ElementType.Script : n === "style" ? Qi.ElementType.Style : Qi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(h1)
);
an.Element = LK;
function EK(e) {
  return (0, Qi.isTag)(e);
}
an.isTag = EK;
function kK(e) {
  return e.type === Qi.ElementType.CDATA;
}
an.isCDATA = kK;
function PK(e) {
  return e.type === Qi.ElementType.Text;
}
an.isText = PK;
function SK(e) {
  return e.type === Qi.ElementType.Comment;
}
an.isComment = SK;
function MK(e) {
  return e.type === Qi.ElementType.Directive;
}
an.isDirective = MK;
function DK(e) {
  return e.type === Qi.ElementType.Root;
}
an.isDocument = DK;
function ebe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
an.hasChildren = ebe;
function AD(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (PK(e))
    n = new bK(e.data);
  else if (SK(e))
    n = new wK(e.data);
  else if (EK(e)) {
    var r = t ? EO(e.children) : [], o = new LK(e.name, lf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = lf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = lf({}, e["x-attribsPrefix"])), n = o;
  } else if (kK(e)) {
    var r = t ? EO(e.children) : [], i = new OK(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (DK(e)) {
    var r = t ? EO(e.children) : [], a = new xK(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (MK(e)) {
    var s = new CK(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
an.cloneNode = AD;
function EO(e) {
  for (var t = e.map(function(r) {
    return AD(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = wr && wr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = wr && wr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = TD, o = an;
  n(an, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(_D);
var _K = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(_K);
Object.defineProperty(d1, "__esModule", { value: !0 });
d1.formatAttributes = TK;
d1.formatDOM = jK;
var mm = _D, tbe = _K;
function nbe(e) {
  return tbe.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function TK(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function rbe(e) {
  e = e.toLowerCase();
  var t = nbe(e);
  return t || e;
}
function jK(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = rbe(s.nodeName);
        o = new mm.Element(l, TK(s.attributes)), o.children = jK(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new mm.Text(s.nodeValue);
        break;
      case 8:
        o = new mm.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new mm.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var obe = wr && wr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(MD, "__esModule", { value: !0 });
MD.default = lbe;
var ibe = obe(DD), sbe = d1, abe = /<(![a-zA-Z\s]+)>/;
function lbe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(abe), n = t ? t[1] : void 0;
  return (0, sbe.formatDOM)((0, ibe.default)(e), null, n);
}
var g1 = {}, Ks = {}, m1 = {}, ube = 0;
m1.SAME = ube;
var cbe = 1;
m1.CAMELCASE = cbe;
m1.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const AK = 0, Cu = 1, v1 = 2, y1 = 3, BD = 4, BK = 5, IK = 6;
function pbe(e) {
  return ni.hasOwnProperty(e) ? ni[e] : null;
}
function Di(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === v1 || t === y1 || t === BD, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ni = {}, dbe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
dbe.forEach((e) => {
  ni[e] = new Di(
    e,
    AK,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ni[e] = new Di(
    e,
    Cu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ni[e] = new Di(
    e,
    v1,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ni[e] = new Di(
    e,
    v1,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ni[e] = new Di(
    e,
    y1,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ni[e] = new Di(
    e,
    y1,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ni[e] = new Di(
    e,
    BD,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ni[e] = new Di(
    e,
    IK,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ni[e] = new Di(
    e,
    BK,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const ID = /[\-\:]([a-z])/g, RD = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ID, RD);
  ni[t] = new Di(
    t,
    Cu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ID, RD);
  ni[t] = new Di(
    t,
    Cu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ID, RD);
  ni[t] = new Di(
    t,
    Cu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ni[e] = new Di(
    e,
    Cu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const fbe = "xlinkHref";
ni[fbe] = new Di(
  "xlinkHref",
  Cu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ni[e] = new Di(
    e,
    Cu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: hbe,
  SAME: gbe,
  possibleStandardNames: aN
} = m1, mbe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", vbe = mbe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ybe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + vbe + "]*$")
), bbe = Object.keys(
  aN
).reduce((e, t) => {
  const n = aN[t];
  return n === gbe ? e[t] = t : n === hbe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Ks.BOOLEAN = y1;
Ks.BOOLEANISH_STRING = v1;
Ks.NUMERIC = BK;
Ks.OVERLOADED_BOOLEAN = BD;
Ks.POSITIVE_NUMERIC = IK;
Ks.RESERVED = AK;
Ks.STRING = Cu;
Ks.getPropertyInfo = pbe;
Ks.isCustomAttribute = ybe;
Ks.possibleStandardNames = bbe;
var ND = {}, FD = {}, lN = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, wbe = /\n/g, Cbe = /^\s*/, Obe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, xbe = /^:\s*/, Lbe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Ebe = /^[;\s]*/, kbe = /^\s+|\s+$/g, Pbe = `
`, uN = "/", cN = "*", pc = "", Sbe = "comment", Mbe = "declaration", Dbe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(wbe);
    v && (n += v.length);
    var b = f.lastIndexOf(Pbe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(Cbe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(uN != e.charAt(0) || cN != e.charAt(1))) {
      for (var v = 2; pc != e.charAt(v) && (cN != e.charAt(v) || uN != e.charAt(v + 1)); )
        ++v;
      if (v += 2, pc === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: Sbe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(Obe);
    if (v) {
      if (p(), !l(xbe)) return s("property missing ':'");
      var b = l(Lbe), L = f({
        type: Mbe,
        property: pN(v[0].replace(lN, pc)),
        value: b ? pN(b[0].replace(lN, pc)) : pc
      });
      return l(Ebe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function pN(e) {
  return e ? e.replace(kbe, pc) : pc;
}
var _be = wr && wr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(FD, "__esModule", { value: !0 });
FD.default = jbe;
var Tbe = _be(Dbe);
function jbe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Tbe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var b1 = {};
Object.defineProperty(b1, "__esModule", { value: !0 });
b1.camelCase = void 0;
var Abe = /^--[a-zA-Z0-9_-]+$/, Bbe = /-([a-z])/g, Ibe = /^[^-]+$/, Rbe = /^-(webkit|moz|ms|o|khtml)-/, Nbe = /^-(ms)-/, Fbe = function(e) {
  return !e || Ibe.test(e) || Abe.test(e);
}, zbe = function(e, t) {
  return t.toUpperCase();
}, dN = function(e, t) {
  return "".concat(t, "-");
}, Ube = function(e, t) {
  return t === void 0 && (t = {}), Fbe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Nbe, dN) : e = e.replace(Rbe, dN), e.replace(Bbe, zbe));
};
b1.camelCase = Ube;
var Wbe = wr && wr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Hbe = Wbe(FD), Vbe = b1;
function iP(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Hbe.default)(e, function(r, o) {
    r && o && (n[(0, Vbe.camelCase)(r, t)] = o);
  }), n;
}
iP.default = iP;
var $be = iP;
(function(e) {
  var t = wr && wr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t($be), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(ND);
Object.defineProperty(g1, "__esModule", { value: !0 });
g1.default = Ybe;
var $d = Ks, fN = ND, qbe = ["checked", "value"], Zbe = ["input", "select", "textarea"], Gbe = {
  reset: !0,
  submit: !0
};
function Ybe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Gbe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, $d.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = hN(a);
    if (s) {
      var l = (0, $d.getPropertyInfo)(s);
      switch (qbe.includes(s) && Zbe.includes(t) && !r && (s = hN("default" + a)), n[s] = i, l && l.type) {
        case $d.BOOLEAN:
          n[s] = !0;
          break;
        case $d.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    fN.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, fN.setStyleProp)(e.style, n), n;
}
function hN(e) {
  return $d.possibleStandardNames[e];
}
var zD = {}, Xbe = wr && wr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zD, "__esModule", { value: !0 });
zD.default = RK;
var kO = we, Kbe = Xbe(g1), uf = ND, Jbe = {
  cloneElement: kO.cloneElement,
  createElement: kO.createElement,
  isValidElement: kO.isValidElement
};
function RK(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || uf.returnFirstArg, i = t.library || Jbe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, uf.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Qbe(f) ? ((0, uf.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Kbe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = RK(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Qbe(e) {
  return uf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, uf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = wr && wr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(MD);
  e.htmlToDOM = n.default;
  var r = t(g1);
  e.attributesToProps = r.default;
  var o = t(zD);
  e.domToReact = o.default;
  var i = _D;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(yK);
const e0e = /* @__PURE__ */ wye(yK);
e0e.default;
var Cr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function t0e(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var sP = { exports: {} }, id = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gN;
function n0e() {
  if (gN) return id;
  gN = 1;
  var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return id.Fragment = n, id.jsx = a, id.jsxs = a, id;
}
var vm = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mN;
function r0e() {
  return mN || (mN = 1, process.env.NODE_ENV !== "production" && function() {
    var e = we, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function b(g) {
      if (g === null || typeof g != "object")
        return null;
      var A = f && g[f] || g[v];
      return typeof A == "function" ? A : null;
    }
    var L = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(g) {
      {
        for (var A = arguments.length, G = new Array(A > 1 ? A - 1 : 0), te = 1; te < A; te++)
          G[te - 1] = arguments[te];
        D("error", g, G);
      }
    }
    function D(g, A, G) {
      {
        var te = L.ReactDebugCurrentFrame, ae = te.getStackAddendum();
        ae !== "" && (A += "%s", G = G.concat([ae]));
        var ue = G.map(function(se) {
          return String(se);
        });
        ue.unshift("Warning: " + A), Function.prototype.apply.call(console[g], console, ue);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, U = !1, k;
    k = Symbol.for("react.module.reference");
    function N(g) {
      return !!(typeof g == "string" || typeof g == "function" || g === r || g === i || U || g === o || g === u || g === c || S || g === y || x || m || C || typeof g == "object" && g !== null && (g.$$typeof === d || g.$$typeof === p || g.$$typeof === a || g.$$typeof === s || g.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      g.$$typeof === k || g.getModuleId !== void 0));
    }
    function R(g, A, G) {
      var te = g.displayName;
      if (te)
        return te;
      var ae = A.displayName || A.name || "";
      return ae !== "" ? G + "(" + ae + ")" : G;
    }
    function V(g) {
      return g.displayName || "Context";
    }
    function $(g) {
      if (g == null)
        return null;
      if (typeof g.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof g == "function")
        return g.displayName || g.name || null;
      if (typeof g == "string")
        return g;
      switch (g) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case s:
            var A = g;
            return V(A) + ".Consumer";
          case a:
            var G = g;
            return V(G._context) + ".Provider";
          case l:
            return R(g, g.render, "ForwardRef");
          case p:
            var te = g.displayName || null;
            return te !== null ? te : $(g.type) || "Memo";
          case d: {
            var ae = g, ue = ae._payload, se = ae._init;
            try {
              return $(se(ue));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, Z = 0, X, K, Q, J, P, _, z;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function H() {
      {
        if (Z === 0) {
          X = console.log, K = console.info, Q = console.warn, J = console.error, P = console.group, _ = console.groupCollapsed, z = console.groupEnd;
          var g = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: g,
            log: g,
            warn: g,
            error: g,
            group: g,
            groupCollapsed: g,
            groupEnd: g
          });
        }
        Z++;
      }
    }
    function O() {
      {
        if (Z--, Z === 0) {
          var g = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, g, {
              value: X
            }),
            info: W({}, g, {
              value: K
            }),
            warn: W({}, g, {
              value: Q
            }),
            error: W({}, g, {
              value: J
            }),
            group: W({}, g, {
              value: P
            }),
            groupCollapsed: W({}, g, {
              value: _
            }),
            groupEnd: W({}, g, {
              value: z
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = L.ReactCurrentDispatcher, F;
    function T(g, A, G) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var te = ae.stack.trim().match(/\n( *(at )?)/);
            F = te && te[1] || "";
          }
        return `
` + F + g;
      }
    }
    var q = !1, B;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Y();
    }
    function I(g, A) {
      if (!g || q)
        return "";
      {
        var G = B.get(g);
        if (G !== void 0)
          return G;
      }
      var te;
      q = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ue;
      ue = j.current, j.current = null, H();
      try {
        if (A) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (je) {
              te = je;
            }
            Reflect.construct(g, [], se);
          } else {
            try {
              se.call();
            } catch (je) {
              te = je;
            }
            g.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            te = je;
          }
          g();
        }
      } catch (je) {
        if (je && te && typeof je.stack == "string") {
          for (var ie = je.stack.split(`
`), Oe = te.stack.split(`
`), de = ie.length - 1, fe = Oe.length - 1; de >= 1 && fe >= 0 && ie[de] !== Oe[fe]; )
            fe--;
          for (; de >= 1 && fe >= 0; de--, fe--)
            if (ie[de] !== Oe[fe]) {
              if (de !== 1 || fe !== 1)
                do
                  if (de--, fe--, fe < 0 || ie[de] !== Oe[fe]) {
                    var Ue = `
` + ie[de].replace(" at new ", " at ");
                    return g.displayName && Ue.includes("<anonymous>") && (Ue = Ue.replace("<anonymous>", g.displayName)), typeof g == "function" && B.set(g, Ue), Ue;
                  }
                while (de >= 1 && fe >= 0);
              break;
            }
        }
      } finally {
        q = !1, j.current = ue, O(), Error.prepareStackTrace = ae;
      }
      var Lt = g ? g.displayName || g.name : "", vt = Lt ? T(Lt) : "";
      return typeof g == "function" && B.set(g, vt), vt;
    }
    function le(g, A, G) {
      return I(g, !1);
    }
    function he(g) {
      var A = g.prototype;
      return !!(A && A.isReactComponent);
    }
    function oe(g, A, G) {
      if (g == null)
        return "";
      if (typeof g == "function")
        return I(g, he(g));
      if (typeof g == "string")
        return T(g);
      switch (g) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof g == "object")
        switch (g.$$typeof) {
          case l:
            return le(g.render);
          case p:
            return oe(g.type, A, G);
          case d: {
            var te = g, ae = te._payload, ue = te._init;
            try {
              return oe(ue(ae), A, G);
            } catch {
            }
          }
        }
      return "";
    }
    var Be = Object.prototype.hasOwnProperty, We = {}, He = L.ReactDebugCurrentFrame;
    function Ie(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        He.setExtraStackFrame(G);
      } else
        He.setExtraStackFrame(null);
    }
    function nt(g, A, G, te, ae) {
      {
        var ue = Function.call.bind(Be);
        for (var se in g)
          if (ue(g, se)) {
            var ie = void 0;
            try {
              if (typeof g[se] != "function") {
                var Oe = Error((te || "React class") + ": " + G + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof g[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Oe.name = "Invariant Violation", Oe;
              }
              ie = g[se](A, se, te, G, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Ie(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", te || "React class", G, se, typeof ie), Ie(null)), ie instanceof Error && !(ie.message in We) && (We[ie.message] = !0, Ie(ae), w("Failed %s type: %s", G, ie.message), Ie(null));
          }
      }
    }
    var $e = Array.isArray;
    function Ce(g) {
      return $e(g);
    }
    function Qe(g) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, G = A && g[Symbol.toStringTag] || g.constructor.name || "Object";
        return G;
      }
    }
    function lt(g) {
      try {
        return be(g), !1;
      } catch {
        return !0;
      }
    }
    function be(g) {
      return "" + g;
    }
    function Ee(g) {
      if (lt(g))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Qe(g)), be(g);
    }
    var Ae = L.ReactCurrentOwner, ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Re, ot, ve;
    ve = {};
    function yt(g) {
      if (Be.call(g, "ref")) {
        var A = Object.getOwnPropertyDescriptor(g, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.ref !== void 0;
    }
    function it(g) {
      if (Be.call(g, "key")) {
        var A = Object.getOwnPropertyDescriptor(g, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return g.key !== void 0;
    }
    function st(g, A) {
      if (typeof g.ref == "string" && Ae.current && A && Ae.current.stateNode !== A) {
        var G = $(Ae.current.type);
        ve[G] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ae.current.type), g.ref), ve[G] = !0);
      }
    }
    function ut(g, A) {
      {
        var G = function() {
          Re || (Re = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "key", {
          get: G,
          configurable: !0
        });
      }
    }
    function bt(g, A) {
      {
        var G = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        G.isReactWarning = !0, Object.defineProperty(g, "ref", {
          get: G,
          configurable: !0
        });
      }
    }
    var ct = function(g, A, G, te, ae, ue, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: g,
        key: A,
        ref: G,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ue
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: te
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function wt(g, A, G, te, ae) {
      {
        var ue, se = {}, ie = null, Oe = null;
        G !== void 0 && (Ee(G), ie = "" + G), it(A) && (Ee(A.key), ie = "" + A.key), yt(A) && (Oe = A.ref, st(A, ae));
        for (ue in A)
          Be.call(A, ue) && !ze.hasOwnProperty(ue) && (se[ue] = A[ue]);
        if (g && g.defaultProps) {
          var de = g.defaultProps;
          for (ue in de)
            se[ue] === void 0 && (se[ue] = de[ue]);
        }
        if (ie || Oe) {
          var fe = typeof g == "function" ? g.displayName || g.name || "Unknown" : g;
          ie && ut(se, fe), Oe && bt(se, fe);
        }
        return ct(g, ie, Oe, ae, te, Ae.current, se);
      }
    }
    var tt = L.ReactCurrentOwner, gt = L.ReactDebugCurrentFrame;
    function rt(g) {
      if (g) {
        var A = g._owner, G = oe(g.type, g._source, A ? A.type : null);
        gt.setExtraStackFrame(G);
      } else
        gt.setExtraStackFrame(null);
    }
    var Ct;
    Ct = !1;
    function pt(g) {
      return typeof g == "object" && g !== null && g.$$typeof === t;
    }
    function Et() {
      {
        if (tt.current) {
          var g = $(tt.current.type);
          if (g)
            return `

Check the render method of \`` + g + "`.";
        }
        return "";
      }
    }
    function Ot(g) {
      return "";
    }
    var kt = {};
    function xt(g) {
      {
        var A = Et();
        if (!A) {
          var G = typeof g == "string" ? g : g.displayName || g.name;
          G && (A = `

Check the top-level render call using <` + G + ">.");
        }
        return A;
      }
    }
    function Pt(g, A) {
      {
        if (!g._store || g._store.validated || g.key != null)
          return;
        g._store.validated = !0;
        var G = xt(A);
        if (kt[G])
          return;
        kt[G] = !0;
        var te = "";
        g && g._owner && g._owner !== tt.current && (te = " It was passed a child from " + $(g._owner.type) + "."), rt(g), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', G, te), rt(null);
      }
    }
    function Vt(g, A) {
      {
        if (typeof g != "object")
          return;
        if (Ce(g))
          for (var G = 0; G < g.length; G++) {
            var te = g[G];
            pt(te) && Pt(te, A);
          }
        else if (pt(g))
          g._store && (g._store.validated = !0);
        else if (g) {
          var ae = b(g);
          if (typeof ae == "function" && ae !== g.entries)
            for (var ue = ae.call(g), se; !(se = ue.next()).done; )
              pt(se.value) && Pt(se.value, A);
        }
      }
    }
    function mt(g) {
      {
        var A = g.type;
        if (A == null || typeof A == "string")
          return;
        var G;
        if (typeof A == "function")
          G = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === p))
          G = A.propTypes;
        else
          return;
        if (G) {
          var te = $(A);
          nt(G, g.props, "prop", te, g);
        } else if (A.PropTypes !== void 0 && !Ct) {
          Ct = !0;
          var ae = $(A);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ne(g) {
      {
        for (var A = Object.keys(g.props), G = 0; G < A.length; G++) {
          var te = A[G];
          if (te !== "children" && te !== "key") {
            rt(g), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", te), rt(null);
            break;
          }
        }
        g.ref !== null && (rt(g), w("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var so = {};
    function ao(g, A, G, te, ae, ue) {
      {
        var se = N(g);
        if (!se) {
          var ie = "";
          (g === void 0 || typeof g == "object" && g !== null && Object.keys(g).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Oe = Ot();
          Oe ? ie += Oe : ie += Et();
          var de;
          g === null ? de = "null" : Ce(g) ? de = "array" : g !== void 0 && g.$$typeof === t ? (de = "<" + ($(g.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof g, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var fe = wt(g, A, G, ae, ue);
        if (fe == null)
          return fe;
        if (se) {
          var Ue = A.children;
          if (Ue !== void 0)
            if (te)
              if (Ce(Ue)) {
                for (var Lt = 0; Lt < Ue.length; Lt++)
                  Vt(Ue[Lt], g);
                Object.freeze && Object.freeze(Ue);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vt(Ue, g);
        }
        if (Be.call(A, "key")) {
          var vt = $(g), je = Object.keys(A).filter(function(wi) {
            return wi !== "key";
          }), Wn = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[vt + Wn]) {
            var bi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Wn, vt, bi, vt), so[vt + Wn] = !0;
          }
        }
        return g === r ? ne(fe) : mt(fe), fe;
      }
    }
    function gi(g, A, G) {
      return ao(g, A, G, !0);
    }
    function mi(g, A, G) {
      return ao(g, A, G, !1);
    }
    var vi = mi, yi = gi;
    vm.Fragment = r, vm.jsx = vi, vm.jsxs = yi;
  }()), vm;
}
process.env.NODE_ENV === "production" ? sP.exports = n0e() : sP.exports = r0e();
var qi = sP.exports;
Ve({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function vN(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function pi(e) {
  var t, n;
  return vN(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(vN(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var NK = Symbol.for("immer-nothing"), yN = Symbol.for("immer-draftable"), Ts = Symbol.for("immer-state"), o0e = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function zi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = o0e[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var vp = Object.getPrototypeOf;
function Zc(e) {
  return !!e && !!e[Ts];
}
function Gc(e) {
  var t;
  return e ? FK(e) || Array.isArray(e) || !!e[yN] || !!((t = e.constructor) != null && t[yN]) || C1(e) || O1(e) : !1;
}
var i0e = Object.prototype.constructor.toString();
function FK(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = vp(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === i0e;
}
function nb(e, t) {
  w1(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function w1(e) {
  const t = e[Ts];
  return t ? t.type_ : Array.isArray(e) ? 1 : C1(e) ? 2 : O1(e) ? 3 : 0;
}
function aP(e, t) {
  return w1(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function zK(e, t, n) {
  const r = w1(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function s0e(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function C1(e) {
  return e instanceof Map;
}
function O1(e) {
  return e instanceof Set;
}
function rc(e) {
  return e.copy_ || e.base_;
}
function lP(e, t) {
  if (C1(e))
    return new Map(e);
  if (O1(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = FK(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ts];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(vp(e), r);
  } else {
    const r = vp(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function UD(e, t = !1) {
  return x1(e) || Zc(e) || !Gc(e) || (w1(e) > 1 && (e.set = e.add = e.clear = e.delete = a0e), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => UD(r, !0))), e;
}
function a0e() {
  zi(2);
}
function x1(e) {
  return Object.isFrozen(e);
}
var l0e = {};
function Yc(e) {
  const t = l0e[e];
  return t || zi(0, e), t;
}
var oh;
function UK() {
  return oh;
}
function u0e(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function bN(e, t) {
  t && (Yc("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function uP(e) {
  cP(e), e.drafts_.forEach(c0e), e.drafts_ = null;
}
function cP(e) {
  e === oh && (oh = e.parent_);
}
function wN(e) {
  return oh = u0e(oh, e);
}
function c0e(e) {
  const t = e[Ts];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function CN(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ts].modified_ && (uP(t), zi(4)), Gc(e) && (e = rb(t, e), t.parent_ || ob(t, e)), t.patches_ && Yc("Patches").generateReplacementPatches_(
    n[Ts].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = rb(t, n, []), uP(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== NK ? e : void 0;
}
function rb(e, t, n) {
  if (x1(t))
    return t;
  const r = t[Ts];
  if (!r)
    return nb(
      t,
      (o, i) => ON(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return ob(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), nb(
      i,
      (s, l) => ON(e, r, o, s, l, n, a)
    ), ob(e, o, !1), n && e.patches_ && Yc("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function ON(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && zi(5), Zc(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !aP(t.assigned_, r) ? i.concat(r) : void 0, l = rb(e, o, s);
    if (zK(n, r, l), Zc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Gc(o) && !x1(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    rb(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && ob(e, o);
  }
}
function ob(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && UD(t, n);
}
function p0e(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : UK(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = WD;
  n && (o = [r], i = ih);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var WD = {
  get(e, t) {
    if (t === Ts)
      return e;
    const n = rc(e);
    if (!aP(n, t))
      return d0e(e, n, t);
    const r = n[t];
    return e.finalized_ || !Gc(r) ? r : r === PO(e.base_, t) ? (SO(e), e.copy_[t] = dP(r, e)) : r;
  },
  has(e, t) {
    return t in rc(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(rc(e));
  },
  set(e, t, n) {
    const r = WK(rc(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = PO(rc(e), t), i = o == null ? void 0 : o[Ts];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (s0e(n, o) && (n !== void 0 || aP(e.base_, t)))
        return !0;
      SO(e), pP(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return PO(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, SO(e), pP(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = rc(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    zi(11);
  },
  getPrototypeOf(e) {
    return vp(e.base_);
  },
  setPrototypeOf() {
    zi(12);
  }
}, ih = {};
nb(WD, (e, t) => {
  ih[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
ih.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && zi(13), ih.set.call(this, e, t, void 0);
};
ih.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && zi(14), WD.set.call(this, e[0], t, n, e[0]);
};
function PO(e, t) {
  const n = e[Ts];
  return (n ? rc(n) : e)[t];
}
function d0e(e, t, n) {
  var r;
  const o = WK(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function WK(e, t) {
  if (!(t in e))
    return;
  let n = vp(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = vp(n);
  }
}
function pP(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && pP(e.parent_));
}
function SO(e) {
  e.copy_ || (e.copy_ = lP(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var f0e = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && zi(6), r !== void 0 && typeof r != "function" && zi(7);
      let o;
      if (Gc(t)) {
        const i = wN(this), a = dP(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? uP(i) : cP(i);
        }
        return bN(i, r), CN(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === NK && (o = void 0), this.autoFreeze_ && UD(o, !0), r) {
          const i = [], a = [];
          Yc("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        zi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Gc(e) || zi(8), Zc(e) && (e = h0e(e));
    const t = wN(this), n = dP(e, void 0);
    return n[Ts].isManual_ = !0, cP(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ts];
    (!n || !n.isManual_) && zi(9);
    const { scope_: r } = n;
    return bN(r, t), CN(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Yc("Patches").applyPatches_;
    return Zc(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function dP(e, t) {
  const n = C1(e) ? Yc("MapSet").proxyMap_(e, t) : O1(e) ? Yc("MapSet").proxySet_(e, t) : p0e(e, t);
  return (t ? t.scope_ : UK()).drafts_.push(n), n;
}
function h0e(e) {
  return Zc(e) || zi(10, e), HK(e);
}
function HK(e) {
  if (!Gc(e) || x1(e))
    return e;
  const t = e[Ts];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = lP(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = lP(e, !0);
  return nb(n, (r, o) => {
    zK(n, r, HK(o));
  }), t && (t.finalized_ = !1), n;
}
var js = new f0e(), HD = js.produce;
js.produceWithPatches.bind(
  js
);
js.setAutoFreeze.bind(js);
js.setUseStrictShallowCopy.bind(js);
js.applyPatches.bind(js);
var xN = js.createDraft.bind(js), LN = js.finishDraft.bind(js), Je = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Je.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Je.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Je.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Je.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Je.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Je.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Je.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Je.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Je.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Je.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Je.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Je.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Je.isAncestor(t, e) && !Je.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Je.equals(i, r) || Je.endsBefore(i, r) || Je.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Je.equals(a, r) || Je.isAncestor(a, r))
          return null;
        Je.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Je.equals(s, r) || Je.endsBefore(s, r) ? r[s.length - 1] -= 1 : Je.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Je.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Je.endsBefore(u, r) ? r[u.length - 1] += 1 : Je.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Je.equals(p, d))
          return r;
        if (Je.isAncestor(p, r) || Je.equals(p, r)) {
          var y = d.slice();
          return Je.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Je.isSibling(p, d) && (Je.isAncestor(d, r) || Je.equals(d, r)) ? Je.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Je.endsBefore(d, r) || Je.equals(d, r) || Je.isAncestor(d, r) ? (Je.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Je.endsBefore(p, r) && (Je.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function sh(e) {
  "@babel/helpers - typeof";
  return sh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sh(e);
}
function g0e(e, t) {
  if (sh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (sh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function m0e(e) {
  var t = g0e(e, "string");
  return sh(t) === "symbol" ? t : String(t);
}
function Pp(e, t, n) {
  return t = m0e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function EN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sd(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EN(Object(n), !0).forEach(function(r) {
      Pp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var v0e = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Bt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Jt.points(t))
          t[l] = Br.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Bt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, b] of Jt.points(t))
          t[b] = Br.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: L
      } = n, w = Bt.get(e, L), D = Je.previous(L), x = Bt.get(e, D), m = Bt.parent(e, L), C = L[L.length - 1];
      if (To.isText(w) && To.isText(x))
        x.text += w.text;
      else if (!To.isText(w) && !To.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(L, "] to nodes of different interfaces: ").concat(ls.stringify(w), " ").concat(ls.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, U] of Jt.points(t))
          t[U] = Br.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: k,
        newPath: N
      } = n;
      if (Je.isAncestor(k, N))
        throw new Error("Cannot move a path [".concat(k, "] to new path [").concat(N, "] because the destination is inside itself."));
      var R = Bt.get(e, k), V = Bt.parent(e, k), $ = k[k.length - 1];
      V.children.splice($, 1);
      var W = Je.transform(k, n), Z = Bt.get(e, Je.parent(W)), X = W[W.length - 1];
      if (Z.children.splice(X, 0, R), t)
        for (var [K, Q] of Jt.points(t))
          t[Q] = Br.transform(K, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, P = J[J.length - 1], _ = Bt.parent(e, J);
      if (_.children.splice(P, 1), t)
        for (var [z, M] of Jt.points(t)) {
          var H = Br.transform(z, n);
          if (t != null && H != null)
            t[M] = H;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Bt.texts(e))
              if (Je.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var q = !1;
            O && j && (Je.equals(j[1], J) ? q = !Je.hasPrevious(j[1]) : q = Je.common(O[1], J).length < Je.common(j[1], J).length), O && !q ? (z.path = O[1], z.offset = O[0].text.length) : j ? (z.path = j[1], z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Y,
        text: I
      } = n;
      if (I.length === 0) break;
      var le = Bt.leaf(e, B), he = le.text.slice(0, Y), oe = le.text.slice(Y + I.length);
      if (le.text = he + oe, t)
        for (var [Be, We] of Jt.points(t))
          t[We] = Br.transform(Be, n);
      break;
    }
    case "set_node": {
      var {
        path: He,
        properties: Ie,
        newProperties: nt
      } = n;
      if (He.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var $e = Bt.get(e, He);
      for (var Ce in nt) {
        if (Ce === "children" || Ce === "text")
          throw new Error('Cannot set the "'.concat(Ce, '" property of nodes!'));
        var Qe = nt[Ce];
        Qe == null ? delete $e[Ce] : $e[Ce] = Qe;
      }
      for (var lt in Ie)
        nt.hasOwnProperty(lt) || delete $e[lt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: be
      } = n;
      if (be == null)
        t = be;
      else {
        if (t == null) {
          if (!Jt.isRange(be))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ls.stringify(be), " when there is no current selection."));
          t = sd({}, be);
        }
        for (var Ee in be) {
          var Ae = be[Ee];
          if (Ae == null) {
            if (Ee === "anchor" || Ee === "focus")
              throw new Error('Cannot remove the "'.concat(Ee, '" selection property'));
            delete t[Ee];
          } else
            t[Ee] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: ze,
        position: Re,
        properties: ot
      } = n;
      if (ze.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(ze, "] because the root node cannot be split."));
      var ve = Bt.get(e, ze), yt = Bt.parent(e, ze), it = ze[ze.length - 1], st;
      if (To.isText(ve)) {
        var ut = ve.text.slice(0, Re), bt = ve.text.slice(Re);
        ve.text = ut, st = sd(sd({}, ot), {}, {
          text: bt
        });
      } else {
        var ct = ve.children.slice(0, Re), wt = ve.children.slice(Re);
        ve.children = ct, st = sd(sd({}, ot), {}, {
          children: wt
        });
      }
      if (yt.children.splice(it + 1, 0, st), t)
        for (var [tt, gt] of Jt.points(t))
          t[gt] = Br.transform(tt, n);
      break;
    }
  }
  return t;
}, y0e = {
  transform(e, t) {
    e.children = xN(e.children);
    var n = e.selection && xN(e.selection);
    try {
      n = v0e(e, n, t);
    } finally {
      e.children = LN(e.children), n ? e.selection = Zc(n) ? LN(n) : n : e.selection = null;
    }
  }
}, b0e = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, w0e = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, VK = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (pi(r) && pi(o)) {
      if (!VK(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function C0e(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ah(e, t) {
  if (e == null) return {};
  var n = C0e(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var O0e = ["anchor", "focus"];
function kN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function x0e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kN(Object(n), !0).forEach(function(r) {
      Pp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Jt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Jt.edges(e);
    return t;
  },
  equals(e, t) {
    return Br.equals(e.anchor, t.anchor) && Br.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Jt.isRange(t)) {
      if (Jt.includes(e, t.anchor) || Jt.includes(e, t.focus))
        return !0;
      var [n, r] = Jt.edges(e), [o, i] = Jt.edges(t);
      return Br.isBefore(n, o) && Br.isAfter(r, i);
    }
    var [a, s] = Jt.edges(e), l = !1, u = !1;
    return Br.isPoint(t) ? (l = Br.compare(t, a) >= 0, u = Br.compare(t, s) <= 0) : (l = Je.compare(t, a.path) >= 0, u = Je.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ah(e, O0e), [r, o] = Jt.edges(e), [i, a] = Jt.edges(t), s = Br.isBefore(r, i) ? i : r, l = Br.isBefore(o, a) ? o : a;
    return Br.isBefore(l, s) ? null : x0e({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Br.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Br.equals(t, n);
  },
  isExpanded(e) {
    return !Jt.isCollapsed(e);
  },
  isForward(e) {
    return !Jt.isBackward(e);
  },
  isRange(e) {
    return pi(e) && Br.isPoint(e.anchor) && Br.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Jt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return HD(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Jt.isCollapsed(r);
        Jt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Jt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = Br.transform(r.anchor, t, {
        affinity: i
      }), u = Br.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, PN = (e) => pi(e) && Bt.isNodeList(e.children) && !fr.isEditor(e), Ga = {
  isAncestor(e) {
    return pi(e) && Bt.isNodeList(e.children);
  },
  isElement: PN,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ga.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return PN(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, L0e = ["children"], E0e = ["text"], SN = /* @__PURE__ */ new WeakMap(), Bt = {
  ancestor(e, t) {
    var n = Bt.get(e, t);
    if (To.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ls.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Je.ancestors(t, n)) {
        var o = Bt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (To.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ls.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ls.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Bt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Bt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Je.common(t, n), o = Bt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Bt.get(e, t);
    if (fr.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ls.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        Ga.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ga.isAncestor(e)) {
      var t = ah(e, L0e);
      return t;
    } else {
      var t = ah(e, E0e);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Bt.get(e, n); r && !(To.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (To.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ls.stringify(e)));
    var n = HD({
      children: e.children
    }, (r) => {
      var [o, i] = Jt.edges(t), a = Bt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Jt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Jt.includes(t, s)) {
          var l = Bt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Je.equals(s, i.path)) {
          var c = Bt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Je.equals(s, o.path)) {
          var p = Bt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      fr.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (To.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ls.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (To.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return To.isText(e) || Ga.isElement(e) || fr.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = SN.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Bt.isNode(r));
    return SN.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Bt.get(e, n); r && !(To.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Bt.get(e, t);
    if (!To.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ls.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Je.levels(t, n)) {
        var o = Bt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ga.isElement(e) && Ga.isElementProps(t) && Ga.matches(e, t) || To.isText(e) && To.isTextProps(t) && To.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Je.isBefore(s, i) : Je.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !To.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Je.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Bt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Je.next(s);
          if (Bt.has(e, c)) {
            s = c, l = Bt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Je.previous(s);
          s = p, l = Bt.get(e, s);
          continue;
        }
        s = Je.parent(s), l = Bt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Je.parent(t), r = Bt.get(e, n);
    if (To.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return To.isText(e) ? e.text : e.children.map(Bt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Bt.nodes(e, t))
        To.isText(n) && (yield [n, r]);
    }();
  }
};
function MN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MN(Object(n), !0).forEach(function(r) {
      Pp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qd = {
  isNodeOperation(e) {
    return qd.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!pi(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Je.isPath(e.path) && Bt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Je.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Je.isPath(e.path) && pi(e.properties);
      case "move_node":
        return Je.isPath(e.path) && Je.isPath(e.newPath);
      case "remove_node":
        return Je.isPath(e.path) && Bt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Je.isPath(e.path);
      case "set_node":
        return Je.isPath(e.path) && pi(e.properties) && pi(e.newProperties);
      case "set_selection":
        return e.properties === null && Jt.isRange(e.newProperties) || e.newProperties === null && Jt.isRange(e.properties) || pi(e.properties) && pi(e.newProperties);
      case "split_node":
        return Je.isPath(e.path) && typeof e.position == "number" && pi(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => qd.isOperation(t));
  },
  isSelectionOperation(e) {
    return qd.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return qd.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Hr(Hr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Hr(Hr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Hr(Hr({}, e), {}, {
          type: "split_node",
          path: Je.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Je.equals(t, n))
          return e;
        if (Je.isSibling(n, t))
          return Hr(Hr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Je.transform(n, e), o = Je.transform(Je.next(n), e);
        return Hr(Hr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Hr(Hr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Hr(Hr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Hr(Hr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Hr(Hr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Hr(Hr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Hr(Hr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Hr(Hr({}, e), {}, {
          type: "merge_node",
          path: Je.next(e.path)
        });
    }
  }
}, DN = /* @__PURE__ */ new WeakMap(), k0e = (e) => {
  var t = DN.get(e);
  if (t !== void 0)
    return t;
  if (!pi(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || pi(e.marks)) && (e.selection === null || Jt.isRange(e.selection)) && Bt.isNodeList(e.children) && qd.isOperationList(e.operations);
  return DN.set(e, n), n;
}, fr = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return k0e(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function _N(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function TN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _N(Object(n), !0).forEach(function(r) {
      Pp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _N(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Br = {
  compare(e, t) {
    var n = Je.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Br.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Br.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Je.equals(e.path, t.path);
  },
  isPoint(e) {
    return pi(e) && typeof e.offset == "number" && Je.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return HD(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Je.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Je.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Je.equals(t.path, i) && (r.offset += t.position), r.path = Je.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Je.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Je.equals(t.path, i) || Je.isAncestor(t.path, i))
            return null;
          r.path = Je.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Je.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Je.transform(i, t, TN(TN({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Je.transform(i, t, n);
          break;
        }
      }
    });
  }
}, jN = void 0, ls = {
  setScrubber(e) {
    jN = e;
  },
  stringify(e) {
    return JSON.stringify(e, jN);
  }
}, P0e = ["text"], S0e = ["anchor", "focus"];
function AN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ja(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AN(Object(n), !0).forEach(function(r) {
      Pp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var To = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = ah(i, P0e);
      return a;
    }
    return VK(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return pi(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => To.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [ja({}, e)];
    for (var r of t) {
      var o = ah(r, S0e), [i, a] = Jt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, b = void 0;
        if (c < l) {
          var L = c - y;
          b = ja(ja({}, f), {}, {
            text: f.text.slice(L)
          }), f = ja(ja({}, f), {}, {
            text: f.text.slice(0, L)
          });
        }
        if (u > y) {
          var w = u - y;
          v = ja(ja({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = ja(ja({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), b && s.push(b);
      }
      n = s;
    }
    return n;
  }
}, M0e = (e) => e.selection ? e.selection : e.children.length > 0 ? fr.end(e, []) : [0], Sr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Sr || (Sr = {}));
Sr.L, Sr.L | Sr.V | Sr.LV | Sr.LVT, Sr.LV | Sr.V, Sr.V | Sr.T, Sr.LVT | Sr.T, Sr.T, Sr.Any, Sr.Extend | Sr.ZWJ, Sr.Any, Sr.SpacingMark, Sr.Prepend, Sr.Any, Sr.ZWJ, Sr.ExtPict, Sr.RI, Sr.RI;
var D0e = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    fr.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = M0e(e)
      } = n;
      if (Je.isPath(o) && (o = fr.range(e, o)), Jt.isRange(o))
        if (Jt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Jt.end(o);
          if (!r && fr.void(e, {
            at: i
          }))
            return;
          var a = Jt.start(o), s = fr.pointRef(e, a), l = fr.pointRef(e, i);
          ib.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, ib.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && fr.void(e, {
        at: o
      }) || fr.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function BN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ym(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BN(Object(n), !0).forEach(function(r) {
      Pp(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ib = ym(ym(ym(ym({}, y0e), b0e), w0e), D0e), $K = {}, VD = {}, $D = {};
Object.defineProperty($D, "__esModule", { value: !0 });
$D.default = A0e;
var IN = "html", RN = "head", bm = "body", _0e = /<([a-zA-Z]+[0-9]?)/, NN = /<head[^]*>/i, FN = /<body[^]*>/i, sb = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, fP = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, zN = typeof window == "object" && window.DOMParser;
if (typeof zN == "function") {
  var T0e = new zN(), j0e = "text/html";
  fP = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), T0e.parseFromString(e, j0e);
  }, sb = fP;
}
if (typeof document == "object" && document.implementation) {
  var wm = document.implementation.createHTMLDocument();
  sb = function(e, t) {
    if (t) {
      var n = wm.documentElement.querySelector(t);
      return n && (n.innerHTML = e), wm;
    }
    return wm.documentElement.innerHTML = e, wm;
  };
}
var Cm = typeof document == "object" && document.createElement("template"), hP;
Cm && Cm.content && (hP = function(e) {
  return Cm.innerHTML = e, Cm.content.childNodes;
});
function A0e(e) {
  var t, n, r = e.match(_0e), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case IN: {
      var i = fP(e);
      if (!NN.test(e)) {
        var a = i.querySelector(RN);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!FN.test(e)) {
        var a = i.querySelector(bm);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(IN);
    }
    case RN:
    case bm: {
      var s = sb(e).querySelectorAll(o);
      return FN.test(e) && NN.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (hP)
        return hP(e);
      var a = sb(e, bm).querySelector(bm);
      return a.childNodes;
    }
  }
}
var L1 = {}, qD = {}, ZD = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(ZD);
var ln = {}, Ou = Cr && Cr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), cf = Cr && Cr.__assign || function() {
  return cf = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, cf.apply(this, arguments);
};
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.cloneNode = ln.hasChildren = ln.isDocument = ln.isDirective = ln.isComment = ln.isText = ln.isCDATA = ln.isTag = ln.Element = ln.Document = ln.CDATA = ln.NodeWithChildren = ln.ProcessingInstruction = ln.Comment = ln.Text = ln.DataNode = ln.Node = void 0;
var es = ZD, GD = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), YD(this, t);
    }, e;
  }()
);
ln.Node = GD;
var E1 = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(GD)
);
ln.DataNode = E1;
var qK = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = es.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(E1)
);
ln.Text = qK;
var ZK = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = es.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(E1)
);
ln.Comment = ZK;
var GK = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = es.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(E1)
);
ln.ProcessingInstruction = GK;
var k1 = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(GD)
);
ln.NodeWithChildren = k1;
var YK = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = es.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(k1)
);
ln.CDATA = YK;
var XK = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = es.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(k1)
);
ln.Document = XK;
var KK = (
  /** @class */
  function(e) {
    Ou(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? es.ElementType.Script : n === "style" ? es.ElementType.Style : es.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(k1)
);
ln.Element = KK;
function JK(e) {
  return (0, es.isTag)(e);
}
ln.isTag = JK;
function QK(e) {
  return e.type === es.ElementType.CDATA;
}
ln.isCDATA = QK;
function eJ(e) {
  return e.type === es.ElementType.Text;
}
ln.isText = eJ;
function tJ(e) {
  return e.type === es.ElementType.Comment;
}
ln.isComment = tJ;
function nJ(e) {
  return e.type === es.ElementType.Directive;
}
ln.isDirective = nJ;
function rJ(e) {
  return e.type === es.ElementType.Root;
}
ln.isDocument = rJ;
function B0e(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
ln.hasChildren = B0e;
function YD(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (eJ(e))
    n = new qK(e.data);
  else if (tJ(e))
    n = new ZK(e.data);
  else if (JK(e)) {
    var r = t ? MO(e.children) : [], o = new KK(e.name, cf({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = cf({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = cf({}, e["x-attribsPrefix"])), n = o;
  } else if (QK(e)) {
    var r = t ? MO(e.children) : [], i = new YK(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (rJ(e)) {
    var r = t ? MO(e.children) : [], a = new XK(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (nJ(e)) {
    var s = new GK(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
ln.cloneNode = YD;
function MO(e) {
  for (var t = e.map(function(r) {
    return YD(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Cr && Cr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Cr && Cr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = ZD, o = ln;
  n(ln, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(qD);
var oJ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(oJ);
Object.defineProperty(L1, "__esModule", { value: !0 });
L1.formatAttributes = iJ;
L1.formatDOM = sJ;
var Om = qD, I0e = oJ;
function R0e(e) {
  return I0e.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function iJ(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function N0e(e) {
  e = e.toLowerCase();
  var t = R0e(e);
  return t || e;
}
function sJ(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = N0e(s.nodeName);
        o = new Om.Element(l, iJ(s.attributes)), o.children = sJ(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Om.Text(s.nodeValue);
        break;
      case 8:
        o = new Om.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Om.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var F0e = Cr && Cr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(VD, "__esModule", { value: !0 });
VD.default = H0e;
var z0e = F0e($D), U0e = L1, W0e = /<(![a-zA-Z\s]+)>/;
function H0e(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(W0e), n = t ? t[1] : void 0;
  return (0, U0e.formatDOM)((0, z0e.default)(e), null, n);
}
var P1 = {}, Js = {}, S1 = {}, V0e = 0;
S1.SAME = V0e;
var $0e = 1;
S1.CAMELCASE = $0e;
S1.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const aJ = 0, xu = 1, M1 = 2, D1 = 3, XD = 4, lJ = 5, uJ = 6;
function q0e(e) {
  return ri.hasOwnProperty(e) ? ri[e] : null;
}
function _i(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === M1 || t === D1 || t === XD, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ri = {}, Z0e = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Z0e.forEach((e) => {
  ri[e] = new _i(
    e,
    aJ,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ri[e] = new _i(
    e,
    xu,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ri[e] = new _i(
    e,
    M1,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ri[e] = new _i(
    e,
    M1,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ri[e] = new _i(
    e,
    D1,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ri[e] = new _i(
    e,
    D1,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ri[e] = new _i(
    e,
    XD,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ri[e] = new _i(
    e,
    uJ,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ri[e] = new _i(
    e,
    lJ,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const KD = /[\-\:]([a-z])/g, JD = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(KD, JD);
  ri[t] = new _i(
    t,
    xu,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(KD, JD);
  ri[t] = new _i(
    t,
    xu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(KD, JD);
  ri[t] = new _i(
    t,
    xu,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ri[e] = new _i(
    e,
    xu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const G0e = "xlinkHref";
ri[G0e] = new _i(
  "xlinkHref",
  xu,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ri[e] = new _i(
    e,
    xu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Y0e,
  SAME: X0e,
  possibleStandardNames: UN
} = S1, K0e = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", J0e = K0e + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Q0e = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + J0e + "]*$")
), ewe = Object.keys(
  UN
).reduce((e, t) => {
  const n = UN[t];
  return n === X0e ? e[t] = t : n === Y0e ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Js.BOOLEAN = D1;
Js.BOOLEANISH_STRING = M1;
Js.NUMERIC = lJ;
Js.OVERLOADED_BOOLEAN = XD;
Js.POSITIVE_NUMERIC = uJ;
Js.RESERVED = aJ;
Js.STRING = xu;
Js.getPropertyInfo = q0e;
Js.isCustomAttribute = Q0e;
Js.possibleStandardNames = ewe;
var QD = {}, e_ = {}, WN = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, twe = /\n/g, nwe = /^\s*/, rwe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, owe = /^:\s*/, iwe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, swe = /^[;\s]*/, awe = /^\s+|\s+$/g, lwe = `
`, HN = "/", VN = "*", dc = "", uwe = "comment", cwe = "declaration", pwe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(twe);
    v && (n += v.length);
    var b = f.lastIndexOf(lwe);
    r = ~b ? f.length - b : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var b = v[0];
      return o(b), e = e.slice(b.length), v;
    }
  }
  function u() {
    l(nwe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(HN != e.charAt(0) || VN != e.charAt(1))) {
      for (var v = 2; dc != e.charAt(v) && (VN != e.charAt(v) || HN != e.charAt(v + 1)); )
        ++v;
      if (v += 2, dc === e.charAt(v - 1))
        return s("End of comment missing");
      var b = e.slice(2, v - 2);
      return r += 2, o(b), e = e.slice(v), r += 2, f({
        type: uwe,
        comment: b
      });
    }
  }
  function d() {
    var f = i(), v = l(rwe);
    if (v) {
      if (p(), !l(owe)) return s("property missing ':'");
      var b = l(iwe), L = f({
        type: cwe,
        property: $N(v[0].replace(WN, dc)),
        value: b ? $N(b[0].replace(WN, dc)) : dc
      });
      return l(swe), L;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function $N(e) {
  return e ? e.replace(awe, dc) : dc;
}
var dwe = Cr && Cr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(e_, "__esModule", { value: !0 });
e_.default = hwe;
var fwe = dwe(pwe);
function hwe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, fwe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var _1 = {};
Object.defineProperty(_1, "__esModule", { value: !0 });
_1.camelCase = void 0;
var gwe = /^--[a-zA-Z0-9_-]+$/, mwe = /-([a-z])/g, vwe = /^[^-]+$/, ywe = /^-(webkit|moz|ms|o|khtml)-/, bwe = /^-(ms)-/, wwe = function(e) {
  return !e || vwe.test(e) || gwe.test(e);
}, Cwe = function(e, t) {
  return t.toUpperCase();
}, qN = function(e, t) {
  return "".concat(t, "-");
}, Owe = function(e, t) {
  return t === void 0 && (t = {}), wwe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(bwe, qN) : e = e.replace(ywe, qN), e.replace(mwe, Cwe));
};
_1.camelCase = Owe;
var xwe = Cr && Cr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Lwe = xwe(e_), Ewe = _1;
function gP(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Lwe.default)(e, function(r, o) {
    r && o && (n[(0, Ewe.camelCase)(r, t)] = o);
  }), n;
}
gP.default = gP;
var kwe = gP;
(function(e) {
  var t = Cr && Cr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = we, r = t(kwe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(QD);
Object.defineProperty(P1, "__esModule", { value: !0 });
P1.default = Dwe;
var Zd = Js, ZN = QD, Pwe = ["checked", "value"], Swe = ["input", "select", "textarea"], Mwe = {
  reset: !0,
  submit: !0
};
function Dwe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Mwe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Zd.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = GN(a);
    if (s) {
      var l = (0, Zd.getPropertyInfo)(s);
      switch (Pwe.includes(s) && Swe.includes(t) && !r && (s = GN("default" + a)), n[s] = i, l && l.type) {
        case Zd.BOOLEAN:
          n[s] = !0;
          break;
        case Zd.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    ZN.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, ZN.setStyleProp)(e.style, n), n;
}
function GN(e) {
  return Zd.possibleStandardNames[e];
}
var t_ = {}, _we = Cr && Cr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(t_, "__esModule", { value: !0 });
t_.default = cJ;
var DO = we, Twe = _we(P1), pf = QD, jwe = {
  cloneElement: DO.cloneElement,
  createElement: DO.createElement,
  isValidElement: DO.isValidElement
};
function cJ(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || pf.returnFirstArg, i = t.library || jwe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, pf.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Awe(f) ? ((0, pf.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Twe.default)(f.attribs, f.name));
    var b = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (b = cJ(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, b), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Awe(e) {
  return pf.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, pf.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Cr && Cr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(VD);
  e.htmlToDOM = n.default;
  var r = t(P1);
  e.attributesToProps = r.default;
  var o = t(t_);
  e.domToReact = o.default;
  var i = qD;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})($K);
const Bwe = /* @__PURE__ */ t0e($K);
Bwe.default;
Ve({});
function Iwe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Rwe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
Iwe(Rwe.CNPJ).length;
ma((e, t) => /* @__PURE__ */ qi.jsx("input", { ref: t, ...e }));
Ve({});
var sl = {};
Object.defineProperty(sl, "__esModule", {
  value: !0
});
var Nwe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), _O = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, pJ = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Nwe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, n_ = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var xm = 1; xm < 20; xm++)
  n_["f" + xm] = 111 + xm;
function T1(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return dJ(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return fJ(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Fwe(e, t) {
  return T1(e, t);
}
function zwe(e, t) {
  return T1(e, { byKey: !0 }, t);
}
function dJ(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in _O)
    r[_O[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = r_(d), v = _O[f];
      if (d.length > 1 && !v && !pJ[d] && !n_[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = hJ(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function fJ(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function hJ(e) {
  e = r_(e);
  var t = n_[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function r_(e) {
  return e = e.toLowerCase(), e = pJ[e] || e, e;
}
sl.default = T1;
var TO = sl.isHotkey = T1;
sl.isCodeHotkey = Fwe;
sl.isKeyHotkey = zwe;
sl.parseHotkey = dJ;
sl.compareHotkey = fJ;
sl.toKeyCode = hJ;
sl.toKeyName = r_;
var Uwe = typeof Cr == "object" && Cr && Cr.Object === Object && Cr, Wwe = Uwe, Hwe = Wwe, Vwe = typeof self == "object" && self && self.Object === Object && self, $we = Hwe || Vwe || Function("return this")(), qwe = $we, Zwe = qwe, Gwe = Zwe.Symbol, gJ = Gwe, YN = gJ;
YN && YN.toStringTag;
var XN = gJ;
XN && XN.toStringTag;
var KN;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(KN || (KN = {}));
var o_ = function(e) {
  return Object.freeze(e);
}, Ywe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, o_(this);
  }
  return e;
}(), Xwe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, o_(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), JN = typeof window < "u" ? window : {};
/msie|trident/i.test(JN.navigator && JN.navigator.userAgent);
var jO = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Ywe((n ? t : e) || 0, (n ? e : t) || 0);
};
o_({
  devicePixelContentBoxSize: jO(),
  borderBoxSize: jO(),
  contentBoxSize: jO(),
  contentRect: new Xwe(0, 0, 0, 0)
});
function lh(e) {
  "@babel/helpers - typeof";
  return lh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, lh(e);
}
function Kwe(e, t) {
  if (lh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (lh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Jwe(e) {
  var t = Kwe(e, "string");
  return lh(t) === "symbol" ? t : String(t);
}
function df(e, t, n) {
  return t = Jwe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Qwe = /* @__PURE__ */ Ve(null), AO, BO;
parseInt(we.version.split(".")[0], 10);
var QN = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), IO = typeof navigator < "u" && /Android/.test(navigator.userAgent), Lm = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), e1e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (AO = navigator.userAgent.match(/Version\/(\d+)/)) !== null && AO !== void 0 && AO[1] && parseInt((BO = navigator.userAgent.match(/Version\/(\d+)/)) === null || BO === void 0 ? void 0 : BO[1], 10) < 17;
var t1e = /* @__PURE__ */ new WeakMap(), n1e = /* @__PURE__ */ new WeakMap(), r1e = /* @__PURE__ */ new WeakMap(), o1e = /* @__PURE__ */ new WeakMap(), i1e = /* @__PURE__ */ new WeakMap(), eF = /* @__PURE__ */ new WeakMap(), s1e = /* @__PURE__ */ new WeakMap(), tF = /* @__PURE__ */ new WeakMap(), Em = /* @__PURE__ */ new WeakMap(), a1e = /* @__PURE__ */ new WeakMap(), l1e = /* @__PURE__ */ new WeakMap(), u1e = /* @__PURE__ */ new WeakMap(), mJ = globalThis.Node, c1e = globalThis.Text, vJ = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, p1e = (e) => ab(e) && e.nodeType === 8, ua = (e) => ab(e) && e.nodeType === 1, ab = (e) => {
  var t = vJ(e);
  return !!t && e instanceof t.Node;
}, nF = (e) => {
  var t = e && e.anchorNode && vJ(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, d1e = (e) => {
  var [t, n] = e;
  if (ua(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = yJ(t, o, r ? "backward" : "forward"), r = o < n; ua(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = h1e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, f1e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, yJ = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (p1e(o) || ua(o) && o.childNodes.length === 0 || ua(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, h1e = (e, t, n) => {
  var [r] = yJ(e, t, n);
  return r;
}, rF = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), bJ = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ua(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = pn.getWindow(e);
  if (o.contains(r))
    return pn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : bJ(e, i, n);
}, oF = (e, t) => !!(e.compareDocumentPosition(t) & mJ.DOCUMENT_POSITION_PRECEDING), g1e = (e, t) => !!(e.compareDocumentPosition(t) & mJ.DOCUMENT_POSITION_FOLLOWING), m1e = 0;
class v1e {
  constructor() {
    df(this, "id", void 0), this.id = "".concat(m1e++);
  }
}
var pn = {
  androidPendingDiffs: (e) => u1e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = l1e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = pn.toDOMNode(e, e), n = pn.findDocumentOrShadowRoot(e);
    Em.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = pn.findDocumentOrShadowRoot(e), r = rF(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && ib.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = pn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = pn.toSlateNode(e, t.target), a = pn.findPath(e, i);
    if (Ga.isElement(i) && fr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = fr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? fr.before(e, u) : fr.after(e, u);
      if (c) {
        var p = fr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = pn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = pn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = eF.get(t);
    return n || (n = new v1e(), eF.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = n1e.get(r);
      if (o == null) {
        if (fr.isEditor(r))
          return n;
        break;
      }
      var i = t1e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ls.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Em.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          pn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = pn.toDOMNode(e, e), r = pn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = rF(r), i = pn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || ib.select(e, fr.start(e, [])), Em.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = r1e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = pn.toDOMNode(e, e), i;
    try {
      i = ua(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => ab(t) && pn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return fr.hasPath(e, n.path) && fr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => pn.hasEditableTarget(e, t) || pn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => ab(t) && pn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!a1e.get(e),
  isFocused: (e) => !!Em.get(e),
  isReadOnly: (e) => !!tF.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (tF.get(e)) return !1;
    var n = pn.hasTarget(e, t) && pn.toSlateNode(e, t);
    return Ga.isElement(n) && fr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = s1e.get(e), r = fr.isEditor(t) ? o1e.get(e) : n == null ? void 0 : n.get(pn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ls.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = fr.node(e, t.path), r = pn.toDOMNode(e, n), o;
    fr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof c1e ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ls.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Jt.isBackward(t), i = pn.toDOMPoint(e, n), a = Jt.isCollapsed(t) ? i : pn.toDOMPoint(e, r), s = pn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = ua(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = ua(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ua(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? i1e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : d1e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = pn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = pn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (IO && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var N = U[k];
          if (pn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var R = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, W = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = W.find((M) => g1e(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var Z, X = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = (Z = X.findLast((M) => oF(L, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      IO && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Lm && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (IO && !u && !r) {
      var K = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (K && pn.hasDOMNode(e, K, {
        editable: !0
      })) {
        var Q = pn.toSlateNode(e, K), {
          path: J,
          offset: P
        } = fr.start(e, pn.findPath(e, Q));
        return K.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = pn.toSlateNode(e, u), z = pn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = nF(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (nF(t)) {
        if (Lm && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        e1e && f1e(s) || Lm ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Lm && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = pn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = oF(s, u) || s === u && c < l, x = p ? w : pn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Jt.isExpanded(m) && Jt.isForward(m) && ua(u) && fr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = fr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, y1e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, b1e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, w1e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Vr = (e) => {
  var t = y1e[e], n = b1e[e], r = w1e[e], o = t && TO(t), i = n && TO(n), a = r && TO(r);
  return (s) => !!(o && o(s) || QN && i && i(s) || !QN && a && a(s));
};
Vr("bold"), Vr("compose"), Vr("moveBackward"), Vr("moveForward"), Vr("deleteBackward"), Vr("deleteForward"), Vr("deleteLineBackward"), Vr("deleteLineForward"), Vr("deleteWordBackward"), Vr("deleteWordForward"), Vr("extendBackward"), Vr("extendForward"), Vr("extendLineBackward"), Vr("extendLineForward"), Vr("italic"), Vr("moveLineBackward"), Vr("moveLineForward"), Vr("moveWordBackward"), Vr("moveWordForward"), Vr("redo"), Vr("insertSoftBreak"), Vr("splitBlock"), Vr("transposeCharacter"), Vr("undo");
var C1e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => bJ(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, O1e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class x1e extends au {
  constructor() {
    super(...arguments), df(this, "context", null), df(this, "manager", null), df(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, O1e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = C1e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
df(x1e, "contextType", Qwe);
Ve({});
Ve({});
Ve({});
var jo = {}, i_ = {}, Ph = {}, Sh = {}, wJ = "Expected a function", iF = NaN, L1e = "[object Symbol]", E1e = /^\s+|\s+$/g, k1e = /^[-+]0x[0-9a-f]+$/i, P1e = /^0b[01]+$/i, S1e = /^0o[0-7]+$/i, M1e = parseInt, D1e = typeof Cr == "object" && Cr && Cr.Object === Object && Cr, _1e = typeof self == "object" && self && self.Object === Object && self, T1e = D1e || _1e || Function("return this")(), j1e = Object.prototype, A1e = j1e.toString, B1e = Math.max, I1e = Math.min, RO = function() {
  return T1e.Date.now();
};
function R1e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(wJ);
  t = sF(t) || 0, lb(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? B1e(sF(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? I1e(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = RO();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(RO());
  }
  function m() {
    var C = RO(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function N1e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(wJ);
  return lb(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), R1e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function lb(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function F1e(e) {
  return !!e && typeof e == "object";
}
function z1e(e) {
  return typeof e == "symbol" || F1e(e) && A1e.call(e) == L1e;
}
function sF(e) {
  if (typeof e == "number")
    return e;
  if (z1e(e))
    return iF;
  if (lb(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = lb(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(E1e, "");
  var n = P1e.test(e);
  return n || S1e.test(e) ? M1e(e.slice(2), n ? 2 : 8) : k1e.test(e) ? iF : +e;
}
var U1e = N1e, Mh = {};
Object.defineProperty(Mh, "__esModule", {
  value: !0
});
Mh.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), oy.has(t) || oy.set(t, /* @__PURE__ */ new Set());
  var o = oy.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Mh.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), oy.get(t).delete(n.name || t);
};
var oy = /* @__PURE__ */ new Map();
Object.defineProperty(Sh, "__esModule", {
  value: !0
});
var W1e = U1e, H1e = $1e(W1e), V1e = Mh;
function $1e(e) {
  return e && e.__esModule ? e : { default: e };
}
var q1e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, H1e.default)(e, t);
}, uo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = q1e(function(r) {
        uo.scrollHandler(e);
      }, t);
      uo.scrollSpyContainers.push(e), (0, V1e.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return uo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = uo.scrollSpyContainers[uo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(uo.currentPositionX(e), uo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    uo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = uo.scrollSpyContainers[uo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(uo.currentPositionX(t), uo.currentPositionY(t));
  },
  updateStates: function() {
    uo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    uo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), uo.spySetState && uo.spySetState.length && uo.spySetState.indexOf(e) > -1 && uo.spySetState.splice(uo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", uo.scrollHandler);
  },
  update: function() {
    return uo.scrollSpyContainers.forEach(function(e) {
      return uo.scrollHandler(e);
    });
  }
};
Sh.default = uo;
var Sp = {}, Dh = {};
Object.defineProperty(Dh, "__esModule", {
  value: !0
});
var Z1e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, G1e = function() {
  return window.location.hash.replace(/^#/, "");
}, Y1e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, X1e = function(e) {
  return getComputedStyle(e).position !== "static";
}, NO = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, K1e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (X1e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = NO(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return NO(t, s).offsetTop - NO(e, s).offsetTop;
};
Dh.default = {
  updateHash: Z1e,
  getHash: G1e,
  filterElementInContainer: Y1e,
  scrollOffset: K1e
};
var j1 = {}, s_ = {};
Object.defineProperty(s_, "__esModule", {
  value: !0
});
s_.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var a_ = {};
Object.defineProperty(a_, "__esModule", {
  value: !0
});
var J1e = Mh, Q1e = ["mousedown", "mousewheel", "touchmove", "keydown"];
a_.default = {
  subscribe: function(e) {
    return typeof document < "u" && Q1e.forEach(function(t) {
      return (0, J1e.addPassiveEventListener)(document, t, e);
    });
  }
};
var _h = {};
Object.defineProperty(_h, "__esModule", {
  value: !0
});
var mP = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      mP.registered[e] = t;
    },
    remove: function(e) {
      mP.registered[e] = null;
    }
  }
};
_h.default = mP;
Object.defineProperty(j1, "__esModule", {
  value: !0
});
var eCe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, tCe = Dh;
A1(tCe);
var nCe = s_, aF = A1(nCe), rCe = a_, oCe = A1(rCe), iCe = _h, ta = A1(iCe);
function A1(e) {
  return e && e.__esModule ? e : { default: e };
}
var CJ = function(e) {
  return aF.default[e.smooth] || aF.default.defaultEasing;
}, sCe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, aCe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, vP = function() {
  return aCe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), OJ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, xJ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, LJ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, lCe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, uCe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, cCe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ta.default.registered.end && ta.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    vP.call(window, i);
    return;
  }
  ta.default.registered.end && ta.default.registered.end(o.to, o.target, o.currentPosition);
}, l_ = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Th = function(e, t, n, r) {
  t.data = t.data || OJ(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (oCe.default.subscribe(o), l_(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? xJ(t) : LJ(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ta.default.registered.end && ta.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = sCe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = CJ(t), a = cCe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ta.default.registered.begin && ta.default.registered.begin(t.data.to, t.data.target), vP.call(window, a);
    }, t.delay);
    return;
  }
  ta.default.registered.begin && ta.default.registered.begin(t.data.to, t.data.target), vP.call(window, a);
}, B1 = function(e) {
  return e = eCe({}, e), e.data = e.data || OJ(), e.absolute = !0, e;
}, pCe = function(e) {
  Th(0, B1(e));
}, dCe = function(e, t) {
  Th(e, B1(t));
}, fCe = function(e) {
  e = B1(e), l_(e), Th(e.horizontal ? lCe(e) : uCe(e), e);
}, hCe = function(e, t) {
  t = B1(t), l_(t);
  var n = t.horizontal ? xJ(t) : LJ(t);
  Th(e + n, t);
};
j1.default = {
  animateTopScroll: Th,
  getAnimationType: CJ,
  scrollToTop: pCe,
  scrollToBottom: fCe,
  scrollTo: dCe,
  scrollMore: hCe
};
Object.defineProperty(Sp, "__esModule", {
  value: !0
});
var gCe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, mCe = Dh, vCe = u_(mCe), yCe = j1, bCe = u_(yCe), wCe = _h, km = u_(wCe);
function u_(e) {
  return e && e.__esModule ? e : { default: e };
}
var Pm = {}, lF = void 0;
Sp.default = {
  unmount: function() {
    Pm = {};
  },
  register: function(e, t) {
    Pm[e] = t;
  },
  unregister: function(e) {
    delete Pm[e];
  },
  get: function(e) {
    return Pm[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return lF = e;
  },
  getActiveLink: function() {
    return lF;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = gCe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = vCe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      km.default.registered.begin && km.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, km.default.registered.end && km.default.registered.end(e, n);
      return;
    }
    bCe.default.animateTopScroll(s, t, e, n);
  }
};
var yP = { exports: {} }, FO = { exports: {} }, Hn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uF;
function CCe() {
  if (uF) return Hn;
  uF = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Hn.AsyncMode = l, Hn.ConcurrentMode = u, Hn.ContextConsumer = s, Hn.ContextProvider = a, Hn.Element = t, Hn.ForwardRef = c, Hn.Fragment = r, Hn.Lazy = f, Hn.Memo = y, Hn.Portal = n, Hn.Profiler = i, Hn.StrictMode = o, Hn.Suspense = p, Hn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Hn.isConcurrentMode = x, Hn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Hn.isContextProvider = function(m) {
    return D(m) === a;
  }, Hn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Hn.isForwardRef = function(m) {
    return D(m) === c;
  }, Hn.isFragment = function(m) {
    return D(m) === r;
  }, Hn.isLazy = function(m) {
    return D(m) === f;
  }, Hn.isMemo = function(m) {
    return D(m) === y;
  }, Hn.isPortal = function(m) {
    return D(m) === n;
  }, Hn.isProfiler = function(m) {
    return D(m) === i;
  }, Hn.isStrictMode = function(m) {
    return D(m) === o;
  }, Hn.isSuspense = function(m) {
    return D(m) === p;
  }, Hn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, Hn.typeOf = D, Hn;
}
var Qn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cF;
function OCe() {
  return cF || (cF = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === y || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === L || I.$$typeof === w || I.$$typeof === v);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, N = c, R = r, V = f, $ = y, W = n, Z = i, X = o, K = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(I) || x(I) === l;
    }
    function P(I) {
      return x(I) === u;
    }
    function _(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function M(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function H(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function F(I) {
      return x(I) === y;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function B(I) {
      return x(I) === o;
    }
    function Y(I) {
      return x(I) === p;
    }
    Qn.AsyncMode = m, Qn.ConcurrentMode = C, Qn.ContextConsumer = S, Qn.ContextProvider = U, Qn.Element = k, Qn.ForwardRef = N, Qn.Fragment = R, Qn.Lazy = V, Qn.Memo = $, Qn.Portal = W, Qn.Profiler = Z, Qn.StrictMode = X, Qn.Suspense = K, Qn.isAsyncMode = J, Qn.isConcurrentMode = P, Qn.isContextConsumer = _, Qn.isContextProvider = z, Qn.isElement = M, Qn.isForwardRef = H, Qn.isFragment = O, Qn.isLazy = j, Qn.isMemo = F, Qn.isPortal = T, Qn.isProfiler = q, Qn.isStrictMode = B, Qn.isSuspense = Y, Qn.isValidElementType = D, Qn.typeOf = x;
  }()), Qn;
}
var pF;
function EJ() {
  return pF || (pF = 1, process.env.NODE_ENV === "production" ? FO.exports = CCe() : FO.exports = OCe()), FO.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var zO, dF;
function xCe() {
  if (dF) return zO;
  dF = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return zO = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, zO;
}
var UO, fF;
function c_() {
  if (fF) return UO;
  fF = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return UO = e, UO;
}
var hF, gF;
function kJ() {
  return gF || (gF = 1, hF = Function.call.bind(Object.prototype.hasOwnProperty)), hF;
}
var WO, mF;
function LCe() {
  if (mF) return WO;
  mF = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = c_(), n = {}, r = kJ();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, WO = o, WO;
}
var HO, vF;
function ECe() {
  if (vF) return HO;
  vF = 1;
  var e = EJ(), t = xCe(), n = c_(), r = kJ(), o = LCe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return HO = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: N(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, j, F, T, q, B, Y) {
        if (T = T || d, B = B || F, Y !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + q + " `" + B + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + q + " `" + B + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, F, T, q, B);
      }
      var H = M.bind(null, !1);
      return H.isRequired = M.bind(null, !0), H;
    }
    function L(P) {
      function _(z, M, H, O, j, F) {
        var T = z[M], q = X(T);
        if (q !== P) {
          var B = K(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + B + "` supplied to `" + H + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var T = X(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var B = P(F, q, H, O, j + "[" + q + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!s(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!e.isValidElementType(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, H, O, j) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, T = J(z[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, H, O, j) {
        for (var F = z[M], T = 0; T < P.length; T++)
          if (f(F, P[T]))
            return null;
        var q = JSON.stringify(P, function(B, Y) {
          var I = K(Y);
          return I === "symbol" ? String(Y) : Y;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + H + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside objectOf.");
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var B = P(F, q, H, O, j + "." + q, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(H, O, j, F, T) {
        for (var q = [], B = 0; B < P.length; B++) {
          var Y = P[B], I = Y(H, O, j, F, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(M);
    }
    function N() {
      function P(_, z, M, H, O) {
        return W(_[z]) ? null : new v("Invalid " + H + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, _, z, M, H) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + H + "`."
      );
    }
    function V(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        for (var q in P) {
          var B = P[q];
          if (typeof B != "function")
            return R(H, O, j, q, K(B));
          var Y = B(F, q, H, O, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var B in q) {
          var Y = P[B];
          if (r(P, B) && typeof Y != "function")
            return R(H, O, j, B, K(Y));
          if (!Y)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + B + "` supplied to `" + H + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var I = Y(F, B, H, O, j + "." + B, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(_);
    }
    function W(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(W);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var H = M.value;
                if (H && !W(H[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function X(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(_, P) ? "symbol" : _;
    }
    function K(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = X(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = K(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, HO;
}
var VO, yF;
function kCe() {
  if (yF) return VO;
  yF = 1;
  var e = c_();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, VO = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, VO;
}
if (process.env.NODE_ENV !== "production") {
  var PCe = EJ(), SCe = !0;
  yP.exports = ECe()(PCe.isElement, SCe);
} else
  yP.exports = kCe()();
var I1 = yP.exports, R1 = {};
Object.defineProperty(R1, "__esModule", {
  value: !0
});
var MCe = Dh, $O = DCe(MCe);
function DCe(e) {
  return e && e.__esModule ? e : { default: e };
}
var _Ce = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return $O.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && $O.default.getHash() !== e && $O.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
R1.default = _Ce;
Object.defineProperty(Ph, "__esModule", {
  value: !0
});
var Sm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, TCe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), jCe = we, bF = jh(jCe), ACe = Sh, Mm = jh(ACe), BCe = Sp, ICe = jh(BCe), RCe = I1, $r = jh(RCe), NCe = R1, hl = jh(NCe);
function jh(e) {
  return e && e.__esModule ? e : { default: e };
}
function FCe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function zCe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function UCe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var wF = {
  to: $r.default.string.isRequired,
  containerId: $r.default.string,
  container: $r.default.object,
  activeClass: $r.default.string,
  activeStyle: $r.default.object,
  spy: $r.default.bool,
  horizontal: $r.default.bool,
  smooth: $r.default.oneOfType([$r.default.bool, $r.default.string]),
  offset: $r.default.number,
  delay: $r.default.number,
  isDynamic: $r.default.bool,
  onClick: $r.default.func,
  duration: $r.default.oneOfType([$r.default.number, $r.default.func]),
  absolute: $r.default.bool,
  onSetActive: $r.default.func,
  onSetInactive: $r.default.func,
  ignoreCancelEvents: $r.default.bool,
  hashSpy: $r.default.bool,
  saveHashHistory: $r.default.bool,
  spyThrottle: $r.default.number
};
Ph.default = function(e, t) {
  var n = t || ICe.default, r = function(i) {
    UCe(a, i);
    function a(s) {
      FCe(this, a);
      var l = zCe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return TCe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Mm.default.isMounted(s) || Mm.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (hl.default.isMounted() || hl.default.mount(n), hl.default.mapContainer(this.props.to, s)), Mm.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Mm.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Sm({}, this.props.style, this.props.activeStyle) : l = Sm({}, this.props.style);
        var u = Sm({}, this.props);
        for (var c in wF)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, bF.default.createElement(e, u);
      }
    }]), a;
  }(bF.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Sm({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(hl.default.isMounted() && !hl.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var N = n.getActiveLink();
        if (y) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && hl.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            hl.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, W = $ === void 0 ? !1 : $;
          i.props.hashSpy && hl.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = wF, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(i_, "__esModule", {
  value: !0
});
var WCe = we, CF = PJ(WCe), HCe = Ph, VCe = PJ(HCe);
function PJ(e) {
  return e && e.__esModule ? e : { default: e };
}
function $Ce(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function OF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function qCe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ZCe = function(e) {
  qCe(t, e);
  function t() {
    var n, r, o, i;
    $Ce(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = OF(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return CF.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), OF(o, i);
  }
  return t;
}(CF.default.Component);
i_.default = (0, VCe.default)(ZCe);
var p_ = {};
Object.defineProperty(p_, "__esModule", {
  value: !0
});
var GCe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), YCe = we, xF = SJ(YCe), XCe = Ph, KCe = SJ(XCe);
function SJ(e) {
  return e && e.__esModule ? e : { default: e };
}
function JCe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function QCe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eOe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tOe = function(e) {
  eOe(t, e);
  function t() {
    return JCe(this, t), QCe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return GCe(t, [{
    key: "render",
    value: function() {
      return xF.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(xF.default.Component);
p_.default = (0, KCe.default)(tOe);
var d_ = {}, N1 = {};
Object.defineProperty(N1, "__esModule", {
  value: !0
});
var nOe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rOe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), oOe = we, LF = F1(oOe), iOe = il;
F1(iOe);
var sOe = Sp, EF = F1(sOe), aOe = I1, kF = F1(aOe);
function F1(e) {
  return e && e.__esModule ? e : { default: e };
}
function lOe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uOe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cOe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
N1.default = function(e) {
  var t = function(n) {
    cOe(r, n);
    function r(o) {
      lOe(this, r);
      var i = uOe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return rOe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        EF.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        EF.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return LF.default.createElement(e, nOe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(LF.default.Component);
  return t.propTypes = {
    name: kF.default.string,
    id: kF.default.string
  }, t;
};
Object.defineProperty(d_, "__esModule", {
  value: !0
});
var PF = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pOe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), dOe = we, SF = f_(dOe), fOe = N1, hOe = f_(fOe), gOe = I1, MF = f_(gOe);
function f_(e) {
  return e && e.__esModule ? e : { default: e };
}
function mOe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vOe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yOe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var MJ = function(e) {
  yOe(t, e);
  function t() {
    return mOe(this, t), vOe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return pOe(t, [{
    key: "render",
    value: function() {
      var n = this, r = PF({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, SF.default.createElement(
        "div",
        PF({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(SF.default.Component);
MJ.propTypes = {
  name: MF.default.string,
  id: MF.default.string
};
d_.default = (0, hOe.default)(MJ);
var qO = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, DF = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function _F(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function TF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jF(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Dm = we, ju = Sh, ZO = Sp, yo = I1, gl = R1, AF = {
  to: yo.string.isRequired,
  containerId: yo.string,
  container: yo.object,
  activeClass: yo.string,
  spy: yo.bool,
  smooth: yo.oneOfType([yo.bool, yo.string]),
  offset: yo.number,
  delay: yo.number,
  isDynamic: yo.bool,
  onClick: yo.func,
  duration: yo.oneOfType([yo.number, yo.func]),
  absolute: yo.bool,
  onSetActive: yo.func,
  onSetInactive: yo.func,
  ignoreCancelEvents: yo.bool,
  hashSpy: yo.bool,
  spyThrottle: yo.number
}, bOe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || ZO, r = function(i) {
      jF(a, i);
      function a(s) {
        _F(this, a);
        var l = TF(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return DF(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            ju.isMounted(s) || ju.mount(s, this.props.spyThrottle), this.props.hashSpy && (gl.isMounted() || gl.mount(n), gl.mapContainer(this.props.to, s)), this.props.spy && ju.addStateHandler(this.stateHandler), ju.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          ju.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = qO({}, this.props);
          for (var u in AF)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Dm.createElement(e, l);
        }
      }]), a;
    }(Dm.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, qO({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(gl.isMounted() && !gl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && gl.getHash() === l && gl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), ju.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && gl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), ju.updateStates();
        }
      };
    };
    return r.propTypes = AF, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      jF(r, n);
      function r(o) {
        _F(this, r);
        var i = TF(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return DF(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          ZO.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          ZO.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Dm.createElement(e, qO({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Dm.Component);
    return t.propTypes = {
      name: yo.string,
      id: yo.string
    }, t;
  }
}, wOe = bOe;
Object.defineProperty(jo, "__esModule", {
  value: !0
});
jo.Helpers = jo.ScrollElement = jo.ScrollLink = jo.animateScroll = jo.scrollSpy = jo.Events = jo.scroller = jo.Element = jo.Button = jo.Link = void 0;
var COe = i_, DJ = ya(COe), OOe = p_, _J = ya(OOe), xOe = d_, TJ = ya(xOe), LOe = Sp, jJ = ya(LOe), EOe = _h, AJ = ya(EOe), kOe = Sh, BJ = ya(kOe), POe = j1, IJ = ya(POe), SOe = Ph, RJ = ya(SOe), MOe = N1, NJ = ya(MOe), DOe = wOe, FJ = ya(DOe);
function ya(e) {
  return e && e.__esModule ? e : { default: e };
}
jo.Link = DJ.default;
jo.Button = _J.default;
jo.Element = TJ.default;
jo.scroller = jJ.default;
jo.Events = AJ.default;
jo.scrollSpy = BJ.default;
jo.animateScroll = IJ.default;
jo.ScrollLink = RJ.default;
jo.ScrollElement = NJ.default;
jo.Helpers = FJ.default;
jo.default = { Link: DJ.default, Button: _J.default, Element: TJ.default, scroller: jJ.default, Events: AJ.default, scrollSpy: BJ.default, animateScroll: IJ.default, ScrollLink: RJ.default, ScrollElement: NJ.default, Helpers: FJ.default };
Ve({});
Ve({});
Ve({});
function uh(e) {
  "@babel/helpers - typeof";
  return uh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, uh(e);
}
function _Oe(e, t) {
  if (uh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (uh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function TOe(e) {
  var t = _Oe(e, "string");
  return uh(t) == "symbol" ? t : t + "";
}
function ke(e, t, n) {
  return (t = TOe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function zJ(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var GO, BF;
function jOe() {
  if (BF) return GO;
  BF = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return GO = t, GO;
}
var AOe = jOe(), Uo = /* @__PURE__ */ zJ(AOe), Rt = Ve(null);
function BOe() {
  Uo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Rt);
  return Uo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function IOe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function ROe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function NOe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return ROe(e, i), o;
}
function FOe(e, t, n) {
  var r = IOe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function zOe(e) {
  google.maps.event.removeListener(e);
}
function En() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(zOe);
}
function yn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = FOe(o, i, n);
  return NOe(t, r, o, i), a;
}
function UOe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = ht(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null), [B, Y] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (B !== null && google.maps.event.removeListener(B), Y(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var I = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(I), I !== null && D && D(I), () => {
      I !== null && x && x(I);
    };
  }, []), qi.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: qi.jsx(Rt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(UOe);
function IF(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function UJ(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        IF(i, r, o, a, s, "next", l);
      }
      function s(l) {
        IF(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function WJ(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Uo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var fc = typeof document < "u";
function HJ(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return fc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function RF(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function VJ() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return RF(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return RF(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var ad = !1;
function $J() {
  return qi.jsx("div", {
    children: "Loading..."
  });
}
var bP = {
  id: "script-loader",
  version: "weekly"
};
class WOe extends pe {
  constructor() {
    super(...arguments), ke(this, "check", zn()), ke(this, "state", {
      loaded: !1
    }), ke(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ke(this, "isCleaningUp", /* @__PURE__ */ UJ(function* () {
      function t(n) {
        if (!ad)
          n();
        else if (fc)
          var r = window.setInterval(function() {
            ad || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ke(this, "cleanup", () => {
      ad = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ke(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && VJ(), Uo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: WJ(this.props)
      };
      HJ(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (fc) {
      if (window.google && window.google.maps && !ad) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), fc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (fc) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, ad = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return qi.jsxs(qi.Fragment, {
      children: [qi.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || qi.jsx($J, {})]
    });
  }
}
ke(WOe, "defaultProps", bP);
function HOe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function h_(e, t) {
  if (e == null) return {};
  var n, r, o = HOe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var NF;
function VOe(e) {
  var {
    id: t = bP.id,
    version: n = bP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = ht(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    fc && u && VJ();
  }, [u]), h(function() {
    f && Uo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = WJ({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!fc)
      return;
    function x() {
      y.current && (v(!0), NF = w);
    }
    if (window.google && window.google.maps && NF === w) {
      x();
      return;
    }
    HJ({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = ht();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var $Oe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], qOe = qi.jsx($J, {});
function ZOe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = h_(e, $Oe), {
    isLoaded: s,
    loadError: l
  } = VOe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || qOe;
}
me(ZOe);
var FF;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(FF || (FF = {}));
function zF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ub(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zF(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var UF = {}, WF = {
  options(e, t) {
    e.setOptions(t);
  }
};
function GOe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Rt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(ub(ub({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(GOe);
class YOe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      trafficLayer: null
    }), ke(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(ub(ub({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: WF,
      eventMap: UF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: WF,
      eventMap: UF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), En(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(YOe, "contextType", Rt);
function XOe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Rt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(XOe);
class KOe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      bicyclingLayer: null
    }), ke(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(KOe, "contextType", Rt);
function JOe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Rt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(JOe);
class QOe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      transitLayer: null
    }), ke(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(QOe, "contextType", Rt);
function HF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HF(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var VF = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, $F = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function exe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Rt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Uo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(cb(cb({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && v(google.maps.event.addListener(N, "circlecomplete", r)), o && L(google.maps.event.addListener(N, "markercomplete", o)), i && D(google.maps.event.addListener(N, "overlaycomplete", i)), a && m(google.maps.event.addListener(N, "polygoncomplete", a)), s && S(google.maps.event.addListener(N, "polylinecomplete", s)), l && k(google.maps.event.addListener(N, "rectanglecomplete", l)), y(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(exe);
class txe extends pe {
  constructor(t) {
    super(t), ke(this, "registeredEvents", []), ke(this, "state", {
      drawingManager: null
    }), ke(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Uo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(cb(cb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: $F,
      eventMap: VF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: $F,
      eventMap: VF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), En(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ke(txe, "contextType", Rt);
function qF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ep(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qF(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZF = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, GF = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, pb = {};
function nxe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: W,
    onFlatChanged: Z,
    onIconChanged: X,
    onPositionChanged: K,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, H = ge(Rt), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null), [oe, Be] = E(null), [We, He] = E(null), [Ie, nt] = E(null), [$e, Ce] = E(null), [Qe, lt] = E(null), [be, Ee] = E(null), [Ae, ze] = E(null), [Re, ot] = E(null), [ve, yt] = E(null), [it, st] = E(null), [ut, bt] = E(null), [ct, wt] = E(null), [tt, gt] = E(null), [rt, Ct] = E(null), [pt, Et] = E(null), [Ot, kt] = E(null), [xt, Pt] = E(null);
  h(() => {
    O !== null && O.setMap(H);
  }, [H]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), He(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Ie !== null && google.maps.event.removeListener(Ie), nt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && N && ($e !== null && google.maps.event.removeListener($e), Ce(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), h(() => {
    O && L && (Qe !== null && google.maps.event.removeListener(Qe), lt(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (be !== null && google.maps.event.removeListener(be), Ee(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && R && (Ae !== null && google.maps.event.removeListener(Ae), ze(google.maps.event.addListener(O, "clickable_changed", R)));
  }, [R]), h(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), ot(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), yt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && W && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), bt(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && X && (ct !== null && google.maps.event.removeListener(ct), wt(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), h(() => {
    O && K && (tt !== null && google.maps.event.removeListener(tt), gt(google.maps.event.addListener(O, "position_changed", K)));
  }, [K]), h(() => {
    O && Q && (rt !== null && google.maps.event.removeListener(rt), Ct(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Et(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Ot !== null && google.maps.event.removeListener(Ot), kt(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (xt !== null && google.maps.event.removeListener(xt), Pt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var mt = ep(ep(ep({}, n || pb), r ? pb : {
      map: H
    }), {}, {
      position: t
    }), ne = new google.maps.Marker(mt);
    return r ? r.addMarker(ne, !!o) : ne.setMap(H), t && ne.setPosition(t), typeof s < "u" && ne.setVisible(s), typeof a < "u" && ne.setDraggable(a), typeof u < "u" && ne.setClickable(u), typeof c == "string" && ne.setCursor(c), p && ne.setIcon(p), typeof d < "u" && ne.setLabel(d), typeof y < "u" && ne.setOpacity(y), f && ne.setShape(f), typeof v == "string" && ne.setTitle(v), typeof b == "number" && ne.setZIndex(b), w && T(google.maps.event.addListener(ne, "dblclick", w)), x && B(google.maps.event.addListener(ne, "dragend", x)), m && I(google.maps.event.addListener(ne, "dragstart", m)), k && he(google.maps.event.addListener(ne, "mousedown", k)), C && Be(google.maps.event.addListener(ne, "mouseout", C)), S && He(google.maps.event.addListener(ne, "mouseover", S)), U && nt(google.maps.event.addListener(ne, "mouseup", U)), N && Ce(google.maps.event.addListener(ne, "rightclick", N)), L && lt(google.maps.event.addListener(ne, "click", L)), D && Ee(google.maps.event.addListener(ne, "drag", D)), R && ze(google.maps.event.addListener(ne, "clickable_changed", R)), V && ot(google.maps.event.addListener(ne, "cursor_changed", V)), $ && yt(google.maps.event.addListener(ne, "animation_changed", $)), W && st(google.maps.event.addListener(ne, "draggable_changed", W)), Z && bt(google.maps.event.addListener(ne, "flat_changed", Z)), X && wt(google.maps.event.addListener(ne, "icon_changed", X)), K && gt(google.maps.event.addListener(ne, "position_changed", K)), Q && Ct(google.maps.event.addListener(ne, "shape_changed", Q)), J && Et(google.maps.event.addListener(ne, "title_changed", J)), P && kt(google.maps.event.addListener(ne, "visible_changed", P)), _ && Pt(google.maps.event.addListener(ne, "zindex_changed", _)), j(ne), z && z(ne), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), We !== null && google.maps.event.removeListener(We), Ie !== null && google.maps.event.removeListener(Ie), $e !== null && google.maps.event.removeListener($e), Qe !== null && google.maps.event.removeListener(Qe), Ae !== null && google.maps.event.removeListener(Ae), Re !== null && google.maps.event.removeListener(Re), ve !== null && google.maps.event.removeListener(ve), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), Ot !== null && google.maps.event.removeListener(Ot), xt !== null && google.maps.event.removeListener(xt), M && M(ne), r ? r.removeMarker(ne, !!o) : ne && ne.setMap(null);
    };
  }, []);
  var Vt = un(() => i ? at.map(i, (mt) => {
    if (!di(mt))
      return mt;
    var ne = mt;
    return fi(ne, {
      anchor: O
    });
  }) : null, [i, O]);
  return qi.jsx(qi.Fragment, {
    children: Vt
  }) || null;
}
me(nxe);
class rxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return UJ(function* () {
      var n = ep(ep(ep({}, t.props.options || pb), t.props.clusterer ? pb : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = yn({
        updaterMap: GF,
        eventMap: ZF,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: GF,
      eventMap: ZF,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), En(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!di(n))
        return n;
      var r = n;
      return fi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ke(rxe, "contextType", Rt);
var oxe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), ixe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new oxe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function sxe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var axe = 2e3, lxe = 500, uxe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", cxe = "png", pxe = [53, 56, 66, 78, 90], dxe = "cluster", qJ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || uxe, this.imageExtension = r.imageExtension || cxe, this.imageSizes = r.imageSizes || pxe, this.calculator = r.calculator || sxe, this.batchSize = r.batchSize || axe, this.batchSizeIE = r.batchSizeIE || lxe, this.clusterClass = r.clusterClass || dxe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new ixe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function YF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fxe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YF(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var As = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Tn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, hxe = {};
function gxe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, N] = E(null), R = ge(Rt), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, As.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, As.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, As.onClick, w)));
  }, [w]), h(() => {
    k && D && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(k, As.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (X !== null && google.maps.event.removeListener(X), Z(google.maps.event.addListener(k, As.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Tn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Tn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Tn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Tn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Tn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Tn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Tn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Tn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Tn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Tn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Tn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Tn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Tn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Tn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Tn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (R) {
      var z = fxe({}, n || hxe), M = new qJ(R, [], z);
      return r && Tn.averageCenter(M, r), o && Tn.batchSizeIE(M, o), i && Tn.calculator(M, i), a && Tn.clusterClass(M, a), s && Tn.enableRetinaIcons(M, s), l && Tn.gridSize(M, l), u && Tn.ignoreHidden(M, u), c && Tn.imageExtension(M, c), p && Tn.imagePath(M, p), d && Tn.imageSizes(M, d), y && Tn.maxZoom(M, y), f && Tn.minimumClusterSize(M, f), v && Tn.styles(M, v), b && Tn.title(M, b), L && Tn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, As.onMouseOut, C)), m && _(google.maps.event.addListener(M, As.onMouseOver, m)), w && $(google.maps.event.addListener(M, As.onClick, w)), D && Z(google.maps.event.addListener(M, As.onClusteringBegin, D)), x && K(google.maps.event.addListener(M, As.onClusteringEnd, x)), N(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(gxe);
class mxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      markerClusterer: null
    }), ke(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new qJ(this.context, [], this.props.options);
      this.registeredEvents = yn({
        updaterMap: Tn,
        eventMap: As,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: Tn,
      eventMap: As,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), En(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ke(mxe, "contextType", Rt);
function XF(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var ZJ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || XF(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, XF));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), vxe = ["position"], yxe = ["position"];
function KF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function db(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KF(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JF = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, QF = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, bxe = {};
function wxe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Rt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var R = r || bxe, {
        position: V
      } = R, $ = h_(R, vxe), W;
      V && !(V instanceof google.maps.LatLng) && (W = new google.maps.LatLng(V.lat, V.lng));
      var Z = new ZJ(db(db({}, $), W ? {
        position: W
      } : {}));
      N.current = document.createElement("div"), v(Z), a && L(google.maps.event.addListener(Z, "closeclick", a)), s && D(google.maps.event.addListener(Z, "domready", s)), l && m(google.maps.event.addListener(Z, "content_changed", l)), u && S(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(y, n) : Z.getPosition() ? Z.open(y) : Uo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(wxe);
class Cxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoBox: null
    }), ke(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Uo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ke(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = h_(t, yxe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new ZJ(db(db({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = yn({
      updaterMap: QF,
      eventMap: JF,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: QF,
      eventMap: JF,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), En(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
ke(Cxe, "contextType", Rt);
var ez, tz;
function Oxe() {
  return tz || (tz = 1, ez = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), ez;
}
var xxe = Oxe(), nz = /* @__PURE__ */ zJ(xxe), rz = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], YO = 1, ld = 8;
class g_ {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== YO)
      throw new Error("Got v".concat(o, " data when expected v").concat(YO, "."));
    var i = rz[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new g_(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = rz.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ld, t), this.coords = new this.ArrayType(this.data, ld + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ld + a + s + l), this.ids = new this.IndexArrayType(this.data, ld, t), this.coords = new this.ArrayType(this.data, ld + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (YO << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return wP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          oz(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      oz(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function wP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    GJ(e, t, a, r, o, i), wP(e, t, n, r, a - 1, 1 - i), wP(e, t, n, a + 1, o, 1 - i);
  }
}
function GJ(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      GJ(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (ud(e, t, r, n), t[2 * o + i] > y && ud(e, t, r, o); f < v; ) {
      for (ud(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? ud(e, t, r, v) : (v++, ud(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function ud(e, t, n, r) {
  XO(e, n, r), XO(t, 2 * n, 2 * r), XO(t, 2 * n + 1, 2 * r + 1);
}
function XO(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function oz(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Lxe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, iz = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Au = 2, Fl = 3, KO = 4, _l = 5, YJ = 6;
class Exe {
  constructor(t) {
    this.options = Object.assign(Object.create(Lxe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = iz(_m(u)), d = iz(Tm(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(_m(r), Tm(a), _m(i), Tm(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + _l] > 1 ? sz(p, f, this.clusterProps) : this.points[p[f + Fl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + KO] === t && p.push(a[y + _l] > 1 ? sz(a, y, this.clusterProps) : this.points[a[y + Fl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new g_(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + _l] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = XJ(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Fl]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = _m(f), d = Tm(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Fl] : L = this.points[n[l + Fl]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Au] <= n)) {
        l[p + Au] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + _l], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Au] > n && (b += l[w + _l]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Au] <= n)) {
              l[k + Au] = n;
              var N = l[k + _l];
              D += l[k] * N, x += l[k + 1] * N, l[k + KO] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + KO] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Au] <= n)) {
                l[$ + Au] = n;
                for (var W = 0; W < c; W++) u.push(l[$ + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + _l] > 1) {
      var o = this.clusterProps[t[n + YJ]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Fl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function sz(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Fl],
    properties: XJ(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [kxe(e[t]), Pxe(e[t + 1])]
    }
  };
}
function XJ(e, t, n) {
  var r = e[t + _l], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + YJ], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Fl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function _m(e) {
  return e / 360 + 0.5;
}
function Tm(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function kxe(e) {
  return (e - 0.5) * 360;
}
function Pxe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Sxe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class us {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class CP {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(us.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => us.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (us.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Mxe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Dxe(n);
  }
}
var Dxe = (e) => {
  var t = e.map((n) => new CP({
    position: us.getPosition(n),
    markers: [n]
  }));
  return t;
};
class _xe extends Mxe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Sxe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Exe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!nz(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = us.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !nz(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new CP({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new CP({
      markers: [i],
      position: us.getPosition(i)
    });
  }
}
class Txe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class jxe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (us.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function Axe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class m_ {
  constructor() {
    Axe(m_, google.maps.OverlayView);
  }
}
var ff;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(ff || (ff = {}));
var Bxe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Ixe extends m_ {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new _xe(o),
      renderer: a = new jxe(),
      onClusterClick: s = Bxe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (us.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, ff.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || us.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => us.setMap(l, null)));
      }
      google.maps.event.trigger(this, ff.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => us.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Txe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => us.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, ff.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), us.setMap(r.marker, n);
    });
  }
}
function az(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? az(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : az(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Rxe(e) {
  var t = BOe(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new Ixe(lz(lz({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Nxe(e) {
  var {
    children: t,
    options: n
  } = e, r = Rxe(n);
  return r !== null ? t(r) : null;
}
me(Nxe);
var uz = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, cz = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function Fxe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Rt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return v(R), N.current = document.createElement("div"), a && L(google.maps.event.addListener(R, "closeclick", a)), s && D(google.maps.event.addListener(R, "domready", s)), l && m(google.maps.event.addListener(R, "content_changed", l)), u && S(google.maps.event.addListener(R, "position_changed", u)), c && k(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(y, n) : R.getPosition() ? R.open(y) : Uo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(R), R.close();
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(Fxe);
class zxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoWindow: null
    }), ke(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Uo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ke(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = yn({
      updaterMap: cz,
      eventMap: uz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: cz,
      eventMap: uz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (En(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
ke(zxe, "contextType", Rt);
function pz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dz = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, fz = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Uxe = {};
function Wxe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Rt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(fb(fb({}, t || Uxe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && k(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && $(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && K(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), b && F(google.maps.event.addListener(T, "drag", b)), m(T), L && L(T), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(Wxe);
class Hxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      polyline: null
    }), ke(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(fb(fb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: fz,
      eventMap: dz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: fz,
      eventMap: dz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), En(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Hxe, "contextType", Rt);
function hz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mz = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, vz = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Vxe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Rt), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var B = new google.maps.Polygon(gz(gz({}, t), {}, {
      map: m
    }));
    return i && B.setPath(i), a && B.setPaths(a), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && k(google.maps.event.addListener(B, "dblclick", s)), l && R(google.maps.event.addListener(B, "dragend", l)), u && $(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && K(google.maps.event.addListener(B, "mousemove", p)), d && J(google.maps.event.addListener(B, "mouseout", d)), y && _(google.maps.event.addListener(B, "mouseover", y)), f && M(google.maps.event.addListener(B, "mouseup", f)), v && O(google.maps.event.addListener(B, "rightclick", v)), b && F(google.maps.event.addListener(B, "click", b)), L && q(google.maps.event.addListener(B, "drag", L)), S(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), D && D(B), B.setMap(null);
    };
  }, []), null;
}
me(Vxe);
class $xe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = yn({
      updaterMap: vz,
      eventMap: mz,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: vz,
      eventMap: mz,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), En(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ke($xe, "contextType", Rt);
function yz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bz = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, wz = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function qxe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Rt), [m, C] = E(null), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var Y = new google.maps.Rectangle(hb(hb({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && U(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && W(google.maps.event.addListener(Y, "mousedown", u)), c && X(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), y && z(google.maps.event.addListener(Y, "mouseup", y)), f && H(google.maps.event.addListener(Y, "rightclick", f)), v && j(google.maps.event.addListener(Y, "click", v)), b && T(google.maps.event.addListener(Y, "drag", b)), L && B(google.maps.event.addListener(Y, "bounds_changed", L)), C(Y), w && w(Y), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(Y), Y.setMap(null);
    };
  }, []), null;
}
me(qxe);
class Zxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      rectangle: null
    }), ke(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(hb(hb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: wz,
      eventMap: bz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: wz,
      eventMap: bz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), En(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Zxe, "contextType", Rt);
function Cz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Cz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Cz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Oz = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, xz = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Gxe = {};
function Yxe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Rt), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(gb(gb({}, t || Gxe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), y && z(google.maps.event.addListener(oe, "mouseover", y)), f && H(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), b && T(google.maps.event.addListener(oe, "click", b)), L && B(google.maps.event.addListener(oe, "drag", L)), w && I(google.maps.event.addListener(oe, "center_changed", w)), D && he(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), x && x(oe), () => {
      k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
me(Yxe);
class Xxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      circle: null
    }), ke(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(gb(gb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: xz,
      eventMap: Oz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: xz,
      eventMap: Oz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), En(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ke(Xxe, "contextType", Rt);
function Lz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Lz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Lz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ez = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, kz = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Kxe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Rt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var B = new google.maps.Data(mb(mb({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(B, "dblclick", r)), o && S(google.maps.event.addListener(B, "mousedown", o)), i && k(google.maps.event.addListener(B, "mousemove", i)), a && R(google.maps.event.addListener(B, "mouseout", a)), s && $(google.maps.event.addListener(B, "mouseover", s)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && K(google.maps.event.addListener(B, "rightclick", u)), n && J(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && O(google.maps.event.addListener(B, "removeproperty", d)), y && F(google.maps.event.addListener(B, "setgeometry", y)), f && q(google.maps.event.addListener(B, "setproperty", f)), D(B), v && v(B);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(Kxe);
class Jxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      data: null
    }), ke(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(mb(mb({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = yn({
        updaterMap: kz,
        eventMap: Ez,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: kz,
      eventMap: Ez,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), En(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Jxe, "contextType", Rt);
function Pz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Pz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mz = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Dz = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Qxe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      kmlLayer: null
    }), ke(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(Sz(Sz({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: Dz,
      eventMap: Mz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: Dz,
      eventMap: Mz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), En(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Qxe, "contextType", Rt);
function KJ(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function eLe(e, t) {
  return new t(e.lat, e.lng);
}
function tLe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function nLe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function rLe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function oLe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function iLe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function JJ(e, t, n, r) {
  return n !== void 0 ? oLe(e, t, rLe(n, google.maps.LatLngBounds, tLe)) : iLe(e, t, nLe(r, google.maps.LatLng, eLe));
}
function sLe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function _z(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _z(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _z(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function lLe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = aLe({}, this.container ? KJ(this.container, o) : {
        x: 0,
        y: 0
      }), u = JJ(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Tz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function jz(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Az(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function cLe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Rt), c = un(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = un(() => lLe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), hi.createPortal(l, c);
}
me(cLe);
class Mp extends pe {
  constructor(t) {
    super(t), ke(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ke(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Uo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ke(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ke(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = uLe({
        x: 0,
        y: 0
      }, this.containerRef.current ? KJ(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = JJ(r, o, this.props.bounds, this.props.position);
      if (!sLe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ke(this, "draw", () => {
      this.onPositionElement();
    }), ke(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = zn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = jz(t.position), r = jz(this.props.position), o = Az(t.bounds), i = Az(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? hi.createPortal(qi.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
ke(Mp, "FLOAT_PANE", "floatPane");
ke(Mp, "MAP_PANE", "mapPane");
ke(Mp, "MARKER_LAYER", "markerLayer");
ke(Mp, "OVERLAY_LAYER", "overlayLayer");
ke(Mp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ke(Mp, "contextType", Rt);
function pLe() {
}
function Bz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rz = {
  onDblClick: "dblclick",
  onClick: "click"
}, Nz = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function dLe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Rt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = un(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(dLe);
class QJ extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      groundOverlay: null
    }), ke(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Uo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Iz(Iz({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: Nz,
      eventMap: Rz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: Nz,
      eventMap: Rz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ke(QJ, "defaultProps", {
  onLoad: pLe
});
ke(QJ, "contextType", Rt);
function Fz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fz(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zz = {}, Uz = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function fLe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Rt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || Uo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Uo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(vb(vb({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(fLe);
class hLe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      heatmapLayer: null
    }), ke(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Uo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Uo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(vb(vb({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = yn({
      updaterMap: Uz,
      eventMap: zz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: Uz,
      eventMap: zz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), En(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(hLe, "contextType", Rt);
var Wz = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Hz = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class gLe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      streetViewPanorama: null
    }), ke(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = yn({
      updaterMap: Hz,
      eventMap: Wz,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: Hz,
      eventMap: Wz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), En(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ke(gLe, "contextType", Rt);
class mLe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      streetViewService: null
    }), ke(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ke(mLe, "contextType", Rt);
var Vz = {
  onDirectionsChanged: "directions_changed"
}, $z = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class vLe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      directionsRenderer: null
    }), ke(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = yn({
      updaterMap: $z,
      eventMap: Vz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: $z,
      eventMap: Vz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), En(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(vLe, "contextType", Rt);
var qz = {
  onPlacesChanged: "places_changed"
}, Zz = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class yLe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", zn()), ke(this, "state", {
      searchBox: null
    }), ke(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Uo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = yn({
          updaterMap: Zz,
          eventMap: qz,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: Zz,
      eventMap: qz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), En(this.registeredEvents));
  }
  render() {
    return qi.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
ke(yLe, "contextType", Rt);
var Gz = {
  onPlaceChanged: "place_changed"
}, Yz = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class eQ extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", zn()), ke(this, "state", {
      autocomplete: null
    }), ke(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Uo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = yn({
        updaterMap: Yz,
        eventMap: Gz,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    En(this.registeredEvents), this.registeredEvents = yn({
      updaterMap: Yz,
      eventMap: Gz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && En(this.registeredEvents);
  }
  render() {
    return qi.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
ke(eQ, "defaultProps", {
  className: ""
});
ke(eQ, "contextType", Rt);
let bLe = { data: "" }, wLe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || bLe, CLe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, OLe = /\/\*[^]*?\*\/|  +/g, Xz = /\n+/g, Yl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Yl(a, i) : i + "{" + Yl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Yl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Yl.p ? Yl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Aa = {}, tQ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + tQ(e[n]);
    return t;
  }
  return e;
}, xLe = (e, t, n, r, o) => {
  let i = tQ(e), a = Aa[i] || (Aa[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Aa[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = CLe.exec(u.replace(OLe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(Xz, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(Xz, " ").trim();
      return d[0];
    })(e);
    Aa[a] = Yl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Aa.g ? Aa.g : null;
  return n && (Aa.g = Aa[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Aa[a], t, r, s), a;
}, LLe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Yl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function z1(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return xLe(n.unshift ? n.raw ? LLe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, wLe(t.target), t.g, t.o, t.k);
}
let nQ, OP, xP;
z1.bind({ g: 1 });
let Ka = z1.bind({ k: 1 });
function ELe(e, t, n, r) {
  Yl.p = t, nQ = e, OP = n, xP = r;
}
function Lu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: OP && OP() }, s), n.o = / *go\d+/.test(l), s.className = z1.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), xP && u[0] && xP(s), nQ(u, s);
    }
    return o;
  };
}
var kLe = (e) => typeof e == "function", PLe = (e, t) => kLe(e) ? e(t) : e, SLe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), MLe = Ka`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, DLe = Ka`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, _Le = Ka`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, TLe = Lu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${MLe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${DLe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${_Le} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, jLe = Ka`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, ALe = Lu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${jLe} 1s linear infinite;
`, BLe = Ka`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, ILe = Ka`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, RLe = Lu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${BLe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${ILe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, NLe = Lu("div")`
  position: absolute;
`, FLe = Lu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, zLe = Ka`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, ULe = Lu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${zLe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, WLe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(ULe, null, t) : t : n === "blank" ? null : Ne.createElement(FLe, null, Ne.createElement(ALe, { ...r }), n !== "loading" && Ne.createElement(NLe, null, n === "error" ? Ne.createElement(TLe, { ...r }) : Ne.createElement(RLe, { ...r })));
}, HLe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, VLe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, $Le = "0%{opacity:0;} 100%{opacity:1;}", qLe = "0%{opacity:1;} 100%{opacity:0;}", ZLe = Lu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, GLe = Lu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, YLe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = SLe() ? [$Le, qLe] : [HLe(n), VLe(n)];
  return { animation: t ? `${Ka(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ka(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? YLe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(WLe, { toast: e }), a = Ne.createElement(GLe, { ...e.ariaProps }, PLe(e.message, e));
  return Ne.createElement(ZLe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
ELe(Ne.createElement);
z1`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ve({});
function XLe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const KLe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
XLe(KLe.CNPJ).length;
ma((e, t) => /* @__PURE__ */ $i.jsx("input", { ref: t, ...e }));
Ve({});
var al = {};
Object.defineProperty(al, "__esModule", {
  value: !0
});
var JLe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), JO = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, rQ = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: JLe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, v_ = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var jm = 1; jm < 20; jm++)
  v_["f" + jm] = 111 + jm;
function U1(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return oQ(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return iQ(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function QLe(e, t) {
  return U1(e, t);
}
function eEe(e, t) {
  return U1(e, { byKey: !0 }, t);
}
function oQ(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in JO)
    r[JO[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = y_(d), v = JO[f];
      if (d.length > 1 && !v && !rQ[d] && !v_[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = sQ(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function iQ(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function sQ(e) {
  e = y_(e);
  var t = v_[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function y_(e) {
  return e = e.toLowerCase(), e = rQ[e] || e, e;
}
al.default = U1;
var QO = al.isHotkey = U1;
al.isCodeHotkey = QLe;
al.isKeyHotkey = eEe;
al.parseHotkey = oQ;
al.compareHotkey = iQ;
al.toKeyCode = sQ;
al.toKeyName = y_;
var tEe = typeof wr == "object" && wr && wr.Object === Object && wr, nEe = tEe, rEe = nEe, oEe = typeof self == "object" && self && self.Object === Object && self, iEe = rEe || oEe || Function("return this")(), sEe = iEe, aEe = sEe, lEe = aEe.Symbol, aQ = lEe, Kz = aQ;
Kz && Kz.toStringTag;
var Jz = aQ;
Jz && Jz.toStringTag;
var Qz;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Qz || (Qz = {}));
var b_ = function(e) {
  return Object.freeze(e);
}, uEe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, b_(this);
  }
  return e;
}(), cEe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, b_(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), e2 = typeof window < "u" ? window : {};
/msie|trident/i.test(e2.navigator && e2.navigator.userAgent);
var ex = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new uEe((n ? t : e) || 0, (n ? e : t) || 0);
};
b_({
  devicePixelContentBoxSize: ex(),
  borderBoxSize: ex(),
  contentBoxSize: ex(),
  contentRect: new cEe(0, 0, 0, 0)
});
function ch(e) {
  "@babel/helpers - typeof";
  return ch = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ch(e);
}
function pEe(e, t) {
  if (ch(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ch(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dEe(e) {
  var t = pEe(e, "string");
  return ch(t) === "symbol" ? t : String(t);
}
function hf(e, t, n) {
  return t = dEe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var fEe = /* @__PURE__ */ Ve(null), tx, nx;
parseInt(we.version.split(".")[0], 10);
var t2 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), rx = typeof navigator < "u" && /Android/.test(navigator.userAgent), Am = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), hEe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (tx = navigator.userAgent.match(/Version\/(\d+)/)) !== null && tx !== void 0 && tx[1] && parseInt((nx = navigator.userAgent.match(/Version\/(\d+)/)) === null || nx === void 0 ? void 0 : nx[1], 10) < 17;
var gEe = /* @__PURE__ */ new WeakMap(), mEe = /* @__PURE__ */ new WeakMap(), vEe = /* @__PURE__ */ new WeakMap(), yEe = /* @__PURE__ */ new WeakMap(), bEe = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap(), wEe = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap(), Bm = /* @__PURE__ */ new WeakMap(), CEe = /* @__PURE__ */ new WeakMap(), OEe = /* @__PURE__ */ new WeakMap(), xEe = /* @__PURE__ */ new WeakMap(), lQ = globalThis.Node, LEe = globalThis.Text, uQ = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, EEe = (e) => yb(e) && e.nodeType === 8, ca = (e) => yb(e) && e.nodeType === 1, yb = (e) => {
  var t = uQ(e);
  return !!t && e instanceof t.Node;
}, o2 = (e) => {
  var t = e && e.anchorNode && uQ(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, kEe = (e) => {
  var [t, n] = e;
  if (ca(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = cQ(t, o, r ? "backward" : "forward"), r = o < n; ca(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = SEe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, PEe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, cQ = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (EEe(o) || ca(o) && o.childNodes.length === 0 || ca(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, SEe = (e, t, n) => {
  var [r] = cQ(e, t, n);
  return r;
}, i2 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), pQ = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ca(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = dn.getWindow(e);
  if (o.contains(r))
    return dn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : pQ(e, i, n);
}, s2 = (e, t) => !!(e.compareDocumentPosition(t) & lQ.DOCUMENT_POSITION_PRECEDING), MEe = (e, t) => !!(e.compareDocumentPosition(t) & lQ.DOCUMENT_POSITION_FOLLOWING), DEe = 0;
class _Ee {
  constructor() {
    hf(this, "id", void 0), this.id = "".concat(DEe++);
  }
}
var dn = {
  androidPendingDiffs: (e) => xEe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = OEe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = dn.toDOMNode(e, e), n = dn.findDocumentOrShadowRoot(e);
    Bm.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = dn.findDocumentOrShadowRoot(e), r = i2(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && eb.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = dn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = dn.toSlateNode(e, t.target), a = dn.findPath(e, i);
    if (Za.isElement(i) && dr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = dr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? dr.before(e, u) : dr.after(e, u);
      if (c) {
        var p = dr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = dn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = dn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = n2.get(t);
    return n || (n = new _Ee(), n2.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = mEe.get(r);
      if (o == null) {
        if (dr.isEditor(r))
          return n;
        break;
      }
      var i = gEe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(as.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Bm.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          dn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = dn.toDOMNode(e, e), r = dn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = i2(r), i = dn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || eb.select(e, dr.start(e, [])), Bm.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = vEe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = dn.toDOMNode(e, e), i;
    try {
      i = ca(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => yb(t) && dn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return dr.hasPath(e, n.path) && dr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => dn.hasEditableTarget(e, t) || dn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => yb(t) && dn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!CEe.get(e),
  isFocused: (e) => !!Bm.get(e),
  isReadOnly: (e) => !!r2.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (r2.get(e)) return !1;
    var n = dn.hasTarget(e, t) && dn.toSlateNode(e, t);
    return Za.isElement(n) && dr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = wEe.get(e), r = dr.isEditor(t) ? yEe.get(e) : n == null ? void 0 : n.get(dn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(as.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = dr.node(e, t.path), r = dn.toDOMNode(e, n), o;
    dr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof LEe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(as.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Kt.isBackward(t), i = dn.toDOMPoint(e, n), a = Kt.isCollapsed(t) ? i : dn.toDOMPoint(e, r), s = dn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = ca(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = ca(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ca(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? bEe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : kEe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = dn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = dn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (rx && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var N = U[k];
          if (dn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var R = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, W = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = W.find((M) => MEe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var Z, X = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = (Z = X.findLast((M) => s2(L, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      rx && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Am && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (rx && !u && !r) {
      var K = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (K && dn.hasDOMNode(e, K, {
        editable: !0
      })) {
        var Q = dn.toSlateNode(e, K), {
          path: J,
          offset: P
        } = dr.start(e, dn.findPath(e, Q));
        return K.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = dn.toSlateNode(e, u), z = dn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = o2(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (o2(t)) {
        if (Am && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        hEe && PEe(s) || Am ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Am && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = dn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = s2(s, u) || s === u && c < l, x = p ? w : dn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Kt.isExpanded(m) && Kt.isForward(m) && ca(u) && dr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = dr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, TEe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, jEe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, AEe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, qr = (e) => {
  var t = TEe[e], n = jEe[e], r = AEe[e], o = t && QO(t), i = n && QO(n), a = r && QO(r);
  return (s) => !!(o && o(s) || t2 && i && i(s) || !t2 && a && a(s));
};
qr("bold"), qr("compose"), qr("moveBackward"), qr("moveForward"), qr("deleteBackward"), qr("deleteForward"), qr("deleteLineBackward"), qr("deleteLineForward"), qr("deleteWordBackward"), qr("deleteWordForward"), qr("extendBackward"), qr("extendForward"), qr("extendLineBackward"), qr("extendLineForward"), qr("italic"), qr("moveLineBackward"), qr("moveLineForward"), qr("moveWordBackward"), qr("moveWordForward"), qr("redo"), qr("insertSoftBreak"), qr("splitBlock"), qr("transposeCharacter"), qr("undo");
var BEe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => pQ(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, IEe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class REe extends au {
  constructor() {
    super(...arguments), hf(this, "context", null), hf(this, "manager", null), hf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, IEe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = BEe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
hf(REe, "contextType", fEe);
Ve({});
Ve({});
Ve({});
var Ao = {}, w_ = {}, Ah = {}, Bh = {}, dQ = "Expected a function", a2 = NaN, NEe = "[object Symbol]", FEe = /^\s+|\s+$/g, zEe = /^[-+]0x[0-9a-f]+$/i, UEe = /^0b[01]+$/i, WEe = /^0o[0-7]+$/i, HEe = parseInt, VEe = typeof wr == "object" && wr && wr.Object === Object && wr, $Ee = typeof self == "object" && self && self.Object === Object && self, qEe = VEe || $Ee || Function("return this")(), ZEe = Object.prototype, GEe = ZEe.toString, YEe = Math.max, XEe = Math.min, ox = function() {
  return qEe.Date.now();
};
function KEe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(dQ);
  t = l2(t) || 0, bb(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? YEe(l2(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? XEe(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = ox();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(ox());
  }
  function m() {
    var C = ox(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function JEe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(dQ);
  return bb(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), KEe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function bb(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function QEe(e) {
  return !!e && typeof e == "object";
}
function eke(e) {
  return typeof e == "symbol" || QEe(e) && GEe.call(e) == NEe;
}
function l2(e) {
  if (typeof e == "number")
    return e;
  if (eke(e))
    return a2;
  if (bb(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = bb(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(FEe, "");
  var n = UEe.test(e);
  return n || WEe.test(e) ? HEe(e.slice(2), n ? 2 : 8) : zEe.test(e) ? a2 : +e;
}
var tke = JEe, Ih = {};
Object.defineProperty(Ih, "__esModule", {
  value: !0
});
Ih.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), iy.has(t) || iy.set(t, /* @__PURE__ */ new Set());
  var o = iy.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Ih.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), iy.get(t).delete(n.name || t);
};
var iy = /* @__PURE__ */ new Map();
Object.defineProperty(Bh, "__esModule", {
  value: !0
});
var nke = tke, rke = ike(nke), oke = Ih;
function ike(e) {
  return e && e.__esModule ? e : { default: e };
}
var ske = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, rke.default)(e, t);
}, co = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = ske(function(r) {
        co.scrollHandler(e);
      }, t);
      co.scrollSpyContainers.push(e), (0, oke.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return co.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = co.scrollSpyContainers[co.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(co.currentPositionX(e), co.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    co.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = co.scrollSpyContainers[co.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(co.currentPositionX(t), co.currentPositionY(t));
  },
  updateStates: function() {
    co.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    co.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), co.spySetState && co.spySetState.length && co.spySetState.indexOf(e) > -1 && co.spySetState.splice(co.spySetState.indexOf(e), 1), document.removeEventListener("scroll", co.scrollHandler);
  },
  update: function() {
    return co.scrollSpyContainers.forEach(function(e) {
      return co.scrollHandler(e);
    });
  }
};
Bh.default = co;
var Dp = {}, Rh = {};
Object.defineProperty(Rh, "__esModule", {
  value: !0
});
var ake = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, lke = function() {
  return window.location.hash.replace(/^#/, "");
}, uke = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, cke = function(e) {
  return getComputedStyle(e).position !== "static";
}, ix = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, pke = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (cke(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = ix(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return ix(t, s).offsetTop - ix(e, s).offsetTop;
};
Rh.default = {
  updateHash: ake,
  getHash: lke,
  filterElementInContainer: uke,
  scrollOffset: pke
};
var W1 = {}, C_ = {};
Object.defineProperty(C_, "__esModule", {
  value: !0
});
C_.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var O_ = {};
Object.defineProperty(O_, "__esModule", {
  value: !0
});
var dke = Ih, fke = ["mousedown", "mousewheel", "touchmove", "keydown"];
O_.default = {
  subscribe: function(e) {
    return typeof document < "u" && fke.forEach(function(t) {
      return (0, dke.addPassiveEventListener)(document, t, e);
    });
  }
};
var Nh = {};
Object.defineProperty(Nh, "__esModule", {
  value: !0
});
var LP = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      LP.registered[e] = t;
    },
    remove: function(e) {
      LP.registered[e] = null;
    }
  }
};
Nh.default = LP;
Object.defineProperty(W1, "__esModule", {
  value: !0
});
var hke = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, gke = Rh;
H1(gke);
var mke = C_, u2 = H1(mke), vke = O_, yke = H1(vke), bke = Nh, na = H1(bke);
function H1(e) {
  return e && e.__esModule ? e : { default: e };
}
var fQ = function(e) {
  return u2.default[e.smooth] || u2.default.defaultEasing;
}, wke = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Cke = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, EP = function() {
  return Cke() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), hQ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, gQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, mQ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Oke = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, xke = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Lke = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    na.default.registered.end && na.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    EP.call(window, i);
    return;
  }
  na.default.registered.end && na.default.registered.end(o.to, o.target, o.currentPosition);
}, x_ = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Fh = function(e, t, n, r) {
  t.data = t.data || hQ(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (yke.default.subscribe(o), x_(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? gQ(t) : mQ(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    na.default.registered.end && na.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = wke(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = fQ(t), a = Lke.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      na.default.registered.begin && na.default.registered.begin(t.data.to, t.data.target), EP.call(window, a);
    }, t.delay);
    return;
  }
  na.default.registered.begin && na.default.registered.begin(t.data.to, t.data.target), EP.call(window, a);
}, V1 = function(e) {
  return e = hke({}, e), e.data = e.data || hQ(), e.absolute = !0, e;
}, Eke = function(e) {
  Fh(0, V1(e));
}, kke = function(e, t) {
  Fh(e, V1(t));
}, Pke = function(e) {
  e = V1(e), x_(e), Fh(e.horizontal ? Oke(e) : xke(e), e);
}, Ske = function(e, t) {
  t = V1(t), x_(t);
  var n = t.horizontal ? gQ(t) : mQ(t);
  Fh(e + n, t);
};
W1.default = {
  animateTopScroll: Fh,
  getAnimationType: fQ,
  scrollToTop: Eke,
  scrollToBottom: Pke,
  scrollTo: kke,
  scrollMore: Ske
};
Object.defineProperty(Dp, "__esModule", {
  value: !0
});
var Mke = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Dke = Rh, _ke = L_(Dke), Tke = W1, jke = L_(Tke), Ake = Nh, Im = L_(Ake);
function L_(e) {
  return e && e.__esModule ? e : { default: e };
}
var Rm = {}, c2 = void 0;
Dp.default = {
  unmount: function() {
    Rm = {};
  },
  register: function(e, t) {
    Rm[e] = t;
  },
  unregister: function(e) {
    delete Rm[e];
  },
  get: function(e) {
    return Rm[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return c2 = e;
  },
  getActiveLink: function() {
    return c2;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Mke({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = _ke.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Im.default.registered.begin && Im.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Im.default.registered.end && Im.default.registered.end(e, n);
      return;
    }
    jke.default.animateTopScroll(s, t, e, n);
  }
};
var kP = { exports: {} }, sx = { exports: {} }, Vn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var p2;
function Bke() {
  if (p2) return Vn;
  p2 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Vn.AsyncMode = l, Vn.ConcurrentMode = u, Vn.ContextConsumer = s, Vn.ContextProvider = a, Vn.Element = t, Vn.ForwardRef = c, Vn.Fragment = r, Vn.Lazy = f, Vn.Memo = y, Vn.Portal = n, Vn.Profiler = i, Vn.StrictMode = o, Vn.Suspense = p, Vn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Vn.isConcurrentMode = x, Vn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Vn.isContextProvider = function(m) {
    return D(m) === a;
  }, Vn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Vn.isForwardRef = function(m) {
    return D(m) === c;
  }, Vn.isFragment = function(m) {
    return D(m) === r;
  }, Vn.isLazy = function(m) {
    return D(m) === f;
  }, Vn.isMemo = function(m) {
    return D(m) === y;
  }, Vn.isPortal = function(m) {
    return D(m) === n;
  }, Vn.isProfiler = function(m) {
    return D(m) === i;
  }, Vn.isStrictMode = function(m) {
    return D(m) === o;
  }, Vn.isSuspense = function(m) {
    return D(m) === p;
  }, Vn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, Vn.typeOf = D, Vn;
}
var er = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var d2;
function Ike() {
  return d2 || (d2 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === y || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === L || I.$$typeof === w || I.$$typeof === v);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, N = c, R = r, V = f, $ = y, W = n, Z = i, X = o, K = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(I) || x(I) === l;
    }
    function P(I) {
      return x(I) === u;
    }
    function _(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function M(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function H(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function F(I) {
      return x(I) === y;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function B(I) {
      return x(I) === o;
    }
    function Y(I) {
      return x(I) === p;
    }
    er.AsyncMode = m, er.ConcurrentMode = C, er.ContextConsumer = S, er.ContextProvider = U, er.Element = k, er.ForwardRef = N, er.Fragment = R, er.Lazy = V, er.Memo = $, er.Portal = W, er.Profiler = Z, er.StrictMode = X, er.Suspense = K, er.isAsyncMode = J, er.isConcurrentMode = P, er.isContextConsumer = _, er.isContextProvider = z, er.isElement = M, er.isForwardRef = H, er.isFragment = O, er.isLazy = j, er.isMemo = F, er.isPortal = T, er.isProfiler = q, er.isStrictMode = B, er.isSuspense = Y, er.isValidElementType = D, er.typeOf = x;
  }()), er;
}
var f2;
function vQ() {
  return f2 || (f2 = 1, process.env.NODE_ENV === "production" ? sx.exports = Bke() : sx.exports = Ike()), sx.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var ax, h2;
function Rke() {
  if (h2) return ax;
  h2 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return ax = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, ax;
}
var lx, g2;
function E_() {
  if (g2) return lx;
  g2 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return lx = e, lx;
}
var m2, v2;
function yQ() {
  return v2 || (v2 = 1, m2 = Function.call.bind(Object.prototype.hasOwnProperty)), m2;
}
var ux, y2;
function Nke() {
  if (y2) return ux;
  y2 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = E_(), n = {}, r = yQ();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, ux = o, ux;
}
var cx, b2;
function Fke() {
  if (b2) return cx;
  b2 = 1;
  var e = vQ(), t = Rke(), n = E_(), r = yQ(), o = Nke(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return cx = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: N(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, j, F, T, q, B, Y) {
        if (T = T || d, B = B || F, Y !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + q + " `" + B + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + q + " `" + B + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, F, T, q, B);
      }
      var H = M.bind(null, !1);
      return H.isRequired = M.bind(null, !0), H;
    }
    function L(P) {
      function _(z, M, H, O, j, F) {
        var T = z[M], q = X(T);
        if (q !== P) {
          var B = K(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + B + "` supplied to `" + H + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var T = X(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var B = P(F, q, H, O, j + "[" + q + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!s(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!e.isValidElementType(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, H, O, j) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, T = J(z[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, H, O, j) {
        for (var F = z[M], T = 0; T < P.length; T++)
          if (f(F, P[T]))
            return null;
        var q = JSON.stringify(P, function(B, Y) {
          var I = K(Y);
          return I === "symbol" ? String(Y) : Y;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + H + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside objectOf.");
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var B = P(F, q, H, O, j + "." + q, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(H, O, j, F, T) {
        for (var q = [], B = 0; B < P.length; B++) {
          var Y = P[B], I = Y(H, O, j, F, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(M);
    }
    function N() {
      function P(_, z, M, H, O) {
        return W(_[z]) ? null : new v("Invalid " + H + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, _, z, M, H) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + H + "`."
      );
    }
    function V(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        for (var q in P) {
          var B = P[q];
          if (typeof B != "function")
            return R(H, O, j, q, K(B));
          var Y = B(F, q, H, O, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var B in q) {
          var Y = P[B];
          if (r(P, B) && typeof Y != "function")
            return R(H, O, j, B, K(Y));
          if (!Y)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + B + "` supplied to `" + H + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var I = Y(F, B, H, O, j + "." + B, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(_);
    }
    function W(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(W);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var H = M.value;
                if (H && !W(H[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function X(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(_, P) ? "symbol" : _;
    }
    function K(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = X(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = K(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, cx;
}
var px, w2;
function zke() {
  if (w2) return px;
  w2 = 1;
  var e = E_();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, px = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, px;
}
if (process.env.NODE_ENV !== "production") {
  var Uke = vQ(), Wke = !0;
  kP.exports = Fke()(Uke.isElement, Wke);
} else
  kP.exports = zke()();
var $1 = kP.exports, q1 = {};
Object.defineProperty(q1, "__esModule", {
  value: !0
});
var Hke = Rh, dx = Vke(Hke);
function Vke(e) {
  return e && e.__esModule ? e : { default: e };
}
var $ke = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return dx.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && dx.default.getHash() !== e && dx.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
q1.default = $ke;
Object.defineProperty(Ah, "__esModule", {
  value: !0
});
var Nm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qke = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Zke = we, C2 = zh(Zke), Gke = Bh, Fm = zh(Gke), Yke = Dp, Xke = zh(Yke), Kke = $1, Zr = zh(Kke), Jke = q1, ml = zh(Jke);
function zh(e) {
  return e && e.__esModule ? e : { default: e };
}
function Qke(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ePe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var O2 = {
  to: Zr.default.string.isRequired,
  containerId: Zr.default.string,
  container: Zr.default.object,
  activeClass: Zr.default.string,
  activeStyle: Zr.default.object,
  spy: Zr.default.bool,
  horizontal: Zr.default.bool,
  smooth: Zr.default.oneOfType([Zr.default.bool, Zr.default.string]),
  offset: Zr.default.number,
  delay: Zr.default.number,
  isDynamic: Zr.default.bool,
  onClick: Zr.default.func,
  duration: Zr.default.oneOfType([Zr.default.number, Zr.default.func]),
  absolute: Zr.default.bool,
  onSetActive: Zr.default.func,
  onSetInactive: Zr.default.func,
  ignoreCancelEvents: Zr.default.bool,
  hashSpy: Zr.default.bool,
  saveHashHistory: Zr.default.bool,
  spyThrottle: Zr.default.number
};
Ah.default = function(e, t) {
  var n = t || Xke.default, r = function(i) {
    tPe(a, i);
    function a(s) {
      Qke(this, a);
      var l = ePe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return qke(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Fm.default.isMounted(s) || Fm.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (ml.default.isMounted() || ml.default.mount(n), ml.default.mapContainer(this.props.to, s)), Fm.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Fm.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Nm({}, this.props.style, this.props.activeStyle) : l = Nm({}, this.props.style);
        var u = Nm({}, this.props);
        for (var c in O2)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, C2.default.createElement(e, u);
      }
    }]), a;
  }(C2.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Nm({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(ml.default.isMounted() && !ml.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var N = n.getActiveLink();
        if (y) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && ml.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            ml.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, W = $ === void 0 ? !1 : $;
          i.props.hashSpy && ml.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = O2, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(w_, "__esModule", {
  value: !0
});
var nPe = we, x2 = bQ(nPe), rPe = Ah, oPe = bQ(rPe);
function bQ(e) {
  return e && e.__esModule ? e : { default: e };
}
function iPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function L2(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var aPe = function(e) {
  sPe(t, e);
  function t() {
    var n, r, o, i;
    iPe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = L2(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return x2.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), L2(o, i);
  }
  return t;
}(x2.default.Component);
w_.default = (0, oPe.default)(aPe);
var k_ = {};
Object.defineProperty(k_, "__esModule", {
  value: !0
});
var lPe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), uPe = we, E2 = wQ(uPe), cPe = Ah, pPe = wQ(cPe);
function wQ(e) {
  return e && e.__esModule ? e : { default: e };
}
function dPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fPe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function hPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gPe = function(e) {
  hPe(t, e);
  function t() {
    return dPe(this, t), fPe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return lPe(t, [{
    key: "render",
    value: function() {
      return E2.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(E2.default.Component);
k_.default = (0, pPe.default)(gPe);
var P_ = {}, Z1 = {};
Object.defineProperty(Z1, "__esModule", {
  value: !0
});
var mPe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, vPe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), yPe = we, k2 = G1(yPe), bPe = il;
G1(bPe);
var wPe = Dp, P2 = G1(wPe), CPe = $1, S2 = G1(CPe);
function G1(e) {
  return e && e.__esModule ? e : { default: e };
}
function OPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function xPe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function LPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Z1.default = function(e) {
  var t = function(n) {
    LPe(r, n);
    function r(o) {
      OPe(this, r);
      var i = xPe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return vPe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        P2.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        P2.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return k2.default.createElement(e, mPe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(k2.default.Component);
  return t.propTypes = {
    name: S2.default.string,
    id: S2.default.string
  }, t;
};
Object.defineProperty(P_, "__esModule", {
  value: !0
});
var M2 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, EPe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), kPe = we, D2 = S_(kPe), PPe = Z1, SPe = S_(PPe), MPe = $1, _2 = S_(MPe);
function S_(e) {
  return e && e.__esModule ? e : { default: e };
}
function DPe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _Pe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function TPe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var CQ = function(e) {
  TPe(t, e);
  function t() {
    return DPe(this, t), _Pe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return EPe(t, [{
    key: "render",
    value: function() {
      var n = this, r = M2({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, D2.default.createElement(
        "div",
        M2({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(D2.default.Component);
CQ.propTypes = {
  name: _2.default.string,
  id: _2.default.string
};
P_.default = (0, SPe.default)(CQ);
var fx = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, T2 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function j2(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function A2(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function B2(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var zm = we, Bu = Bh, hx = Dp, bo = $1, vl = q1, I2 = {
  to: bo.string.isRequired,
  containerId: bo.string,
  container: bo.object,
  activeClass: bo.string,
  spy: bo.bool,
  smooth: bo.oneOfType([bo.bool, bo.string]),
  offset: bo.number,
  delay: bo.number,
  isDynamic: bo.bool,
  onClick: bo.func,
  duration: bo.oneOfType([bo.number, bo.func]),
  absolute: bo.bool,
  onSetActive: bo.func,
  onSetInactive: bo.func,
  ignoreCancelEvents: bo.bool,
  hashSpy: bo.bool,
  spyThrottle: bo.number
}, jPe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || hx, r = function(i) {
      B2(a, i);
      function a(s) {
        j2(this, a);
        var l = A2(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return T2(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Bu.isMounted(s) || Bu.mount(s, this.props.spyThrottle), this.props.hashSpy && (vl.isMounted() || vl.mount(n), vl.mapContainer(this.props.to, s)), this.props.spy && Bu.addStateHandler(this.stateHandler), Bu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Bu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = fx({}, this.props);
          for (var u in I2)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, zm.createElement(e, l);
        }
      }]), a;
    }(zm.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, fx({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(vl.isMounted() && !vl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && vl.getHash() === l && vl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Bu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && vl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Bu.updateStates();
        }
      };
    };
    return r.propTypes = I2, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      B2(r, n);
      function r(o) {
        j2(this, r);
        var i = A2(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return T2(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          hx.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          hx.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return zm.createElement(e, fx({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(zm.Component);
    return t.propTypes = {
      name: bo.string,
      id: bo.string
    }, t;
  }
}, APe = jPe;
Object.defineProperty(Ao, "__esModule", {
  value: !0
});
Ao.Helpers = Ao.ScrollElement = Ao.ScrollLink = Ao.animateScroll = Ao.scrollSpy = Ao.Events = Ao.scroller = Ao.Element = Ao.Button = Ao.Link = void 0;
var BPe = w_, OQ = ba(BPe), IPe = k_, xQ = ba(IPe), RPe = P_, LQ = ba(RPe), NPe = Dp, EQ = ba(NPe), FPe = Nh, kQ = ba(FPe), zPe = Bh, PQ = ba(zPe), UPe = W1, SQ = ba(UPe), WPe = Ah, MQ = ba(WPe), HPe = Z1, DQ = ba(HPe), VPe = APe, _Q = ba(VPe);
function ba(e) {
  return e && e.__esModule ? e : { default: e };
}
Ao.Link = OQ.default;
Ao.Button = xQ.default;
Ao.Element = LQ.default;
Ao.scroller = EQ.default;
Ao.Events = kQ.default;
Ao.scrollSpy = PQ.default;
Ao.animateScroll = SQ.default;
Ao.ScrollLink = MQ.default;
Ao.ScrollElement = DQ.default;
Ao.Helpers = _Q.default;
Ao.default = { Link: OQ.default, Button: xQ.default, Element: LQ.default, scroller: EQ.default, Events: kQ.default, scrollSpy: PQ.default, animateScroll: SQ.default, ScrollLink: MQ.default, ScrollElement: DQ.default, Helpers: _Q.default };
Ve({});
Ve({});
Ve({});
function ph(e) {
  "@babel/helpers - typeof";
  return ph = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ph(e);
}
function $Pe(e, t) {
  if (ph(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ph(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qPe(e) {
  var t = $Pe(e, "string");
  return ph(t) == "symbol" ? t : t + "";
}
function Pe(e, t, n) {
  return (t = qPe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function TQ(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var gx, R2;
function ZPe() {
  if (R2) return gx;
  R2 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return gx = t, gx;
}
var GPe = ZPe(), Wo = /* @__PURE__ */ TQ(GPe), Nt = Ve(null);
function YPe() {
  Wo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Nt);
  return Wo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function XPe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function KPe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function JPe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return KPe(e, i), o;
}
function QPe(e, t, n) {
  var r = XPe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function eSe(e) {
  google.maps.event.removeListener(e);
}
function kn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(eSe);
}
function bn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = QPe(o, i, n);
  return JPe(t, r, o, i), a;
}
function tSe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = ht(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null), [B, Y] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (B !== null && google.maps.event.removeListener(B), Y(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var I = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(I), I !== null && D && D(I), () => {
      I !== null && x && x(I);
    };
  }, []), $i.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: $i.jsx(Nt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(tSe);
function N2(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function jQ(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        N2(i, r, o, a, s, "next", l);
      }
      function s(l) {
        N2(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function AQ(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Wo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var hc = typeof document < "u";
function BQ(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return hc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function F2(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function IQ() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return F2(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return F2(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var cd = !1;
function RQ() {
  return $i.jsx("div", {
    children: "Loading..."
  });
}
var PP = {
  id: "script-loader",
  version: "weekly"
};
class nSe extends pe {
  constructor() {
    super(...arguments), Pe(this, "check", zn()), Pe(this, "state", {
      loaded: !1
    }), Pe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Pe(this, "isCleaningUp", /* @__PURE__ */ jQ(function* () {
      function t(n) {
        if (!cd)
          n();
        else if (hc)
          var r = window.setInterval(function() {
            cd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Pe(this, "cleanup", () => {
      cd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Pe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && IQ(), Wo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: AQ(this.props)
      };
      BQ(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (hc) {
      if (window.google && window.google.maps && !cd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), hc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (hc) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, cd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return $i.jsxs($i.Fragment, {
      children: [$i.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || $i.jsx(RQ, {})]
    });
  }
}
Pe(nSe, "defaultProps", PP);
function rSe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function M_(e, t) {
  if (e == null) return {};
  var n, r, o = rSe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var z2;
function oSe(e) {
  var {
    id: t = PP.id,
    version: n = PP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = ht(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    hc && u && IQ();
  }, [u]), h(function() {
    f && Wo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = AQ({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!hc)
      return;
    function x() {
      y.current && (v(!0), z2 = w);
    }
    if (window.google && window.google.maps && z2 === w) {
      x();
      return;
    }
    BQ({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = ht();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var iSe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], sSe = $i.jsx(RQ, {});
function aSe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = M_(e, iSe), {
    isLoaded: s,
    loadError: l
  } = oSe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || sSe;
}
me(aSe);
var U2;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(U2 || (U2 = {}));
function W2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? W2(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H2 = {}, V2 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function lSe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Nt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(wb(wb({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(lSe);
class uSe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      trafficLayer: null
    }), Pe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(wb(wb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: V2,
      eventMap: H2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: V2,
      eventMap: H2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), kn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(uSe, "contextType", Nt);
function cSe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Nt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(cSe);
class pSe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      bicyclingLayer: null
    }), Pe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(pSe, "contextType", Nt);
function dSe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Nt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(dSe);
class fSe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      transitLayer: null
    }), Pe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(fSe, "contextType", Nt);
function $2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $2(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var q2 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Z2 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function hSe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Nt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Wo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Cb(Cb({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && v(google.maps.event.addListener(N, "circlecomplete", r)), o && L(google.maps.event.addListener(N, "markercomplete", o)), i && D(google.maps.event.addListener(N, "overlaycomplete", i)), a && m(google.maps.event.addListener(N, "polygoncomplete", a)), s && S(google.maps.event.addListener(N, "polylinecomplete", s)), l && k(google.maps.event.addListener(N, "rectanglecomplete", l)), y(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(hSe);
class gSe extends pe {
  constructor(t) {
    super(t), Pe(this, "registeredEvents", []), Pe(this, "state", {
      drawingManager: null
    }), Pe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Wo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Cb(Cb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: Z2,
      eventMap: q2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: Z2,
      eventMap: q2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), kn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(gSe, "contextType", Nt);
function G2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G2(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Y2 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, X2 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Ob = {};
function mSe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: W,
    onFlatChanged: Z,
    onIconChanged: X,
    onPositionChanged: K,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, H = ge(Nt), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null), [oe, Be] = E(null), [We, He] = E(null), [Ie, nt] = E(null), [$e, Ce] = E(null), [Qe, lt] = E(null), [be, Ee] = E(null), [Ae, ze] = E(null), [Re, ot] = E(null), [ve, yt] = E(null), [it, st] = E(null), [ut, bt] = E(null), [ct, wt] = E(null), [tt, gt] = E(null), [rt, Ct] = E(null), [pt, Et] = E(null), [Ot, kt] = E(null), [xt, Pt] = E(null);
  h(() => {
    O !== null && O.setMap(H);
  }, [H]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), He(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Ie !== null && google.maps.event.removeListener(Ie), nt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && N && ($e !== null && google.maps.event.removeListener($e), Ce(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), h(() => {
    O && L && (Qe !== null && google.maps.event.removeListener(Qe), lt(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (be !== null && google.maps.event.removeListener(be), Ee(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && R && (Ae !== null && google.maps.event.removeListener(Ae), ze(google.maps.event.addListener(O, "clickable_changed", R)));
  }, [R]), h(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), ot(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), yt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && W && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), bt(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && X && (ct !== null && google.maps.event.removeListener(ct), wt(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), h(() => {
    O && K && (tt !== null && google.maps.event.removeListener(tt), gt(google.maps.event.addListener(O, "position_changed", K)));
  }, [K]), h(() => {
    O && Q && (rt !== null && google.maps.event.removeListener(rt), Ct(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Et(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Ot !== null && google.maps.event.removeListener(Ot), kt(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (xt !== null && google.maps.event.removeListener(xt), Pt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var mt = tp(tp(tp({}, n || Ob), r ? Ob : {
      map: H
    }), {}, {
      position: t
    }), ne = new google.maps.Marker(mt);
    return r ? r.addMarker(ne, !!o) : ne.setMap(H), t && ne.setPosition(t), typeof s < "u" && ne.setVisible(s), typeof a < "u" && ne.setDraggable(a), typeof u < "u" && ne.setClickable(u), typeof c == "string" && ne.setCursor(c), p && ne.setIcon(p), typeof d < "u" && ne.setLabel(d), typeof y < "u" && ne.setOpacity(y), f && ne.setShape(f), typeof v == "string" && ne.setTitle(v), typeof b == "number" && ne.setZIndex(b), w && T(google.maps.event.addListener(ne, "dblclick", w)), x && B(google.maps.event.addListener(ne, "dragend", x)), m && I(google.maps.event.addListener(ne, "dragstart", m)), k && he(google.maps.event.addListener(ne, "mousedown", k)), C && Be(google.maps.event.addListener(ne, "mouseout", C)), S && He(google.maps.event.addListener(ne, "mouseover", S)), U && nt(google.maps.event.addListener(ne, "mouseup", U)), N && Ce(google.maps.event.addListener(ne, "rightclick", N)), L && lt(google.maps.event.addListener(ne, "click", L)), D && Ee(google.maps.event.addListener(ne, "drag", D)), R && ze(google.maps.event.addListener(ne, "clickable_changed", R)), V && ot(google.maps.event.addListener(ne, "cursor_changed", V)), $ && yt(google.maps.event.addListener(ne, "animation_changed", $)), W && st(google.maps.event.addListener(ne, "draggable_changed", W)), Z && bt(google.maps.event.addListener(ne, "flat_changed", Z)), X && wt(google.maps.event.addListener(ne, "icon_changed", X)), K && gt(google.maps.event.addListener(ne, "position_changed", K)), Q && Ct(google.maps.event.addListener(ne, "shape_changed", Q)), J && Et(google.maps.event.addListener(ne, "title_changed", J)), P && kt(google.maps.event.addListener(ne, "visible_changed", P)), _ && Pt(google.maps.event.addListener(ne, "zindex_changed", _)), j(ne), z && z(ne), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), We !== null && google.maps.event.removeListener(We), Ie !== null && google.maps.event.removeListener(Ie), $e !== null && google.maps.event.removeListener($e), Qe !== null && google.maps.event.removeListener(Qe), Ae !== null && google.maps.event.removeListener(Ae), Re !== null && google.maps.event.removeListener(Re), ve !== null && google.maps.event.removeListener(ve), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), Ot !== null && google.maps.event.removeListener(Ot), xt !== null && google.maps.event.removeListener(xt), M && M(ne), r ? r.removeMarker(ne, !!o) : ne && ne.setMap(null);
    };
  }, []);
  var Vt = un(() => i ? at.map(i, (mt) => {
    if (!di(mt))
      return mt;
    var ne = mt;
    return fi(ne, {
      anchor: O
    });
  }) : null, [i, O]);
  return $i.jsx($i.Fragment, {
    children: Vt
  }) || null;
}
me(mSe);
class vSe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return jQ(function* () {
      var n = tp(tp(tp({}, t.props.options || Ob), t.props.clusterer ? Ob : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = bn({
        updaterMap: X2,
        eventMap: Y2,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: X2,
      eventMap: Y2,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), kn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!di(n))
        return n;
      var r = n;
      return fi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Pe(vSe, "contextType", Nt);
var ySe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), bSe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new ySe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function wSe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var CSe = 2e3, OSe = 500, xSe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", LSe = "png", ESe = [53, 56, 66, 78, 90], kSe = "cluster", NQ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || xSe, this.imageExtension = r.imageExtension || LSe, this.imageSizes = r.imageSizes || ESe, this.calculator = r.calculator || wSe, this.batchSize = r.batchSize || CSe, this.batchSizeIE = r.batchSizeIE || OSe, this.clusterClass = r.clusterClass || kSe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new bSe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function K2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function PSe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K2(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, jn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, SSe = {};
function MSe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, N] = E(null), R = ge(Nt), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, Bs.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, Bs.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, Bs.onClick, w)));
  }, [w]), h(() => {
    k && D && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(k, Bs.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (X !== null && google.maps.event.removeListener(X), Z(google.maps.event.addListener(k, Bs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && jn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && jn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && jn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && jn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && jn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && jn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && jn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && jn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && jn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && jn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && jn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && jn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && jn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && jn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && jn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (R) {
      var z = PSe({}, n || SSe), M = new NQ(R, [], z);
      return r && jn.averageCenter(M, r), o && jn.batchSizeIE(M, o), i && jn.calculator(M, i), a && jn.clusterClass(M, a), s && jn.enableRetinaIcons(M, s), l && jn.gridSize(M, l), u && jn.ignoreHidden(M, u), c && jn.imageExtension(M, c), p && jn.imagePath(M, p), d && jn.imageSizes(M, d), y && jn.maxZoom(M, y), f && jn.minimumClusterSize(M, f), v && jn.styles(M, v), b && jn.title(M, b), L && jn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, Bs.onMouseOut, C)), m && _(google.maps.event.addListener(M, Bs.onMouseOver, m)), w && $(google.maps.event.addListener(M, Bs.onClick, w)), D && Z(google.maps.event.addListener(M, Bs.onClusteringBegin, D)), x && K(google.maps.event.addListener(M, Bs.onClusteringEnd, x)), N(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(MSe);
class DSe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      markerClusterer: null
    }), Pe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new NQ(this.context, [], this.props.options);
      this.registeredEvents = bn({
        updaterMap: jn,
        eventMap: Bs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: jn,
      eventMap: Bs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), kn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Pe(DSe, "contextType", Nt);
function J2(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var FQ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || J2(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, J2));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), _Se = ["position"], TSe = ["position"];
function Q2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q2(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eU = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, tU = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, jSe = {};
function ASe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Nt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var R = r || jSe, {
        position: V
      } = R, $ = M_(R, _Se), W;
      V && !(V instanceof google.maps.LatLng) && (W = new google.maps.LatLng(V.lat, V.lng));
      var Z = new FQ(xb(xb({}, $), W ? {
        position: W
      } : {}));
      N.current = document.createElement("div"), v(Z), a && L(google.maps.event.addListener(Z, "closeclick", a)), s && D(google.maps.event.addListener(Z, "domready", s)), l && m(google.maps.event.addListener(Z, "content_changed", l)), u && S(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(y, n) : Z.getPosition() ? Z.open(y) : Wo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(ASe);
class BSe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", null), Pe(this, "state", {
      infoBox: null
    }), Pe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Wo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Pe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = M_(t, TSe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new FQ(xb(xb({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = bn({
      updaterMap: tU,
      eventMap: eU,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: tU,
      eventMap: eU,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), kn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
Pe(BSe, "contextType", Nt);
var nU, rU;
function ISe() {
  return rU || (rU = 1, nU = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), nU;
}
var RSe = ISe(), oU = /* @__PURE__ */ TQ(RSe), iU = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], mx = 1, pd = 8;
class D_ {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== mx)
      throw new Error("Got v".concat(o, " data when expected v").concat(mx, "."));
    var i = iU[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new D_(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = iU.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, pd, t), this.coords = new this.ArrayType(this.data, pd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(pd + a + s + l), this.ids = new this.IndexArrayType(this.data, pd, t), this.coords = new this.ArrayType(this.data, pd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (mx << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return SP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          sU(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      sU(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function SP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    zQ(e, t, a, r, o, i), SP(e, t, n, r, a - 1, 1 - i), SP(e, t, n, a + 1, o, 1 - i);
  }
}
function zQ(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      zQ(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (dd(e, t, r, n), t[2 * o + i] > y && dd(e, t, r, o); f < v; ) {
      for (dd(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? dd(e, t, r, v) : (v++, dd(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function dd(e, t, n, r) {
  vx(e, n, r), vx(t, 2 * n, 2 * r), vx(t, 2 * n + 1, 2 * r + 1);
}
function vx(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function sU(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var NSe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, aU = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Iu = 2, zl = 3, yx = 4, Tl = 5, UQ = 6;
class FSe {
  constructor(t) {
    this.options = Object.assign(Object.create(NSe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = aU(Um(u)), d = aU(Wm(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Um(r), Wm(a), Um(i), Wm(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Tl] > 1 ? lU(p, f, this.clusterProps) : this.points[p[f + zl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + yx] === t && p.push(a[y + Tl] > 1 ? lU(a, y, this.clusterProps) : this.points[a[y + zl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new D_(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Tl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = WQ(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + zl]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Um(f), d = Wm(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + zl] : L = this.points[n[l + zl]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Iu] <= n)) {
        l[p + Iu] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Tl], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Iu] > n && (b += l[w + Tl]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Iu] <= n)) {
              l[k + Iu] = n;
              var N = l[k + Tl];
              D += l[k] * N, x += l[k + 1] * N, l[k + yx] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + yx] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Iu] <= n)) {
                l[$ + Iu] = n;
                for (var W = 0; W < c; W++) u.push(l[$ + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Tl] > 1) {
      var o = this.clusterProps[t[n + UQ]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + zl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function lU(e, t, n) {
  return {
    type: "Feature",
    id: e[t + zl],
    properties: WQ(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [zSe(e[t]), USe(e[t + 1])]
    }
  };
}
function WQ(e, t, n) {
  var r = e[t + Tl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + UQ], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + zl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Um(e) {
  return e / 360 + 0.5;
}
function Wm(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function zSe(e) {
  return (e - 0.5) * 360;
}
function USe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function WSe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class cs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class MP {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(cs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => cs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (cs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class HSe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return VSe(n);
  }
}
var VSe = (e) => {
  var t = e.map((n) => new MP({
    position: cs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class $Se extends HSe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = WSe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new FSe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!oU(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = cs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !oU(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new MP({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new MP({
      markers: [i],
      position: cs.getPosition(i)
    });
  }
}
class qSe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class ZSe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (cs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function GSe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class __ {
  constructor() {
    GSe(__, google.maps.OverlayView);
  }
}
var gf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(gf || (gf = {}));
var YSe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class XSe extends __ {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new $Se(o),
      renderer: a = new ZSe(),
      onClusterClick: s = YSe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (cs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, gf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || cs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => cs.setMap(l, null)));
      }
      google.maps.event.trigger(this, gf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => cs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new qSe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => cs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, gf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), cs.setMap(r.marker, n);
    });
  }
}
function uU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function KSe(e) {
  var t = YPe(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new XSe(cU(cU({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function JSe(e) {
  var {
    children: t,
    options: n
  } = e, r = KSe(n);
  return r !== null ? t(r) : null;
}
me(JSe);
var pU = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, dU = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function QSe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Nt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return v(R), N.current = document.createElement("div"), a && L(google.maps.event.addListener(R, "closeclick", a)), s && D(google.maps.event.addListener(R, "domready", s)), l && m(google.maps.event.addListener(R, "content_changed", l)), u && S(google.maps.event.addListener(R, "position_changed", u)), c && k(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(y, n) : R.getPosition() ? R.open(y) : Wo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(R), R.close();
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(QSe);
class eMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", null), Pe(this, "state", {
      infoWindow: null
    }), Pe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Wo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Pe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = bn({
      updaterMap: dU,
      eventMap: pU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: dU,
      eventMap: pU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (kn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
Pe(eMe, "contextType", Nt);
function fU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hU = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, gU = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, tMe = {};
function nMe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Nt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(Lb(Lb({}, t || tMe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && k(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && $(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && K(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), b && F(google.maps.event.addListener(T, "drag", b)), m(T), L && L(T), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(nMe);
class rMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      polyline: null
    }), Pe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Lb(Lb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: gU,
      eventMap: hU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: gU,
      eventMap: hU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), kn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(rMe, "contextType", Nt);
function mU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yU = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, bU = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function oMe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Nt), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var B = new google.maps.Polygon(vU(vU({}, t), {}, {
      map: m
    }));
    return i && B.setPath(i), a && B.setPaths(a), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && k(google.maps.event.addListener(B, "dblclick", s)), l && R(google.maps.event.addListener(B, "dragend", l)), u && $(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && K(google.maps.event.addListener(B, "mousemove", p)), d && J(google.maps.event.addListener(B, "mouseout", d)), y && _(google.maps.event.addListener(B, "mouseover", y)), f && M(google.maps.event.addListener(B, "mouseup", f)), v && O(google.maps.event.addListener(B, "rightclick", v)), b && F(google.maps.event.addListener(B, "click", b)), L && q(google.maps.event.addListener(B, "drag", L)), S(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), D && D(B), B.setMap(null);
    };
  }, []), null;
}
me(oMe);
class iMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = bn({
      updaterMap: bU,
      eventMap: yU,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: bU,
      eventMap: yU,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), kn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(iMe, "contextType", Nt);
function wU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Eb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CU = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, OU = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function sMe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Nt), [m, C] = E(null), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var Y = new google.maps.Rectangle(Eb(Eb({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && U(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && W(google.maps.event.addListener(Y, "mousedown", u)), c && X(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), y && z(google.maps.event.addListener(Y, "mouseup", y)), f && H(google.maps.event.addListener(Y, "rightclick", f)), v && j(google.maps.event.addListener(Y, "click", v)), b && T(google.maps.event.addListener(Y, "drag", b)), L && B(google.maps.event.addListener(Y, "bounds_changed", L)), C(Y), w && w(Y), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(Y), Y.setMap(null);
    };
  }, []), null;
}
me(sMe);
class aMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      rectangle: null
    }), Pe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Eb(Eb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: OU,
      eventMap: CU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: OU,
      eventMap: CU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), kn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(aMe, "contextType", Nt);
function xU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var LU = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, EU = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, lMe = {};
function uMe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Nt), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(kb(kb({}, t || lMe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), y && z(google.maps.event.addListener(oe, "mouseover", y)), f && H(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), b && T(google.maps.event.addListener(oe, "click", b)), L && B(google.maps.event.addListener(oe, "drag", L)), w && I(google.maps.event.addListener(oe, "center_changed", w)), D && he(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), x && x(oe), () => {
      k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
me(uMe);
class cMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      circle: null
    }), Pe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(kb(kb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: EU,
      eventMap: LU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: EU,
      eventMap: LU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), kn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Pe(cMe, "contextType", Nt);
function kU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PU = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, SU = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function pMe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Nt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var B = new google.maps.Data(Pb(Pb({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(B, "dblclick", r)), o && S(google.maps.event.addListener(B, "mousedown", o)), i && k(google.maps.event.addListener(B, "mousemove", i)), a && R(google.maps.event.addListener(B, "mouseout", a)), s && $(google.maps.event.addListener(B, "mouseover", s)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && K(google.maps.event.addListener(B, "rightclick", u)), n && J(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && O(google.maps.event.addListener(B, "removeproperty", d)), y && F(google.maps.event.addListener(B, "setgeometry", y)), f && q(google.maps.event.addListener(B, "setproperty", f)), D(B), v && v(B);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(pMe);
class dMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      data: null
    }), Pe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Pb(Pb({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = bn({
        updaterMap: SU,
        eventMap: PU,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: SU,
      eventMap: PU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), kn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(dMe, "contextType", Nt);
function MU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function DU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _U = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, TU = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class fMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      kmlLayer: null
    }), Pe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(DU(DU({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: TU,
      eventMap: _U,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: TU,
      eventMap: _U,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), kn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(fMe, "contextType", Nt);
function HQ(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function hMe(e, t) {
  return new t(e.lat, e.lng);
}
function gMe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function mMe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function vMe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function yMe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function bMe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function VQ(e, t, n, r) {
  return n !== void 0 ? yMe(e, t, vMe(n, google.maps.LatLngBounds, gMe)) : bMe(e, t, mMe(r, google.maps.LatLng, hMe));
}
function wMe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function jU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CMe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function OMe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = CMe({}, this.container ? HQ(this.container, o) : {
        x: 0,
        y: 0
      }), u = VQ(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function AU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xMe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function BU(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function IU(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function LMe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Nt), c = un(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = un(() => OMe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), hi.createPortal(l, c);
}
me(LMe);
class _p extends pe {
  constructor(t) {
    super(t), Pe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Pe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Wo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Pe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Pe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = xMe({
        x: 0,
        y: 0
      }, this.containerRef.current ? HQ(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = VQ(r, o, this.props.bounds, this.props.position);
      if (!wMe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Pe(this, "draw", () => {
      this.onPositionElement();
    }), Pe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = zn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = BU(t.position), r = BU(this.props.position), o = IU(t.bounds), i = IU(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? hi.createPortal($i.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Pe(_p, "FLOAT_PANE", "floatPane");
Pe(_p, "MAP_PANE", "mapPane");
Pe(_p, "MARKER_LAYER", "markerLayer");
Pe(_p, "OVERLAY_LAYER", "overlayLayer");
Pe(_p, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Pe(_p, "contextType", Nt);
function EMe() {
}
function RU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FU = {
  onDblClick: "dblclick",
  onClick: "click"
}, zU = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function kMe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Nt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = un(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(kMe);
class $Q extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      groundOverlay: null
    }), Pe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Wo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, NU(NU({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: zU,
      eventMap: FU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: zU,
      eventMap: FU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Pe($Q, "defaultProps", {
  onLoad: EMe
});
Pe($Q, "contextType", Nt);
function UU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UU(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WU = {}, HU = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function PMe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Nt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || Wo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Wo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Sb(Sb({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(PMe);
class SMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      heatmapLayer: null
    }), Pe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Wo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Wo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Sb(Sb({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = bn({
      updaterMap: HU,
      eventMap: WU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: HU,
      eventMap: WU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), kn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(SMe, "contextType", Nt);
var VU = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, $U = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class MMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      streetViewPanorama: null
    }), Pe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = bn({
      updaterMap: $U,
      eventMap: VU,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: $U,
      eventMap: VU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), kn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Pe(MMe, "contextType", Nt);
class DMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      streetViewService: null
    }), Pe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Pe(DMe, "contextType", Nt);
var qU = {
  onDirectionsChanged: "directions_changed"
}, ZU = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class _Me extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      directionsRenderer: null
    }), Pe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = bn({
      updaterMap: ZU,
      eventMap: qU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: ZU,
      eventMap: qU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), kn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(_Me, "contextType", Nt);
var GU = {
  onPlacesChanged: "places_changed"
}, YU = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class TMe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", zn()), Pe(this, "state", {
      searchBox: null
    }), Pe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Wo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = bn({
          updaterMap: YU,
          eventMap: GU,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: YU,
      eventMap: GU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), kn(this.registeredEvents));
  }
  render() {
    return $i.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Pe(TMe, "contextType", Nt);
var XU = {
  onPlaceChanged: "place_changed"
}, KU = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class qQ extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", zn()), Pe(this, "state", {
      autocomplete: null
    }), Pe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Wo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = bn({
        updaterMap: KU,
        eventMap: XU,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    kn(this.registeredEvents), this.registeredEvents = bn({
      updaterMap: KU,
      eventMap: XU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && kn(this.registeredEvents);
  }
  render() {
    return $i.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Pe(qQ, "defaultProps", {
  className: ""
});
Pe(qQ, "contextType", Nt);
let jMe = { data: "" }, AMe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || jMe, BMe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, IMe = /\/\*[^]*?\*\/|  +/g, JU = /\n+/g, Xl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Xl(a, i) : i + "{" + Xl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Xl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Xl.p ? Xl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ba = {}, ZQ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + ZQ(e[n]);
    return t;
  }
  return e;
}, RMe = (e, t, n, r, o) => {
  let i = ZQ(e), a = Ba[i] || (Ba[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ba[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = BMe.exec(u.replace(IMe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(JU, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(JU, " ").trim();
      return d[0];
    })(e);
    Ba[a] = Xl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ba.g ? Ba.g : null;
  return n && (Ba.g = Ba[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ba[a], t, r, s), a;
}, NMe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Xl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Y1(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return RMe(n.unshift ? n.raw ? NMe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, AMe(t.target), t.g, t.o, t.k);
}
let GQ, DP, _P;
Y1.bind({ g: 1 });
let Ja = Y1.bind({ k: 1 });
function FMe(e, t, n, r) {
  Xl.p = t, GQ = e, DP = n, _P = r;
}
function Eu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: DP && DP() }, s), n.o = / *go\d+/.test(l), s.className = Y1.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), _P && u[0] && _P(s), GQ(u, s);
    }
    return o;
  };
}
var zMe = (e) => typeof e == "function", UMe = (e, t) => zMe(e) ? e(t) : e, WMe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), HMe = Ja`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, VMe = Ja`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, $Me = Ja`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, qMe = Eu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${HMe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${VMe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${$Me} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, ZMe = Ja`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, GMe = Eu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${ZMe} 1s linear infinite;
`, YMe = Ja`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, XMe = Ja`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, KMe = Eu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${YMe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${XMe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, JMe = Eu("div")`
  position: absolute;
`, QMe = Eu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, eDe = Ja`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, tDe = Eu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${eDe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, nDe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(tDe, null, t) : t : n === "blank" ? null : Ne.createElement(QMe, null, Ne.createElement(GMe, { ...r }), n !== "loading" && Ne.createElement(JMe, null, n === "error" ? Ne.createElement(qMe, { ...r }) : Ne.createElement(KMe, { ...r })));
}, rDe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, oDe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, iDe = "0%{opacity:0;} 100%{opacity:1;}", sDe = "0%{opacity:1;} 100%{opacity:0;}", aDe = Eu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, lDe = Eu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, uDe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = WMe() ? [iDe, sDe] : [rDe(n), oDe(n)];
  return { animation: t ? `${Ja(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ja(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? uDe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(nDe, { toast: e }), a = Ne.createElement(lDe, { ...e.ariaProps }, UMe(e.message, e));
  return Ne.createElement(aDe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
FMe(Ne.createElement);
Y1`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ve({});
function cDe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const pDe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
cDe(pDe.CNPJ).length;
ma((e, t) => /* @__PURE__ */ Vi.jsx("input", { ref: t, ...e }));
Ve({});
var ll = {};
Object.defineProperty(ll, "__esModule", {
  value: !0
});
var dDe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), bx = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, YQ = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: dDe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, T_ = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Hm = 1; Hm < 20; Hm++)
  T_["f" + Hm] = 111 + Hm;
function X1(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return XQ(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return KQ(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function fDe(e, t) {
  return X1(e, t);
}
function hDe(e, t) {
  return X1(e, { byKey: !0 }, t);
}
function XQ(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in bx)
    r[bx[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = j_(d), v = bx[f];
      if (d.length > 1 && !v && !YQ[d] && !T_[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = JQ(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function KQ(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function JQ(e) {
  e = j_(e);
  var t = T_[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function j_(e) {
  return e = e.toLowerCase(), e = YQ[e] || e, e;
}
ll.default = X1;
var wx = ll.isHotkey = X1;
ll.isCodeHotkey = fDe;
ll.isKeyHotkey = hDe;
ll.parseHotkey = XQ;
ll.compareHotkey = KQ;
ll.toKeyCode = JQ;
ll.toKeyName = j_;
var gDe = typeof br == "object" && br && br.Object === Object && br, mDe = gDe, vDe = mDe, yDe = typeof self == "object" && self && self.Object === Object && self, bDe = vDe || yDe || Function("return this")(), wDe = bDe, CDe = wDe, ODe = CDe.Symbol, QQ = ODe, QU = QQ;
QU && QU.toStringTag;
var eW = QQ;
eW && eW.toStringTag;
var tW;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(tW || (tW = {}));
var A_ = function(e) {
  return Object.freeze(e);
}, xDe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, A_(this);
  }
  return e;
}(), LDe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, A_(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), nW = typeof window < "u" ? window : {};
/msie|trident/i.test(nW.navigator && nW.navigator.userAgent);
var Cx = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new xDe((n ? t : e) || 0, (n ? e : t) || 0);
};
A_({
  devicePixelContentBoxSize: Cx(),
  borderBoxSize: Cx(),
  contentBoxSize: Cx(),
  contentRect: new LDe(0, 0, 0, 0)
});
function dh(e) {
  "@babel/helpers - typeof";
  return dh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, dh(e);
}
function EDe(e, t) {
  if (dh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (dh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function kDe(e) {
  var t = EDe(e, "string");
  return dh(t) === "symbol" ? t : String(t);
}
function mf(e, t, n) {
  return t = kDe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var PDe = /* @__PURE__ */ Ve(null), Ox, xx;
parseInt(we.version.split(".")[0], 10);
var rW = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Lx = typeof navigator < "u" && /Android/.test(navigator.userAgent), Vm = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), SDe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Ox = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Ox !== void 0 && Ox[1] && parseInt((xx = navigator.userAgent.match(/Version\/(\d+)/)) === null || xx === void 0 ? void 0 : xx[1], 10) < 17;
var MDe = /* @__PURE__ */ new WeakMap(), DDe = /* @__PURE__ */ new WeakMap(), _De = /* @__PURE__ */ new WeakMap(), TDe = /* @__PURE__ */ new WeakMap(), jDe = /* @__PURE__ */ new WeakMap(), oW = /* @__PURE__ */ new WeakMap(), ADe = /* @__PURE__ */ new WeakMap(), iW = /* @__PURE__ */ new WeakMap(), $m = /* @__PURE__ */ new WeakMap(), BDe = /* @__PURE__ */ new WeakMap(), IDe = /* @__PURE__ */ new WeakMap(), RDe = /* @__PURE__ */ new WeakMap(), eee = globalThis.Node, NDe = globalThis.Text, tee = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, FDe = (e) => Mb(e) && e.nodeType === 8, pa = (e) => Mb(e) && e.nodeType === 1, Mb = (e) => {
  var t = tee(e);
  return !!t && e instanceof t.Node;
}, sW = (e) => {
  var t = e && e.anchorNode && tee(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, zDe = (e) => {
  var [t, n] = e;
  if (pa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = nee(t, o, r ? "backward" : "forward"), r = o < n; pa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = WDe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, UDe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, nee = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (FDe(o) || pa(o) && o.childNodes.length === 0 || pa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, WDe = (e, t, n) => {
  var [r] = nee(e, t, n);
  return r;
}, aW = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), ree = (e, t, n) => {
  var {
    target: r
  } = t;
  if (pa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = fn.getWindow(e);
  if (o.contains(r))
    return fn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : ree(e, i, n);
}, lW = (e, t) => !!(e.compareDocumentPosition(t) & eee.DOCUMENT_POSITION_PRECEDING), HDe = (e, t) => !!(e.compareDocumentPosition(t) & eee.DOCUMENT_POSITION_FOLLOWING), VDe = 0;
class $De {
  constructor() {
    mf(this, "id", void 0), this.id = "".concat(VDe++);
  }
}
var fn = {
  androidPendingDiffs: (e) => RDe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = IDe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = fn.toDOMNode(e, e), n = fn.findDocumentOrShadowRoot(e);
    $m.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = fn.findDocumentOrShadowRoot(e), r = aW(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Yy.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = fn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = fn.toSlateNode(e, t.target), a = fn.findPath(e, i);
    if (qa.isElement(i) && pr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = pr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? pr.before(e, u) : pr.after(e, u);
      if (c) {
        var p = pr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = fn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = fn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = oW.get(t);
    return n || (n = new $De(), oW.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = DDe.get(r);
      if (o == null) {
        if (pr.isEditor(r))
          return n;
        break;
      }
      var i = MDe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ss.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!$m.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          fn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = fn.toDOMNode(e, e), r = fn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = aW(r), i = fn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Yy.select(e, pr.start(e, [])), $m.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = _De.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = fn.toDOMNode(e, e), i;
    try {
      i = pa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Mb(t) && fn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return pr.hasPath(e, n.path) && pr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => fn.hasEditableTarget(e, t) || fn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Mb(t) && fn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!BDe.get(e),
  isFocused: (e) => !!$m.get(e),
  isReadOnly: (e) => !!iW.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (iW.get(e)) return !1;
    var n = fn.hasTarget(e, t) && fn.toSlateNode(e, t);
    return qa.isElement(n) && pr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = ADe.get(e), r = pr.isEditor(t) ? TDe.get(e) : n == null ? void 0 : n.get(fn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ss.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = pr.node(e, t.path), r = fn.toDOMNode(e, n), o;
    pr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof NDe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ss.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Xt.isBackward(t), i = fn.toDOMPoint(e, n), a = Xt.isCollapsed(t) ? i : fn.toDOMPoint(e, r), s = fn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = pa(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = pa(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = pa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? jDe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : zDe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = fn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = fn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Lx && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var N = U[k];
          if (fn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var R = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, W = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = W.find((M) => HDe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var Z, X = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = (Z = X.findLast((M) => lW(L, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Lx && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Vm && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Lx && !u && !r) {
      var K = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (K && fn.hasDOMNode(e, K, {
        editable: !0
      })) {
        var Q = fn.toSlateNode(e, K), {
          path: J,
          offset: P
        } = pr.start(e, fn.findPath(e, Q));
        return K.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = fn.toSlateNode(e, u), z = fn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = sW(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (sW(t)) {
        if (Vm && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        SDe && UDe(s) || Vm ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Vm && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = fn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = lW(s, u) || s === u && c < l, x = p ? w : fn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Xt.isExpanded(m) && Xt.isForward(m) && pa(u) && pr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = pr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, qDe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, ZDe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, GDe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Gr = (e) => {
  var t = qDe[e], n = ZDe[e], r = GDe[e], o = t && wx(t), i = n && wx(n), a = r && wx(r);
  return (s) => !!(o && o(s) || rW && i && i(s) || !rW && a && a(s));
};
Gr("bold"), Gr("compose"), Gr("moveBackward"), Gr("moveForward"), Gr("deleteBackward"), Gr("deleteForward"), Gr("deleteLineBackward"), Gr("deleteLineForward"), Gr("deleteWordBackward"), Gr("deleteWordForward"), Gr("extendBackward"), Gr("extendForward"), Gr("extendLineBackward"), Gr("extendLineForward"), Gr("italic"), Gr("moveLineBackward"), Gr("moveLineForward"), Gr("moveWordBackward"), Gr("moveWordForward"), Gr("redo"), Gr("insertSoftBreak"), Gr("splitBlock"), Gr("transposeCharacter"), Gr("undo");
var YDe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => ree(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, XDe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class KDe extends au {
  constructor() {
    super(...arguments), mf(this, "context", null), mf(this, "manager", null), mf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, XDe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = YDe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
mf(KDe, "contextType", PDe);
Ve({});
Ve({});
Ve({});
var Bo = {}, B_ = {}, Uh = {}, Wh = {}, oee = "Expected a function", uW = NaN, JDe = "[object Symbol]", QDe = /^\s+|\s+$/g, e_e = /^[-+]0x[0-9a-f]+$/i, t_e = /^0b[01]+$/i, n_e = /^0o[0-7]+$/i, r_e = parseInt, o_e = typeof br == "object" && br && br.Object === Object && br, i_e = typeof self == "object" && self && self.Object === Object && self, s_e = o_e || i_e || Function("return this")(), a_e = Object.prototype, l_e = a_e.toString, u_e = Math.max, c_e = Math.min, Ex = function() {
  return s_e.Date.now();
};
function p_e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(oee);
  t = cW(t) || 0, Db(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? u_e(cW(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? c_e(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = Ex();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Ex());
  }
  function m() {
    var C = Ex(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function d_e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(oee);
  return Db(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), p_e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Db(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function f_e(e) {
  return !!e && typeof e == "object";
}
function h_e(e) {
  return typeof e == "symbol" || f_e(e) && l_e.call(e) == JDe;
}
function cW(e) {
  if (typeof e == "number")
    return e;
  if (h_e(e))
    return uW;
  if (Db(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Db(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(QDe, "");
  var n = t_e.test(e);
  return n || n_e.test(e) ? r_e(e.slice(2), n ? 2 : 8) : e_e.test(e) ? uW : +e;
}
var g_e = d_e, Hh = {};
Object.defineProperty(Hh, "__esModule", {
  value: !0
});
Hh.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), sy.has(t) || sy.set(t, /* @__PURE__ */ new Set());
  var o = sy.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Hh.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), sy.get(t).delete(n.name || t);
};
var sy = /* @__PURE__ */ new Map();
Object.defineProperty(Wh, "__esModule", {
  value: !0
});
var m_e = g_e, v_e = b_e(m_e), y_e = Hh;
function b_e(e) {
  return e && e.__esModule ? e : { default: e };
}
var w_e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, v_e.default)(e, t);
}, po = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = w_e(function(r) {
        po.scrollHandler(e);
      }, t);
      po.scrollSpyContainers.push(e), (0, y_e.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return po.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = po.scrollSpyContainers[po.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(po.currentPositionX(e), po.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    po.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = po.scrollSpyContainers[po.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(po.currentPositionX(t), po.currentPositionY(t));
  },
  updateStates: function() {
    po.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    po.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), po.spySetState && po.spySetState.length && po.spySetState.indexOf(e) > -1 && po.spySetState.splice(po.spySetState.indexOf(e), 1), document.removeEventListener("scroll", po.scrollHandler);
  },
  update: function() {
    return po.scrollSpyContainers.forEach(function(e) {
      return po.scrollHandler(e);
    });
  }
};
Wh.default = po;
var Tp = {}, Vh = {};
Object.defineProperty(Vh, "__esModule", {
  value: !0
});
var C_e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, O_e = function() {
  return window.location.hash.replace(/^#/, "");
}, x_e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, L_e = function(e) {
  return getComputedStyle(e).position !== "static";
}, kx = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, E_e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (L_e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = kx(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return kx(t, s).offsetTop - kx(e, s).offsetTop;
};
Vh.default = {
  updateHash: C_e,
  getHash: O_e,
  filterElementInContainer: x_e,
  scrollOffset: E_e
};
var K1 = {}, I_ = {};
Object.defineProperty(I_, "__esModule", {
  value: !0
});
I_.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var R_ = {};
Object.defineProperty(R_, "__esModule", {
  value: !0
});
var k_e = Hh, P_e = ["mousedown", "mousewheel", "touchmove", "keydown"];
R_.default = {
  subscribe: function(e) {
    return typeof document < "u" && P_e.forEach(function(t) {
      return (0, k_e.addPassiveEventListener)(document, t, e);
    });
  }
};
var $h = {};
Object.defineProperty($h, "__esModule", {
  value: !0
});
var TP = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      TP.registered[e] = t;
    },
    remove: function(e) {
      TP.registered[e] = null;
    }
  }
};
$h.default = TP;
Object.defineProperty(K1, "__esModule", {
  value: !0
});
var S_e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, M_e = Vh;
J1(M_e);
var D_e = I_, pW = J1(D_e), __e = R_, T_e = J1(__e), j_e = $h, ra = J1(j_e);
function J1(e) {
  return e && e.__esModule ? e : { default: e };
}
var iee = function(e) {
  return pW.default[e.smooth] || pW.default.defaultEasing;
}, A_e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, B_e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, jP = function() {
  return B_e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), see = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, aee = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, lee = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, I_e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, R_e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, N_e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ra.default.registered.end && ra.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    jP.call(window, i);
    return;
  }
  ra.default.registered.end && ra.default.registered.end(o.to, o.target, o.currentPosition);
}, N_ = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, qh = function(e, t, n, r) {
  t.data = t.data || see(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (T_e.default.subscribe(o), N_(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? aee(t) : lee(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ra.default.registered.end && ra.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = A_e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = iee(t), a = N_e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ra.default.registered.begin && ra.default.registered.begin(t.data.to, t.data.target), jP.call(window, a);
    }, t.delay);
    return;
  }
  ra.default.registered.begin && ra.default.registered.begin(t.data.to, t.data.target), jP.call(window, a);
}, Q1 = function(e) {
  return e = S_e({}, e), e.data = e.data || see(), e.absolute = !0, e;
}, F_e = function(e) {
  qh(0, Q1(e));
}, z_e = function(e, t) {
  qh(e, Q1(t));
}, U_e = function(e) {
  e = Q1(e), N_(e), qh(e.horizontal ? I_e(e) : R_e(e), e);
}, W_e = function(e, t) {
  t = Q1(t), N_(t);
  var n = t.horizontal ? aee(t) : lee(t);
  qh(e + n, t);
};
K1.default = {
  animateTopScroll: qh,
  getAnimationType: iee,
  scrollToTop: F_e,
  scrollToBottom: U_e,
  scrollTo: z_e,
  scrollMore: W_e
};
Object.defineProperty(Tp, "__esModule", {
  value: !0
});
var H_e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, V_e = Vh, $_e = F_(V_e), q_e = K1, Z_e = F_(q_e), G_e = $h, qm = F_(G_e);
function F_(e) {
  return e && e.__esModule ? e : { default: e };
}
var Zm = {}, dW = void 0;
Tp.default = {
  unmount: function() {
    Zm = {};
  },
  register: function(e, t) {
    Zm[e] = t;
  },
  unregister: function(e) {
    delete Zm[e];
  },
  get: function(e) {
    return Zm[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return dW = e;
  },
  getActiveLink: function() {
    return dW;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = H_e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = $_e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      qm.default.registered.begin && qm.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, qm.default.registered.end && qm.default.registered.end(e, n);
      return;
    }
    Z_e.default.animateTopScroll(s, t, e, n);
  }
};
var AP = { exports: {} }, Px = { exports: {} }, $n = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fW;
function Y_e() {
  if (fW) return $n;
  fW = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return $n.AsyncMode = l, $n.ConcurrentMode = u, $n.ContextConsumer = s, $n.ContextProvider = a, $n.Element = t, $n.ForwardRef = c, $n.Fragment = r, $n.Lazy = f, $n.Memo = y, $n.Portal = n, $n.Profiler = i, $n.StrictMode = o, $n.Suspense = p, $n.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, $n.isConcurrentMode = x, $n.isContextConsumer = function(m) {
    return D(m) === s;
  }, $n.isContextProvider = function(m) {
    return D(m) === a;
  }, $n.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, $n.isForwardRef = function(m) {
    return D(m) === c;
  }, $n.isFragment = function(m) {
    return D(m) === r;
  }, $n.isLazy = function(m) {
    return D(m) === f;
  }, $n.isMemo = function(m) {
    return D(m) === y;
  }, $n.isPortal = function(m) {
    return D(m) === n;
  }, $n.isProfiler = function(m) {
    return D(m) === i;
  }, $n.isStrictMode = function(m) {
    return D(m) === o;
  }, $n.isSuspense = function(m) {
    return D(m) === p;
  }, $n.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, $n.typeOf = D, $n;
}
var tr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hW;
function X_e() {
  return hW || (hW = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === y || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === L || I.$$typeof === w || I.$$typeof === v);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, N = c, R = r, V = f, $ = y, W = n, Z = i, X = o, K = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(I) || x(I) === l;
    }
    function P(I) {
      return x(I) === u;
    }
    function _(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function M(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function H(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function F(I) {
      return x(I) === y;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function B(I) {
      return x(I) === o;
    }
    function Y(I) {
      return x(I) === p;
    }
    tr.AsyncMode = m, tr.ConcurrentMode = C, tr.ContextConsumer = S, tr.ContextProvider = U, tr.Element = k, tr.ForwardRef = N, tr.Fragment = R, tr.Lazy = V, tr.Memo = $, tr.Portal = W, tr.Profiler = Z, tr.StrictMode = X, tr.Suspense = K, tr.isAsyncMode = J, tr.isConcurrentMode = P, tr.isContextConsumer = _, tr.isContextProvider = z, tr.isElement = M, tr.isForwardRef = H, tr.isFragment = O, tr.isLazy = j, tr.isMemo = F, tr.isPortal = T, tr.isProfiler = q, tr.isStrictMode = B, tr.isSuspense = Y, tr.isValidElementType = D, tr.typeOf = x;
  }()), tr;
}
var gW;
function uee() {
  return gW || (gW = 1, process.env.NODE_ENV === "production" ? Px.exports = Y_e() : Px.exports = X_e()), Px.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Sx, mW;
function K_e() {
  if (mW) return Sx;
  mW = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Sx = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Sx;
}
var Mx, vW;
function z_() {
  if (vW) return Mx;
  vW = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Mx = e, Mx;
}
var yW, bW;
function cee() {
  return bW || (bW = 1, yW = Function.call.bind(Object.prototype.hasOwnProperty)), yW;
}
var Dx, wW;
function J_e() {
  if (wW) return Dx;
  wW = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = z_(), n = {}, r = cee();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Dx = o, Dx;
}
var _x, CW;
function Q_e() {
  if (CW) return _x;
  CW = 1;
  var e = uee(), t = K_e(), n = z_(), r = cee(), o = J_e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return _x = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: N(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, j, F, T, q, B, Y) {
        if (T = T || d, B = B || F, Y !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + q + " `" + B + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + q + " `" + B + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, F, T, q, B);
      }
      var H = M.bind(null, !1);
      return H.isRequired = M.bind(null, !0), H;
    }
    function L(P) {
      function _(z, M, H, O, j, F) {
        var T = z[M], q = X(T);
        if (q !== P) {
          var B = K(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + B + "` supplied to `" + H + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var T = X(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var B = P(F, q, H, O, j + "[" + q + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!s(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!e.isValidElementType(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, H, O, j) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, T = J(z[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, H, O, j) {
        for (var F = z[M], T = 0; T < P.length; T++)
          if (f(F, P[T]))
            return null;
        var q = JSON.stringify(P, function(B, Y) {
          var I = K(Y);
          return I === "symbol" ? String(Y) : Y;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + H + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside objectOf.");
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var B = P(F, q, H, O, j + "." + q, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(H, O, j, F, T) {
        for (var q = [], B = 0; B < P.length; B++) {
          var Y = P[B], I = Y(H, O, j, F, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(M);
    }
    function N() {
      function P(_, z, M, H, O) {
        return W(_[z]) ? null : new v("Invalid " + H + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, _, z, M, H) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + H + "`."
      );
    }
    function V(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        for (var q in P) {
          var B = P[q];
          if (typeof B != "function")
            return R(H, O, j, q, K(B));
          var Y = B(F, q, H, O, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var B in q) {
          var Y = P[B];
          if (r(P, B) && typeof Y != "function")
            return R(H, O, j, B, K(Y));
          if (!Y)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + B + "` supplied to `" + H + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var I = Y(F, B, H, O, j + "." + B, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(_);
    }
    function W(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(W);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var H = M.value;
                if (H && !W(H[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function X(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(_, P) ? "symbol" : _;
    }
    function K(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = X(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = K(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, _x;
}
var Tx, OW;
function eTe() {
  if (OW) return Tx;
  OW = 1;
  var e = z_();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Tx = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Tx;
}
if (process.env.NODE_ENV !== "production") {
  var tTe = uee(), nTe = !0;
  AP.exports = Q_e()(tTe.isElement, nTe);
} else
  AP.exports = eTe()();
var eC = AP.exports, tC = {};
Object.defineProperty(tC, "__esModule", {
  value: !0
});
var rTe = Vh, jx = oTe(rTe);
function oTe(e) {
  return e && e.__esModule ? e : { default: e };
}
var iTe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return jx.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && jx.default.getHash() !== e && jx.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
tC.default = iTe;
Object.defineProperty(Uh, "__esModule", {
  value: !0
});
var Gm = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, sTe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), aTe = we, xW = Zh(aTe), lTe = Wh, Ym = Zh(lTe), uTe = Tp, cTe = Zh(uTe), pTe = eC, Yr = Zh(pTe), dTe = tC, yl = Zh(dTe);
function Zh(e) {
  return e && e.__esModule ? e : { default: e };
}
function fTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function gTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var LW = {
  to: Yr.default.string.isRequired,
  containerId: Yr.default.string,
  container: Yr.default.object,
  activeClass: Yr.default.string,
  activeStyle: Yr.default.object,
  spy: Yr.default.bool,
  horizontal: Yr.default.bool,
  smooth: Yr.default.oneOfType([Yr.default.bool, Yr.default.string]),
  offset: Yr.default.number,
  delay: Yr.default.number,
  isDynamic: Yr.default.bool,
  onClick: Yr.default.func,
  duration: Yr.default.oneOfType([Yr.default.number, Yr.default.func]),
  absolute: Yr.default.bool,
  onSetActive: Yr.default.func,
  onSetInactive: Yr.default.func,
  ignoreCancelEvents: Yr.default.bool,
  hashSpy: Yr.default.bool,
  saveHashHistory: Yr.default.bool,
  spyThrottle: Yr.default.number
};
Uh.default = function(e, t) {
  var n = t || cTe.default, r = function(i) {
    gTe(a, i);
    function a(s) {
      fTe(this, a);
      var l = hTe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return sTe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Ym.default.isMounted(s) || Ym.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (yl.default.isMounted() || yl.default.mount(n), yl.default.mapContainer(this.props.to, s)), Ym.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Ym.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Gm({}, this.props.style, this.props.activeStyle) : l = Gm({}, this.props.style);
        var u = Gm({}, this.props);
        for (var c in LW)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, xW.default.createElement(e, u);
      }
    }]), a;
  }(xW.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Gm({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(yl.default.isMounted() && !yl.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var N = n.getActiveLink();
        if (y) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && yl.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            yl.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, W = $ === void 0 ? !1 : $;
          i.props.hashSpy && yl.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = LW, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(B_, "__esModule", {
  value: !0
});
var mTe = we, EW = pee(mTe), vTe = Uh, yTe = pee(vTe);
function pee(e) {
  return e && e.__esModule ? e : { default: e };
}
function bTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kW(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function wTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var CTe = function(e) {
  wTe(t, e);
  function t() {
    var n, r, o, i;
    bTe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = kW(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return EW.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), kW(o, i);
  }
  return t;
}(EW.default.Component);
B_.default = (0, yTe.default)(CTe);
var U_ = {};
Object.defineProperty(U_, "__esModule", {
  value: !0
});
var OTe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), xTe = we, PW = dee(xTe), LTe = Uh, ETe = dee(LTe);
function dee(e) {
  return e && e.__esModule ? e : { default: e };
}
function kTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function STe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var MTe = function(e) {
  STe(t, e);
  function t() {
    return kTe(this, t), PTe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return OTe(t, [{
    key: "render",
    value: function() {
      return PW.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(PW.default.Component);
U_.default = (0, ETe.default)(MTe);
var W_ = {}, nC = {};
Object.defineProperty(nC, "__esModule", {
  value: !0
});
var DTe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _Te = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), TTe = we, SW = rC(TTe), jTe = il;
rC(jTe);
var ATe = Tp, MW = rC(ATe), BTe = eC, DW = rC(BTe);
function rC(e) {
  return e && e.__esModule ? e : { default: e };
}
function ITe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function RTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function NTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
nC.default = function(e) {
  var t = function(n) {
    NTe(r, n);
    function r(o) {
      ITe(this, r);
      var i = RTe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return _Te(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        MW.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        MW.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return SW.default.createElement(e, DTe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(SW.default.Component);
  return t.propTypes = {
    name: DW.default.string,
    id: DW.default.string
  }, t;
};
Object.defineProperty(W_, "__esModule", {
  value: !0
});
var _W = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, FTe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), zTe = we, TW = H_(zTe), UTe = nC, WTe = H_(UTe), HTe = eC, jW = H_(HTe);
function H_(e) {
  return e && e.__esModule ? e : { default: e };
}
function VTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function $Te(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function qTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fee = function(e) {
  qTe(t, e);
  function t() {
    return VTe(this, t), $Te(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return FTe(t, [{
    key: "render",
    value: function() {
      var n = this, r = _W({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, TW.default.createElement(
        "div",
        _W({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(TW.default.Component);
fee.propTypes = {
  name: jW.default.string,
  id: jW.default.string
};
W_.default = (0, WTe.default)(fee);
var Ax = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, AW = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function BW(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function IW(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function RW(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Xm = we, Ru = Wh, Bx = Tp, wo = eC, bl = tC, NW = {
  to: wo.string.isRequired,
  containerId: wo.string,
  container: wo.object,
  activeClass: wo.string,
  spy: wo.bool,
  smooth: wo.oneOfType([wo.bool, wo.string]),
  offset: wo.number,
  delay: wo.number,
  isDynamic: wo.bool,
  onClick: wo.func,
  duration: wo.oneOfType([wo.number, wo.func]),
  absolute: wo.bool,
  onSetActive: wo.func,
  onSetInactive: wo.func,
  ignoreCancelEvents: wo.bool,
  hashSpy: wo.bool,
  spyThrottle: wo.number
}, ZTe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Bx, r = function(i) {
      RW(a, i);
      function a(s) {
        BW(this, a);
        var l = IW(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return AW(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Ru.isMounted(s) || Ru.mount(s, this.props.spyThrottle), this.props.hashSpy && (bl.isMounted() || bl.mount(n), bl.mapContainer(this.props.to, s)), this.props.spy && Ru.addStateHandler(this.stateHandler), Ru.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ru.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = Ax({}, this.props);
          for (var u in NW)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Xm.createElement(e, l);
        }
      }]), a;
    }(Xm.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, Ax({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(bl.isMounted() && !bl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && bl.getHash() === l && bl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ru.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && bl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ru.updateStates();
        }
      };
    };
    return r.propTypes = NW, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      RW(r, n);
      function r(o) {
        BW(this, r);
        var i = IW(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return AW(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Bx.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Bx.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Xm.createElement(e, Ax({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Xm.Component);
    return t.propTypes = {
      name: wo.string,
      id: wo.string
    }, t;
  }
}, GTe = ZTe;
Object.defineProperty(Bo, "__esModule", {
  value: !0
});
Bo.Helpers = Bo.ScrollElement = Bo.ScrollLink = Bo.animateScroll = Bo.scrollSpy = Bo.Events = Bo.scroller = Bo.Element = Bo.Button = Bo.Link = void 0;
var YTe = B_, hee = wa(YTe), XTe = U_, gee = wa(XTe), KTe = W_, mee = wa(KTe), JTe = Tp, vee = wa(JTe), QTe = $h, yee = wa(QTe), eje = Wh, bee = wa(eje), tje = K1, wee = wa(tje), nje = Uh, Cee = wa(nje), rje = nC, Oee = wa(rje), oje = GTe, xee = wa(oje);
function wa(e) {
  return e && e.__esModule ? e : { default: e };
}
Bo.Link = hee.default;
Bo.Button = gee.default;
Bo.Element = mee.default;
Bo.scroller = vee.default;
Bo.Events = yee.default;
Bo.scrollSpy = bee.default;
Bo.animateScroll = wee.default;
Bo.ScrollLink = Cee.default;
Bo.ScrollElement = Oee.default;
Bo.Helpers = xee.default;
Bo.default = { Link: hee.default, Button: gee.default, Element: mee.default, scroller: vee.default, Events: yee.default, scrollSpy: bee.default, animateScroll: wee.default, ScrollLink: Cee.default, ScrollElement: Oee.default, Helpers: xee.default };
Ve({});
Ve({});
Ve({});
function fh(e) {
  "@babel/helpers - typeof";
  return fh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fh(e);
}
function ije(e, t) {
  if (fh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (fh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function sje(e) {
  var t = ije(e, "string");
  return fh(t) == "symbol" ? t : t + "";
}
function Se(e, t, n) {
  return (t = sje(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Lee(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ix, FW;
function aje() {
  if (FW) return Ix;
  FW = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Ix = t, Ix;
}
var lje = aje(), Ho = /* @__PURE__ */ Lee(lje), Ft = Ve(null);
function uje() {
  Ho(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ft);
  return Ho(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function cje(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function pje(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function dje(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return pje(e, i), o;
}
function fje(e, t, n) {
  var r = cje(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function hje(e) {
  google.maps.event.removeListener(e);
}
function Pn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(hje);
}
function wn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = fje(o, i, n);
  return dje(t, r, o, i), a;
}
function gje(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = ht(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null), [B, Y] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (B !== null && google.maps.event.removeListener(B), Y(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var I = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(I), I !== null && D && D(I), () => {
      I !== null && x && x(I);
    };
  }, []), Vi.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: Vi.jsx(Ft.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(gje);
function zW(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Eee(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        zW(i, r, o, a, s, "next", l);
      }
      function s(l) {
        zW(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function kee(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Ho(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var gc = typeof document < "u";
function Pee(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return gc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function UW(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function See() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return UW(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return UW(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var fd = !1;
function Mee() {
  return Vi.jsx("div", {
    children: "Loading..."
  });
}
var BP = {
  id: "script-loader",
  version: "weekly"
};
class mje extends pe {
  constructor() {
    super(...arguments), Se(this, "check", zn()), Se(this, "state", {
      loaded: !1
    }), Se(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Se(this, "isCleaningUp", /* @__PURE__ */ Eee(function* () {
      function t(n) {
        if (!fd)
          n();
        else if (gc)
          var r = window.setInterval(function() {
            fd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Se(this, "cleanup", () => {
      fd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Se(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && See(), Ho(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: kee(this.props)
      };
      Pee(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (gc) {
      if (window.google && window.google.maps && !fd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), gc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (gc) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, fd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Vi.jsxs(Vi.Fragment, {
      children: [Vi.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Vi.jsx(Mee, {})]
    });
  }
}
Se(mje, "defaultProps", BP);
function vje(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function V_(e, t) {
  if (e == null) return {};
  var n, r, o = vje(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var WW;
function yje(e) {
  var {
    id: t = BP.id,
    version: n = BP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = ht(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    gc && u && See();
  }, [u]), h(function() {
    f && Ho(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = kee({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!gc)
      return;
    function x() {
      y.current && (v(!0), WW = w);
    }
    if (window.google && window.google.maps && WW === w) {
      x();
      return;
    }
    Pee({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = ht();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var bje = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], wje = Vi.jsx(Mee, {});
function Cje(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = V_(e, bje), {
    isLoaded: s,
    loadError: l
  } = yje(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || wje;
}
me(Cje);
var HW;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(HW || (HW = {}));
function VW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _b(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VW(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $W = {}, qW = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Oje(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ft), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(_b(_b({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(Oje);
class xje extends pe {
  constructor() {
    super(...arguments), Se(this, "state", {
      trafficLayer: null
    }), Se(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Se(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(_b(_b({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: qW,
      eventMap: $W,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: qW,
      eventMap: $W,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Pn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(xje, "contextType", Ft);
function Lje(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ft), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(Lje);
class Eje extends pe {
  constructor() {
    super(...arguments), Se(this, "state", {
      bicyclingLayer: null
    }), Se(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(Eje, "contextType", Ft);
function kje(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ft), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(kje);
class Pje extends pe {
  constructor() {
    super(...arguments), Se(this, "state", {
      transitLayer: null
    }), Se(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(Pje, "contextType", Ft);
function ZW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Tb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZW(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GW = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, YW = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Sje(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ft), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Ho(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Tb(Tb({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && v(google.maps.event.addListener(N, "circlecomplete", r)), o && L(google.maps.event.addListener(N, "markercomplete", o)), i && D(google.maps.event.addListener(N, "overlaycomplete", i)), a && m(google.maps.event.addListener(N, "polygoncomplete", a)), s && S(google.maps.event.addListener(N, "polylinecomplete", s)), l && k(google.maps.event.addListener(N, "rectanglecomplete", l)), y(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(Sje);
class Mje extends pe {
  constructor(t) {
    super(t), Se(this, "registeredEvents", []), Se(this, "state", {
      drawingManager: null
    }), Se(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Ho(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Tb(Tb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: YW,
      eventMap: GW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: YW,
      eventMap: GW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Pn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Se(Mje, "contextType", Ft);
function XW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function np(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XW(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KW = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, JW = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, jb = {};
function Dje(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: W,
    onFlatChanged: Z,
    onIconChanged: X,
    onPositionChanged: K,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, H = ge(Ft), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null), [oe, Be] = E(null), [We, He] = E(null), [Ie, nt] = E(null), [$e, Ce] = E(null), [Qe, lt] = E(null), [be, Ee] = E(null), [Ae, ze] = E(null), [Re, ot] = E(null), [ve, yt] = E(null), [it, st] = E(null), [ut, bt] = E(null), [ct, wt] = E(null), [tt, gt] = E(null), [rt, Ct] = E(null), [pt, Et] = E(null), [Ot, kt] = E(null), [xt, Pt] = E(null);
  h(() => {
    O !== null && O.setMap(H);
  }, [H]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), He(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Ie !== null && google.maps.event.removeListener(Ie), nt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && N && ($e !== null && google.maps.event.removeListener($e), Ce(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), h(() => {
    O && L && (Qe !== null && google.maps.event.removeListener(Qe), lt(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (be !== null && google.maps.event.removeListener(be), Ee(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && R && (Ae !== null && google.maps.event.removeListener(Ae), ze(google.maps.event.addListener(O, "clickable_changed", R)));
  }, [R]), h(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), ot(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), yt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && W && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), bt(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && X && (ct !== null && google.maps.event.removeListener(ct), wt(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), h(() => {
    O && K && (tt !== null && google.maps.event.removeListener(tt), gt(google.maps.event.addListener(O, "position_changed", K)));
  }, [K]), h(() => {
    O && Q && (rt !== null && google.maps.event.removeListener(rt), Ct(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Et(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Ot !== null && google.maps.event.removeListener(Ot), kt(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (xt !== null && google.maps.event.removeListener(xt), Pt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var mt = np(np(np({}, n || jb), r ? jb : {
      map: H
    }), {}, {
      position: t
    }), ne = new google.maps.Marker(mt);
    return r ? r.addMarker(ne, !!o) : ne.setMap(H), t && ne.setPosition(t), typeof s < "u" && ne.setVisible(s), typeof a < "u" && ne.setDraggable(a), typeof u < "u" && ne.setClickable(u), typeof c == "string" && ne.setCursor(c), p && ne.setIcon(p), typeof d < "u" && ne.setLabel(d), typeof y < "u" && ne.setOpacity(y), f && ne.setShape(f), typeof v == "string" && ne.setTitle(v), typeof b == "number" && ne.setZIndex(b), w && T(google.maps.event.addListener(ne, "dblclick", w)), x && B(google.maps.event.addListener(ne, "dragend", x)), m && I(google.maps.event.addListener(ne, "dragstart", m)), k && he(google.maps.event.addListener(ne, "mousedown", k)), C && Be(google.maps.event.addListener(ne, "mouseout", C)), S && He(google.maps.event.addListener(ne, "mouseover", S)), U && nt(google.maps.event.addListener(ne, "mouseup", U)), N && Ce(google.maps.event.addListener(ne, "rightclick", N)), L && lt(google.maps.event.addListener(ne, "click", L)), D && Ee(google.maps.event.addListener(ne, "drag", D)), R && ze(google.maps.event.addListener(ne, "clickable_changed", R)), V && ot(google.maps.event.addListener(ne, "cursor_changed", V)), $ && yt(google.maps.event.addListener(ne, "animation_changed", $)), W && st(google.maps.event.addListener(ne, "draggable_changed", W)), Z && bt(google.maps.event.addListener(ne, "flat_changed", Z)), X && wt(google.maps.event.addListener(ne, "icon_changed", X)), K && gt(google.maps.event.addListener(ne, "position_changed", K)), Q && Ct(google.maps.event.addListener(ne, "shape_changed", Q)), J && Et(google.maps.event.addListener(ne, "title_changed", J)), P && kt(google.maps.event.addListener(ne, "visible_changed", P)), _ && Pt(google.maps.event.addListener(ne, "zindex_changed", _)), j(ne), z && z(ne), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), We !== null && google.maps.event.removeListener(We), Ie !== null && google.maps.event.removeListener(Ie), $e !== null && google.maps.event.removeListener($e), Qe !== null && google.maps.event.removeListener(Qe), Ae !== null && google.maps.event.removeListener(Ae), Re !== null && google.maps.event.removeListener(Re), ve !== null && google.maps.event.removeListener(ve), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), Ot !== null && google.maps.event.removeListener(Ot), xt !== null && google.maps.event.removeListener(xt), M && M(ne), r ? r.removeMarker(ne, !!o) : ne && ne.setMap(null);
    };
  }, []);
  var Vt = un(() => i ? at.map(i, (mt) => {
    if (!di(mt))
      return mt;
    var ne = mt;
    return fi(ne, {
      anchor: O
    });
  }) : null, [i, O]);
  return Vi.jsx(Vi.Fragment, {
    children: Vt
  }) || null;
}
me(Dje);
class _je extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Eee(function* () {
      var n = np(np(np({}, t.props.options || jb), t.props.clusterer ? jb : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = wn({
        updaterMap: JW,
        eventMap: KW,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: JW,
      eventMap: KW,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Pn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!di(n))
        return n;
      var r = n;
      return fi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Se(_je, "contextType", Ft);
var Tje = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), jje = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Tje(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Aje(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Bje = 2e3, Ije = 500, Rje = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Nje = "png", Fje = [53, 56, 66, 78, 90], zje = "cluster", Dee = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Rje, this.imageExtension = r.imageExtension || Nje, this.imageSizes = r.imageSizes || Fje, this.calculator = r.calculator || Aje, this.batchSize = r.batchSize || Bje, this.batchSizeIE = r.batchSizeIE || Ije, this.clusterClass = r.clusterClass || zje, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new jje(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function QW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uje(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QW(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Is = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, An = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Wje = {};
function Hje(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, N] = E(null), R = ge(Ft), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, Is.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, Is.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, Is.onClick, w)));
  }, [w]), h(() => {
    k && D && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(k, Is.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (X !== null && google.maps.event.removeListener(X), Z(google.maps.event.addListener(k, Is.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && An.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && An.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && An.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && An.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && An.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && An.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && An.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && An.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && An.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && An.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && An.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && An.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && An.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && An.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && An.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (R) {
      var z = Uje({}, n || Wje), M = new Dee(R, [], z);
      return r && An.averageCenter(M, r), o && An.batchSizeIE(M, o), i && An.calculator(M, i), a && An.clusterClass(M, a), s && An.enableRetinaIcons(M, s), l && An.gridSize(M, l), u && An.ignoreHidden(M, u), c && An.imageExtension(M, c), p && An.imagePath(M, p), d && An.imageSizes(M, d), y && An.maxZoom(M, y), f && An.minimumClusterSize(M, f), v && An.styles(M, v), b && An.title(M, b), L && An.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, Is.onMouseOut, C)), m && _(google.maps.event.addListener(M, Is.onMouseOver, m)), w && $(google.maps.event.addListener(M, Is.onClick, w)), D && Z(google.maps.event.addListener(M, Is.onClusteringBegin, D)), x && K(google.maps.event.addListener(M, Is.onClusteringEnd, x)), N(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(Hje);
class Vje extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      markerClusterer: null
    }), Se(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Dee(this.context, [], this.props.options);
      this.registeredEvents = wn({
        updaterMap: An,
        eventMap: Is,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: An,
      eventMap: Is,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Pn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Se(Vje, "contextType", Ft);
function eH(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var _ee = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || eH(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, eH));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), $je = ["position"], qje = ["position"];
function tH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ab(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nH = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, rH = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Zje = {};
function Gje(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ft), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var R = r || Zje, {
        position: V
      } = R, $ = V_(R, $je), W;
      V && !(V instanceof google.maps.LatLng) && (W = new google.maps.LatLng(V.lat, V.lng));
      var Z = new _ee(Ab(Ab({}, $), W ? {
        position: W
      } : {}));
      N.current = document.createElement("div"), v(Z), a && L(google.maps.event.addListener(Z, "closeclick", a)), s && D(google.maps.event.addListener(Z, "domready", s)), l && m(google.maps.event.addListener(Z, "content_changed", l)), u && S(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(y, n) : Z.getPosition() ? Z.open(y) : Ho(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(Gje);
class Yje extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "containerElement", null), Se(this, "state", {
      infoBox: null
    }), Se(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Ho(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Se(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = V_(t, qje), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new _ee(Ab(Ab({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = wn({
      updaterMap: rH,
      eventMap: nH,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: rH,
      eventMap: nH,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Pn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
Se(Yje, "contextType", Ft);
var oH, iH;
function Xje() {
  return iH || (iH = 1, oH = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), oH;
}
var Kje = Xje(), sH = /* @__PURE__ */ Lee(Kje), aH = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Rx = 1, hd = 8;
class $_ {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Rx)
      throw new Error("Got v".concat(o, " data when expected v").concat(Rx, "."));
    var i = aH[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new $_(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = aH.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, hd, t), this.coords = new this.ArrayType(this.data, hd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(hd + a + s + l), this.ids = new this.IndexArrayType(this.data, hd, t), this.coords = new this.ArrayType(this.data, hd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Rx << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return IP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          lH(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      lH(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function IP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Tee(e, t, a, r, o, i), IP(e, t, n, r, a - 1, 1 - i), IP(e, t, n, a + 1, o, 1 - i);
  }
}
function Tee(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Tee(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (gd(e, t, r, n), t[2 * o + i] > y && gd(e, t, r, o); f < v; ) {
      for (gd(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? gd(e, t, r, v) : (v++, gd(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function gd(e, t, n, r) {
  Nx(e, n, r), Nx(t, 2 * n, 2 * r), Nx(t, 2 * n + 1, 2 * r + 1);
}
function Nx(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function lH(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Jje = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, uH = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Nu = 2, Ul = 3, Fx = 4, jl = 5, jee = 6;
class Qje {
  constructor(t) {
    this.options = Object.assign(Object.create(Jje), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = uH(Km(u)), d = uH(Jm(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Km(r), Jm(a), Km(i), Jm(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + jl] > 1 ? cH(p, f, this.clusterProps) : this.points[p[f + Ul]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + Fx] === t && p.push(a[y + jl] > 1 ? cH(a, y, this.clusterProps) : this.points[a[y + Ul]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new $_(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + jl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Aee(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Ul]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Km(f), d = Jm(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Ul] : L = this.points[n[l + Ul]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Nu] <= n)) {
        l[p + Nu] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + jl], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Nu] > n && (b += l[w + jl]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Nu] <= n)) {
              l[k + Nu] = n;
              var N = l[k + jl];
              D += l[k] * N, x += l[k + 1] * N, l[k + Fx] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + Fx] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Nu] <= n)) {
                l[$ + Nu] = n;
                for (var W = 0; W < c; W++) u.push(l[$ + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + jl] > 1) {
      var o = this.clusterProps[t[n + jee]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ul]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function cH(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ul],
    properties: Aee(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [eAe(e[t]), tAe(e[t + 1])]
    }
  };
}
function Aee(e, t, n) {
  var r = e[t + jl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + jee], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ul],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Km(e) {
  return e / 360 + 0.5;
}
function Jm(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function eAe(e) {
  return (e - 0.5) * 360;
}
function tAe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function nAe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ps {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class RP {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(ps.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ps.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ps.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class rAe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return oAe(n);
  }
}
var oAe = (e) => {
  var t = e.map((n) => new RP({
    position: ps.getPosition(n),
    markers: [n]
  }));
  return t;
};
class iAe extends rAe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = nAe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Qje(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!sH(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = ps.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !sH(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new RP({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new RP({
      markers: [i],
      position: ps.getPosition(i)
    });
  }
}
class sAe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class aAe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (ps.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function lAe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class q_ {
  constructor() {
    lAe(q_, google.maps.OverlayView);
  }
}
var vf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(vf || (vf = {}));
var uAe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class cAe extends q_ {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new iAe(o),
      renderer: a = new aAe(),
      onClusterClick: s = uAe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ps.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, vf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ps.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => ps.setMap(l, null)));
      }
      google.maps.event.trigger(this, vf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ps.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new sAe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ps.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, vf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ps.setMap(r.marker, n);
    });
  }
}
function pH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function pAe(e) {
  var t = uje(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new cAe(dH(dH({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function dAe(e) {
  var {
    children: t,
    options: n
  } = e, r = pAe(n);
  return r !== null ? t(r) : null;
}
me(dAe);
var fH = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, hH = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function fAe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ft), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return v(R), N.current = document.createElement("div"), a && L(google.maps.event.addListener(R, "closeclick", a)), s && D(google.maps.event.addListener(R, "domready", s)), l && m(google.maps.event.addListener(R, "content_changed", l)), u && S(google.maps.event.addListener(R, "position_changed", u)), c && k(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(y, n) : R.getPosition() ? R.open(y) : Ho(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(R), R.close();
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(fAe);
class hAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "containerElement", null), Se(this, "state", {
      infoWindow: null
    }), Se(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Ho(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Se(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = wn({
      updaterMap: hH,
      eventMap: fH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: hH,
      eventMap: fH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Pn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
Se(hAe, "contextType", Ft);
function gH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mH = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, vH = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, gAe = {};
function mAe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Ft), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(Bb(Bb({}, t || gAe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && k(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && $(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && K(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), b && F(google.maps.event.addListener(T, "drag", b)), m(T), L && L(T), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(mAe);
class vAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      polyline: null
    }), Se(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Bb(Bb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: vH,
      eventMap: mH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: vH,
      eventMap: mH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Pn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Se(vAe, "contextType", Ft);
function yH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wH = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, CH = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function yAe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Ft), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var B = new google.maps.Polygon(bH(bH({}, t), {}, {
      map: m
    }));
    return i && B.setPath(i), a && B.setPaths(a), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && k(google.maps.event.addListener(B, "dblclick", s)), l && R(google.maps.event.addListener(B, "dragend", l)), u && $(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && K(google.maps.event.addListener(B, "mousemove", p)), d && J(google.maps.event.addListener(B, "mouseout", d)), y && _(google.maps.event.addListener(B, "mouseover", y)), f && M(google.maps.event.addListener(B, "mouseup", f)), v && O(google.maps.event.addListener(B, "rightclick", v)), b && F(google.maps.event.addListener(B, "click", b)), L && q(google.maps.event.addListener(B, "drag", L)), S(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), D && D(B), B.setMap(null);
    };
  }, []), null;
}
me(yAe);
class bAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = wn({
      updaterMap: CH,
      eventMap: wH,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: CH,
      eventMap: wH,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Pn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Se(bAe, "contextType", Ft);
function OH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ib(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xH = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, LH = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function wAe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Ft), [m, C] = E(null), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var Y = new google.maps.Rectangle(Ib(Ib({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && U(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && W(google.maps.event.addListener(Y, "mousedown", u)), c && X(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), y && z(google.maps.event.addListener(Y, "mouseup", y)), f && H(google.maps.event.addListener(Y, "rightclick", f)), v && j(google.maps.event.addListener(Y, "click", v)), b && T(google.maps.event.addListener(Y, "drag", b)), L && B(google.maps.event.addListener(Y, "bounds_changed", L)), C(Y), w && w(Y), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(Y), Y.setMap(null);
    };
  }, []), null;
}
me(wAe);
class CAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      rectangle: null
    }), Se(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Ib(Ib({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: LH,
      eventMap: xH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: LH,
      eventMap: xH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Pn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Se(CAe, "contextType", Ft);
function EH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kH = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, PH = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, OAe = {};
function xAe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Ft), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(Rb(Rb({}, t || OAe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), y && z(google.maps.event.addListener(oe, "mouseover", y)), f && H(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), b && T(google.maps.event.addListener(oe, "click", b)), L && B(google.maps.event.addListener(oe, "drag", L)), w && I(google.maps.event.addListener(oe, "center_changed", w)), D && he(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), x && x(oe), () => {
      k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
me(xAe);
class LAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      circle: null
    }), Se(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Rb(Rb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: PH,
      eventMap: kH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: PH,
      eventMap: kH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Pn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Se(LAe, "contextType", Ft);
function SH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? SH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : SH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var MH = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, DH = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function EAe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Ft), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var B = new google.maps.Data(Nb(Nb({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(B, "dblclick", r)), o && S(google.maps.event.addListener(B, "mousedown", o)), i && k(google.maps.event.addListener(B, "mousemove", i)), a && R(google.maps.event.addListener(B, "mouseout", a)), s && $(google.maps.event.addListener(B, "mouseover", s)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && K(google.maps.event.addListener(B, "rightclick", u)), n && J(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && O(google.maps.event.addListener(B, "removeproperty", d)), y && F(google.maps.event.addListener(B, "setgeometry", y)), f && q(google.maps.event.addListener(B, "setproperty", f)), D(B), v && v(B);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(EAe);
class kAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      data: null
    }), Se(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Nb(Nb({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = wn({
        updaterMap: DH,
        eventMap: MH,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: DH,
      eventMap: MH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Pn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Se(kAe, "contextType", Ft);
function _H(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function TH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _H(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _H(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jH = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, AH = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class PAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      kmlLayer: null
    }), Se(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(TH(TH({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: AH,
      eventMap: jH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: AH,
      eventMap: jH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Pn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(PAe, "contextType", Ft);
function Bee(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function SAe(e, t) {
  return new t(e.lat, e.lng);
}
function MAe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function DAe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function _Ae(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function TAe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function jAe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Iee(e, t, n, r) {
  return n !== void 0 ? TAe(e, t, _Ae(n, google.maps.LatLngBounds, MAe)) : jAe(e, t, DAe(r, google.maps.LatLng, SAe));
}
function AAe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function BH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BAe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function IAe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = BAe({}, this.container ? Bee(this.container, o) : {
        x: 0,
        y: 0
      }), u = Iee(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function IH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function RAe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function RH(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function NH(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function NAe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ft), c = un(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = un(() => IAe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), hi.createPortal(l, c);
}
me(NAe);
class jp extends pe {
  constructor(t) {
    super(t), Se(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Se(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Ho(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Se(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Se(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = RAe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Bee(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Iee(r, o, this.props.bounds, this.props.position);
      if (!AAe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Se(this, "draw", () => {
      this.onPositionElement();
    }), Se(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = zn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = RH(t.position), r = RH(this.props.position), o = NH(t.bounds), i = NH(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? hi.createPortal(Vi.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Se(jp, "FLOAT_PANE", "floatPane");
Se(jp, "MAP_PANE", "mapPane");
Se(jp, "MARKER_LAYER", "markerLayer");
Se(jp, "OVERLAY_LAYER", "overlayLayer");
Se(jp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Se(jp, "contextType", Ft);
function FAe() {
}
function FH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var UH = {
  onDblClick: "dblclick",
  onClick: "click"
}, WH = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function zAe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ft), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = un(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(zAe);
class Ree extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      groundOverlay: null
    }), Se(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Ho(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, zH(zH({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: WH,
      eventMap: UH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: WH,
      eventMap: UH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Se(Ree, "defaultProps", {
  onLoad: FAe
});
Se(Ree, "contextType", Ft);
function HH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HH(Object(n), !0).forEach(function(r) {
      Se(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var VH = {}, $H = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function UAe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ft), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || Ho(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Ho(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Fb(Fb({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(UAe);
class WAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      heatmapLayer: null
    }), Se(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Ho(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Ho(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Fb(Fb({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = wn({
      updaterMap: $H,
      eventMap: VH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: $H,
      eventMap: VH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Pn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Se(WAe, "contextType", Ft);
var qH = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, ZH = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class HAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      streetViewPanorama: null
    }), Se(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = wn({
      updaterMap: ZH,
      eventMap: qH,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: ZH,
      eventMap: qH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Pn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Se(HAe, "contextType", Ft);
class VAe extends pe {
  constructor() {
    super(...arguments), Se(this, "state", {
      streetViewService: null
    }), Se(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Se(VAe, "contextType", Ft);
var GH = {
  onDirectionsChanged: "directions_changed"
}, YH = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class $Ae extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "state", {
      directionsRenderer: null
    }), Se(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = wn({
      updaterMap: YH,
      eventMap: GH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: YH,
      eventMap: GH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Pn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Se($Ae, "contextType", Ft);
var XH = {
  onPlacesChanged: "places_changed"
}, KH = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class qAe extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "containerElement", zn()), Se(this, "state", {
      searchBox: null
    }), Se(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Ho(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = wn({
          updaterMap: KH,
          eventMap: XH,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: KH,
      eventMap: XH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Pn(this.registeredEvents));
  }
  render() {
    return Vi.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Se(qAe, "contextType", Ft);
var JH = {
  onPlaceChanged: "place_changed"
}, QH = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Nee extends pe {
  constructor() {
    super(...arguments), Se(this, "registeredEvents", []), Se(this, "containerElement", zn()), Se(this, "state", {
      autocomplete: null
    }), Se(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Ho(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = wn({
        updaterMap: QH,
        eventMap: JH,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Pn(this.registeredEvents), this.registeredEvents = wn({
      updaterMap: QH,
      eventMap: JH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Pn(this.registeredEvents);
  }
  render() {
    return Vi.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Se(Nee, "defaultProps", {
  className: ""
});
Se(Nee, "contextType", Ft);
let ZAe = { data: "" }, GAe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || ZAe, YAe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, XAe = /\/\*[^]*?\*\/|  +/g, eV = /\n+/g, Kl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Kl(a, i) : i + "{" + Kl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Kl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Kl.p ? Kl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ia = {}, Fee = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Fee(e[n]);
    return t;
  }
  return e;
}, KAe = (e, t, n, r, o) => {
  let i = Fee(e), a = Ia[i] || (Ia[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ia[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = YAe.exec(u.replace(XAe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(eV, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(eV, " ").trim();
      return d[0];
    })(e);
    Ia[a] = Kl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ia.g ? Ia.g : null;
  return n && (Ia.g = Ia[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ia[a], t, r, s), a;
}, JAe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Kl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function oC(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return KAe(n.unshift ? n.raw ? JAe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, GAe(t.target), t.g, t.o, t.k);
}
let zee, NP, FP;
oC.bind({ g: 1 });
let Qa = oC.bind({ k: 1 });
function QAe(e, t, n, r) {
  Kl.p = t, zee = e, NP = n, FP = r;
}
function ku(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: NP && NP() }, s), n.o = / *go\d+/.test(l), s.className = oC.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), FP && u[0] && FP(s), zee(u, s);
    }
    return o;
  };
}
var eBe = (e) => typeof e == "function", tBe = (e, t) => eBe(e) ? e(t) : e, nBe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), rBe = Qa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, oBe = Qa`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, iBe = Qa`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, sBe = ku("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${rBe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${oBe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${iBe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, aBe = Qa`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, lBe = ku("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${aBe} 1s linear infinite;
`, uBe = Qa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, cBe = Qa`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, pBe = ku("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${uBe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${cBe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, dBe = ku("div")`
  position: absolute;
`, fBe = ku("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, hBe = Qa`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, gBe = ku("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${hBe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, mBe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(gBe, null, t) : t : n === "blank" ? null : Ne.createElement(fBe, null, Ne.createElement(lBe, { ...r }), n !== "loading" && Ne.createElement(dBe, null, n === "error" ? Ne.createElement(sBe, { ...r }) : Ne.createElement(pBe, { ...r })));
}, vBe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, yBe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, bBe = "0%{opacity:0;} 100%{opacity:1;}", wBe = "0%{opacity:1;} 100%{opacity:0;}", CBe = ku("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, OBe = ku("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, xBe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = nBe() ? [bBe, wBe] : [vBe(n), yBe(n)];
  return { animation: t ? `${Qa(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Qa(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? xBe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(mBe, { toast: e }), a = Ne.createElement(OBe, { ...e.ariaProps }, tBe(e.message, e));
  return Ne.createElement(CBe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
QAe(Ne.createElement);
oC`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ve({});
function LBe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const EBe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
LBe(EBe.CNPJ).length;
ma((e, t) => /* @__PURE__ */ Hi.jsx("input", { ref: t, ...e }));
Ve({});
var ul = {};
Object.defineProperty(ul, "__esModule", {
  value: !0
});
var kBe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), zx = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Uee = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: kBe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Z_ = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Qm = 1; Qm < 20; Qm++)
  Z_["f" + Qm] = 111 + Qm;
function iC(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Wee(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Hee(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function PBe(e, t) {
  return iC(e, t);
}
function SBe(e, t) {
  return iC(e, { byKey: !0 }, t);
}
function Wee(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in zx)
    r[zx[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = G_(d), v = zx[f];
      if (d.length > 1 && !v && !Uee[d] && !Z_[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Vee(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Hee(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Vee(e) {
  e = G_(e);
  var t = Z_[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function G_(e) {
  return e = e.toLowerCase(), e = Uee[e] || e, e;
}
ul.default = iC;
var Ux = ul.isHotkey = iC;
ul.isCodeHotkey = PBe;
ul.isKeyHotkey = SBe;
ul.parseHotkey = Wee;
ul.compareHotkey = Hee;
ul.toKeyCode = Vee;
ul.toKeyName = G_;
var MBe = typeof yr == "object" && yr && yr.Object === Object && yr, DBe = MBe, _Be = DBe, TBe = typeof self == "object" && self && self.Object === Object && self, jBe = _Be || TBe || Function("return this")(), ABe = jBe, BBe = ABe, IBe = BBe.Symbol, $ee = IBe, tV = $ee;
tV && tV.toStringTag;
var nV = $ee;
nV && nV.toStringTag;
var rV;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(rV || (rV = {}));
var Y_ = function(e) {
  return Object.freeze(e);
}, RBe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Y_(this);
  }
  return e;
}(), NBe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Y_(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), oV = typeof window < "u" ? window : {};
/msie|trident/i.test(oV.navigator && oV.navigator.userAgent);
var Wx = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new RBe((n ? t : e) || 0, (n ? e : t) || 0);
};
Y_({
  devicePixelContentBoxSize: Wx(),
  borderBoxSize: Wx(),
  contentBoxSize: Wx(),
  contentRect: new NBe(0, 0, 0, 0)
});
function hh(e) {
  "@babel/helpers - typeof";
  return hh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, hh(e);
}
function FBe(e, t) {
  if (hh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (hh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function zBe(e) {
  var t = FBe(e, "string");
  return hh(t) === "symbol" ? t : String(t);
}
function yf(e, t, n) {
  return t = zBe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var UBe = /* @__PURE__ */ Ve(null), Hx, Vx;
parseInt(we.version.split(".")[0], 10);
var iV = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), $x = typeof navigator < "u" && /Android/.test(navigator.userAgent), ev = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), WBe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Hx = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Hx !== void 0 && Hx[1] && parseInt((Vx = navigator.userAgent.match(/Version\/(\d+)/)) === null || Vx === void 0 ? void 0 : Vx[1], 10) < 17;
var HBe = /* @__PURE__ */ new WeakMap(), VBe = /* @__PURE__ */ new WeakMap(), $Be = /* @__PURE__ */ new WeakMap(), qBe = /* @__PURE__ */ new WeakMap(), ZBe = /* @__PURE__ */ new WeakMap(), sV = /* @__PURE__ */ new WeakMap(), GBe = /* @__PURE__ */ new WeakMap(), aV = /* @__PURE__ */ new WeakMap(), tv = /* @__PURE__ */ new WeakMap(), YBe = /* @__PURE__ */ new WeakMap(), XBe = /* @__PURE__ */ new WeakMap(), KBe = /* @__PURE__ */ new WeakMap(), qee = globalThis.Node, JBe = globalThis.Text, Zee = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, QBe = (e) => zb(e) && e.nodeType === 8, da = (e) => zb(e) && e.nodeType === 1, zb = (e) => {
  var t = Zee(e);
  return !!t && e instanceof t.Node;
}, lV = (e) => {
  var t = e && e.anchorNode && Zee(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, eIe = (e) => {
  var [t, n] = e;
  if (da(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Gee(t, o, r ? "backward" : "forward"), r = o < n; da(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = nIe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, tIe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Gee = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (QBe(o) || da(o) && o.childNodes.length === 0 || da(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, nIe = (e, t, n) => {
  var [r] = Gee(e, t, n);
  return r;
}, uV = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Yee = (e, t, n) => {
  var {
    target: r
  } = t;
  if (da(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = hn.getWindow(e);
  if (o.contains(r))
    return hn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Yee(e, i, n);
}, cV = (e, t) => !!(e.compareDocumentPosition(t) & qee.DOCUMENT_POSITION_PRECEDING), rIe = (e, t) => !!(e.compareDocumentPosition(t) & qee.DOCUMENT_POSITION_FOLLOWING), oIe = 0;
class iIe {
  constructor() {
    yf(this, "id", void 0), this.id = "".concat(oIe++);
  }
}
var hn = {
  androidPendingDiffs: (e) => KBe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = XBe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = hn.toDOMNode(e, e), n = hn.findDocumentOrShadowRoot(e);
    tv.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = hn.findDocumentOrShadowRoot(e), r = uV(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Vy.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = hn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = hn.toSlateNode(e, t.target), a = hn.findPath(e, i);
    if ($a.isElement(i) && cr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = cr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? cr.before(e, u) : cr.after(e, u);
      if (c) {
        var p = cr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = hn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = hn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = sV.get(t);
    return n || (n = new iIe(), sV.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = VBe.get(r);
      if (o == null) {
        if (cr.isEditor(r))
          return n;
        break;
      }
      var i = HBe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(is.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!tv.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          hn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = hn.toDOMNode(e, e), r = hn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = uV(r), i = hn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Vy.select(e, cr.start(e, [])), tv.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = $Be.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = hn.toDOMNode(e, e), i;
    try {
      i = da(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => zb(t) && hn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return cr.hasPath(e, n.path) && cr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => hn.hasEditableTarget(e, t) || hn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => zb(t) && hn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!YBe.get(e),
  isFocused: (e) => !!tv.get(e),
  isReadOnly: (e) => !!aV.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (aV.get(e)) return !1;
    var n = hn.hasTarget(e, t) && hn.toSlateNode(e, t);
    return $a.isElement(n) && cr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = GBe.get(e), r = cr.isEditor(t) ? qBe.get(e) : n == null ? void 0 : n.get(hn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(is.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = cr.node(e, t.path), r = hn.toDOMNode(e, n), o;
    cr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof JBe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(is.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Yt.isBackward(t), i = hn.toDOMPoint(e, n), a = Yt.isCollapsed(t) ? i : hn.toDOMPoint(e, r), s = hn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = da(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = da(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = da(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? ZBe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : eIe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = hn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = hn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if ($x && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var N = U[k];
          if (hn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var R = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, W = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = W.find((M) => rIe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var Z, X = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = (Z = X.findLast((M) => cV(L, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      $x && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      ev && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if ($x && !u && !r) {
      var K = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (K && hn.hasDOMNode(e, K, {
        editable: !0
      })) {
        var Q = hn.toSlateNode(e, K), {
          path: J,
          offset: P
        } = cr.start(e, hn.findPath(e, Q));
        return K.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = hn.toSlateNode(e, u), z = hn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = lV(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (lV(t)) {
        if (ev && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        WBe && tIe(s) || ev ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    ev && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = hn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = cV(s, u) || s === u && c < l, x = p ? w : hn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Yt.isExpanded(m) && Yt.isForward(m) && da(u) && cr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = cr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, sIe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, aIe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, lIe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Xr = (e) => {
  var t = sIe[e], n = aIe[e], r = lIe[e], o = t && Ux(t), i = n && Ux(n), a = r && Ux(r);
  return (s) => !!(o && o(s) || iV && i && i(s) || !iV && a && a(s));
};
Xr("bold"), Xr("compose"), Xr("moveBackward"), Xr("moveForward"), Xr("deleteBackward"), Xr("deleteForward"), Xr("deleteLineBackward"), Xr("deleteLineForward"), Xr("deleteWordBackward"), Xr("deleteWordForward"), Xr("extendBackward"), Xr("extendForward"), Xr("extendLineBackward"), Xr("extendLineForward"), Xr("italic"), Xr("moveLineBackward"), Xr("moveLineForward"), Xr("moveWordBackward"), Xr("moveWordForward"), Xr("redo"), Xr("insertSoftBreak"), Xr("splitBlock"), Xr("transposeCharacter"), Xr("undo");
var uIe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Yee(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, cIe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class pIe extends au {
  constructor() {
    super(...arguments), yf(this, "context", null), yf(this, "manager", null), yf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, cIe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = uIe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
yf(pIe, "contextType", UBe);
Ve({});
Ve({});
Ve({});
var Io = {}, X_ = {}, Gh = {}, Yh = {}, Xee = "Expected a function", pV = NaN, dIe = "[object Symbol]", fIe = /^\s+|\s+$/g, hIe = /^[-+]0x[0-9a-f]+$/i, gIe = /^0b[01]+$/i, mIe = /^0o[0-7]+$/i, vIe = parseInt, yIe = typeof yr == "object" && yr && yr.Object === Object && yr, bIe = typeof self == "object" && self && self.Object === Object && self, wIe = yIe || bIe || Function("return this")(), CIe = Object.prototype, OIe = CIe.toString, xIe = Math.max, LIe = Math.min, qx = function() {
  return wIe.Date.now();
};
function EIe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Xee);
  t = dV(t) || 0, Ub(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? xIe(dV(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? LIe(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = qx();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(qx());
  }
  function m() {
    var C = qx(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function kIe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Xee);
  return Ub(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), EIe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Ub(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function PIe(e) {
  return !!e && typeof e == "object";
}
function SIe(e) {
  return typeof e == "symbol" || PIe(e) && OIe.call(e) == dIe;
}
function dV(e) {
  if (typeof e == "number")
    return e;
  if (SIe(e))
    return pV;
  if (Ub(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Ub(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(fIe, "");
  var n = gIe.test(e);
  return n || mIe.test(e) ? vIe(e.slice(2), n ? 2 : 8) : hIe.test(e) ? pV : +e;
}
var MIe = kIe, Xh = {};
Object.defineProperty(Xh, "__esModule", {
  value: !0
});
Xh.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), ay.has(t) || ay.set(t, /* @__PURE__ */ new Set());
  var o = ay.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Xh.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), ay.get(t).delete(n.name || t);
};
var ay = /* @__PURE__ */ new Map();
Object.defineProperty(Yh, "__esModule", {
  value: !0
});
var DIe = MIe, _Ie = jIe(DIe), TIe = Xh;
function jIe(e) {
  return e && e.__esModule ? e : { default: e };
}
var AIe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, _Ie.default)(e, t);
}, fo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = AIe(function(r) {
        fo.scrollHandler(e);
      }, t);
      fo.scrollSpyContainers.push(e), (0, TIe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return fo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = fo.scrollSpyContainers[fo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(fo.currentPositionX(e), fo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    fo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = fo.scrollSpyContainers[fo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(fo.currentPositionX(t), fo.currentPositionY(t));
  },
  updateStates: function() {
    fo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    fo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), fo.spySetState && fo.spySetState.length && fo.spySetState.indexOf(e) > -1 && fo.spySetState.splice(fo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", fo.scrollHandler);
  },
  update: function() {
    return fo.scrollSpyContainers.forEach(function(e) {
      return fo.scrollHandler(e);
    });
  }
};
Yh.default = fo;
var Ap = {}, Kh = {};
Object.defineProperty(Kh, "__esModule", {
  value: !0
});
var BIe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, IIe = function() {
  return window.location.hash.replace(/^#/, "");
}, RIe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, NIe = function(e) {
  return getComputedStyle(e).position !== "static";
}, Zx = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, FIe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (NIe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Zx(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Zx(t, s).offsetTop - Zx(e, s).offsetTop;
};
Kh.default = {
  updateHash: BIe,
  getHash: IIe,
  filterElementInContainer: RIe,
  scrollOffset: FIe
};
var sC = {}, K_ = {};
Object.defineProperty(K_, "__esModule", {
  value: !0
});
K_.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var J_ = {};
Object.defineProperty(J_, "__esModule", {
  value: !0
});
var zIe = Xh, UIe = ["mousedown", "mousewheel", "touchmove", "keydown"];
J_.default = {
  subscribe: function(e) {
    return typeof document < "u" && UIe.forEach(function(t) {
      return (0, zIe.addPassiveEventListener)(document, t, e);
    });
  }
};
var Jh = {};
Object.defineProperty(Jh, "__esModule", {
  value: !0
});
var zP = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      zP.registered[e] = t;
    },
    remove: function(e) {
      zP.registered[e] = null;
    }
  }
};
Jh.default = zP;
Object.defineProperty(sC, "__esModule", {
  value: !0
});
var WIe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, HIe = Kh;
aC(HIe);
var VIe = K_, fV = aC(VIe), $Ie = J_, qIe = aC($Ie), ZIe = Jh, oa = aC(ZIe);
function aC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Kee = function(e) {
  return fV.default[e.smooth] || fV.default.defaultEasing;
}, GIe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, YIe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, UP = function() {
  return YIe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Jee = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Qee = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, ete = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, XIe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, KIe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, JIe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    oa.default.registered.end && oa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    UP.call(window, i);
    return;
  }
  oa.default.registered.end && oa.default.registered.end(o.to, o.target, o.currentPosition);
}, Q_ = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Qh = function(e, t, n, r) {
  t.data = t.data || Jee(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (qIe.default.subscribe(o), Q_(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Qee(t) : ete(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    oa.default.registered.end && oa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = GIe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Kee(t), a = JIe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      oa.default.registered.begin && oa.default.registered.begin(t.data.to, t.data.target), UP.call(window, a);
    }, t.delay);
    return;
  }
  oa.default.registered.begin && oa.default.registered.begin(t.data.to, t.data.target), UP.call(window, a);
}, lC = function(e) {
  return e = WIe({}, e), e.data = e.data || Jee(), e.absolute = !0, e;
}, QIe = function(e) {
  Qh(0, lC(e));
}, eRe = function(e, t) {
  Qh(e, lC(t));
}, tRe = function(e) {
  e = lC(e), Q_(e), Qh(e.horizontal ? XIe(e) : KIe(e), e);
}, nRe = function(e, t) {
  t = lC(t), Q_(t);
  var n = t.horizontal ? Qee(t) : ete(t);
  Qh(e + n, t);
};
sC.default = {
  animateTopScroll: Qh,
  getAnimationType: Kee,
  scrollToTop: QIe,
  scrollToBottom: tRe,
  scrollTo: eRe,
  scrollMore: nRe
};
Object.defineProperty(Ap, "__esModule", {
  value: !0
});
var rRe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, oRe = Kh, iRe = eT(oRe), sRe = sC, aRe = eT(sRe), lRe = Jh, nv = eT(lRe);
function eT(e) {
  return e && e.__esModule ? e : { default: e };
}
var rv = {}, hV = void 0;
Ap.default = {
  unmount: function() {
    rv = {};
  },
  register: function(e, t) {
    rv[e] = t;
  },
  unregister: function(e) {
    delete rv[e];
  },
  get: function(e) {
    return rv[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return hV = e;
  },
  getActiveLink: function() {
    return hV;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = rRe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = iRe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      nv.default.registered.begin && nv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, nv.default.registered.end && nv.default.registered.end(e, n);
      return;
    }
    aRe.default.animateTopScroll(s, t, e, n);
  }
};
var WP = { exports: {} }, Gx = { exports: {} }, qn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gV;
function uRe() {
  if (gV) return qn;
  gV = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return qn.AsyncMode = l, qn.ConcurrentMode = u, qn.ContextConsumer = s, qn.ContextProvider = a, qn.Element = t, qn.ForwardRef = c, qn.Fragment = r, qn.Lazy = f, qn.Memo = y, qn.Portal = n, qn.Profiler = i, qn.StrictMode = o, qn.Suspense = p, qn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, qn.isConcurrentMode = x, qn.isContextConsumer = function(m) {
    return D(m) === s;
  }, qn.isContextProvider = function(m) {
    return D(m) === a;
  }, qn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, qn.isForwardRef = function(m) {
    return D(m) === c;
  }, qn.isFragment = function(m) {
    return D(m) === r;
  }, qn.isLazy = function(m) {
    return D(m) === f;
  }, qn.isMemo = function(m) {
    return D(m) === y;
  }, qn.isPortal = function(m) {
    return D(m) === n;
  }, qn.isProfiler = function(m) {
    return D(m) === i;
  }, qn.isStrictMode = function(m) {
    return D(m) === o;
  }, qn.isSuspense = function(m) {
    return D(m) === p;
  }, qn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, qn.typeOf = D, qn;
}
var nr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mV;
function cRe() {
  return mV || (mV = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === y || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === L || I.$$typeof === w || I.$$typeof === v);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, N = c, R = r, V = f, $ = y, W = n, Z = i, X = o, K = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(I) || x(I) === l;
    }
    function P(I) {
      return x(I) === u;
    }
    function _(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function M(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function H(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function F(I) {
      return x(I) === y;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function B(I) {
      return x(I) === o;
    }
    function Y(I) {
      return x(I) === p;
    }
    nr.AsyncMode = m, nr.ConcurrentMode = C, nr.ContextConsumer = S, nr.ContextProvider = U, nr.Element = k, nr.ForwardRef = N, nr.Fragment = R, nr.Lazy = V, nr.Memo = $, nr.Portal = W, nr.Profiler = Z, nr.StrictMode = X, nr.Suspense = K, nr.isAsyncMode = J, nr.isConcurrentMode = P, nr.isContextConsumer = _, nr.isContextProvider = z, nr.isElement = M, nr.isForwardRef = H, nr.isFragment = O, nr.isLazy = j, nr.isMemo = F, nr.isPortal = T, nr.isProfiler = q, nr.isStrictMode = B, nr.isSuspense = Y, nr.isValidElementType = D, nr.typeOf = x;
  }()), nr;
}
var vV;
function tte() {
  return vV || (vV = 1, process.env.NODE_ENV === "production" ? Gx.exports = uRe() : Gx.exports = cRe()), Gx.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Yx, yV;
function pRe() {
  if (yV) return Yx;
  yV = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Yx = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, Yx;
}
var Xx, bV;
function tT() {
  if (bV) return Xx;
  bV = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Xx = e, Xx;
}
var wV, CV;
function nte() {
  return CV || (CV = 1, wV = Function.call.bind(Object.prototype.hasOwnProperty)), wV;
}
var Kx, OV;
function dRe() {
  if (OV) return Kx;
  OV = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = tT(), n = {}, r = nte();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Kx = o, Kx;
}
var Jx, xV;
function fRe() {
  if (xV) return Jx;
  xV = 1;
  var e = tte(), t = pRe(), n = tT(), r = nte(), o = dRe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Jx = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: N(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, j, F, T, q, B, Y) {
        if (T = T || d, B = B || F, Y !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + q + " `" + B + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + q + " `" + B + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, F, T, q, B);
      }
      var H = M.bind(null, !1);
      return H.isRequired = M.bind(null, !0), H;
    }
    function L(P) {
      function _(z, M, H, O, j, F) {
        var T = z[M], q = X(T);
        if (q !== P) {
          var B = K(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + B + "` supplied to `" + H + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var T = X(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var B = P(F, q, H, O, j + "[" + q + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!s(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!e.isValidElementType(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, H, O, j) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, T = J(z[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, H, O, j) {
        for (var F = z[M], T = 0; T < P.length; T++)
          if (f(F, P[T]))
            return null;
        var q = JSON.stringify(P, function(B, Y) {
          var I = K(Y);
          return I === "symbol" ? String(Y) : Y;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + H + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside objectOf.");
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var B = P(F, q, H, O, j + "." + q, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(H, O, j, F, T) {
        for (var q = [], B = 0; B < P.length; B++) {
          var Y = P[B], I = Y(H, O, j, F, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(M);
    }
    function N() {
      function P(_, z, M, H, O) {
        return W(_[z]) ? null : new v("Invalid " + H + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, _, z, M, H) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + H + "`."
      );
    }
    function V(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        for (var q in P) {
          var B = P[q];
          if (typeof B != "function")
            return R(H, O, j, q, K(B));
          var Y = B(F, q, H, O, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var B in q) {
          var Y = P[B];
          if (r(P, B) && typeof Y != "function")
            return R(H, O, j, B, K(Y));
          if (!Y)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + B + "` supplied to `" + H + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var I = Y(F, B, H, O, j + "." + B, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(_);
    }
    function W(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(W);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var H = M.value;
                if (H && !W(H[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function X(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(_, P) ? "symbol" : _;
    }
    function K(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = X(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = K(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, Jx;
}
var Qx, LV;
function hRe() {
  if (LV) return Qx;
  LV = 1;
  var e = tT();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Qx = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Qx;
}
if (process.env.NODE_ENV !== "production") {
  var gRe = tte(), mRe = !0;
  WP.exports = fRe()(gRe.isElement, mRe);
} else
  WP.exports = hRe()();
var uC = WP.exports, cC = {};
Object.defineProperty(cC, "__esModule", {
  value: !0
});
var vRe = Kh, eL = yRe(vRe);
function yRe(e) {
  return e && e.__esModule ? e : { default: e };
}
var bRe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return eL.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && eL.default.getHash() !== e && eL.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
cC.default = bRe;
Object.defineProperty(Gh, "__esModule", {
  value: !0
});
var ov = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, wRe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), CRe = we, EV = eg(CRe), ORe = Yh, iv = eg(ORe), xRe = Ap, LRe = eg(xRe), ERe = uC, Kr = eg(ERe), kRe = cC, wl = eg(kRe);
function eg(e) {
  return e && e.__esModule ? e : { default: e };
}
function PRe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function SRe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function MRe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kV = {
  to: Kr.default.string.isRequired,
  containerId: Kr.default.string,
  container: Kr.default.object,
  activeClass: Kr.default.string,
  activeStyle: Kr.default.object,
  spy: Kr.default.bool,
  horizontal: Kr.default.bool,
  smooth: Kr.default.oneOfType([Kr.default.bool, Kr.default.string]),
  offset: Kr.default.number,
  delay: Kr.default.number,
  isDynamic: Kr.default.bool,
  onClick: Kr.default.func,
  duration: Kr.default.oneOfType([Kr.default.number, Kr.default.func]),
  absolute: Kr.default.bool,
  onSetActive: Kr.default.func,
  onSetInactive: Kr.default.func,
  ignoreCancelEvents: Kr.default.bool,
  hashSpy: Kr.default.bool,
  saveHashHistory: Kr.default.bool,
  spyThrottle: Kr.default.number
};
Gh.default = function(e, t) {
  var n = t || LRe.default, r = function(i) {
    MRe(a, i);
    function a(s) {
      PRe(this, a);
      var l = SRe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return wRe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          iv.default.isMounted(s) || iv.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (wl.default.isMounted() || wl.default.mount(n), wl.default.mapContainer(this.props.to, s)), iv.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        iv.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = ov({}, this.props.style, this.props.activeStyle) : l = ov({}, this.props.style);
        var u = ov({}, this.props);
        for (var c in kV)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, EV.default.createElement(e, u);
      }
    }]), a;
  }(EV.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, ov({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(wl.default.isMounted() && !wl.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var N = n.getActiveLink();
        if (y) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && wl.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            wl.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, W = $ === void 0 ? !1 : $;
          i.props.hashSpy && wl.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = kV, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(X_, "__esModule", {
  value: !0
});
var DRe = we, PV = rte(DRe), _Re = Gh, TRe = rte(_Re);
function rte(e) {
  return e && e.__esModule ? e : { default: e };
}
function jRe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function SV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ARe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var BRe = function(e) {
  ARe(t, e);
  function t() {
    var n, r, o, i;
    jRe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = SV(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return PV.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), SV(o, i);
  }
  return t;
}(PV.default.Component);
X_.default = (0, TRe.default)(BRe);
var nT = {};
Object.defineProperty(nT, "__esModule", {
  value: !0
});
var IRe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), RRe = we, MV = ote(RRe), NRe = Gh, FRe = ote(NRe);
function ote(e) {
  return e && e.__esModule ? e : { default: e };
}
function zRe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function URe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function WRe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var HRe = function(e) {
  WRe(t, e);
  function t() {
    return zRe(this, t), URe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return IRe(t, [{
    key: "render",
    value: function() {
      return MV.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(MV.default.Component);
nT.default = (0, FRe.default)(HRe);
var rT = {}, pC = {};
Object.defineProperty(pC, "__esModule", {
  value: !0
});
var VRe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $Re = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qRe = we, DV = dC(qRe), ZRe = il;
dC(ZRe);
var GRe = Ap, _V = dC(GRe), YRe = uC, TV = dC(YRe);
function dC(e) {
  return e && e.__esModule ? e : { default: e };
}
function XRe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KRe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function JRe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
pC.default = function(e) {
  var t = function(n) {
    JRe(r, n);
    function r(o) {
      XRe(this, r);
      var i = KRe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return $Re(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        _V.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        _V.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return DV.default.createElement(e, VRe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(DV.default.Component);
  return t.propTypes = {
    name: TV.default.string,
    id: TV.default.string
  }, t;
};
Object.defineProperty(rT, "__esModule", {
  value: !0
});
var jV = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, QRe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), eNe = we, AV = oT(eNe), tNe = pC, nNe = oT(tNe), rNe = uC, BV = oT(rNe);
function oT(e) {
  return e && e.__esModule ? e : { default: e };
}
function oNe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iNe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sNe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ite = function(e) {
  sNe(t, e);
  function t() {
    return oNe(this, t), iNe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return QRe(t, [{
    key: "render",
    value: function() {
      var n = this, r = jV({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, AV.default.createElement(
        "div",
        jV({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(AV.default.Component);
ite.propTypes = {
  name: BV.default.string,
  id: BV.default.string
};
rT.default = (0, nNe.default)(ite);
var tL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, IV = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function RV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function NV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function FV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var sv = we, Fu = Yh, nL = Ap, Co = uC, Cl = cC, zV = {
  to: Co.string.isRequired,
  containerId: Co.string,
  container: Co.object,
  activeClass: Co.string,
  spy: Co.bool,
  smooth: Co.oneOfType([Co.bool, Co.string]),
  offset: Co.number,
  delay: Co.number,
  isDynamic: Co.bool,
  onClick: Co.func,
  duration: Co.oneOfType([Co.number, Co.func]),
  absolute: Co.bool,
  onSetActive: Co.func,
  onSetInactive: Co.func,
  ignoreCancelEvents: Co.bool,
  hashSpy: Co.bool,
  spyThrottle: Co.number
}, aNe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || nL, r = function(i) {
      FV(a, i);
      function a(s) {
        RV(this, a);
        var l = NV(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return IV(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Fu.isMounted(s) || Fu.mount(s, this.props.spyThrottle), this.props.hashSpy && (Cl.isMounted() || Cl.mount(n), Cl.mapContainer(this.props.to, s)), this.props.spy && Fu.addStateHandler(this.stateHandler), Fu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Fu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = tL({}, this.props);
          for (var u in zV)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, sv.createElement(e, l);
        }
      }]), a;
    }(sv.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, tL({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Cl.isMounted() && !Cl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Cl.getHash() === l && Cl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Fu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Cl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Fu.updateStates();
        }
      };
    };
    return r.propTypes = zV, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      FV(r, n);
      function r(o) {
        RV(this, r);
        var i = NV(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return IV(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          nL.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          nL.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return sv.createElement(e, tL({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(sv.Component);
    return t.propTypes = {
      name: Co.string,
      id: Co.string
    }, t;
  }
}, lNe = aNe;
Object.defineProperty(Io, "__esModule", {
  value: !0
});
Io.Helpers = Io.ScrollElement = Io.ScrollLink = Io.animateScroll = Io.scrollSpy = Io.Events = Io.scroller = Io.Element = Io.Button = Io.Link = void 0;
var uNe = X_, ste = Ca(uNe), cNe = nT, ate = Ca(cNe), pNe = rT, lte = Ca(pNe), dNe = Ap, ute = Ca(dNe), fNe = Jh, cte = Ca(fNe), hNe = Yh, pte = Ca(hNe), gNe = sC, dte = Ca(gNe), mNe = Gh, fte = Ca(mNe), vNe = pC, hte = Ca(vNe), yNe = lNe, gte = Ca(yNe);
function Ca(e) {
  return e && e.__esModule ? e : { default: e };
}
Io.Link = ste.default;
Io.Button = ate.default;
Io.Element = lte.default;
Io.scroller = ute.default;
Io.Events = cte.default;
Io.scrollSpy = pte.default;
Io.animateScroll = dte.default;
Io.ScrollLink = fte.default;
Io.ScrollElement = hte.default;
Io.Helpers = gte.default;
Io.default = { Link: ste.default, Button: ate.default, Element: lte.default, scroller: ute.default, Events: cte.default, scrollSpy: pte.default, animateScroll: dte.default, ScrollLink: fte.default, ScrollElement: hte.default, Helpers: gte.default };
Ve({});
Ve({});
Ve({});
function gh(e) {
  "@babel/helpers - typeof";
  return gh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, gh(e);
}
function bNe(e, t) {
  if (gh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (gh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function wNe(e) {
  var t = bNe(e, "string");
  return gh(t) == "symbol" ? t : t + "";
}
function Me(e, t, n) {
  return (t = wNe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function mte(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var rL, UV;
function CNe() {
  if (UV) return rL;
  UV = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return rL = t, rL;
}
var ONe = CNe(), Vo = /* @__PURE__ */ mte(ONe), zt = Ve(null);
function xNe() {
  Vo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(zt);
  return Vo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function LNe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function ENe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function kNe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return ENe(e, i), o;
}
function PNe(e, t, n) {
  var r = LNe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function SNe(e) {
  google.maps.event.removeListener(e);
}
function Sn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(SNe);
}
function Cn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = PNe(o, i, n);
  return kNe(t, r, o, i), a;
}
function MNe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = ht(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null), [B, Y] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (B !== null && google.maps.event.removeListener(B), Y(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var I = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(I), I !== null && D && D(I), () => {
      I !== null && x && x(I);
    };
  }, []), Hi.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: Hi.jsx(zt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(MNe);
function WV(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function vte(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        WV(i, r, o, a, s, "next", l);
      }
      function s(l) {
        WV(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function yte(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Vo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var mc = typeof document < "u";
function bte(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return mc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function HV(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function wte() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return HV(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return HV(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var md = !1;
function Cte() {
  return Hi.jsx("div", {
    children: "Loading..."
  });
}
var HP = {
  id: "script-loader",
  version: "weekly"
};
class DNe extends pe {
  constructor() {
    super(...arguments), Me(this, "check", zn()), Me(this, "state", {
      loaded: !1
    }), Me(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Me(this, "isCleaningUp", /* @__PURE__ */ vte(function* () {
      function t(n) {
        if (!md)
          n();
        else if (mc)
          var r = window.setInterval(function() {
            md || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Me(this, "cleanup", () => {
      md = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Me(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && wte(), Vo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: yte(this.props)
      };
      bte(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (mc) {
      if (window.google && window.google.maps && !md) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), mc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (mc) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, md = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Hi.jsxs(Hi.Fragment, {
      children: [Hi.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Hi.jsx(Cte, {})]
    });
  }
}
Me(DNe, "defaultProps", HP);
function _Ne(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function iT(e, t) {
  if (e == null) return {};
  var n, r, o = _Ne(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var VV;
function TNe(e) {
  var {
    id: t = HP.id,
    version: n = HP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = ht(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    mc && u && wte();
  }, [u]), h(function() {
    f && Vo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = yte({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!mc)
      return;
    function x() {
      y.current && (v(!0), VV = w);
    }
    if (window.google && window.google.maps && VV === w) {
      x();
      return;
    }
    bte({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = ht();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var jNe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], ANe = Hi.jsx(Cte, {});
function BNe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = iT(e, jNe), {
    isLoaded: s,
    loadError: l
  } = TNe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || ANe;
}
me(BNe);
var $V;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})($V || ($V = {}));
function qV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qV(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZV = {}, GV = {
  options(e, t) {
    e.setOptions(t);
  }
};
function INe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(zt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Wb(Wb({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(INe);
class RNe extends pe {
  constructor() {
    super(...arguments), Me(this, "state", {
      trafficLayer: null
    }), Me(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Wb(Wb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: GV,
      eventMap: ZV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: GV,
      eventMap: ZV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Sn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(RNe, "contextType", zt);
function NNe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(zt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(NNe);
class FNe extends pe {
  constructor() {
    super(...arguments), Me(this, "state", {
      bicyclingLayer: null
    }), Me(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(FNe, "contextType", zt);
function zNe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(zt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(zNe);
class UNe extends pe {
  constructor() {
    super(...arguments), Me(this, "state", {
      transitLayer: null
    }), Me(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(UNe, "contextType", zt);
function YV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YV(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XV = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, KV = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function WNe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(zt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Vo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Hb(Hb({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && v(google.maps.event.addListener(N, "circlecomplete", r)), o && L(google.maps.event.addListener(N, "markercomplete", o)), i && D(google.maps.event.addListener(N, "overlaycomplete", i)), a && m(google.maps.event.addListener(N, "polygoncomplete", a)), s && S(google.maps.event.addListener(N, "polylinecomplete", s)), l && k(google.maps.event.addListener(N, "rectanglecomplete", l)), y(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(WNe);
class HNe extends pe {
  constructor(t) {
    super(t), Me(this, "registeredEvents", []), Me(this, "state", {
      drawingManager: null
    }), Me(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Vo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Hb(Hb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: KV,
      eventMap: XV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: KV,
      eventMap: XV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Sn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Me(HNe, "contextType", zt);
function JV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JV(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QV = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, e$ = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Vb = {};
function VNe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: W,
    onFlatChanged: Z,
    onIconChanged: X,
    onPositionChanged: K,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, H = ge(zt), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null), [oe, Be] = E(null), [We, He] = E(null), [Ie, nt] = E(null), [$e, Ce] = E(null), [Qe, lt] = E(null), [be, Ee] = E(null), [Ae, ze] = E(null), [Re, ot] = E(null), [ve, yt] = E(null), [it, st] = E(null), [ut, bt] = E(null), [ct, wt] = E(null), [tt, gt] = E(null), [rt, Ct] = E(null), [pt, Et] = E(null), [Ot, kt] = E(null), [xt, Pt] = E(null);
  h(() => {
    O !== null && O.setMap(H);
  }, [H]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), He(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Ie !== null && google.maps.event.removeListener(Ie), nt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && N && ($e !== null && google.maps.event.removeListener($e), Ce(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), h(() => {
    O && L && (Qe !== null && google.maps.event.removeListener(Qe), lt(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (be !== null && google.maps.event.removeListener(be), Ee(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && R && (Ae !== null && google.maps.event.removeListener(Ae), ze(google.maps.event.addListener(O, "clickable_changed", R)));
  }, [R]), h(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), ot(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), yt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && W && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), bt(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && X && (ct !== null && google.maps.event.removeListener(ct), wt(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), h(() => {
    O && K && (tt !== null && google.maps.event.removeListener(tt), gt(google.maps.event.addListener(O, "position_changed", K)));
  }, [K]), h(() => {
    O && Q && (rt !== null && google.maps.event.removeListener(rt), Ct(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Et(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Ot !== null && google.maps.event.removeListener(Ot), kt(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (xt !== null && google.maps.event.removeListener(xt), Pt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var mt = rp(rp(rp({}, n || Vb), r ? Vb : {
      map: H
    }), {}, {
      position: t
    }), ne = new google.maps.Marker(mt);
    return r ? r.addMarker(ne, !!o) : ne.setMap(H), t && ne.setPosition(t), typeof s < "u" && ne.setVisible(s), typeof a < "u" && ne.setDraggable(a), typeof u < "u" && ne.setClickable(u), typeof c == "string" && ne.setCursor(c), p && ne.setIcon(p), typeof d < "u" && ne.setLabel(d), typeof y < "u" && ne.setOpacity(y), f && ne.setShape(f), typeof v == "string" && ne.setTitle(v), typeof b == "number" && ne.setZIndex(b), w && T(google.maps.event.addListener(ne, "dblclick", w)), x && B(google.maps.event.addListener(ne, "dragend", x)), m && I(google.maps.event.addListener(ne, "dragstart", m)), k && he(google.maps.event.addListener(ne, "mousedown", k)), C && Be(google.maps.event.addListener(ne, "mouseout", C)), S && He(google.maps.event.addListener(ne, "mouseover", S)), U && nt(google.maps.event.addListener(ne, "mouseup", U)), N && Ce(google.maps.event.addListener(ne, "rightclick", N)), L && lt(google.maps.event.addListener(ne, "click", L)), D && Ee(google.maps.event.addListener(ne, "drag", D)), R && ze(google.maps.event.addListener(ne, "clickable_changed", R)), V && ot(google.maps.event.addListener(ne, "cursor_changed", V)), $ && yt(google.maps.event.addListener(ne, "animation_changed", $)), W && st(google.maps.event.addListener(ne, "draggable_changed", W)), Z && bt(google.maps.event.addListener(ne, "flat_changed", Z)), X && wt(google.maps.event.addListener(ne, "icon_changed", X)), K && gt(google.maps.event.addListener(ne, "position_changed", K)), Q && Ct(google.maps.event.addListener(ne, "shape_changed", Q)), J && Et(google.maps.event.addListener(ne, "title_changed", J)), P && kt(google.maps.event.addListener(ne, "visible_changed", P)), _ && Pt(google.maps.event.addListener(ne, "zindex_changed", _)), j(ne), z && z(ne), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), We !== null && google.maps.event.removeListener(We), Ie !== null && google.maps.event.removeListener(Ie), $e !== null && google.maps.event.removeListener($e), Qe !== null && google.maps.event.removeListener(Qe), Ae !== null && google.maps.event.removeListener(Ae), Re !== null && google.maps.event.removeListener(Re), ve !== null && google.maps.event.removeListener(ve), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), Ot !== null && google.maps.event.removeListener(Ot), xt !== null && google.maps.event.removeListener(xt), M && M(ne), r ? r.removeMarker(ne, !!o) : ne && ne.setMap(null);
    };
  }, []);
  var Vt = un(() => i ? at.map(i, (mt) => {
    if (!di(mt))
      return mt;
    var ne = mt;
    return fi(ne, {
      anchor: O
    });
  }) : null, [i, O]);
  return Hi.jsx(Hi.Fragment, {
    children: Vt
  }) || null;
}
me(VNe);
class $Ne extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return vte(function* () {
      var n = rp(rp(rp({}, t.props.options || Vb), t.props.clusterer ? Vb : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Cn({
        updaterMap: e$,
        eventMap: QV,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: e$,
      eventMap: QV,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Sn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!di(n))
        return n;
      var r = n;
      return fi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Me($Ne, "contextType", zt);
var qNe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), ZNe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new qNe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function GNe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var YNe = 2e3, XNe = 500, KNe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", JNe = "png", QNe = [53, 56, 66, 78, 90], eFe = "cluster", Ote = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || KNe, this.imageExtension = r.imageExtension || JNe, this.imageSizes = r.imageSizes || QNe, this.calculator = r.calculator || GNe, this.batchSize = r.batchSize || YNe, this.batchSizeIE = r.batchSizeIE || XNe, this.clusterClass = r.clusterClass || eFe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new ZNe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function t$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tFe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Bn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, nFe = {};
function rFe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, N] = E(null), R = ge(zt), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, Rs.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, Rs.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, Rs.onClick, w)));
  }, [w]), h(() => {
    k && D && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(k, Rs.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (X !== null && google.maps.event.removeListener(X), Z(google.maps.event.addListener(k, Rs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Bn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Bn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Bn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Bn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Bn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Bn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Bn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Bn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Bn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Bn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Bn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Bn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Bn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Bn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Bn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (R) {
      var z = tFe({}, n || nFe), M = new Ote(R, [], z);
      return r && Bn.averageCenter(M, r), o && Bn.batchSizeIE(M, o), i && Bn.calculator(M, i), a && Bn.clusterClass(M, a), s && Bn.enableRetinaIcons(M, s), l && Bn.gridSize(M, l), u && Bn.ignoreHidden(M, u), c && Bn.imageExtension(M, c), p && Bn.imagePath(M, p), d && Bn.imageSizes(M, d), y && Bn.maxZoom(M, y), f && Bn.minimumClusterSize(M, f), v && Bn.styles(M, v), b && Bn.title(M, b), L && Bn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, Rs.onMouseOut, C)), m && _(google.maps.event.addListener(M, Rs.onMouseOver, m)), w && $(google.maps.event.addListener(M, Rs.onClick, w)), D && Z(google.maps.event.addListener(M, Rs.onClusteringBegin, D)), x && K(google.maps.event.addListener(M, Rs.onClusteringEnd, x)), N(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(rFe);
class oFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      markerClusterer: null
    }), Me(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Ote(this.context, [], this.props.options);
      this.registeredEvents = Cn({
        updaterMap: Bn,
        eventMap: Rs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: Bn,
      eventMap: Rs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Sn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Me(oFe, "contextType", zt);
function n$(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var xte = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || n$(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, n$));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), iFe = ["position"], sFe = ["position"];
function r$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $b(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var o$ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, i$ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, aFe = {};
function lFe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(zt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var R = r || aFe, {
        position: V
      } = R, $ = iT(R, iFe), W;
      V && !(V instanceof google.maps.LatLng) && (W = new google.maps.LatLng(V.lat, V.lng));
      var Z = new xte($b($b({}, $), W ? {
        position: W
      } : {}));
      N.current = document.createElement("div"), v(Z), a && L(google.maps.event.addListener(Z, "closeclick", a)), s && D(google.maps.event.addListener(Z, "domready", s)), l && m(google.maps.event.addListener(Z, "content_changed", l)), u && S(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(y, n) : Z.getPosition() ? Z.open(y) : Vo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(lFe);
class uFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "containerElement", null), Me(this, "state", {
      infoBox: null
    }), Me(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Vo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Me(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = iT(t, sFe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new xte($b($b({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Cn({
      updaterMap: i$,
      eventMap: o$,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: i$,
      eventMap: o$,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Sn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
Me(uFe, "contextType", zt);
var s$, a$;
function cFe() {
  return a$ || (a$ = 1, s$ = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), s$;
}
var pFe = cFe(), l$ = /* @__PURE__ */ mte(pFe), u$ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], oL = 1, vd = 8;
let dFe = class Lte {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== oL)
      throw new Error("Got v".concat(o, " data when expected v").concat(oL, "."));
    var i = u$[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Lte(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = u$.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, vd, t), this.coords = new this.ArrayType(this.data, vd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(vd + a + s + l), this.ids = new this.IndexArrayType(this.data, vd, t), this.coords = new this.ArrayType(this.data, vd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (oL << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return VP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          c$(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      c$(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
};
function VP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Ete(e, t, a, r, o, i), VP(e, t, n, r, a - 1, 1 - i), VP(e, t, n, a + 1, o, 1 - i);
  }
}
function Ete(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Ete(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (yd(e, t, r, n), t[2 * o + i] > y && yd(e, t, r, o); f < v; ) {
      for (yd(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? yd(e, t, r, v) : (v++, yd(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function yd(e, t, n, r) {
  iL(e, n, r), iL(t, 2 * n, 2 * r), iL(t, 2 * n + 1, 2 * r + 1);
}
function iL(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function c$(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var fFe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, p$ = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), zu = 2, Wl = 3, sL = 4, Al = 5, kte = 6;
class hFe {
  constructor(t) {
    this.options = Object.assign(Object.create(fFe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = p$(av(u)), d = p$(lv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(av(r), lv(a), av(i), lv(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Al] > 1 ? d$(p, f, this.clusterProps) : this.points[p[f + Wl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + sL] === t && p.push(a[y + Al] > 1 ? d$(a, y, this.clusterProps) : this.points[a[y + Wl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new dFe(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Al] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Pte(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Wl]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = av(f), d = lv(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Wl] : L = this.points[n[l + Wl]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + zu] <= n)) {
        l[p + zu] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Al], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + zu] > n && (b += l[w + Al]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + zu] <= n)) {
              l[k + zu] = n;
              var N = l[k + Al];
              D += l[k] * N, x += l[k + 1] * N, l[k + sL] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + sL] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + zu] <= n)) {
                l[$ + zu] = n;
                for (var W = 0; W < c; W++) u.push(l[$ + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Al] > 1) {
      var o = this.clusterProps[t[n + kte]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Wl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function d$(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Wl],
    properties: Pte(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [gFe(e[t]), mFe(e[t + 1])]
    }
  };
}
function Pte(e, t, n) {
  var r = e[t + Al], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + kte], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Wl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function av(e) {
  return e / 360 + 0.5;
}
function lv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function gFe(e) {
  return (e - 0.5) * 360;
}
function mFe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function vFe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ds {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class $P {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(ds.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ds.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ds.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class yFe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return bFe(n);
  }
}
var bFe = (e) => {
  var t = e.map((n) => new $P({
    position: ds.getPosition(n),
    markers: [n]
  }));
  return t;
};
class wFe extends yFe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = vFe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new hFe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!l$(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = ds.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !l$(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new $P({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new $P({
      markers: [i],
      position: ds.getPosition(i)
    });
  }
}
class CFe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class OFe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (ds.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function xFe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class sT {
  constructor() {
    xFe(sT, google.maps.OverlayView);
  }
}
var bf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(bf || (bf = {}));
var LFe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class EFe extends sT {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new wFe(o),
      renderer: a = new OFe(),
      onClusterClick: s = LFe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ds.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, bf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ds.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => ds.setMap(l, null)));
      }
      google.maps.event.trigger(this, bf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ds.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new CFe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ds.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, bf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ds.setMap(r.marker, n);
    });
  }
}
function f$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function h$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function kFe(e) {
  var t = xNe(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new EFe(h$(h$({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function PFe(e) {
  var {
    children: t,
    options: n
  } = e, r = kFe(n);
  return r !== null ? t(r) : null;
}
me(PFe);
var g$ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, m$ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function SFe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(zt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return v(R), N.current = document.createElement("div"), a && L(google.maps.event.addListener(R, "closeclick", a)), s && D(google.maps.event.addListener(R, "domready", s)), l && m(google.maps.event.addListener(R, "content_changed", l)), u && S(google.maps.event.addListener(R, "position_changed", u)), c && k(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(y, n) : R.getPosition() ? R.open(y) : Vo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(R), R.close();
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(SFe);
class MFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "containerElement", null), Me(this, "state", {
      infoWindow: null
    }), Me(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Vo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Me(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Cn({
      updaterMap: m$,
      eventMap: g$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: m$,
      eventMap: g$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Sn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
Me(MFe, "contextType", zt);
function v$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? v$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : v$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var y$ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, b$ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, DFe = {};
function _Fe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(zt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(qb(qb({}, t || DFe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && k(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && $(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && K(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), b && F(google.maps.event.addListener(T, "drag", b)), m(T), L && L(T), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(_Fe);
class TFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      polyline: null
    }), Me(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(qb(qb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: b$,
      eventMap: y$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: b$,
      eventMap: y$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Sn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Me(TFe, "contextType", zt);
function w$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function C$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var O$ = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, x$ = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function jFe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(zt), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var B = new google.maps.Polygon(C$(C$({}, t), {}, {
      map: m
    }));
    return i && B.setPath(i), a && B.setPaths(a), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && k(google.maps.event.addListener(B, "dblclick", s)), l && R(google.maps.event.addListener(B, "dragend", l)), u && $(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && K(google.maps.event.addListener(B, "mousemove", p)), d && J(google.maps.event.addListener(B, "mouseout", d)), y && _(google.maps.event.addListener(B, "mouseover", y)), f && M(google.maps.event.addListener(B, "mouseup", f)), v && O(google.maps.event.addListener(B, "rightclick", v)), b && F(google.maps.event.addListener(B, "click", b)), L && q(google.maps.event.addListener(B, "drag", L)), S(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), D && D(B), B.setMap(null);
    };
  }, []), null;
}
me(jFe);
class AFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Cn({
      updaterMap: x$,
      eventMap: O$,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: x$,
      eventMap: O$,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Sn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Me(AFe, "contextType", zt);
function L$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E$ = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, k$ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function BFe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(zt), [m, C] = E(null), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var Y = new google.maps.Rectangle(Zb(Zb({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && U(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && W(google.maps.event.addListener(Y, "mousedown", u)), c && X(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), y && z(google.maps.event.addListener(Y, "mouseup", y)), f && H(google.maps.event.addListener(Y, "rightclick", f)), v && j(google.maps.event.addListener(Y, "click", v)), b && T(google.maps.event.addListener(Y, "drag", b)), L && B(google.maps.event.addListener(Y, "bounds_changed", L)), C(Y), w && w(Y), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(Y), Y.setMap(null);
    };
  }, []), null;
}
me(BFe);
class IFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      rectangle: null
    }), Me(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Zb(Zb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: k$,
      eventMap: E$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: k$,
      eventMap: E$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Sn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Me(IFe, "contextType", zt);
function P$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var S$ = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, M$ = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, RFe = {};
function NFe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(zt), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(Gb(Gb({}, t || RFe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), y && z(google.maps.event.addListener(oe, "mouseover", y)), f && H(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), b && T(google.maps.event.addListener(oe, "click", b)), L && B(google.maps.event.addListener(oe, "drag", L)), w && I(google.maps.event.addListener(oe, "center_changed", w)), D && he(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), x && x(oe), () => {
      k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
me(NFe);
class FFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      circle: null
    }), Me(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Gb(Gb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: M$,
      eventMap: S$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: M$,
      eventMap: S$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Sn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Me(FFe, "contextType", zt);
function D$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? D$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : D$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _$ = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, T$ = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function zFe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(zt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var B = new google.maps.Data(Yb(Yb({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(B, "dblclick", r)), o && S(google.maps.event.addListener(B, "mousedown", o)), i && k(google.maps.event.addListener(B, "mousemove", i)), a && R(google.maps.event.addListener(B, "mouseout", a)), s && $(google.maps.event.addListener(B, "mouseover", s)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && K(google.maps.event.addListener(B, "rightclick", u)), n && J(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && O(google.maps.event.addListener(B, "removeproperty", d)), y && F(google.maps.event.addListener(B, "setgeometry", y)), f && q(google.maps.event.addListener(B, "setproperty", f)), D(B), v && v(B);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(zFe);
class UFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      data: null
    }), Me(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Yb(Yb({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Cn({
        updaterMap: T$,
        eventMap: _$,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: T$,
      eventMap: _$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Sn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Me(UFe, "contextType", zt);
function j$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function A$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var B$ = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, I$ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class WFe extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      kmlLayer: null
    }), Me(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(A$(A$({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: I$,
      eventMap: B$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: I$,
      eventMap: B$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Sn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(WFe, "contextType", zt);
function Ste(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function HFe(e, t) {
  return new t(e.lat, e.lng);
}
function VFe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function $Fe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function qFe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function ZFe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function GFe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Mte(e, t, n, r) {
  return n !== void 0 ? ZFe(e, t, qFe(n, google.maps.LatLngBounds, VFe)) : GFe(e, t, $Fe(r, google.maps.LatLng, HFe));
}
function YFe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function R$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XFe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function KFe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = XFe({}, this.container ? Ste(this.container, o) : {
        x: 0,
        y: 0
      }), u = Mte(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function N$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JFe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function F$(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function z$(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function QFe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(zt), c = un(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = un(() => KFe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), hi.createPortal(l, c);
}
me(QFe);
class Bp extends pe {
  constructor(t) {
    super(t), Me(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Me(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Vo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Me(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Me(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = JFe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Ste(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Mte(r, o, this.props.bounds, this.props.position);
      if (!YFe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Me(this, "draw", () => {
      this.onPositionElement();
    }), Me(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = zn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = F$(t.position), r = F$(this.props.position), o = z$(t.bounds), i = z$(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? hi.createPortal(Hi.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Me(Bp, "FLOAT_PANE", "floatPane");
Me(Bp, "MAP_PANE", "mapPane");
Me(Bp, "MARKER_LAYER", "markerLayer");
Me(Bp, "OVERLAY_LAYER", "overlayLayer");
Me(Bp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Me(Bp, "contextType", zt);
function eze() {
}
function U$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function W$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H$ = {
  onDblClick: "dblclick",
  onClick: "click"
}, V$ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function tze(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(zt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = un(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(tze);
class Dte extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      groundOverlay: null
    }), Me(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Vo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, W$(W$({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: V$,
      eventMap: H$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: V$,
      eventMap: H$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Me(Dte, "defaultProps", {
  onLoad: eze
});
Me(Dte, "contextType", zt);
function $$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $$(Object(n), !0).forEach(function(r) {
      Me(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var q$ = {}, Z$ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function nze(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(zt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || Vo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Vo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Xb(Xb({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(nze);
class rze extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      heatmapLayer: null
    }), Me(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Vo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Vo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Xb(Xb({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Cn({
      updaterMap: Z$,
      eventMap: q$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: Z$,
      eventMap: q$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Sn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(rze, "contextType", zt);
var G$ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Y$ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class oze extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      streetViewPanorama: null
    }), Me(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Cn({
      updaterMap: Y$,
      eventMap: G$,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: Y$,
      eventMap: G$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Sn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Me(oze, "contextType", zt);
class ize extends pe {
  constructor() {
    super(...arguments), Me(this, "state", {
      streetViewService: null
    }), Me(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Me(ize, "contextType", zt);
var X$ = {
  onDirectionsChanged: "directions_changed"
}, K$ = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class sze extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "state", {
      directionsRenderer: null
    }), Me(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Cn({
      updaterMap: K$,
      eventMap: X$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: K$,
      eventMap: X$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Sn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Me(sze, "contextType", zt);
var J$ = {
  onPlacesChanged: "places_changed"
}, Q$ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class aze extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "containerElement", zn()), Me(this, "state", {
      searchBox: null
    }), Me(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Vo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Cn({
          updaterMap: Q$,
          eventMap: J$,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: Q$,
      eventMap: J$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Sn(this.registeredEvents));
  }
  render() {
    return Hi.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Me(aze, "contextType", zt);
var e3 = {
  onPlaceChanged: "place_changed"
}, t3 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class _te extends pe {
  constructor() {
    super(...arguments), Me(this, "registeredEvents", []), Me(this, "containerElement", zn()), Me(this, "state", {
      autocomplete: null
    }), Me(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Vo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Cn({
        updaterMap: t3,
        eventMap: e3,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Sn(this.registeredEvents), this.registeredEvents = Cn({
      updaterMap: t3,
      eventMap: e3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Sn(this.registeredEvents);
  }
  render() {
    return Hi.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Me(_te, "defaultProps", {
  className: ""
});
Me(_te, "contextType", zt);
let lze = { data: "" }, uze = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || lze, cze = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, pze = /\/\*[^]*?\*\/|  +/g, n3 = /\n+/g, Jl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Jl(a, i) : i + "{" + Jl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Jl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Jl.p ? Jl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ra = {}, Tte = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Tte(e[n]);
    return t;
  }
  return e;
}, dze = (e, t, n, r, o) => {
  let i = Tte(e), a = Ra[i] || (Ra[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ra[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = cze.exec(u.replace(pze, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(n3, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(n3, " ").trim();
      return d[0];
    })(e);
    Ra[a] = Jl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ra.g ? Ra.g : null;
  return n && (Ra.g = Ra[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ra[a], t, r, s), a;
}, fze = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Jl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function fC(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return dze(n.unshift ? n.raw ? fze(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, uze(t.target), t.g, t.o, t.k);
}
let jte, qP, ZP;
fC.bind({ g: 1 });
let el = fC.bind({ k: 1 });
function hze(e, t, n, r) {
  Jl.p = t, jte = e, qP = n, ZP = r;
}
function Pu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: qP && qP() }, s), n.o = / *go\d+/.test(l), s.className = fC.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), ZP && u[0] && ZP(s), jte(u, s);
    }
    return o;
  };
}
var gze = (e) => typeof e == "function", mze = (e, t) => gze(e) ? e(t) : e, vze = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), yze = el`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, bze = el`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, wze = el`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Cze = Pu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${yze} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${bze} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${wze} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Oze = el`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, xze = Pu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Oze} 1s linear infinite;
`, Lze = el`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Eze = el`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, kze = Pu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Lze} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Eze} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Pze = Pu("div")`
  position: absolute;
`, Sze = Pu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Mze = el`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Dze = Pu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Mze} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, _ze = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(Dze, null, t) : t : n === "blank" ? null : Ne.createElement(Sze, null, Ne.createElement(xze, { ...r }), n !== "loading" && Ne.createElement(Pze, null, n === "error" ? Ne.createElement(Cze, { ...r }) : Ne.createElement(kze, { ...r })));
}, Tze = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, jze = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Aze = "0%{opacity:0;} 100%{opacity:1;}", Bze = "0%{opacity:1;} 100%{opacity:0;}", Ize = Pu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Rze = Pu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Nze = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = vze() ? [Aze, Bze] : [Tze(n), jze(n)];
  return { animation: t ? `${el(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${el(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Nze(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(_ze, { toast: e }), a = Ne.createElement(Rze, { ...e.ariaProps }, mze(e.message, e));
  return Ne.createElement(Ize, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
hze(Ne.createElement);
fC`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ve({});
function Fze(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const zze = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
Fze(zze.CNPJ).length;
ma((e, t) => /* @__PURE__ */ Wi.jsx("input", { ref: t, ...e }));
Ve({});
var cl = {};
Object.defineProperty(cl, "__esModule", {
  value: !0
});
var Uze = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), aL = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Ate = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: Uze ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, aT = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var uv = 1; uv < 20; uv++)
  aT["f" + uv] = 111 + uv;
function hC(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Bte(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Ite(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Wze(e, t) {
  return hC(e, t);
}
function Hze(e, t) {
  return hC(e, { byKey: !0 }, t);
}
function Bte(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in aL)
    r[aL[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = lT(d), v = aL[f];
      if (d.length > 1 && !v && !Ate[d] && !aT[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Rte(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Ite(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Rte(e) {
  e = lT(e);
  var t = aT[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function lT(e) {
  return e = e.toLowerCase(), e = Ate[e] || e, e;
}
cl.default = hC;
var lL = cl.isHotkey = hC;
cl.isCodeHotkey = Wze;
cl.isKeyHotkey = Hze;
cl.parseHotkey = Bte;
cl.compareHotkey = Ite;
cl.toKeyCode = Rte;
cl.toKeyName = lT;
var Vze = typeof vr == "object" && vr && vr.Object === Object && vr, $ze = Vze, qze = $ze, Zze = typeof self == "object" && self && self.Object === Object && self, Gze = qze || Zze || Function("return this")(), Yze = Gze, Xze = Yze, Kze = Xze.Symbol, Nte = Kze, r3 = Nte;
r3 && r3.toStringTag;
var o3 = Nte;
o3 && o3.toStringTag;
var i3;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(i3 || (i3 = {}));
var uT = function(e) {
  return Object.freeze(e);
}, Jze = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, uT(this);
  }
  return e;
}(), Qze = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, uT(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), s3 = typeof window < "u" ? window : {};
/msie|trident/i.test(s3.navigator && s3.navigator.userAgent);
var uL = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Jze((n ? t : e) || 0, (n ? e : t) || 0);
};
uT({
  devicePixelContentBoxSize: uL(),
  borderBoxSize: uL(),
  contentBoxSize: uL(),
  contentRect: new Qze(0, 0, 0, 0)
});
function mh(e) {
  "@babel/helpers - typeof";
  return mh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, mh(e);
}
function e2e(e, t) {
  if (mh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (mh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function t2e(e) {
  var t = e2e(e, "string");
  return mh(t) === "symbol" ? t : String(t);
}
function wf(e, t, n) {
  return t = t2e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var n2e = /* @__PURE__ */ Ve(null), cL, pL;
parseInt(we.version.split(".")[0], 10);
var a3 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), dL = typeof navigator < "u" && /Android/.test(navigator.userAgent), cv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), r2e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (cL = navigator.userAgent.match(/Version\/(\d+)/)) !== null && cL !== void 0 && cL[1] && parseInt((pL = navigator.userAgent.match(/Version\/(\d+)/)) === null || pL === void 0 ? void 0 : pL[1], 10) < 17;
var o2e = /* @__PURE__ */ new WeakMap(), i2e = /* @__PURE__ */ new WeakMap(), s2e = /* @__PURE__ */ new WeakMap(), a2e = /* @__PURE__ */ new WeakMap(), l2e = /* @__PURE__ */ new WeakMap(), l3 = /* @__PURE__ */ new WeakMap(), u2e = /* @__PURE__ */ new WeakMap(), u3 = /* @__PURE__ */ new WeakMap(), pv = /* @__PURE__ */ new WeakMap(), c2e = /* @__PURE__ */ new WeakMap(), p2e = /* @__PURE__ */ new WeakMap(), d2e = /* @__PURE__ */ new WeakMap(), Fte = globalThis.Node, f2e = globalThis.Text, zte = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, h2e = (e) => Kb(e) && e.nodeType === 8, fa = (e) => Kb(e) && e.nodeType === 1, Kb = (e) => {
  var t = zte(e);
  return !!t && e instanceof t.Node;
}, c3 = (e) => {
  var t = e && e.anchorNode && zte(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, g2e = (e) => {
  var [t, n] = e;
  if (fa(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Ute(t, o, r ? "backward" : "forward"), r = o < n; fa(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = v2e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, m2e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Ute = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (h2e(o) || fa(o) && o.childNodes.length === 0 || fa(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, v2e = (e, t, n) => {
  var [r] = Ute(e, t, n);
  return r;
}, p3 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Wte = (e, t, n) => {
  var {
    target: r
  } = t;
  if (fa(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = gn.getWindow(e);
  if (o.contains(r))
    return gn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Wte(e, i, n);
}, d3 = (e, t) => !!(e.compareDocumentPosition(t) & Fte.DOCUMENT_POSITION_PRECEDING), y2e = (e, t) => !!(e.compareDocumentPosition(t) & Fte.DOCUMENT_POSITION_FOLLOWING), b2e = 0;
class w2e {
  constructor() {
    wf(this, "id", void 0), this.id = "".concat(b2e++);
  }
}
var gn = {
  androidPendingDiffs: (e) => d2e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = p2e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = gn.toDOMNode(e, e), n = gn.findDocumentOrShadowRoot(e);
    pv.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = gn.findDocumentOrShadowRoot(e), r = p3(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Fy.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = gn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = gn.toSlateNode(e, t.target), a = gn.findPath(e, i);
    if (Va.isElement(i) && ur.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = ur.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? ur.before(e, u) : ur.after(e, u);
      if (c) {
        var p = ur.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = gn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = gn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = l3.get(t);
    return n || (n = new w2e(), l3.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = i2e.get(r);
      if (o == null) {
        if (ur.isEditor(r))
          return n;
        break;
      }
      var i = o2e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(os.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!pv.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          gn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = gn.toDOMNode(e, e), r = gn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = p3(r), i = gn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Fy.select(e, ur.start(e, [])), pv.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = s2e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = gn.toDOMNode(e, e), i;
    try {
      i = fa(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Kb(t) && gn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return ur.hasPath(e, n.path) && ur.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => gn.hasEditableTarget(e, t) || gn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Kb(t) && gn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!c2e.get(e),
  isFocused: (e) => !!pv.get(e),
  isReadOnly: (e) => !!u3.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (u3.get(e)) return !1;
    var n = gn.hasTarget(e, t) && gn.toSlateNode(e, t);
    return Va.isElement(n) && ur.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = u2e.get(e), r = ur.isEditor(t) ? a2e.get(e) : n == null ? void 0 : n.get(gn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(os.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = ur.node(e, t.path), r = gn.toDOMNode(e, n), o;
    ur.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof f2e ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(os.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Gt.isBackward(t), i = gn.toDOMPoint(e, n), a = Gt.isCollapsed(t) ? i : gn.toDOMPoint(e, r), s = gn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = fa(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = fa(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = fa(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? l2e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : g2e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = gn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = gn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (dL && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var N = U[k];
          if (gn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var R = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, W = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = W.find((M) => y2e(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var Z, X = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = (Z = X.findLast((M) => d3(L, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      dL && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      cv && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (dL && !u && !r) {
      var K = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (K && gn.hasDOMNode(e, K, {
        editable: !0
      })) {
        var Q = gn.toSlateNode(e, K), {
          path: J,
          offset: P
        } = ur.start(e, gn.findPath(e, Q));
        return K.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = gn.toSlateNode(e, u), z = gn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = c3(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (c3(t)) {
        if (cv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        r2e && m2e(s) || cv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    cv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = gn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = d3(s, u) || s === u && c < l, x = p ? w : gn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Gt.isExpanded(m) && Gt.isForward(m) && fa(u) && ur.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = ur.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, C2e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, O2e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, x2e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Jr = (e) => {
  var t = C2e[e], n = O2e[e], r = x2e[e], o = t && lL(t), i = n && lL(n), a = r && lL(r);
  return (s) => !!(o && o(s) || a3 && i && i(s) || !a3 && a && a(s));
};
Jr("bold"), Jr("compose"), Jr("moveBackward"), Jr("moveForward"), Jr("deleteBackward"), Jr("deleteForward"), Jr("deleteLineBackward"), Jr("deleteLineForward"), Jr("deleteWordBackward"), Jr("deleteWordForward"), Jr("extendBackward"), Jr("extendForward"), Jr("extendLineBackward"), Jr("extendLineForward"), Jr("italic"), Jr("moveLineBackward"), Jr("moveLineForward"), Jr("moveWordBackward"), Jr("moveWordForward"), Jr("redo"), Jr("insertSoftBreak"), Jr("splitBlock"), Jr("transposeCharacter"), Jr("undo");
var L2e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Wte(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, E2e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class k2e extends au {
  constructor() {
    super(...arguments), wf(this, "context", null), wf(this, "manager", null), wf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, E2e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = L2e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
wf(k2e, "contextType", n2e);
Ve({});
Ve({});
Ve({});
var Ro = {}, cT = {}, tg = {}, ng = {}, Hte = "Expected a function", f3 = NaN, P2e = "[object Symbol]", S2e = /^\s+|\s+$/g, M2e = /^[-+]0x[0-9a-f]+$/i, D2e = /^0b[01]+$/i, _2e = /^0o[0-7]+$/i, T2e = parseInt, j2e = typeof vr == "object" && vr && vr.Object === Object && vr, A2e = typeof self == "object" && self && self.Object === Object && self, B2e = j2e || A2e || Function("return this")(), I2e = Object.prototype, R2e = I2e.toString, N2e = Math.max, F2e = Math.min, fL = function() {
  return B2e.Date.now();
};
function z2e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Hte);
  t = h3(t) || 0, Jb(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? N2e(h3(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? F2e(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = fL();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(fL());
  }
  function m() {
    var C = fL(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function U2e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Hte);
  return Jb(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), z2e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Jb(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function W2e(e) {
  return !!e && typeof e == "object";
}
function H2e(e) {
  return typeof e == "symbol" || W2e(e) && R2e.call(e) == P2e;
}
function h3(e) {
  if (typeof e == "number")
    return e;
  if (H2e(e))
    return f3;
  if (Jb(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Jb(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(S2e, "");
  var n = D2e.test(e);
  return n || _2e.test(e) ? T2e(e.slice(2), n ? 2 : 8) : M2e.test(e) ? f3 : +e;
}
var V2e = U2e, rg = {};
Object.defineProperty(rg, "__esModule", {
  value: !0
});
rg.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), ly.has(t) || ly.set(t, /* @__PURE__ */ new Set());
  var o = ly.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
rg.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), ly.get(t).delete(n.name || t);
};
var ly = /* @__PURE__ */ new Map();
Object.defineProperty(ng, "__esModule", {
  value: !0
});
var $2e = V2e, q2e = G2e($2e), Z2e = rg;
function G2e(e) {
  return e && e.__esModule ? e : { default: e };
}
var Y2e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, q2e.default)(e, t);
}, ho = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Y2e(function(r) {
        ho.scrollHandler(e);
      }, t);
      ho.scrollSpyContainers.push(e), (0, Z2e.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return ho.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = ho.scrollSpyContainers[ho.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(ho.currentPositionX(e), ho.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    ho.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = ho.scrollSpyContainers[ho.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(ho.currentPositionX(t), ho.currentPositionY(t));
  },
  updateStates: function() {
    ho.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    ho.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), ho.spySetState && ho.spySetState.length && ho.spySetState.indexOf(e) > -1 && ho.spySetState.splice(ho.spySetState.indexOf(e), 1), document.removeEventListener("scroll", ho.scrollHandler);
  },
  update: function() {
    return ho.scrollSpyContainers.forEach(function(e) {
      return ho.scrollHandler(e);
    });
  }
};
ng.default = ho;
var Ip = {}, og = {};
Object.defineProperty(og, "__esModule", {
  value: !0
});
var X2e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, K2e = function() {
  return window.location.hash.replace(/^#/, "");
}, J2e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Q2e = function(e) {
  return getComputedStyle(e).position !== "static";
}, hL = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, eUe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Q2e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = hL(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return hL(t, s).offsetTop - hL(e, s).offsetTop;
};
og.default = {
  updateHash: X2e,
  getHash: K2e,
  filterElementInContainer: J2e,
  scrollOffset: eUe
};
var gC = {}, pT = {};
Object.defineProperty(pT, "__esModule", {
  value: !0
});
pT.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var dT = {};
Object.defineProperty(dT, "__esModule", {
  value: !0
});
var tUe = rg, nUe = ["mousedown", "mousewheel", "touchmove", "keydown"];
dT.default = {
  subscribe: function(e) {
    return typeof document < "u" && nUe.forEach(function(t) {
      return (0, tUe.addPassiveEventListener)(document, t, e);
    });
  }
};
var ig = {};
Object.defineProperty(ig, "__esModule", {
  value: !0
});
var GP = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      GP.registered[e] = t;
    },
    remove: function(e) {
      GP.registered[e] = null;
    }
  }
};
ig.default = GP;
Object.defineProperty(gC, "__esModule", {
  value: !0
});
var rUe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, oUe = og;
mC(oUe);
var iUe = pT, g3 = mC(iUe), sUe = dT, aUe = mC(sUe), lUe = ig, ia = mC(lUe);
function mC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Vte = function(e) {
  return g3.default[e.smooth] || g3.default.defaultEasing;
}, uUe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, cUe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, YP = function() {
  return cUe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), $te = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, qte = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Zte = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, pUe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, dUe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, fUe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ia.default.registered.end && ia.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    YP.call(window, i);
    return;
  }
  ia.default.registered.end && ia.default.registered.end(o.to, o.target, o.currentPosition);
}, fT = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, sg = function(e, t, n, r) {
  t.data = t.data || $te(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (aUe.default.subscribe(o), fT(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? qte(t) : Zte(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ia.default.registered.end && ia.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = uUe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Vte(t), a = fUe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ia.default.registered.begin && ia.default.registered.begin(t.data.to, t.data.target), YP.call(window, a);
    }, t.delay);
    return;
  }
  ia.default.registered.begin && ia.default.registered.begin(t.data.to, t.data.target), YP.call(window, a);
}, vC = function(e) {
  return e = rUe({}, e), e.data = e.data || $te(), e.absolute = !0, e;
}, hUe = function(e) {
  sg(0, vC(e));
}, gUe = function(e, t) {
  sg(e, vC(t));
}, mUe = function(e) {
  e = vC(e), fT(e), sg(e.horizontal ? pUe(e) : dUe(e), e);
}, vUe = function(e, t) {
  t = vC(t), fT(t);
  var n = t.horizontal ? qte(t) : Zte(t);
  sg(e + n, t);
};
gC.default = {
  animateTopScroll: sg,
  getAnimationType: Vte,
  scrollToTop: hUe,
  scrollToBottom: mUe,
  scrollTo: gUe,
  scrollMore: vUe
};
Object.defineProperty(Ip, "__esModule", {
  value: !0
});
var yUe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, bUe = og, wUe = hT(bUe), CUe = gC, OUe = hT(CUe), xUe = ig, dv = hT(xUe);
function hT(e) {
  return e && e.__esModule ? e : { default: e };
}
var fv = {}, m3 = void 0;
Ip.default = {
  unmount: function() {
    fv = {};
  },
  register: function(e, t) {
    fv[e] = t;
  },
  unregister: function(e) {
    delete fv[e];
  },
  get: function(e) {
    return fv[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return m3 = e;
  },
  getActiveLink: function() {
    return m3;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = yUe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = wUe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      dv.default.registered.begin && dv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, dv.default.registered.end && dv.default.registered.end(e, n);
      return;
    }
    OUe.default.animateTopScroll(s, t, e, n);
  }
};
var XP = { exports: {} }, gL = { exports: {} }, Zn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var v3;
function LUe() {
  if (v3) return Zn;
  v3 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Zn.AsyncMode = l, Zn.ConcurrentMode = u, Zn.ContextConsumer = s, Zn.ContextProvider = a, Zn.Element = t, Zn.ForwardRef = c, Zn.Fragment = r, Zn.Lazy = f, Zn.Memo = y, Zn.Portal = n, Zn.Profiler = i, Zn.StrictMode = o, Zn.Suspense = p, Zn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Zn.isConcurrentMode = x, Zn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Zn.isContextProvider = function(m) {
    return D(m) === a;
  }, Zn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Zn.isForwardRef = function(m) {
    return D(m) === c;
  }, Zn.isFragment = function(m) {
    return D(m) === r;
  }, Zn.isLazy = function(m) {
    return D(m) === f;
  }, Zn.isMemo = function(m) {
    return D(m) === y;
  }, Zn.isPortal = function(m) {
    return D(m) === n;
  }, Zn.isProfiler = function(m) {
    return D(m) === i;
  }, Zn.isStrictMode = function(m) {
    return D(m) === o;
  }, Zn.isSuspense = function(m) {
    return D(m) === p;
  }, Zn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, Zn.typeOf = D, Zn;
}
var rr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var y3;
function EUe() {
  return y3 || (y3 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === y || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === L || I.$$typeof === w || I.$$typeof === v);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, N = c, R = r, V = f, $ = y, W = n, Z = i, X = o, K = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(I) || x(I) === l;
    }
    function P(I) {
      return x(I) === u;
    }
    function _(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function M(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function H(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function F(I) {
      return x(I) === y;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function B(I) {
      return x(I) === o;
    }
    function Y(I) {
      return x(I) === p;
    }
    rr.AsyncMode = m, rr.ConcurrentMode = C, rr.ContextConsumer = S, rr.ContextProvider = U, rr.Element = k, rr.ForwardRef = N, rr.Fragment = R, rr.Lazy = V, rr.Memo = $, rr.Portal = W, rr.Profiler = Z, rr.StrictMode = X, rr.Suspense = K, rr.isAsyncMode = J, rr.isConcurrentMode = P, rr.isContextConsumer = _, rr.isContextProvider = z, rr.isElement = M, rr.isForwardRef = H, rr.isFragment = O, rr.isLazy = j, rr.isMemo = F, rr.isPortal = T, rr.isProfiler = q, rr.isStrictMode = B, rr.isSuspense = Y, rr.isValidElementType = D, rr.typeOf = x;
  }()), rr;
}
var b3;
function Gte() {
  return b3 || (b3 = 1, process.env.NODE_ENV === "production" ? gL.exports = LUe() : gL.exports = EUe()), gL.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var mL, w3;
function kUe() {
  if (w3) return mL;
  w3 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return mL = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, mL;
}
var vL, C3;
function gT() {
  if (C3) return vL;
  C3 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return vL = e, vL;
}
var O3, x3;
function Yte() {
  return x3 || (x3 = 1, O3 = Function.call.bind(Object.prototype.hasOwnProperty)), O3;
}
var yL, L3;
function PUe() {
  if (L3) return yL;
  L3 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = gT(), n = {}, r = Yte();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, yL = o, yL;
}
var bL, E3;
function SUe() {
  if (E3) return bL;
  E3 = 1;
  var e = Gte(), t = kUe(), n = gT(), r = Yte(), o = PUe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return bL = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: N(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, j, F, T, q, B, Y) {
        if (T = T || d, B = B || F, Y !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + q + " `" + B + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + q + " `" + B + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, F, T, q, B);
      }
      var H = M.bind(null, !1);
      return H.isRequired = M.bind(null, !0), H;
    }
    function L(P) {
      function _(z, M, H, O, j, F) {
        var T = z[M], q = X(T);
        if (q !== P) {
          var B = K(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + B + "` supplied to `" + H + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var T = X(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var B = P(F, q, H, O, j + "[" + q + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!s(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!e.isValidElementType(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, H, O, j) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, T = J(z[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, H, O, j) {
        for (var F = z[M], T = 0; T < P.length; T++)
          if (f(F, P[T]))
            return null;
        var q = JSON.stringify(P, function(B, Y) {
          var I = K(Y);
          return I === "symbol" ? String(Y) : Y;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + H + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside objectOf.");
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var B = P(F, q, H, O, j + "." + q, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(H, O, j, F, T) {
        for (var q = [], B = 0; B < P.length; B++) {
          var Y = P[B], I = Y(H, O, j, F, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(M);
    }
    function N() {
      function P(_, z, M, H, O) {
        return W(_[z]) ? null : new v("Invalid " + H + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, _, z, M, H) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + H + "`."
      );
    }
    function V(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        for (var q in P) {
          var B = P[q];
          if (typeof B != "function")
            return R(H, O, j, q, K(B));
          var Y = B(F, q, H, O, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var B in q) {
          var Y = P[B];
          if (r(P, B) && typeof Y != "function")
            return R(H, O, j, B, K(Y));
          if (!Y)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + B + "` supplied to `" + H + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var I = Y(F, B, H, O, j + "." + B, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(_);
    }
    function W(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(W);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var H = M.value;
                if (H && !W(H[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function X(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(_, P) ? "symbol" : _;
    }
    function K(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = X(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = K(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, bL;
}
var wL, k3;
function MUe() {
  if (k3) return wL;
  k3 = 1;
  var e = gT();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, wL = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, wL;
}
if (process.env.NODE_ENV !== "production") {
  var DUe = Gte(), _Ue = !0;
  XP.exports = SUe()(DUe.isElement, _Ue);
} else
  XP.exports = MUe()();
var yC = XP.exports, bC = {};
Object.defineProperty(bC, "__esModule", {
  value: !0
});
var TUe = og, CL = jUe(TUe);
function jUe(e) {
  return e && e.__esModule ? e : { default: e };
}
var AUe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return CL.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && CL.default.getHash() !== e && CL.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
bC.default = AUe;
Object.defineProperty(tg, "__esModule", {
  value: !0
});
var hv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, BUe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), IUe = we, P3 = ag(IUe), RUe = ng, gv = ag(RUe), NUe = Ip, FUe = ag(NUe), zUe = yC, Qr = ag(zUe), UUe = bC, Ol = ag(UUe);
function ag(e) {
  return e && e.__esModule ? e : { default: e };
}
function WUe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HUe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function VUe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var S3 = {
  to: Qr.default.string.isRequired,
  containerId: Qr.default.string,
  container: Qr.default.object,
  activeClass: Qr.default.string,
  activeStyle: Qr.default.object,
  spy: Qr.default.bool,
  horizontal: Qr.default.bool,
  smooth: Qr.default.oneOfType([Qr.default.bool, Qr.default.string]),
  offset: Qr.default.number,
  delay: Qr.default.number,
  isDynamic: Qr.default.bool,
  onClick: Qr.default.func,
  duration: Qr.default.oneOfType([Qr.default.number, Qr.default.func]),
  absolute: Qr.default.bool,
  onSetActive: Qr.default.func,
  onSetInactive: Qr.default.func,
  ignoreCancelEvents: Qr.default.bool,
  hashSpy: Qr.default.bool,
  saveHashHistory: Qr.default.bool,
  spyThrottle: Qr.default.number
};
tg.default = function(e, t) {
  var n = t || FUe.default, r = function(i) {
    VUe(a, i);
    function a(s) {
      WUe(this, a);
      var l = HUe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return BUe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          gv.default.isMounted(s) || gv.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (Ol.default.isMounted() || Ol.default.mount(n), Ol.default.mapContainer(this.props.to, s)), gv.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        gv.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = hv({}, this.props.style, this.props.activeStyle) : l = hv({}, this.props.style);
        var u = hv({}, this.props);
        for (var c in S3)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, P3.default.createElement(e, u);
      }
    }]), a;
  }(P3.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, hv({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ol.default.isMounted() && !Ol.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var N = n.getActiveLink();
        if (y) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Ol.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            Ol.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, W = $ === void 0 ? !1 : $;
          i.props.hashSpy && Ol.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = S3, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(cT, "__esModule", {
  value: !0
});
var $Ue = we, M3 = Xte($Ue), qUe = tg, ZUe = Xte(qUe);
function Xte(e) {
  return e && e.__esModule ? e : { default: e };
}
function GUe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function D3(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function YUe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var XUe = function(e) {
  YUe(t, e);
  function t() {
    var n, r, o, i;
    GUe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = D3(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return M3.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), D3(o, i);
  }
  return t;
}(M3.default.Component);
cT.default = (0, ZUe.default)(XUe);
var mT = {};
Object.defineProperty(mT, "__esModule", {
  value: !0
});
var KUe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), JUe = we, _3 = Kte(JUe), QUe = tg, eWe = Kte(QUe);
function Kte(e) {
  return e && e.__esModule ? e : { default: e };
}
function tWe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nWe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function rWe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var oWe = function(e) {
  rWe(t, e);
  function t() {
    return tWe(this, t), nWe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return KUe(t, [{
    key: "render",
    value: function() {
      return _3.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(_3.default.Component);
mT.default = (0, eWe.default)(oWe);
var vT = {}, wC = {};
Object.defineProperty(wC, "__esModule", {
  value: !0
});
var iWe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, sWe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), aWe = we, T3 = CC(aWe), lWe = il;
CC(lWe);
var uWe = Ip, j3 = CC(uWe), cWe = yC, A3 = CC(cWe);
function CC(e) {
  return e && e.__esModule ? e : { default: e };
}
function pWe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function dWe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function fWe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
wC.default = function(e) {
  var t = function(n) {
    fWe(r, n);
    function r(o) {
      pWe(this, r);
      var i = dWe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return sWe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        j3.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        j3.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return T3.default.createElement(e, iWe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(T3.default.Component);
  return t.propTypes = {
    name: A3.default.string,
    id: A3.default.string
  }, t;
};
Object.defineProperty(vT, "__esModule", {
  value: !0
});
var B3 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, hWe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), gWe = we, I3 = yT(gWe), mWe = wC, vWe = yT(mWe), yWe = yC, R3 = yT(yWe);
function yT(e) {
  return e && e.__esModule ? e : { default: e };
}
function bWe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wWe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function CWe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Jte = function(e) {
  CWe(t, e);
  function t() {
    return bWe(this, t), wWe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return hWe(t, [{
    key: "render",
    value: function() {
      var n = this, r = B3({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, I3.default.createElement(
        "div",
        B3({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(I3.default.Component);
Jte.propTypes = {
  name: R3.default.string,
  id: R3.default.string
};
vT.default = (0, vWe.default)(Jte);
var OL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, N3 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function F3(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function z3(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function U3(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var mv = we, Uu = ng, xL = Ip, Oo = yC, xl = bC, W3 = {
  to: Oo.string.isRequired,
  containerId: Oo.string,
  container: Oo.object,
  activeClass: Oo.string,
  spy: Oo.bool,
  smooth: Oo.oneOfType([Oo.bool, Oo.string]),
  offset: Oo.number,
  delay: Oo.number,
  isDynamic: Oo.bool,
  onClick: Oo.func,
  duration: Oo.oneOfType([Oo.number, Oo.func]),
  absolute: Oo.bool,
  onSetActive: Oo.func,
  onSetInactive: Oo.func,
  ignoreCancelEvents: Oo.bool,
  hashSpy: Oo.bool,
  spyThrottle: Oo.number
}, OWe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || xL, r = function(i) {
      U3(a, i);
      function a(s) {
        F3(this, a);
        var l = z3(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return N3(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Uu.isMounted(s) || Uu.mount(s, this.props.spyThrottle), this.props.hashSpy && (xl.isMounted() || xl.mount(n), xl.mapContainer(this.props.to, s)), this.props.spy && Uu.addStateHandler(this.stateHandler), Uu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Uu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = OL({}, this.props);
          for (var u in W3)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, mv.createElement(e, l);
        }
      }]), a;
    }(mv.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, OL({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(xl.isMounted() && !xl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && xl.getHash() === l && xl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Uu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && xl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Uu.updateStates();
        }
      };
    };
    return r.propTypes = W3, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      U3(r, n);
      function r(o) {
        F3(this, r);
        var i = z3(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return N3(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          xL.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          xL.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return mv.createElement(e, OL({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(mv.Component);
    return t.propTypes = {
      name: Oo.string,
      id: Oo.string
    }, t;
  }
}, xWe = OWe;
Object.defineProperty(Ro, "__esModule", {
  value: !0
});
Ro.Helpers = Ro.ScrollElement = Ro.ScrollLink = Ro.animateScroll = Ro.scrollSpy = Ro.Events = Ro.scroller = Ro.Element = Ro.Button = Ro.Link = void 0;
var LWe = cT, Qte = Oa(LWe), EWe = mT, ene = Oa(EWe), kWe = vT, tne = Oa(kWe), PWe = Ip, nne = Oa(PWe), SWe = ig, rne = Oa(SWe), MWe = ng, one = Oa(MWe), DWe = gC, ine = Oa(DWe), _We = tg, sne = Oa(_We), TWe = wC, ane = Oa(TWe), jWe = xWe, lne = Oa(jWe);
function Oa(e) {
  return e && e.__esModule ? e : { default: e };
}
Ro.Link = Qte.default;
Ro.Button = ene.default;
Ro.Element = tne.default;
Ro.scroller = nne.default;
Ro.Events = rne.default;
Ro.scrollSpy = one.default;
Ro.animateScroll = ine.default;
Ro.ScrollLink = sne.default;
Ro.ScrollElement = ane.default;
Ro.Helpers = lne.default;
Ro.default = { Link: Qte.default, Button: ene.default, Element: tne.default, scroller: nne.default, Events: rne.default, scrollSpy: one.default, animateScroll: ine.default, ScrollLink: sne.default, ScrollElement: ane.default, Helpers: lne.default };
Ve({});
Ve({});
Ve({});
function vh(e) {
  "@babel/helpers - typeof";
  return vh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, vh(e);
}
function AWe(e, t) {
  if (vh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (vh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function BWe(e) {
  var t = AWe(e, "string");
  return vh(t) == "symbol" ? t : t + "";
}
function De(e, t, n) {
  return (t = BWe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function une(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var LL, H3;
function IWe() {
  if (H3) return LL;
  H3 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return LL = t, LL;
}
var RWe = IWe(), $o = /* @__PURE__ */ une(RWe), Ut = Ve(null);
function NWe() {
  $o(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ut);
  return $o(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function FWe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function zWe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function UWe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return zWe(e, i), o;
}
function WWe(e, t, n) {
  var r = FWe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function HWe(e) {
  google.maps.event.removeListener(e);
}
function Mn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(HWe);
}
function On(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = WWe(o, i, n);
  return UWe(t, r, o, i), a;
}
function VWe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = ht(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null), [B, Y] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (B !== null && google.maps.event.removeListener(B), Y(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var I = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(I), I !== null && D && D(I), () => {
      I !== null && x && x(I);
    };
  }, []), Wi.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: Wi.jsx(Ut.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(VWe);
function V3(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function cne(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        V3(i, r, o, a, s, "next", l);
      }
      function s(l) {
        V3(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function pne(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return $o(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var vc = typeof document < "u";
function dne(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return vc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function $3(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function fne() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return $3(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return $3(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var bd = !1;
function hne() {
  return Wi.jsx("div", {
    children: "Loading..."
  });
}
var KP = {
  id: "script-loader",
  version: "weekly"
};
class $We extends pe {
  constructor() {
    super(...arguments), De(this, "check", zn()), De(this, "state", {
      loaded: !1
    }), De(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), De(this, "isCleaningUp", /* @__PURE__ */ cne(function* () {
      function t(n) {
        if (!bd)
          n();
        else if (vc)
          var r = window.setInterval(function() {
            bd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), De(this, "cleanup", () => {
      bd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), De(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && fne(), $o(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: pne(this.props)
      };
      dne(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (vc) {
      if (window.google && window.google.maps && !bd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), vc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (vc) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, bd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Wi.jsxs(Wi.Fragment, {
      children: [Wi.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Wi.jsx(hne, {})]
    });
  }
}
De($We, "defaultProps", KP);
function qWe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function bT(e, t) {
  if (e == null) return {};
  var n, r, o = qWe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var q3;
function ZWe(e) {
  var {
    id: t = KP.id,
    version: n = KP.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = ht(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    vc && u && fne();
  }, [u]), h(function() {
    f && $o(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = pne({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!vc)
      return;
    function x() {
      y.current && (v(!0), q3 = w);
    }
    if (window.google && window.google.maps && q3 === w) {
      x();
      return;
    }
    dne({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = ht();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var GWe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], YWe = Wi.jsx(hne, {});
function XWe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = bT(e, GWe), {
    isLoaded: s,
    loadError: l
  } = ZWe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || YWe;
}
me(XWe);
var Z3;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Z3 || (Z3 = {}));
function G3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G3(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Y3 = {}, X3 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function KWe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ut), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Qb(Qb({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(KWe);
class JWe extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      trafficLayer: null
    }), De(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Qb(Qb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: X3,
      eventMap: Y3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: X3,
      eventMap: Y3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Mn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(JWe, "contextType", Ut);
function QWe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ut), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(QWe);
class eHe extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      bicyclingLayer: null
    }), De(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(eHe, "contextType", Ut);
function tHe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ut), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(tHe);
class nHe extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      transitLayer: null
    }), De(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(nHe, "contextType", Ut);
function K3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function e0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K3(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J3 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Q3 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function rHe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ut), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    $o(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(e0(e0({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && v(google.maps.event.addListener(N, "circlecomplete", r)), o && L(google.maps.event.addListener(N, "markercomplete", o)), i && D(google.maps.event.addListener(N, "overlaycomplete", i)), a && m(google.maps.event.addListener(N, "polygoncomplete", a)), s && S(google.maps.event.addListener(N, "polylinecomplete", s)), l && k(google.maps.event.addListener(N, "rectanglecomplete", l)), y(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(rHe);
class oHe extends pe {
  constructor(t) {
    super(t), De(this, "registeredEvents", []), De(this, "state", {
      drawingManager: null
    }), De(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), $o(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(e0(e0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: Q3,
      eventMap: J3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: Q3,
      eventMap: J3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Mn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
De(oHe, "contextType", Ut);
function e6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function op(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t6 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, n6 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, t0 = {};
function iHe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: W,
    onFlatChanged: Z,
    onIconChanged: X,
    onPositionChanged: K,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, H = ge(Ut), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null), [oe, Be] = E(null), [We, He] = E(null), [Ie, nt] = E(null), [$e, Ce] = E(null), [Qe, lt] = E(null), [be, Ee] = E(null), [Ae, ze] = E(null), [Re, ot] = E(null), [ve, yt] = E(null), [it, st] = E(null), [ut, bt] = E(null), [ct, wt] = E(null), [tt, gt] = E(null), [rt, Ct] = E(null), [pt, Et] = E(null), [Ot, kt] = E(null), [xt, Pt] = E(null);
  h(() => {
    O !== null && O.setMap(H);
  }, [H]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), He(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Ie !== null && google.maps.event.removeListener(Ie), nt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && N && ($e !== null && google.maps.event.removeListener($e), Ce(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), h(() => {
    O && L && (Qe !== null && google.maps.event.removeListener(Qe), lt(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (be !== null && google.maps.event.removeListener(be), Ee(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && R && (Ae !== null && google.maps.event.removeListener(Ae), ze(google.maps.event.addListener(O, "clickable_changed", R)));
  }, [R]), h(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), ot(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), yt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && W && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), bt(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && X && (ct !== null && google.maps.event.removeListener(ct), wt(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), h(() => {
    O && K && (tt !== null && google.maps.event.removeListener(tt), gt(google.maps.event.addListener(O, "position_changed", K)));
  }, [K]), h(() => {
    O && Q && (rt !== null && google.maps.event.removeListener(rt), Ct(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Et(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Ot !== null && google.maps.event.removeListener(Ot), kt(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (xt !== null && google.maps.event.removeListener(xt), Pt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var mt = op(op(op({}, n || t0), r ? t0 : {
      map: H
    }), {}, {
      position: t
    }), ne = new google.maps.Marker(mt);
    return r ? r.addMarker(ne, !!o) : ne.setMap(H), t && ne.setPosition(t), typeof s < "u" && ne.setVisible(s), typeof a < "u" && ne.setDraggable(a), typeof u < "u" && ne.setClickable(u), typeof c == "string" && ne.setCursor(c), p && ne.setIcon(p), typeof d < "u" && ne.setLabel(d), typeof y < "u" && ne.setOpacity(y), f && ne.setShape(f), typeof v == "string" && ne.setTitle(v), typeof b == "number" && ne.setZIndex(b), w && T(google.maps.event.addListener(ne, "dblclick", w)), x && B(google.maps.event.addListener(ne, "dragend", x)), m && I(google.maps.event.addListener(ne, "dragstart", m)), k && he(google.maps.event.addListener(ne, "mousedown", k)), C && Be(google.maps.event.addListener(ne, "mouseout", C)), S && He(google.maps.event.addListener(ne, "mouseover", S)), U && nt(google.maps.event.addListener(ne, "mouseup", U)), N && Ce(google.maps.event.addListener(ne, "rightclick", N)), L && lt(google.maps.event.addListener(ne, "click", L)), D && Ee(google.maps.event.addListener(ne, "drag", D)), R && ze(google.maps.event.addListener(ne, "clickable_changed", R)), V && ot(google.maps.event.addListener(ne, "cursor_changed", V)), $ && yt(google.maps.event.addListener(ne, "animation_changed", $)), W && st(google.maps.event.addListener(ne, "draggable_changed", W)), Z && bt(google.maps.event.addListener(ne, "flat_changed", Z)), X && wt(google.maps.event.addListener(ne, "icon_changed", X)), K && gt(google.maps.event.addListener(ne, "position_changed", K)), Q && Ct(google.maps.event.addListener(ne, "shape_changed", Q)), J && Et(google.maps.event.addListener(ne, "title_changed", J)), P && kt(google.maps.event.addListener(ne, "visible_changed", P)), _ && Pt(google.maps.event.addListener(ne, "zindex_changed", _)), j(ne), z && z(ne), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), We !== null && google.maps.event.removeListener(We), Ie !== null && google.maps.event.removeListener(Ie), $e !== null && google.maps.event.removeListener($e), Qe !== null && google.maps.event.removeListener(Qe), Ae !== null && google.maps.event.removeListener(Ae), Re !== null && google.maps.event.removeListener(Re), ve !== null && google.maps.event.removeListener(ve), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), Ot !== null && google.maps.event.removeListener(Ot), xt !== null && google.maps.event.removeListener(xt), M && M(ne), r ? r.removeMarker(ne, !!o) : ne && ne.setMap(null);
    };
  }, []);
  var Vt = un(() => i ? at.map(i, (mt) => {
    if (!di(mt))
      return mt;
    var ne = mt;
    return fi(ne, {
      anchor: O
    });
  }) : null, [i, O]);
  return Wi.jsx(Wi.Fragment, {
    children: Vt
  }) || null;
}
me(iHe);
class sHe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return cne(function* () {
      var n = op(op(op({}, t.props.options || t0), t.props.clusterer ? t0 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = On({
        updaterMap: n6,
        eventMap: t6,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: n6,
      eventMap: t6,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Mn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!di(n))
        return n;
      var r = n;
      return fi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
De(sHe, "contextType", Ut);
var aHe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), lHe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new aHe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function uHe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var cHe = 2e3, pHe = 500, dHe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", fHe = "png", hHe = [53, 56, 66, 78, 90], gHe = "cluster", gne = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || dHe, this.imageExtension = r.imageExtension || fHe, this.imageSizes = r.imageSizes || hHe, this.calculator = r.calculator || uHe, this.batchSize = r.batchSize || cHe, this.batchSizeIE = r.batchSizeIE || pHe, this.clusterClass = r.clusterClass || gHe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new lHe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function r6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mHe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ns = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, In = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, vHe = {};
function yHe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, N] = E(null), R = ge(Ut), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, Ns.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, Ns.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, Ns.onClick, w)));
  }, [w]), h(() => {
    k && D && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(k, Ns.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (X !== null && google.maps.event.removeListener(X), Z(google.maps.event.addListener(k, Ns.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && In.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && In.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && In.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && In.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && In.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && In.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && In.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && In.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && In.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && In.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && In.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && In.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && In.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && In.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && In.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (R) {
      var z = mHe({}, n || vHe), M = new gne(R, [], z);
      return r && In.averageCenter(M, r), o && In.batchSizeIE(M, o), i && In.calculator(M, i), a && In.clusterClass(M, a), s && In.enableRetinaIcons(M, s), l && In.gridSize(M, l), u && In.ignoreHidden(M, u), c && In.imageExtension(M, c), p && In.imagePath(M, p), d && In.imageSizes(M, d), y && In.maxZoom(M, y), f && In.minimumClusterSize(M, f), v && In.styles(M, v), b && In.title(M, b), L && In.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, Ns.onMouseOut, C)), m && _(google.maps.event.addListener(M, Ns.onMouseOver, m)), w && $(google.maps.event.addListener(M, Ns.onClick, w)), D && Z(google.maps.event.addListener(M, Ns.onClusteringBegin, D)), x && K(google.maps.event.addListener(M, Ns.onClusteringEnd, x)), N(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(yHe);
class bHe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      markerClusterer: null
    }), De(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new gne(this.context, [], this.props.options);
      this.registeredEvents = On({
        updaterMap: In,
        eventMap: Ns,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: In,
      eventMap: Ns,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Mn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
De(bHe, "contextType", Ut);
function o6(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var mne = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || o6(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, o6));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), wHe = ["position"], CHe = ["position"];
function i6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function n0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var s6 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, a6 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, OHe = {};
function xHe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ut), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var R = r || OHe, {
        position: V
      } = R, $ = bT(R, wHe), W;
      V && !(V instanceof google.maps.LatLng) && (W = new google.maps.LatLng(V.lat, V.lng));
      var Z = new mne(n0(n0({}, $), W ? {
        position: W
      } : {}));
      N.current = document.createElement("div"), v(Z), a && L(google.maps.event.addListener(Z, "closeclick", a)), s && D(google.maps.event.addListener(Z, "domready", s)), l && m(google.maps.event.addListener(Z, "content_changed", l)), u && S(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(y, n) : Z.getPosition() ? Z.open(y) : $o(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(xHe);
class LHe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", null), De(this, "state", {
      infoBox: null
    }), De(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : $o(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), De(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = bT(t, CHe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new mne(n0(n0({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = On({
      updaterMap: a6,
      eventMap: s6,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: a6,
      eventMap: s6,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Mn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
De(LHe, "contextType", Ut);
var l6, u6;
function EHe() {
  return u6 || (u6 = 1, l6 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), l6;
}
var kHe = EHe(), c6 = /* @__PURE__ */ une(kHe), p6 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], EL = 1, wd = 8;
class wT {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== EL)
      throw new Error("Got v".concat(o, " data when expected v").concat(EL, "."));
    var i = p6[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new wT(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = p6.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, wd, t), this.coords = new this.ArrayType(this.data, wd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(wd + a + s + l), this.ids = new this.IndexArrayType(this.data, wd, t), this.coords = new this.ArrayType(this.data, wd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (EL << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return JP(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          d6(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      d6(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function JP(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    vne(e, t, a, r, o, i), JP(e, t, n, r, a - 1, 1 - i), JP(e, t, n, a + 1, o, 1 - i);
  }
}
function vne(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      vne(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Cd(e, t, r, n), t[2 * o + i] > y && Cd(e, t, r, o); f < v; ) {
      for (Cd(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Cd(e, t, r, v) : (v++, Cd(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Cd(e, t, n, r) {
  kL(e, n, r), kL(t, 2 * n, 2 * r), kL(t, 2 * n + 1, 2 * r + 1);
}
function kL(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function d6(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var PHe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, f6 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Wu = 2, Hl = 3, PL = 4, Bl = 5, yne = 6;
class SHe {
  constructor(t) {
    this.options = Object.assign(Object.create(PHe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = f6(vv(u)), d = f6(yv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(vv(r), yv(a), vv(i), yv(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Bl] > 1 ? h6(p, f, this.clusterProps) : this.points[p[f + Hl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + PL] === t && p.push(a[y + Bl] > 1 ? h6(a, y, this.clusterProps) : this.points[a[y + Hl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new wT(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Bl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = bne(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Hl]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = vv(f), d = yv(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Hl] : L = this.points[n[l + Hl]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Wu] <= n)) {
        l[p + Wu] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Bl], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Wu] > n && (b += l[w + Bl]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Wu] <= n)) {
              l[k + Wu] = n;
              var N = l[k + Bl];
              D += l[k] * N, x += l[k + 1] * N, l[k + PL] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + PL] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Wu] <= n)) {
                l[$ + Wu] = n;
                for (var W = 0; W < c; W++) u.push(l[$ + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Bl] > 1) {
      var o = this.clusterProps[t[n + yne]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Hl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function h6(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Hl],
    properties: bne(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [MHe(e[t]), DHe(e[t + 1])]
    }
  };
}
function bne(e, t, n) {
  var r = e[t + Bl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + yne], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Hl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function vv(e) {
  return e / 360 + 0.5;
}
function yv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function MHe(e) {
  return (e - 0.5) * 360;
}
function DHe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function _He(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class fs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class QP {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(fs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => fs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (fs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class THe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return jHe(n);
  }
}
var jHe = (e) => {
  var t = e.map((n) => new QP({
    position: fs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class AHe extends THe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = _He(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new SHe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!c6(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = fs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !c6(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new QP({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new QP({
      markers: [i],
      position: fs.getPosition(i)
    });
  }
}
class BHe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class IHe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (fs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function RHe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class CT {
  constructor() {
    RHe(CT, google.maps.OverlayView);
  }
}
var Cf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Cf || (Cf = {}));
var NHe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class FHe extends CT {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new AHe(o),
      renderer: a = new IHe(),
      onClusterClick: s = NHe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (fs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Cf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || fs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => fs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Cf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => fs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new BHe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => fs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Cf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), fs.setMap(r.marker, n);
    });
  }
}
function g6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function m6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function zHe(e) {
  var t = NWe(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new FHe(m6(m6({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function UHe(e) {
  var {
    children: t,
    options: n
  } = e, r = zHe(n);
  return r !== null ? t(r) : null;
}
me(UHe);
var v6 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, y6 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function WHe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ut), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return v(R), N.current = document.createElement("div"), a && L(google.maps.event.addListener(R, "closeclick", a)), s && D(google.maps.event.addListener(R, "domready", s)), l && m(google.maps.event.addListener(R, "content_changed", l)), u && S(google.maps.event.addListener(R, "position_changed", u)), c && k(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(y, n) : R.getPosition() ? R.open(y) : $o(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(R), R.close();
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(WHe);
class HHe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", null), De(this, "state", {
      infoWindow: null
    }), De(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : $o(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), De(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = On({
      updaterMap: y6,
      eventMap: v6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: y6,
      eventMap: v6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Mn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
De(HHe, "contextType", Ut);
function b6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function r0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, C6 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, VHe = {};
function $He(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Ut), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(r0(r0({}, t || VHe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && k(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && $(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && K(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), b && F(google.maps.event.addListener(T, "drag", b)), m(T), L && L(T), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me($He);
class qHe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      polyline: null
    }), De(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(r0(r0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: C6,
      eventMap: w6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: C6,
      eventMap: w6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Mn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
De(qHe, "contextType", Ut);
function O6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function x6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, E6 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function ZHe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Ut), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var B = new google.maps.Polygon(x6(x6({}, t), {}, {
      map: m
    }));
    return i && B.setPath(i), a && B.setPaths(a), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && k(google.maps.event.addListener(B, "dblclick", s)), l && R(google.maps.event.addListener(B, "dragend", l)), u && $(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && K(google.maps.event.addListener(B, "mousemove", p)), d && J(google.maps.event.addListener(B, "mouseout", d)), y && _(google.maps.event.addListener(B, "mouseover", y)), f && M(google.maps.event.addListener(B, "mouseup", f)), v && O(google.maps.event.addListener(B, "rightclick", v)), b && F(google.maps.event.addListener(B, "click", b)), L && q(google.maps.event.addListener(B, "drag", L)), S(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), D && D(B), B.setMap(null);
    };
  }, []), null;
}
me(ZHe);
class GHe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = On({
      updaterMap: E6,
      eventMap: L6,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: E6,
      eventMap: L6,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Mn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
De(GHe, "contextType", Ut);
function k6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P6 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, S6 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function YHe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Ut), [m, C] = E(null), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var Y = new google.maps.Rectangle(o0(o0({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && U(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && W(google.maps.event.addListener(Y, "mousedown", u)), c && X(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), y && z(google.maps.event.addListener(Y, "mouseup", y)), f && H(google.maps.event.addListener(Y, "rightclick", f)), v && j(google.maps.event.addListener(Y, "click", v)), b && T(google.maps.event.addListener(Y, "drag", b)), L && B(google.maps.event.addListener(Y, "bounds_changed", L)), C(Y), w && w(Y), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(Y), Y.setMap(null);
    };
  }, []), null;
}
me(YHe);
class XHe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      rectangle: null
    }), De(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(o0(o0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: S6,
      eventMap: P6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: S6,
      eventMap: P6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Mn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
De(XHe, "contextType", Ut);
function M6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function i0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var D6 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, _6 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, KHe = {};
function JHe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Ut), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(i0(i0({}, t || KHe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), y && z(google.maps.event.addListener(oe, "mouseover", y)), f && H(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), b && T(google.maps.event.addListener(oe, "click", b)), L && B(google.maps.event.addListener(oe, "drag", L)), w && I(google.maps.event.addListener(oe, "center_changed", w)), D && he(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), x && x(oe), () => {
      k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
me(JHe);
class QHe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      circle: null
    }), De(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(i0(i0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: _6,
      eventMap: D6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: _6,
      eventMap: D6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Mn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
De(QHe, "contextType", Ut);
function T6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var j6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, A6 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function eVe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Ut), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var B = new google.maps.Data(s0(s0({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(B, "dblclick", r)), o && S(google.maps.event.addListener(B, "mousedown", o)), i && k(google.maps.event.addListener(B, "mousemove", i)), a && R(google.maps.event.addListener(B, "mouseout", a)), s && $(google.maps.event.addListener(B, "mouseover", s)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && K(google.maps.event.addListener(B, "rightclick", u)), n && J(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && O(google.maps.event.addListener(B, "removeproperty", d)), y && F(google.maps.event.addListener(B, "setgeometry", y)), f && q(google.maps.event.addListener(B, "setproperty", f)), D(B), v && v(B);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(eVe);
class tVe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      data: null
    }), De(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(s0(s0({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = On({
        updaterMap: A6,
        eventMap: j6,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: A6,
      eventMap: j6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Mn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
De(tVe, "contextType", Ut);
function B6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function I6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var R6 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, N6 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class nVe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      kmlLayer: null
    }), De(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(I6(I6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: N6,
      eventMap: R6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: N6,
      eventMap: R6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Mn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(nVe, "contextType", Ut);
function wne(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function rVe(e, t) {
  return new t(e.lat, e.lng);
}
function oVe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function iVe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function sVe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function aVe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function lVe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Cne(e, t, n, r) {
  return n !== void 0 ? aVe(e, t, sVe(n, google.maps.LatLngBounds, oVe)) : lVe(e, t, iVe(r, google.maps.LatLng, rVe));
}
function uVe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function F6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cVe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function pVe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = cVe({}, this.container ? wne(this.container, o) : {
        x: 0,
        y: 0
      }), u = Cne(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function z6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dVe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function U6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function W6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function fVe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ut), c = un(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = un(() => pVe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), hi.createPortal(l, c);
}
me(fVe);
class Rp extends pe {
  constructor(t) {
    super(t), De(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), De(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      $o(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), De(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), De(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = dVe({
        x: 0,
        y: 0
      }, this.containerRef.current ? wne(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Cne(r, o, this.props.bounds, this.props.position);
      if (!uVe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), De(this, "draw", () => {
      this.onPositionElement();
    }), De(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = zn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = U6(t.position), r = U6(this.props.position), o = W6(t.bounds), i = W6(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? hi.createPortal(Wi.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
De(Rp, "FLOAT_PANE", "floatPane");
De(Rp, "MAP_PANE", "mapPane");
De(Rp, "MARKER_LAYER", "markerLayer");
De(Rp, "OVERLAY_LAYER", "overlayLayer");
De(Rp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
De(Rp, "contextType", Ut);
function hVe() {
}
function H6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function V6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $6 = {
  onDblClick: "dblclick",
  onClick: "click"
}, q6 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function gVe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ut), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = un(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(gVe);
class One extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      groundOverlay: null
    }), De(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    $o(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, V6(V6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: q6,
      eventMap: $6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: q6,
      eventMap: $6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
De(One, "defaultProps", {
  onLoad: hVe
});
De(One, "contextType", Ut);
function Z6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function a0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z6(Object(n), !0).forEach(function(r) {
      De(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Z6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var G6 = {}, Y6 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function mVe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ut), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || $o(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    $o(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(a0(a0({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(mVe);
class vVe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      heatmapLayer: null
    }), De(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    $o(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), $o(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(a0(a0({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = On({
      updaterMap: Y6,
      eventMap: G6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: Y6,
      eventMap: G6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Mn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
De(vVe, "contextType", Ut);
var X6 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, K6 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class yVe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      streetViewPanorama: null
    }), De(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = On({
      updaterMap: K6,
      eventMap: X6,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: K6,
      eventMap: X6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Mn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
De(yVe, "contextType", Ut);
class bVe extends pe {
  constructor() {
    super(...arguments), De(this, "state", {
      streetViewService: null
    }), De(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
De(bVe, "contextType", Ut);
var J6 = {
  onDirectionsChanged: "directions_changed"
}, Q6 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class wVe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "state", {
      directionsRenderer: null
    }), De(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = On({
      updaterMap: Q6,
      eventMap: J6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: Q6,
      eventMap: J6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Mn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
De(wVe, "contextType", Ut);
var e9 = {
  onPlacesChanged: "places_changed"
}, t9 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class CVe extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", zn()), De(this, "state", {
      searchBox: null
    }), De(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if ($o(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = On({
          updaterMap: t9,
          eventMap: e9,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: t9,
      eventMap: e9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Mn(this.registeredEvents));
  }
  render() {
    return Wi.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
De(CVe, "contextType", Ut);
var n9 = {
  onPlaceChanged: "place_changed"
}, r9 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class xne extends pe {
  constructor() {
    super(...arguments), De(this, "registeredEvents", []), De(this, "containerElement", zn()), De(this, "state", {
      autocomplete: null
    }), De(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    $o(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = On({
        updaterMap: r9,
        eventMap: n9,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Mn(this.registeredEvents), this.registeredEvents = On({
      updaterMap: r9,
      eventMap: n9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Mn(this.registeredEvents);
  }
  render() {
    return Wi.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
De(xne, "defaultProps", {
  className: ""
});
De(xne, "contextType", Ut);
let OVe = { data: "" }, xVe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || OVe, LVe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, EVe = /\/\*[^]*?\*\/|  +/g, o9 = /\n+/g, Ql = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? Ql(a, i) : i + "{" + Ql(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += Ql(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += Ql.p ? Ql.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Na = {}, Lne = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Lne(e[n]);
    return t;
  }
  return e;
}, kVe = (e, t, n, r, o) => {
  let i = Lne(e), a = Na[i] || (Na[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Na[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = LVe.exec(u.replace(EVe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(o9, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(o9, " ").trim();
      return d[0];
    })(e);
    Na[a] = Ql(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Na.g ? Na.g : null;
  return n && (Na.g = Na[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Na[a], t, r, s), a;
}, PVe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Ql(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function OC(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return kVe(n.unshift ? n.raw ? PVe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, xVe(t.target), t.g, t.o, t.k);
}
let Ene, eS, tS;
OC.bind({ g: 1 });
let tl = OC.bind({ k: 1 });
function SVe(e, t, n, r) {
  Ql.p = t, Ene = e, eS = n, tS = r;
}
function Su(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: eS && eS() }, s), n.o = / *go\d+/.test(l), s.className = OC.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), tS && u[0] && tS(s), Ene(u, s);
    }
    return o;
  };
}
var MVe = (e) => typeof e == "function", DVe = (e, t) => MVe(e) ? e(t) : e, _Ve = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), TVe = tl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, jVe = tl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, AVe = tl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, BVe = Su("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${TVe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${jVe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${AVe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, IVe = tl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, RVe = Su("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${IVe} 1s linear infinite;
`, NVe = tl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, FVe = tl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, zVe = Su("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${NVe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${FVe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, UVe = Su("div")`
  position: absolute;
`, WVe = Su("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, HVe = tl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, VVe = Su("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${HVe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, $Ve = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(VVe, null, t) : t : n === "blank" ? null : Ne.createElement(WVe, null, Ne.createElement(RVe, { ...r }), n !== "loading" && Ne.createElement(UVe, null, n === "error" ? Ne.createElement(BVe, { ...r }) : Ne.createElement(zVe, { ...r })));
}, qVe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ZVe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, GVe = "0%{opacity:0;} 100%{opacity:1;}", YVe = "0%{opacity:1;} 100%{opacity:0;}", XVe = Su("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, KVe = Su("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, JVe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = _Ve() ? [GVe, YVe] : [qVe(n), ZVe(n)];
  return { animation: t ? `${tl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${tl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? JVe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement($Ve, { toast: e }), a = Ne.createElement(KVe, { ...e.ariaProps }, DVe(e.message, e));
  return Ne.createElement(XVe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
SVe(Ne.createElement);
OC`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ve({});
function QVe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const e$e = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
QVe(e$e.CNPJ).length;
ma((e, t) => /* @__PURE__ */ Ui.jsx("input", { ref: t, ...e }));
Ve({});
var pl = {};
Object.defineProperty(pl, "__esModule", {
  value: !0
});
var t$e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), SL = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, kne = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: t$e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, OT = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var bv = 1; bv < 20; bv++)
  OT["f" + bv] = 111 + bv;
function xC(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Pne(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Sne(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function n$e(e, t) {
  return xC(e, t);
}
function r$e(e, t) {
  return xC(e, { byKey: !0 }, t);
}
function Pne(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in SL)
    r[SL[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = xT(d), v = SL[f];
      if (d.length > 1 && !v && !kne[d] && !OT[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Mne(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Sne(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Mne(e) {
  e = xT(e);
  var t = OT[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function xT(e) {
  return e = e.toLowerCase(), e = kne[e] || e, e;
}
pl.default = xC;
var ML = pl.isHotkey = xC;
pl.isCodeHotkey = n$e;
pl.isKeyHotkey = r$e;
pl.parseHotkey = Pne;
pl.compareHotkey = Sne;
pl.toKeyCode = Mne;
pl.toKeyName = xT;
var o$e = typeof mr == "object" && mr && mr.Object === Object && mr, i$e = o$e, s$e = i$e, a$e = typeof self == "object" && self && self.Object === Object && self, l$e = s$e || a$e || Function("return this")(), u$e = l$e, c$e = u$e, p$e = c$e.Symbol, Dne = p$e, i9 = Dne;
i9 && i9.toStringTag;
var s9 = Dne;
s9 && s9.toStringTag;
var a9;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(a9 || (a9 = {}));
var LT = function(e) {
  return Object.freeze(e);
}, d$e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, LT(this);
  }
  return e;
}(), f$e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, LT(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), l9 = typeof window < "u" ? window : {};
/msie|trident/i.test(l9.navigator && l9.navigator.userAgent);
var DL = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new d$e((n ? t : e) || 0, (n ? e : t) || 0);
};
LT({
  devicePixelContentBoxSize: DL(),
  borderBoxSize: DL(),
  contentBoxSize: DL(),
  contentRect: new f$e(0, 0, 0, 0)
});
function yh(e) {
  "@babel/helpers - typeof";
  return yh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, yh(e);
}
function h$e(e, t) {
  if (yh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (yh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function g$e(e) {
  var t = h$e(e, "string");
  return yh(t) === "symbol" ? t : String(t);
}
function Of(e, t, n) {
  return t = g$e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var m$e = /* @__PURE__ */ Ve(null), _L, TL;
parseInt(we.version.split(".")[0], 10);
var u9 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), jL = typeof navigator < "u" && /Android/.test(navigator.userAgent), wv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), v$e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (_L = navigator.userAgent.match(/Version\/(\d+)/)) !== null && _L !== void 0 && _L[1] && parseInt((TL = navigator.userAgent.match(/Version\/(\d+)/)) === null || TL === void 0 ? void 0 : TL[1], 10) < 17;
var y$e = /* @__PURE__ */ new WeakMap(), b$e = /* @__PURE__ */ new WeakMap(), w$e = /* @__PURE__ */ new WeakMap(), C$e = /* @__PURE__ */ new WeakMap(), O$e = /* @__PURE__ */ new WeakMap(), c9 = /* @__PURE__ */ new WeakMap(), x$e = /* @__PURE__ */ new WeakMap(), p9 = /* @__PURE__ */ new WeakMap(), Cv = /* @__PURE__ */ new WeakMap(), L$e = /* @__PURE__ */ new WeakMap(), E$e = /* @__PURE__ */ new WeakMap(), k$e = /* @__PURE__ */ new WeakMap(), _ne = globalThis.Node, P$e = globalThis.Text, Tne = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, S$e = (e) => l0(e) && e.nodeType === 8, ha = (e) => l0(e) && e.nodeType === 1, l0 = (e) => {
  var t = Tne(e);
  return !!t && e instanceof t.Node;
}, d9 = (e) => {
  var t = e && e.anchorNode && Tne(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, M$e = (e) => {
  var [t, n] = e;
  if (ha(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = jne(t, o, r ? "backward" : "forward"), r = o < n; ha(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = _$e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, D$e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, jne = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (S$e(o) || ha(o) && o.childNodes.length === 0 || ha(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, _$e = (e, t, n) => {
  var [r] = jne(e, t, n);
  return r;
}, f9 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Ane = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ha(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = mn.getWindow(e);
  if (o.contains(r))
    return mn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Ane(e, i, n);
}, h9 = (e, t) => !!(e.compareDocumentPosition(t) & _ne.DOCUMENT_POSITION_PRECEDING), T$e = (e, t) => !!(e.compareDocumentPosition(t) & _ne.DOCUMENT_POSITION_FOLLOWING), j$e = 0;
class A$e {
  constructor() {
    Of(this, "id", void 0), this.id = "".concat(j$e++);
  }
}
var mn = {
  androidPendingDiffs: (e) => k$e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = E$e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = mn.toDOMNode(e, e), n = mn.findDocumentOrShadowRoot(e);
    Cv.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = mn.findDocumentOrShadowRoot(e), r = f9(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Ay.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = mn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = mn.toSlateNode(e, t.target), a = mn.findPath(e, i);
    if (Ha.isElement(i) && lr.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = lr.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? lr.before(e, u) : lr.after(e, u);
      if (c) {
        var p = lr.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = mn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = mn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = c9.get(t);
    return n || (n = new A$e(), c9.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = b$e.get(r);
      if (o == null) {
        if (lr.isEditor(r))
          return n;
        break;
      }
      var i = y$e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(rs.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Cv.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          mn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = mn.toDOMNode(e, e), r = mn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = f9(r), i = mn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Ay.select(e, lr.start(e, [])), Cv.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = w$e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = mn.toDOMNode(e, e), i;
    try {
      i = ha(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => l0(t) && mn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return lr.hasPath(e, n.path) && lr.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => mn.hasEditableTarget(e, t) || mn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => l0(t) && mn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!L$e.get(e),
  isFocused: (e) => !!Cv.get(e),
  isReadOnly: (e) => !!p9.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (p9.get(e)) return !1;
    var n = mn.hasTarget(e, t) && mn.toSlateNode(e, t);
    return Ha.isElement(n) && lr.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = x$e.get(e), r = lr.isEditor(t) ? C$e.get(e) : n == null ? void 0 : n.get(mn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(rs.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = lr.node(e, t.path), r = mn.toDOMNode(e, n), o;
    lr.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof P$e ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(rs.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Zt.isBackward(t), i = mn.toDOMPoint(e, n), a = Zt.isCollapsed(t) ? i : mn.toDOMPoint(e, r), s = mn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = ha(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = ha(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ha(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? O$e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : M$e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = mn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = mn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (jL && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var N = U[k];
          if (mn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var R = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, W = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = W.find((M) => T$e(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var Z, X = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = (Z = X.findLast((M) => h9(L, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      jL && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      wv && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (jL && !u && !r) {
      var K = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (K && mn.hasDOMNode(e, K, {
        editable: !0
      })) {
        var Q = mn.toSlateNode(e, K), {
          path: J,
          offset: P
        } = lr.start(e, mn.findPath(e, Q));
        return K.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = mn.toSlateNode(e, u), z = mn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = d9(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (d9(t)) {
        if (wv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        v$e && D$e(s) || wv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    wv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = mn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = h9(s, u) || s === u && c < l, x = p ? w : mn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Zt.isExpanded(m) && Zt.isForward(m) && ha(u) && lr.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = lr.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, B$e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, I$e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, R$e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, eo = (e) => {
  var t = B$e[e], n = I$e[e], r = R$e[e], o = t && ML(t), i = n && ML(n), a = r && ML(r);
  return (s) => !!(o && o(s) || u9 && i && i(s) || !u9 && a && a(s));
};
eo("bold"), eo("compose"), eo("moveBackward"), eo("moveForward"), eo("deleteBackward"), eo("deleteForward"), eo("deleteLineBackward"), eo("deleteLineForward"), eo("deleteWordBackward"), eo("deleteWordForward"), eo("extendBackward"), eo("extendForward"), eo("extendLineBackward"), eo("extendLineForward"), eo("italic"), eo("moveLineBackward"), eo("moveLineForward"), eo("moveWordBackward"), eo("moveWordForward"), eo("redo"), eo("insertSoftBreak"), eo("splitBlock"), eo("transposeCharacter"), eo("undo");
var N$e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Ane(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, F$e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class z$e extends au {
  constructor() {
    super(...arguments), Of(this, "context", null), Of(this, "manager", null), Of(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, F$e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = N$e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Of(z$e, "contextType", m$e);
Ve({});
Ve({});
Ve({});
var No = {}, ET = {}, lg = {}, ug = {}, Bne = "Expected a function", g9 = NaN, U$e = "[object Symbol]", W$e = /^\s+|\s+$/g, H$e = /^[-+]0x[0-9a-f]+$/i, V$e = /^0b[01]+$/i, $$e = /^0o[0-7]+$/i, q$e = parseInt, Z$e = typeof mr == "object" && mr && mr.Object === Object && mr, G$e = typeof self == "object" && self && self.Object === Object && self, Y$e = Z$e || G$e || Function("return this")(), X$e = Object.prototype, K$e = X$e.toString, J$e = Math.max, Q$e = Math.min, AL = function() {
  return Y$e.Date.now();
};
function e3e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Bne);
  t = m9(t) || 0, u0(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? J$e(m9(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? Q$e(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = AL();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(AL());
  }
  function m() {
    var C = AL(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function t3e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Bne);
  return u0(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), e3e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function u0(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function n3e(e) {
  return !!e && typeof e == "object";
}
function r3e(e) {
  return typeof e == "symbol" || n3e(e) && K$e.call(e) == U$e;
}
function m9(e) {
  if (typeof e == "number")
    return e;
  if (r3e(e))
    return g9;
  if (u0(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = u0(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(W$e, "");
  var n = V$e.test(e);
  return n || $$e.test(e) ? q$e(e.slice(2), n ? 2 : 8) : H$e.test(e) ? g9 : +e;
}
var o3e = t3e, cg = {};
Object.defineProperty(cg, "__esModule", {
  value: !0
});
cg.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), uy.has(t) || uy.set(t, /* @__PURE__ */ new Set());
  var o = uy.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
cg.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), uy.get(t).delete(n.name || t);
};
var uy = /* @__PURE__ */ new Map();
Object.defineProperty(ug, "__esModule", {
  value: !0
});
var i3e = o3e, s3e = l3e(i3e), a3e = cg;
function l3e(e) {
  return e && e.__esModule ? e : { default: e };
}
var u3e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, s3e.default)(e, t);
}, go = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = u3e(function(r) {
        go.scrollHandler(e);
      }, t);
      go.scrollSpyContainers.push(e), (0, a3e.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return go.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = go.scrollSpyContainers[go.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(go.currentPositionX(e), go.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    go.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = go.scrollSpyContainers[go.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(go.currentPositionX(t), go.currentPositionY(t));
  },
  updateStates: function() {
    go.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    go.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), go.spySetState && go.spySetState.length && go.spySetState.indexOf(e) > -1 && go.spySetState.splice(go.spySetState.indexOf(e), 1), document.removeEventListener("scroll", go.scrollHandler);
  },
  update: function() {
    return go.scrollSpyContainers.forEach(function(e) {
      return go.scrollHandler(e);
    });
  }
};
ug.default = go;
var Np = {}, pg = {};
Object.defineProperty(pg, "__esModule", {
  value: !0
});
var c3e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, p3e = function() {
  return window.location.hash.replace(/^#/, "");
}, d3e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, f3e = function(e) {
  return getComputedStyle(e).position !== "static";
}, BL = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, h3e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (f3e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = BL(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return BL(t, s).offsetTop - BL(e, s).offsetTop;
};
pg.default = {
  updateHash: c3e,
  getHash: p3e,
  filterElementInContainer: d3e,
  scrollOffset: h3e
};
var LC = {}, kT = {};
Object.defineProperty(kT, "__esModule", {
  value: !0
});
kT.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var PT = {};
Object.defineProperty(PT, "__esModule", {
  value: !0
});
var g3e = cg, m3e = ["mousedown", "mousewheel", "touchmove", "keydown"];
PT.default = {
  subscribe: function(e) {
    return typeof document < "u" && m3e.forEach(function(t) {
      return (0, g3e.addPassiveEventListener)(document, t, e);
    });
  }
};
var dg = {};
Object.defineProperty(dg, "__esModule", {
  value: !0
});
var nS = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      nS.registered[e] = t;
    },
    remove: function(e) {
      nS.registered[e] = null;
    }
  }
};
dg.default = nS;
Object.defineProperty(LC, "__esModule", {
  value: !0
});
var v3e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, y3e = pg;
EC(y3e);
var b3e = kT, v9 = EC(b3e), w3e = PT, C3e = EC(w3e), O3e = dg, sa = EC(O3e);
function EC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ine = function(e) {
  return v9.default[e.smooth] || v9.default.defaultEasing;
}, x3e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, L3e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, rS = function() {
  return L3e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Rne = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Nne = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Fne = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, E3e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, k3e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, P3e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    sa.default.registered.end && sa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    rS.call(window, i);
    return;
  }
  sa.default.registered.end && sa.default.registered.end(o.to, o.target, o.currentPosition);
}, ST = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, fg = function(e, t, n, r) {
  t.data = t.data || Rne(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (C3e.default.subscribe(o), ST(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Nne(t) : Fne(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    sa.default.registered.end && sa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = x3e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Ine(t), a = P3e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      sa.default.registered.begin && sa.default.registered.begin(t.data.to, t.data.target), rS.call(window, a);
    }, t.delay);
    return;
  }
  sa.default.registered.begin && sa.default.registered.begin(t.data.to, t.data.target), rS.call(window, a);
}, kC = function(e) {
  return e = v3e({}, e), e.data = e.data || Rne(), e.absolute = !0, e;
}, S3e = function(e) {
  fg(0, kC(e));
}, M3e = function(e, t) {
  fg(e, kC(t));
}, D3e = function(e) {
  e = kC(e), ST(e), fg(e.horizontal ? E3e(e) : k3e(e), e);
}, _3e = function(e, t) {
  t = kC(t), ST(t);
  var n = t.horizontal ? Nne(t) : Fne(t);
  fg(e + n, t);
};
LC.default = {
  animateTopScroll: fg,
  getAnimationType: Ine,
  scrollToTop: S3e,
  scrollToBottom: D3e,
  scrollTo: M3e,
  scrollMore: _3e
};
Object.defineProperty(Np, "__esModule", {
  value: !0
});
var T3e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, j3e = pg, A3e = MT(j3e), B3e = LC, I3e = MT(B3e), R3e = dg, Ov = MT(R3e);
function MT(e) {
  return e && e.__esModule ? e : { default: e };
}
var xv = {}, y9 = void 0;
Np.default = {
  unmount: function() {
    xv = {};
  },
  register: function(e, t) {
    xv[e] = t;
  },
  unregister: function(e) {
    delete xv[e];
  },
  get: function(e) {
    return xv[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return y9 = e;
  },
  getActiveLink: function() {
    return y9;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = T3e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = A3e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Ov.default.registered.begin && Ov.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Ov.default.registered.end && Ov.default.registered.end(e, n);
      return;
    }
    I3e.default.animateTopScroll(s, t, e, n);
  }
};
var oS = { exports: {} }, IL = { exports: {} }, Gn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b9;
function N3e() {
  if (b9) return Gn;
  b9 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Gn.AsyncMode = l, Gn.ConcurrentMode = u, Gn.ContextConsumer = s, Gn.ContextProvider = a, Gn.Element = t, Gn.ForwardRef = c, Gn.Fragment = r, Gn.Lazy = f, Gn.Memo = y, Gn.Portal = n, Gn.Profiler = i, Gn.StrictMode = o, Gn.Suspense = p, Gn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Gn.isConcurrentMode = x, Gn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Gn.isContextProvider = function(m) {
    return D(m) === a;
  }, Gn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Gn.isForwardRef = function(m) {
    return D(m) === c;
  }, Gn.isFragment = function(m) {
    return D(m) === r;
  }, Gn.isLazy = function(m) {
    return D(m) === f;
  }, Gn.isMemo = function(m) {
    return D(m) === y;
  }, Gn.isPortal = function(m) {
    return D(m) === n;
  }, Gn.isProfiler = function(m) {
    return D(m) === i;
  }, Gn.isStrictMode = function(m) {
    return D(m) === o;
  }, Gn.isSuspense = function(m) {
    return D(m) === p;
  }, Gn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, Gn.typeOf = D, Gn;
}
var or = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var w9;
function F3e() {
  return w9 || (w9 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === y || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === L || I.$$typeof === w || I.$$typeof === v);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, N = c, R = r, V = f, $ = y, W = n, Z = i, X = o, K = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(I) || x(I) === l;
    }
    function P(I) {
      return x(I) === u;
    }
    function _(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function M(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function H(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function F(I) {
      return x(I) === y;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function B(I) {
      return x(I) === o;
    }
    function Y(I) {
      return x(I) === p;
    }
    or.AsyncMode = m, or.ConcurrentMode = C, or.ContextConsumer = S, or.ContextProvider = U, or.Element = k, or.ForwardRef = N, or.Fragment = R, or.Lazy = V, or.Memo = $, or.Portal = W, or.Profiler = Z, or.StrictMode = X, or.Suspense = K, or.isAsyncMode = J, or.isConcurrentMode = P, or.isContextConsumer = _, or.isContextProvider = z, or.isElement = M, or.isForwardRef = H, or.isFragment = O, or.isLazy = j, or.isMemo = F, or.isPortal = T, or.isProfiler = q, or.isStrictMode = B, or.isSuspense = Y, or.isValidElementType = D, or.typeOf = x;
  }()), or;
}
var C9;
function zne() {
  return C9 || (C9 = 1, process.env.NODE_ENV === "production" ? IL.exports = N3e() : IL.exports = F3e()), IL.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var RL, O9;
function z3e() {
  if (O9) return RL;
  O9 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return RL = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, RL;
}
var NL, x9;
function DT() {
  if (x9) return NL;
  x9 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return NL = e, NL;
}
var L9, E9;
function Une() {
  return E9 || (E9 = 1, L9 = Function.call.bind(Object.prototype.hasOwnProperty)), L9;
}
var FL, k9;
function U3e() {
  if (k9) return FL;
  k9 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = DT(), n = {}, r = Une();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, FL = o, FL;
}
var zL, P9;
function W3e() {
  if (P9) return zL;
  P9 = 1;
  var e = zne(), t = z3e(), n = DT(), r = Une(), o = U3e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return zL = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: N(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, j, F, T, q, B, Y) {
        if (T = T || d, B = B || F, Y !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + q + " `" + B + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + q + " `" + B + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, F, T, q, B);
      }
      var H = M.bind(null, !1);
      return H.isRequired = M.bind(null, !0), H;
    }
    function L(P) {
      function _(z, M, H, O, j, F) {
        var T = z[M], q = X(T);
        if (q !== P) {
          var B = K(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + B + "` supplied to `" + H + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var T = X(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var B = P(F, q, H, O, j + "[" + q + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!s(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!e.isValidElementType(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, H, O, j) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, T = J(z[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, H, O, j) {
        for (var F = z[M], T = 0; T < P.length; T++)
          if (f(F, P[T]))
            return null;
        var q = JSON.stringify(P, function(B, Y) {
          var I = K(Y);
          return I === "symbol" ? String(Y) : Y;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + H + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside objectOf.");
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var B = P(F, q, H, O, j + "." + q, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(H, O, j, F, T) {
        for (var q = [], B = 0; B < P.length; B++) {
          var Y = P[B], I = Y(H, O, j, F, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(M);
    }
    function N() {
      function P(_, z, M, H, O) {
        return W(_[z]) ? null : new v("Invalid " + H + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, _, z, M, H) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + H + "`."
      );
    }
    function V(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        for (var q in P) {
          var B = P[q];
          if (typeof B != "function")
            return R(H, O, j, q, K(B));
          var Y = B(F, q, H, O, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var B in q) {
          var Y = P[B];
          if (r(P, B) && typeof Y != "function")
            return R(H, O, j, B, K(Y));
          if (!Y)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + B + "` supplied to `" + H + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var I = Y(F, B, H, O, j + "." + B, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(_);
    }
    function W(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(W);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var H = M.value;
                if (H && !W(H[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function X(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(_, P) ? "symbol" : _;
    }
    function K(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = X(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = K(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, zL;
}
var UL, S9;
function H3e() {
  if (S9) return UL;
  S9 = 1;
  var e = DT();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, UL = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, UL;
}
if (process.env.NODE_ENV !== "production") {
  var V3e = zne(), $3e = !0;
  oS.exports = W3e()(V3e.isElement, $3e);
} else
  oS.exports = H3e()();
var PC = oS.exports, SC = {};
Object.defineProperty(SC, "__esModule", {
  value: !0
});
var q3e = pg, WL = Z3e(q3e);
function Z3e(e) {
  return e && e.__esModule ? e : { default: e };
}
var G3e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return WL.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && WL.default.getHash() !== e && WL.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
SC.default = G3e;
Object.defineProperty(lg, "__esModule", {
  value: !0
});
var Lv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Y3e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), X3e = we, M9 = hg(X3e), K3e = ug, Ev = hg(K3e), J3e = Np, Q3e = hg(J3e), e6e = PC, to = hg(e6e), t6e = SC, Ll = hg(t6e);
function hg(e) {
  return e && e.__esModule ? e : { default: e };
}
function n6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function r6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function o6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var D9 = {
  to: to.default.string.isRequired,
  containerId: to.default.string,
  container: to.default.object,
  activeClass: to.default.string,
  activeStyle: to.default.object,
  spy: to.default.bool,
  horizontal: to.default.bool,
  smooth: to.default.oneOfType([to.default.bool, to.default.string]),
  offset: to.default.number,
  delay: to.default.number,
  isDynamic: to.default.bool,
  onClick: to.default.func,
  duration: to.default.oneOfType([to.default.number, to.default.func]),
  absolute: to.default.bool,
  onSetActive: to.default.func,
  onSetInactive: to.default.func,
  ignoreCancelEvents: to.default.bool,
  hashSpy: to.default.bool,
  saveHashHistory: to.default.bool,
  spyThrottle: to.default.number
};
lg.default = function(e, t) {
  var n = t || Q3e.default, r = function(i) {
    o6e(a, i);
    function a(s) {
      n6e(this, a);
      var l = r6e(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return Y3e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Ev.default.isMounted(s) || Ev.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (Ll.default.isMounted() || Ll.default.mount(n), Ll.default.mapContainer(this.props.to, s)), Ev.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Ev.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Lv({}, this.props.style, this.props.activeStyle) : l = Lv({}, this.props.style);
        var u = Lv({}, this.props);
        for (var c in D9)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, M9.default.createElement(e, u);
      }
    }]), a;
  }(M9.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Lv({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ll.default.isMounted() && !Ll.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var N = n.getActiveLink();
        if (y) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Ll.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            Ll.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, W = $ === void 0 ? !1 : $;
          i.props.hashSpy && Ll.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = D9, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(ET, "__esModule", {
  value: !0
});
var i6e = we, _9 = Wne(i6e), s6e = lg, a6e = Wne(s6e);
function Wne(e) {
  return e && e.__esModule ? e : { default: e };
}
function l6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function T9(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function u6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var c6e = function(e) {
  u6e(t, e);
  function t() {
    var n, r, o, i;
    l6e(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = T9(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return _9.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), T9(o, i);
  }
  return t;
}(_9.default.Component);
ET.default = (0, a6e.default)(c6e);
var _T = {};
Object.defineProperty(_T, "__esModule", {
  value: !0
});
var p6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), d6e = we, j9 = Hne(d6e), f6e = lg, h6e = Hne(f6e);
function Hne(e) {
  return e && e.__esModule ? e : { default: e };
}
function g6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function m6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function v6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var y6e = function(e) {
  v6e(t, e);
  function t() {
    return g6e(this, t), m6e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return p6e(t, [{
    key: "render",
    value: function() {
      return j9.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(j9.default.Component);
_T.default = (0, h6e.default)(y6e);
var TT = {}, MC = {};
Object.defineProperty(MC, "__esModule", {
  value: !0
});
var b6e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, w6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), C6e = we, A9 = DC(C6e), O6e = il;
DC(O6e);
var x6e = Np, B9 = DC(x6e), L6e = PC, I9 = DC(L6e);
function DC(e) {
  return e && e.__esModule ? e : { default: e };
}
function E6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function k6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function P6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
MC.default = function(e) {
  var t = function(n) {
    P6e(r, n);
    function r(o) {
      E6e(this, r);
      var i = k6e(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return w6e(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        B9.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        B9.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return A9.default.createElement(e, b6e({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(A9.default.Component);
  return t.propTypes = {
    name: I9.default.string,
    id: I9.default.string
  }, t;
};
Object.defineProperty(TT, "__esModule", {
  value: !0
});
var R9 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, S6e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), M6e = we, N9 = jT(M6e), D6e = MC, _6e = jT(D6e), T6e = PC, F9 = jT(T6e);
function jT(e) {
  return e && e.__esModule ? e : { default: e };
}
function j6e(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function A6e(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function B6e(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Vne = function(e) {
  B6e(t, e);
  function t() {
    return j6e(this, t), A6e(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return S6e(t, [{
    key: "render",
    value: function() {
      var n = this, r = R9({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, N9.default.createElement(
        "div",
        R9({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(N9.default.Component);
Vne.propTypes = {
  name: F9.default.string,
  id: F9.default.string
};
TT.default = (0, _6e.default)(Vne);
var HL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, z9 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function U9(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function W9(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function H9(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kv = we, Hu = ug, VL = Np, xo = PC, El = SC, V9 = {
  to: xo.string.isRequired,
  containerId: xo.string,
  container: xo.object,
  activeClass: xo.string,
  spy: xo.bool,
  smooth: xo.oneOfType([xo.bool, xo.string]),
  offset: xo.number,
  delay: xo.number,
  isDynamic: xo.bool,
  onClick: xo.func,
  duration: xo.oneOfType([xo.number, xo.func]),
  absolute: xo.bool,
  onSetActive: xo.func,
  onSetInactive: xo.func,
  ignoreCancelEvents: xo.bool,
  hashSpy: xo.bool,
  spyThrottle: xo.number
}, I6e = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || VL, r = function(i) {
      H9(a, i);
      function a(s) {
        U9(this, a);
        var l = W9(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return z9(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Hu.isMounted(s) || Hu.mount(s, this.props.spyThrottle), this.props.hashSpy && (El.isMounted() || El.mount(n), El.mapContainer(this.props.to, s)), this.props.spy && Hu.addStateHandler(this.stateHandler), Hu.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Hu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = HL({}, this.props);
          for (var u in V9)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, kv.createElement(e, l);
        }
      }]), a;
    }(kv.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, HL({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(El.isMounted() && !El.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && El.getHash() === l && El.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Hu.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && El.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Hu.updateStates();
        }
      };
    };
    return r.propTypes = V9, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      H9(r, n);
      function r(o) {
        U9(this, r);
        var i = W9(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return z9(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          VL.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          VL.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return kv.createElement(e, HL({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(kv.Component);
    return t.propTypes = {
      name: xo.string,
      id: xo.string
    }, t;
  }
}, R6e = I6e;
Object.defineProperty(No, "__esModule", {
  value: !0
});
No.Helpers = No.ScrollElement = No.ScrollLink = No.animateScroll = No.scrollSpy = No.Events = No.scroller = No.Element = No.Button = No.Link = void 0;
var N6e = ET, $ne = xa(N6e), F6e = _T, qne = xa(F6e), z6e = TT, Zne = xa(z6e), U6e = Np, Gne = xa(U6e), W6e = dg, Yne = xa(W6e), H6e = ug, Xne = xa(H6e), V6e = LC, Kne = xa(V6e), $6e = lg, Jne = xa($6e), q6e = MC, Qne = xa(q6e), Z6e = R6e, ere = xa(Z6e);
function xa(e) {
  return e && e.__esModule ? e : { default: e };
}
No.Link = $ne.default;
No.Button = qne.default;
No.Element = Zne.default;
No.scroller = Gne.default;
No.Events = Yne.default;
No.scrollSpy = Xne.default;
No.animateScroll = Kne.default;
No.ScrollLink = Jne.default;
No.ScrollElement = Qne.default;
No.Helpers = ere.default;
No.default = { Link: $ne.default, Button: qne.default, Element: Zne.default, scroller: Gne.default, Events: Yne.default, scrollSpy: Xne.default, animateScroll: Kne.default, ScrollLink: Jne.default, ScrollElement: Qne.default, Helpers: ere.default };
Ve({});
Ve({});
Ve({});
function bh(e) {
  "@babel/helpers - typeof";
  return bh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, bh(e);
}
function G6e(e, t) {
  if (bh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (bh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Y6e(e) {
  var t = G6e(e, "string");
  return bh(t) == "symbol" ? t : t + "";
}
function _e(e, t, n) {
  return (t = Y6e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function tre(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var $L, $9;
function X6e() {
  if ($9) return $L;
  $9 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return $L = t, $L;
}
var K6e = X6e(), qo = /* @__PURE__ */ tre(K6e), Wt = Ve(null);
function J6e() {
  qo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Wt);
  return qo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Q6e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function e9e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function t9e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return e9e(e, i), o;
}
function n9e(e, t, n) {
  var r = Q6e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function r9e(e) {
  google.maps.event.removeListener(e);
}
function Dn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(r9e);
}
function xn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = n9e(o, i, n);
  return t9e(t, r, o, i), a;
}
function o9e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = ht(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null), [B, Y] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (B !== null && google.maps.event.removeListener(B), Y(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var I = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(I), I !== null && D && D(I), () => {
      I !== null && x && x(I);
    };
  }, []), Ui.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: Ui.jsx(Wt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(o9e);
function q9(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function nre(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        q9(i, r, o, a, s, "next", l);
      }
      function s(l) {
        q9(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function rre(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return qo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var yc = typeof document < "u";
function ore(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return yc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Z9(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function ire() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Z9(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Z9(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Od = !1;
function sre() {
  return Ui.jsx("div", {
    children: "Loading..."
  });
}
var iS = {
  id: "script-loader",
  version: "weekly"
};
class i9e extends pe {
  constructor() {
    super(...arguments), _e(this, "check", zn()), _e(this, "state", {
      loaded: !1
    }), _e(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), _e(this, "isCleaningUp", /* @__PURE__ */ nre(function* () {
      function t(n) {
        if (!Od)
          n();
        else if (yc)
          var r = window.setInterval(function() {
            Od || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), _e(this, "cleanup", () => {
      Od = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), _e(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && ire(), qo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: rre(this.props)
      };
      ore(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (yc) {
      if (window.google && window.google.maps && !Od) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), yc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (yc) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Od = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Ui.jsxs(Ui.Fragment, {
      children: [Ui.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Ui.jsx(sre, {})]
    });
  }
}
_e(i9e, "defaultProps", iS);
function s9e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function AT(e, t) {
  if (e == null) return {};
  var n, r, o = s9e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var G9;
function a9e(e) {
  var {
    id: t = iS.id,
    version: n = iS.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = ht(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    yc && u && ire();
  }, [u]), h(function() {
    f && qo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = rre({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!yc)
      return;
    function x() {
      y.current && (v(!0), G9 = w);
    }
    if (window.google && window.google.maps && G9 === w) {
      x();
      return;
    }
    ore({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = ht();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var l9e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], u9e = Ui.jsx(sre, {});
function c9e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = AT(e, l9e), {
    isLoaded: s,
    loadError: l
  } = a9e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || u9e;
}
me(c9e);
var Y9;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Y9 || (Y9 = {}));
function X9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function c0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X9(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K9 = {}, J9 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function p9e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Wt), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(c0(c0({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(p9e);
class d9e extends pe {
  constructor() {
    super(...arguments), _e(this, "state", {
      trafficLayer: null
    }), _e(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), _e(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(c0(c0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: J9,
      eventMap: K9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: J9,
      eventMap: K9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Dn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(d9e, "contextType", Wt);
function f9e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Wt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(f9e);
class h9e extends pe {
  constructor() {
    super(...arguments), _e(this, "state", {
      bicyclingLayer: null
    }), _e(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(h9e, "contextType", Wt);
function g9e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Wt), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(g9e);
class m9e extends pe {
  constructor() {
    super(...arguments), _e(this, "state", {
      transitLayer: null
    }), _e(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(m9e, "contextType", Wt);
function Q9(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function p0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q9(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q9(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var e8 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, t8 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function v9e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Wt), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    qo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(p0(p0({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && v(google.maps.event.addListener(N, "circlecomplete", r)), o && L(google.maps.event.addListener(N, "markercomplete", o)), i && D(google.maps.event.addListener(N, "overlaycomplete", i)), a && m(google.maps.event.addListener(N, "polygoncomplete", a)), s && S(google.maps.event.addListener(N, "polylinecomplete", s)), l && k(google.maps.event.addListener(N, "rectanglecomplete", l)), y(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(v9e);
class y9e extends pe {
  constructor(t) {
    super(t), _e(this, "registeredEvents", []), _e(this, "state", {
      drawingManager: null
    }), _e(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), qo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(p0(p0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: t8,
      eventMap: e8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: t8,
      eventMap: e8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Dn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
_e(y9e, "contextType", Wt);
function n8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ip(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? n8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : n8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var r8 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, o8 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, d0 = {};
function b9e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: W,
    onFlatChanged: Z,
    onIconChanged: X,
    onPositionChanged: K,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, H = ge(Wt), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null), [oe, Be] = E(null), [We, He] = E(null), [Ie, nt] = E(null), [$e, Ce] = E(null), [Qe, lt] = E(null), [be, Ee] = E(null), [Ae, ze] = E(null), [Re, ot] = E(null), [ve, yt] = E(null), [it, st] = E(null), [ut, bt] = E(null), [ct, wt] = E(null), [tt, gt] = E(null), [rt, Ct] = E(null), [pt, Et] = E(null), [Ot, kt] = E(null), [xt, Pt] = E(null);
  h(() => {
    O !== null && O.setMap(H);
  }, [H]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), He(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Ie !== null && google.maps.event.removeListener(Ie), nt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && N && ($e !== null && google.maps.event.removeListener($e), Ce(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), h(() => {
    O && L && (Qe !== null && google.maps.event.removeListener(Qe), lt(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (be !== null && google.maps.event.removeListener(be), Ee(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && R && (Ae !== null && google.maps.event.removeListener(Ae), ze(google.maps.event.addListener(O, "clickable_changed", R)));
  }, [R]), h(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), ot(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), yt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && W && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), bt(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && X && (ct !== null && google.maps.event.removeListener(ct), wt(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), h(() => {
    O && K && (tt !== null && google.maps.event.removeListener(tt), gt(google.maps.event.addListener(O, "position_changed", K)));
  }, [K]), h(() => {
    O && Q && (rt !== null && google.maps.event.removeListener(rt), Ct(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Et(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Ot !== null && google.maps.event.removeListener(Ot), kt(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (xt !== null && google.maps.event.removeListener(xt), Pt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var mt = ip(ip(ip({}, n || d0), r ? d0 : {
      map: H
    }), {}, {
      position: t
    }), ne = new google.maps.Marker(mt);
    return r ? r.addMarker(ne, !!o) : ne.setMap(H), t && ne.setPosition(t), typeof s < "u" && ne.setVisible(s), typeof a < "u" && ne.setDraggable(a), typeof u < "u" && ne.setClickable(u), typeof c == "string" && ne.setCursor(c), p && ne.setIcon(p), typeof d < "u" && ne.setLabel(d), typeof y < "u" && ne.setOpacity(y), f && ne.setShape(f), typeof v == "string" && ne.setTitle(v), typeof b == "number" && ne.setZIndex(b), w && T(google.maps.event.addListener(ne, "dblclick", w)), x && B(google.maps.event.addListener(ne, "dragend", x)), m && I(google.maps.event.addListener(ne, "dragstart", m)), k && he(google.maps.event.addListener(ne, "mousedown", k)), C && Be(google.maps.event.addListener(ne, "mouseout", C)), S && He(google.maps.event.addListener(ne, "mouseover", S)), U && nt(google.maps.event.addListener(ne, "mouseup", U)), N && Ce(google.maps.event.addListener(ne, "rightclick", N)), L && lt(google.maps.event.addListener(ne, "click", L)), D && Ee(google.maps.event.addListener(ne, "drag", D)), R && ze(google.maps.event.addListener(ne, "clickable_changed", R)), V && ot(google.maps.event.addListener(ne, "cursor_changed", V)), $ && yt(google.maps.event.addListener(ne, "animation_changed", $)), W && st(google.maps.event.addListener(ne, "draggable_changed", W)), Z && bt(google.maps.event.addListener(ne, "flat_changed", Z)), X && wt(google.maps.event.addListener(ne, "icon_changed", X)), K && gt(google.maps.event.addListener(ne, "position_changed", K)), Q && Ct(google.maps.event.addListener(ne, "shape_changed", Q)), J && Et(google.maps.event.addListener(ne, "title_changed", J)), P && kt(google.maps.event.addListener(ne, "visible_changed", P)), _ && Pt(google.maps.event.addListener(ne, "zindex_changed", _)), j(ne), z && z(ne), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), We !== null && google.maps.event.removeListener(We), Ie !== null && google.maps.event.removeListener(Ie), $e !== null && google.maps.event.removeListener($e), Qe !== null && google.maps.event.removeListener(Qe), Ae !== null && google.maps.event.removeListener(Ae), Re !== null && google.maps.event.removeListener(Re), ve !== null && google.maps.event.removeListener(ve), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), Ot !== null && google.maps.event.removeListener(Ot), xt !== null && google.maps.event.removeListener(xt), M && M(ne), r ? r.removeMarker(ne, !!o) : ne && ne.setMap(null);
    };
  }, []);
  var Vt = un(() => i ? at.map(i, (mt) => {
    if (!di(mt))
      return mt;
    var ne = mt;
    return fi(ne, {
      anchor: O
    });
  }) : null, [i, O]);
  return Ui.jsx(Ui.Fragment, {
    children: Vt
  }) || null;
}
me(b9e);
class w9e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return nre(function* () {
      var n = ip(ip(ip({}, t.props.options || d0), t.props.clusterer ? d0 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = xn({
        updaterMap: o8,
        eventMap: r8,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: o8,
      eventMap: r8,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Dn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!di(n))
        return n;
      var r = n;
      return fi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
_e(w9e, "contextType", Wt);
var C9e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), O9e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new C9e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function x9e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var L9e = 2e3, E9e = 500, k9e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", P9e = "png", S9e = [53, 56, 66, 78, 90], M9e = "cluster", are = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || k9e, this.imageExtension = r.imageExtension || P9e, this.imageSizes = r.imageSizes || S9e, this.calculator = r.calculator || x9e, this.batchSize = r.batchSize || L9e, this.batchSizeIE = r.batchSizeIE || E9e, this.clusterClass = r.clusterClass || M9e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new O9e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function i8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function D9e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Rn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, _9e = {};
function T9e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, N] = E(null), R = ge(Wt), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, Fs.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, Fs.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, Fs.onClick, w)));
  }, [w]), h(() => {
    k && D && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(k, Fs.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (X !== null && google.maps.event.removeListener(X), Z(google.maps.event.addListener(k, Fs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Rn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Rn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Rn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Rn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Rn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Rn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Rn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Rn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Rn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Rn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Rn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Rn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Rn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Rn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Rn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (R) {
      var z = D9e({}, n || _9e), M = new are(R, [], z);
      return r && Rn.averageCenter(M, r), o && Rn.batchSizeIE(M, o), i && Rn.calculator(M, i), a && Rn.clusterClass(M, a), s && Rn.enableRetinaIcons(M, s), l && Rn.gridSize(M, l), u && Rn.ignoreHidden(M, u), c && Rn.imageExtension(M, c), p && Rn.imagePath(M, p), d && Rn.imageSizes(M, d), y && Rn.maxZoom(M, y), f && Rn.minimumClusterSize(M, f), v && Rn.styles(M, v), b && Rn.title(M, b), L && Rn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, Fs.onMouseOut, C)), m && _(google.maps.event.addListener(M, Fs.onMouseOver, m)), w && $(google.maps.event.addListener(M, Fs.onClick, w)), D && Z(google.maps.event.addListener(M, Fs.onClusteringBegin, D)), x && K(google.maps.event.addListener(M, Fs.onClusteringEnd, x)), N(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(T9e);
class j9e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      markerClusterer: null
    }), _e(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new are(this.context, [], this.props.options);
      this.registeredEvents = xn({
        updaterMap: Rn,
        eventMap: Fs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: Rn,
      eventMap: Fs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Dn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
_e(j9e, "contextType", Wt);
function s8(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var lre = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || s8(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, s8));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), A9e = ["position"], B9e = ["position"];
function a8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function f0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l8 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, u8 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, I9e = {};
function R9e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Wt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var R = r || I9e, {
        position: V
      } = R, $ = AT(R, A9e), W;
      V && !(V instanceof google.maps.LatLng) && (W = new google.maps.LatLng(V.lat, V.lng));
      var Z = new lre(f0(f0({}, $), W ? {
        position: W
      } : {}));
      N.current = document.createElement("div"), v(Z), a && L(google.maps.event.addListener(Z, "closeclick", a)), s && D(google.maps.event.addListener(Z, "domready", s)), l && m(google.maps.event.addListener(Z, "content_changed", l)), u && S(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(y, n) : Z.getPosition() ? Z.open(y) : qo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(R9e);
class N9e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "containerElement", null), _e(this, "state", {
      infoBox: null
    }), _e(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : qo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), _e(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = AT(t, B9e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new lre(f0(f0({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = xn({
      updaterMap: u8,
      eventMap: l8,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: u8,
      eventMap: l8,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Dn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
_e(N9e, "contextType", Wt);
var c8, p8;
function F9e() {
  return p8 || (p8 = 1, c8 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), c8;
}
var z9e = F9e(), d8 = /* @__PURE__ */ tre(z9e), f8 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], qL = 1, xd = 8;
class BT {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== qL)
      throw new Error("Got v".concat(o, " data when expected v").concat(qL, "."));
    var i = f8[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new BT(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = f8.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, xd, t), this.coords = new this.ArrayType(this.data, xd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(xd + a + s + l), this.ids = new this.IndexArrayType(this.data, xd, t), this.coords = new this.ArrayType(this.data, xd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (qL << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return sS(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          h8(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      h8(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function sS(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    ure(e, t, a, r, o, i), sS(e, t, n, r, a - 1, 1 - i), sS(e, t, n, a + 1, o, 1 - i);
  }
}
function ure(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      ure(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Ld(e, t, r, n), t[2 * o + i] > y && Ld(e, t, r, o); f < v; ) {
      for (Ld(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Ld(e, t, r, v) : (v++, Ld(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Ld(e, t, n, r) {
  ZL(e, n, r), ZL(t, 2 * n, 2 * r), ZL(t, 2 * n + 1, 2 * r + 1);
}
function ZL(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function h8(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var U9e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, g8 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Vu = 2, Vl = 3, GL = 4, Il = 5, cre = 6;
class W9e {
  constructor(t) {
    this.options = Object.assign(Object.create(U9e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = g8(Pv(u)), d = g8(Sv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Pv(r), Sv(a), Pv(i), Sv(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Il] > 1 ? m8(p, f, this.clusterProps) : this.points[p[f + Vl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + GL] === t && p.push(a[y + Il] > 1 ? m8(a, y, this.clusterProps) : this.points[a[y + Vl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new BT(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Il] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = pre(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Vl]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Pv(f), d = Sv(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Vl] : L = this.points[n[l + Vl]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Vu] <= n)) {
        l[p + Vu] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Il], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Vu] > n && (b += l[w + Il]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Vu] <= n)) {
              l[k + Vu] = n;
              var N = l[k + Il];
              D += l[k] * N, x += l[k + 1] * N, l[k + GL] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + GL] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Vu] <= n)) {
                l[$ + Vu] = n;
                for (var W = 0; W < c; W++) u.push(l[$ + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Il] > 1) {
      var o = this.clusterProps[t[n + cre]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Vl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function m8(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Vl],
    properties: pre(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [H9e(e[t]), V9e(e[t + 1])]
    }
  };
}
function pre(e, t, n) {
  var r = e[t + Il], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + cre], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Vl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Pv(e) {
  return e / 360 + 0.5;
}
function Sv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function H9e(e) {
  return (e - 0.5) * 360;
}
function V9e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function $9e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class hs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class aS {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(hs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => hs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (hs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class q9e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Z9e(n);
  }
}
var Z9e = (e) => {
  var t = e.map((n) => new aS({
    position: hs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class G9e extends q9e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = $9e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new W9e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!d8(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = hs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !d8(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new aS({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new aS({
      markers: [i],
      position: hs.getPosition(i)
    });
  }
}
class Y9e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class X9e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (hs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function K9e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class IT {
  constructor() {
    K9e(IT, google.maps.OverlayView);
  }
}
var xf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(xf || (xf = {}));
var J9e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Q9e extends IT {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new G9e(o),
      renderer: a = new X9e(),
      onClusterClick: s = J9e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (hs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, xf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || hs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => hs.setMap(l, null)));
      }
      google.maps.event.trigger(this, xf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => hs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Y9e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => hs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, xf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), hs.setMap(r.marker, n);
    });
  }
}
function v8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function y8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? v8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : v8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function e8e(e) {
  var t = J6e(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new Q9e(y8(y8({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function t8e(e) {
  var {
    children: t,
    options: n
  } = e, r = e8e(n);
  return r !== null ? t(r) : null;
}
me(t8e);
var b8 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, w8 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function n8e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Wt), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return v(R), N.current = document.createElement("div"), a && L(google.maps.event.addListener(R, "closeclick", a)), s && D(google.maps.event.addListener(R, "domready", s)), l && m(google.maps.event.addListener(R, "content_changed", l)), u && S(google.maps.event.addListener(R, "position_changed", u)), c && k(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(y, n) : R.getPosition() ? R.open(y) : qo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(R), R.close();
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(n8e);
class r8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "containerElement", null), _e(this, "state", {
      infoWindow: null
    }), _e(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : qo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), _e(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = xn({
      updaterMap: w8,
      eventMap: b8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: w8,
      eventMap: b8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Dn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
_e(r8e, "contextType", Wt);
function C8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function h0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var O8 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, x8 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, o8e = {};
function i8e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Wt), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(h0(h0({}, t || o8e), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && k(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && $(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && K(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), b && F(google.maps.event.addListener(T, "drag", b)), m(T), L && L(T), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(i8e);
class s8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      polyline: null
    }), _e(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(h0(h0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: x8,
      eventMap: O8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: x8,
      eventMap: O8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Dn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
_e(s8e, "contextType", Wt);
function L8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function E8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var k8 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, P8 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function a8e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Wt), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var B = new google.maps.Polygon(E8(E8({}, t), {}, {
      map: m
    }));
    return i && B.setPath(i), a && B.setPaths(a), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && k(google.maps.event.addListener(B, "dblclick", s)), l && R(google.maps.event.addListener(B, "dragend", l)), u && $(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && K(google.maps.event.addListener(B, "mousemove", p)), d && J(google.maps.event.addListener(B, "mouseout", d)), y && _(google.maps.event.addListener(B, "mouseover", y)), f && M(google.maps.event.addListener(B, "mouseup", f)), v && O(google.maps.event.addListener(B, "rightclick", v)), b && F(google.maps.event.addListener(B, "click", b)), L && q(google.maps.event.addListener(B, "drag", L)), S(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), D && D(B), B.setMap(null);
    };
  }, []), null;
}
me(a8e);
class l8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = xn({
      updaterMap: P8,
      eventMap: k8,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: P8,
      eventMap: k8,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Dn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
_e(l8e, "contextType", Wt);
function S8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function g0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var M8 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, D8 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function u8e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Wt), [m, C] = E(null), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var Y = new google.maps.Rectangle(g0(g0({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && U(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && W(google.maps.event.addListener(Y, "mousedown", u)), c && X(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), y && z(google.maps.event.addListener(Y, "mouseup", y)), f && H(google.maps.event.addListener(Y, "rightclick", f)), v && j(google.maps.event.addListener(Y, "click", v)), b && T(google.maps.event.addListener(Y, "drag", b)), L && B(google.maps.event.addListener(Y, "bounds_changed", L)), C(Y), w && w(Y), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(Y), Y.setMap(null);
    };
  }, []), null;
}
me(u8e);
class c8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      rectangle: null
    }), _e(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(g0(g0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: D8,
      eventMap: M8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: D8,
      eventMap: M8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Dn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
_e(c8e, "contextType", Wt);
function _8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function m0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var T8 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, j8 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, p8e = {};
function d8e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Wt), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(m0(m0({}, t || p8e), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), y && z(google.maps.event.addListener(oe, "mouseover", y)), f && H(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), b && T(google.maps.event.addListener(oe, "click", b)), L && B(google.maps.event.addListener(oe, "drag", L)), w && I(google.maps.event.addListener(oe, "center_changed", w)), D && he(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), x && x(oe), () => {
      k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
me(d8e);
class f8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      circle: null
    }), _e(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(m0(m0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: j8,
      eventMap: T8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: j8,
      eventMap: T8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Dn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
_e(f8e, "contextType", Wt);
function A8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function v0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var B8 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, I8 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function h8e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Wt), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var B = new google.maps.Data(v0(v0({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(B, "dblclick", r)), o && S(google.maps.event.addListener(B, "mousedown", o)), i && k(google.maps.event.addListener(B, "mousemove", i)), a && R(google.maps.event.addListener(B, "mouseout", a)), s && $(google.maps.event.addListener(B, "mouseover", s)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && K(google.maps.event.addListener(B, "rightclick", u)), n && J(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && O(google.maps.event.addListener(B, "removeproperty", d)), y && F(google.maps.event.addListener(B, "setgeometry", y)), f && q(google.maps.event.addListener(B, "setproperty", f)), D(B), v && v(B);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(h8e);
class g8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      data: null
    }), _e(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(v0(v0({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = xn({
        updaterMap: I8,
        eventMap: B8,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: I8,
      eventMap: B8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Dn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
_e(g8e, "contextType", Wt);
function R8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var F8 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, z8 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class m8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      kmlLayer: null
    }), _e(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(N8(N8({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: z8,
      eventMap: F8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: z8,
      eventMap: F8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Dn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(m8e, "contextType", Wt);
function dre(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function v8e(e, t) {
  return new t(e.lat, e.lng);
}
function y8e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function b8e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function w8e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function C8e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function O8e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function fre(e, t, n, r) {
  return n !== void 0 ? C8e(e, t, w8e(n, google.maps.LatLngBounds, y8e)) : O8e(e, t, b8e(r, google.maps.LatLng, v8e));
}
function x8e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function U8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function L8e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function E8e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = L8e({}, this.container ? dre(this.container, o) : {
        x: 0,
        y: 0
      }), u = fre(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function W8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function k8e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? W8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function H8(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function V8(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function P8e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Wt), c = un(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = un(() => E8e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), hi.createPortal(l, c);
}
me(P8e);
class Fp extends pe {
  constructor(t) {
    super(t), _e(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), _e(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      qo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), _e(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), _e(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = k8e({
        x: 0,
        y: 0
      }, this.containerRef.current ? dre(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = fre(r, o, this.props.bounds, this.props.position);
      if (!x8e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), _e(this, "draw", () => {
      this.onPositionElement();
    }), _e(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = zn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = H8(t.position), r = H8(this.props.position), o = V8(t.bounds), i = V8(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? hi.createPortal(Ui.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
_e(Fp, "FLOAT_PANE", "floatPane");
_e(Fp, "MAP_PANE", "mapPane");
_e(Fp, "MARKER_LAYER", "markerLayer");
_e(Fp, "OVERLAY_LAYER", "overlayLayer");
_e(Fp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
_e(Fp, "contextType", Wt);
function S8e() {
}
function $8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function q8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Z8 = {
  onDblClick: "dblclick",
  onClick: "click"
}, G8 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function M8e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Wt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = un(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(M8e);
class hre extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      groundOverlay: null
    }), _e(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    qo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, q8(q8({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: G8,
      eventMap: Z8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: G8,
      eventMap: Z8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
_e(hre, "defaultProps", {
  onLoad: S8e
});
_e(hre, "contextType", Wt);
function Y8(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function y0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y8(Object(n), !0).forEach(function(r) {
      _e(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y8(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var X8 = {}, K8 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function D8e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Wt), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || qo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    qo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(y0(y0({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(D8e);
class _8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      heatmapLayer: null
    }), _e(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    qo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), qo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(y0(y0({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = xn({
      updaterMap: K8,
      eventMap: X8,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: K8,
      eventMap: X8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Dn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(_8e, "contextType", Wt);
var J8 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Q8 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class T8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      streetViewPanorama: null
    }), _e(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = xn({
      updaterMap: Q8,
      eventMap: J8,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: Q8,
      eventMap: J8,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Dn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
_e(T8e, "contextType", Wt);
class j8e extends pe {
  constructor() {
    super(...arguments), _e(this, "state", {
      streetViewService: null
    }), _e(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
_e(j8e, "contextType", Wt);
var e5 = {
  onDirectionsChanged: "directions_changed"
}, t5 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class A8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "state", {
      directionsRenderer: null
    }), _e(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = xn({
      updaterMap: t5,
      eventMap: e5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: t5,
      eventMap: e5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Dn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
_e(A8e, "contextType", Wt);
var n5 = {
  onPlacesChanged: "places_changed"
}, r5 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class B8e extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "containerElement", zn()), _e(this, "state", {
      searchBox: null
    }), _e(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (qo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = xn({
          updaterMap: r5,
          eventMap: n5,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: r5,
      eventMap: n5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Dn(this.registeredEvents));
  }
  render() {
    return Ui.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
_e(B8e, "contextType", Wt);
var o5 = {
  onPlaceChanged: "place_changed"
}, i5 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class gre extends pe {
  constructor() {
    super(...arguments), _e(this, "registeredEvents", []), _e(this, "containerElement", zn()), _e(this, "state", {
      autocomplete: null
    }), _e(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    qo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = xn({
        updaterMap: i5,
        eventMap: o5,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Dn(this.registeredEvents), this.registeredEvents = xn({
      updaterMap: i5,
      eventMap: o5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Dn(this.registeredEvents);
  }
  render() {
    return Ui.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
_e(gre, "defaultProps", {
  className: ""
});
_e(gre, "contextType", Wt);
let I8e = { data: "" }, R8e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || I8e, N8e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, F8e = /\/\*[^]*?\*\/|  +/g, s5 = /\n+/g, eu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? eu(a, i) : i + "{" + eu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += eu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += eu.p ? eu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Fa = {}, mre = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + mre(e[n]);
    return t;
  }
  return e;
}, z8e = (e, t, n, r, o) => {
  let i = mre(e), a = Fa[i] || (Fa[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Fa[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = N8e.exec(u.replace(F8e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(s5, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(s5, " ").trim();
      return d[0];
    })(e);
    Fa[a] = eu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Fa.g ? Fa.g : null;
  return n && (Fa.g = Fa[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Fa[a], t, r, s), a;
}, U8e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : eu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function _C(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return z8e(n.unshift ? n.raw ? U8e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, R8e(t.target), t.g, t.o, t.k);
}
let vre, lS, uS;
_C.bind({ g: 1 });
let nl = _C.bind({ k: 1 });
function W8e(e, t, n, r) {
  eu.p = t, vre = e, lS = n, uS = r;
}
function Mu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: lS && lS() }, s), n.o = / *go\d+/.test(l), s.className = _C.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), uS && u[0] && uS(s), vre(u, s);
    }
    return o;
  };
}
var H8e = (e) => typeof e == "function", V8e = (e, t) => H8e(e) ? e(t) : e, $8e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), q8e = nl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Z8e = nl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, G8e = nl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Y8e = Mu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${q8e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Z8e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${G8e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, X8e = nl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, K8e = Mu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${X8e} 1s linear infinite;
`, J8e = nl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Q8e = nl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, e5e = Mu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${J8e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Q8e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, t5e = Mu("div")`
  position: absolute;
`, n5e = Mu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, r5e = nl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, o5e = Mu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${r5e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, i5e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(o5e, null, t) : t : n === "blank" ? null : Ne.createElement(n5e, null, Ne.createElement(K8e, { ...r }), n !== "loading" && Ne.createElement(t5e, null, n === "error" ? Ne.createElement(Y8e, { ...r }) : Ne.createElement(e5e, { ...r })));
}, s5e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, a5e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, l5e = "0%{opacity:0;} 100%{opacity:1;}", u5e = "0%{opacity:1;} 100%{opacity:0;}", c5e = Mu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, p5e = Mu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, d5e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = $8e() ? [l5e, u5e] : [s5e(n), a5e(n)];
  return { animation: t ? `${nl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${nl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? d5e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(i5e, { toast: e }), a = Ne.createElement(p5e, { ...e.ariaProps }, V8e(e.message, e));
  return Ne.createElement(c5e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
W8e(Ne.createElement);
_C`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function yre(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], y = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ sr.jsxs("button", { className: y, disabled: l || t, ...p, children: [
    /* @__PURE__ */ sr.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ sr.jsx(va, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ sr.jsxs("div", { className: "arkynButtonContent", children: [
      PA(d, a),
      c,
      PA(d, s)
    ] })
  ] });
}
function f5e() {
  const e = FS(), t = tG(), n = nG(), [r, o] = E(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
Ve({});
function h5e(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ sr.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ sr.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ sr.jsx(va, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ sr.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ sr.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function g5e(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ sr.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ sr.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function m5e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const v5e = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
m5e(v5e.CNPJ).length;
ma((e, t) => /* @__PURE__ */ sr.jsx("input", { ref: t, ...e }));
Ve({});
var dl = {};
Object.defineProperty(dl, "__esModule", {
  value: !0
});
var y5e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), YL = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, bre = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: y5e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, RT = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Mv = 1; Mv < 20; Mv++)
  RT["f" + Mv] = 111 + Mv;
function TC(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return wre(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Cre(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function b5e(e, t) {
  return TC(e, t);
}
function w5e(e, t) {
  return TC(e, { byKey: !0 }, t);
}
function wre(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in YL)
    r[YL[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = NT(d), v = YL[f];
      if (d.length > 1 && !v && !bre[d] && !RT[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Ore(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Cre(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Ore(e) {
  e = NT(e);
  var t = RT[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function NT(e) {
  return e = e.toLowerCase(), e = bre[e] || e, e;
}
dl.default = TC;
var XL = dl.isHotkey = TC;
dl.isCodeHotkey = b5e;
dl.isKeyHotkey = w5e;
dl.parseHotkey = wre;
dl.compareHotkey = Cre;
dl.toKeyCode = Ore;
dl.toKeyName = NT;
var C5e = typeof gr == "object" && gr && gr.Object === Object && gr, O5e = C5e, x5e = O5e, L5e = typeof self == "object" && self && self.Object === Object && self, E5e = x5e || L5e || Function("return this")(), k5e = E5e, P5e = k5e, S5e = P5e.Symbol, xre = S5e, a5 = xre;
a5 && a5.toStringTag;
var l5 = xre;
l5 && l5.toStringTag;
var u5;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(u5 || (u5 = {}));
var FT = function(e) {
  return Object.freeze(e);
}, M5e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, FT(this);
  }
  return e;
}(), D5e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, FT(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), c5 = typeof window < "u" ? window : {};
/msie|trident/i.test(c5.navigator && c5.navigator.userAgent);
var KL = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new M5e((n ? t : e) || 0, (n ? e : t) || 0);
};
FT({
  devicePixelContentBoxSize: KL(),
  borderBoxSize: KL(),
  contentBoxSize: KL(),
  contentRect: new D5e(0, 0, 0, 0)
});
function wh(e) {
  "@babel/helpers - typeof";
  return wh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wh(e);
}
function _5e(e, t) {
  if (wh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (wh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function T5e(e) {
  var t = _5e(e, "string");
  return wh(t) === "symbol" ? t : String(t);
}
function Lf(e, t, n) {
  return t = T5e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var j5e = /* @__PURE__ */ Ve(null), JL, QL;
parseInt(we.version.split(".")[0], 10);
var p5 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), eE = typeof navigator < "u" && /Android/.test(navigator.userAgent), Dv = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), A5e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (JL = navigator.userAgent.match(/Version\/(\d+)/)) !== null && JL !== void 0 && JL[1] && parseInt((QL = navigator.userAgent.match(/Version\/(\d+)/)) === null || QL === void 0 ? void 0 : QL[1], 10) < 17;
var B5e = /* @__PURE__ */ new WeakMap(), I5e = /* @__PURE__ */ new WeakMap(), R5e = /* @__PURE__ */ new WeakMap(), N5e = /* @__PURE__ */ new WeakMap(), F5e = /* @__PURE__ */ new WeakMap(), d5 = /* @__PURE__ */ new WeakMap(), z5e = /* @__PURE__ */ new WeakMap(), f5 = /* @__PURE__ */ new WeakMap(), _v = /* @__PURE__ */ new WeakMap(), U5e = /* @__PURE__ */ new WeakMap(), W5e = /* @__PURE__ */ new WeakMap(), H5e = /* @__PURE__ */ new WeakMap(), Lre = globalThis.Node, V5e = globalThis.Text, Ere = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, $5e = (e) => b0(e) && e.nodeType === 8, ga = (e) => b0(e) && e.nodeType === 1, b0 = (e) => {
  var t = Ere(e);
  return !!t && e instanceof t.Node;
}, h5 = (e) => {
  var t = e && e.anchorNode && Ere(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, q5e = (e) => {
  var [t, n] = e;
  if (ga(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = kre(t, o, r ? "backward" : "forward"), r = o < n; ga(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = G5e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Z5e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, kre = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; ($5e(o) || ga(o) && o.childNodes.length === 0 || ga(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, G5e = (e, t, n) => {
  var [r] = kre(e, t, n);
  return r;
}, g5 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Pre = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ga(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = vn.getWindow(e);
  if (o.contains(r))
    return vn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Pre(e, i, n);
}, m5 = (e, t) => !!(e.compareDocumentPosition(t) & Lre.DOCUMENT_POSITION_PRECEDING), Y5e = (e, t) => !!(e.compareDocumentPosition(t) & Lre.DOCUMENT_POSITION_FOLLOWING), X5e = 0;
class K5e {
  constructor() {
    Lf(this, "id", void 0), this.id = "".concat(X5e++);
  }
}
var vn = {
  androidPendingDiffs: (e) => H5e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = W5e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = vn.toDOMNode(e, e), n = vn.findDocumentOrShadowRoot(e);
    _v.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = vn.findDocumentOrShadowRoot(e), r = g5(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && My.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = vn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = vn.toSlateNode(e, t.target), a = vn.findPath(e, i);
    if (Wa.isElement(i) && ar.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = ar.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? ar.before(e, u) : ar.after(e, u);
      if (c) {
        var p = ar.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = vn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = vn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = d5.get(t);
    return n || (n = new K5e(), d5.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = I5e.get(r);
      if (o == null) {
        if (ar.isEditor(r))
          return n;
        break;
      }
      var i = B5e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ns.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!_v.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          vn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = vn.toDOMNode(e, e), r = vn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = g5(r), i = vn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || My.select(e, ar.start(e, [])), _v.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = R5e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = vn.toDOMNode(e, e), i;
    try {
      i = ga(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => b0(t) && vn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return ar.hasPath(e, n.path) && ar.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => vn.hasEditableTarget(e, t) || vn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => b0(t) && vn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!U5e.get(e),
  isFocused: (e) => !!_v.get(e),
  isReadOnly: (e) => !!f5.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (f5.get(e)) return !1;
    var n = vn.hasTarget(e, t) && vn.toSlateNode(e, t);
    return Wa.isElement(n) && ar.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = z5e.get(e), r = ar.isEditor(t) ? N5e.get(e) : n == null ? void 0 : n.get(vn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ns.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = ar.node(e, t.path), r = vn.toDOMNode(e, n), o;
    ar.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof V5e ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ns.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = qt.isBackward(t), i = vn.toDOMPoint(e, n), a = qt.isCollapsed(t) ? i : vn.toDOMPoint(e, r), s = vn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = ga(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = ga(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ga(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? F5e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : q5e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = vn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = vn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (eE && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var N = U[k];
          if (vn.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var R = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, W = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = W.find((M) => Y5e(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var Z, X = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = (Z = X.findLast((M) => m5(L, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      eE && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Dv && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (eE && !u && !r) {
      var K = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (K && vn.hasDOMNode(e, K, {
        editable: !0
      })) {
        var Q = vn.toSlateNode(e, K), {
          path: J,
          offset: P
        } = ar.start(e, vn.findPath(e, Q));
        return K.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = vn.toSlateNode(e, u), z = vn.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = h5(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (h5(t)) {
        if (Dv && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        A5e && Z5e(s) || Dv ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Dv && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = vn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = m5(s, u) || s === u && c < l, x = p ? w : vn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return qt.isExpanded(m) && qt.isForward(m) && ga(u) && ar.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = ar.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, J5e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Q5e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, e4e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, no = (e) => {
  var t = J5e[e], n = Q5e[e], r = e4e[e], o = t && XL(t), i = n && XL(n), a = r && XL(r);
  return (s) => !!(o && o(s) || p5 && i && i(s) || !p5 && a && a(s));
};
no("bold"), no("compose"), no("moveBackward"), no("moveForward"), no("deleteBackward"), no("deleteForward"), no("deleteLineBackward"), no("deleteLineForward"), no("deleteWordBackward"), no("deleteWordForward"), no("extendBackward"), no("extendForward"), no("extendLineBackward"), no("extendLineForward"), no("italic"), no("moveLineBackward"), no("moveLineForward"), no("moveWordBackward"), no("moveWordForward"), no("redo"), no("insertSoftBreak"), no("splitBlock"), no("transposeCharacter"), no("undo");
var t4e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => Pre(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, n4e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class r4e extends au {
  constructor() {
    super(...arguments), Lf(this, "context", null), Lf(this, "manager", null), Lf(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, n4e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = t4e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Lf(r4e, "contextType", j5e);
Ve({});
Ve({});
Ve({});
var Fo = {}, zT = {}, gg = {}, mg = {}, Sre = "Expected a function", v5 = NaN, o4e = "[object Symbol]", i4e = /^\s+|\s+$/g, s4e = /^[-+]0x[0-9a-f]+$/i, a4e = /^0b[01]+$/i, l4e = /^0o[0-7]+$/i, u4e = parseInt, c4e = typeof gr == "object" && gr && gr.Object === Object && gr, p4e = typeof self == "object" && self && self.Object === Object && self, d4e = c4e || p4e || Function("return this")(), f4e = Object.prototype, h4e = f4e.toString, g4e = Math.max, m4e = Math.min, tE = function() {
  return d4e.Date.now();
};
function v4e(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Sre);
  t = y5(t) || 0, w0(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? g4e(y5(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? m4e(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = tE();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(tE());
  }
  function m() {
    var C = tE(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function y4e(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Sre);
  return w0(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), v4e(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function w0(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function b4e(e) {
  return !!e && typeof e == "object";
}
function w4e(e) {
  return typeof e == "symbol" || b4e(e) && h4e.call(e) == o4e;
}
function y5(e) {
  if (typeof e == "number")
    return e;
  if (w4e(e))
    return v5;
  if (w0(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = w0(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(i4e, "");
  var n = a4e.test(e);
  return n || l4e.test(e) ? u4e(e.slice(2), n ? 2 : 8) : s4e.test(e) ? v5 : +e;
}
var C4e = y4e, vg = {};
Object.defineProperty(vg, "__esModule", {
  value: !0
});
vg.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), cy.has(t) || cy.set(t, /* @__PURE__ */ new Set());
  var o = cy.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
vg.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), cy.get(t).delete(n.name || t);
};
var cy = /* @__PURE__ */ new Map();
Object.defineProperty(mg, "__esModule", {
  value: !0
});
var O4e = C4e, x4e = E4e(O4e), L4e = vg;
function E4e(e) {
  return e && e.__esModule ? e : { default: e };
}
var k4e = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, x4e.default)(e, t);
}, mo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = k4e(function(r) {
        mo.scrollHandler(e);
      }, t);
      mo.scrollSpyContainers.push(e), (0, L4e.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return mo.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = mo.scrollSpyContainers[mo.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(mo.currentPositionX(e), mo.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    mo.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = mo.scrollSpyContainers[mo.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(mo.currentPositionX(t), mo.currentPositionY(t));
  },
  updateStates: function() {
    mo.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    mo.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), mo.spySetState && mo.spySetState.length && mo.spySetState.indexOf(e) > -1 && mo.spySetState.splice(mo.spySetState.indexOf(e), 1), document.removeEventListener("scroll", mo.scrollHandler);
  },
  update: function() {
    return mo.scrollSpyContainers.forEach(function(e) {
      return mo.scrollHandler(e);
    });
  }
};
mg.default = mo;
var zp = {}, yg = {};
Object.defineProperty(yg, "__esModule", {
  value: !0
});
var P4e = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, S4e = function() {
  return window.location.hash.replace(/^#/, "");
}, M4e = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, D4e = function(e) {
  return getComputedStyle(e).position !== "static";
}, nE = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, _4e = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (D4e(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = nE(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return nE(t, s).offsetTop - nE(e, s).offsetTop;
};
yg.default = {
  updateHash: P4e,
  getHash: S4e,
  filterElementInContainer: M4e,
  scrollOffset: _4e
};
var jC = {}, UT = {};
Object.defineProperty(UT, "__esModule", {
  value: !0
});
UT.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var WT = {};
Object.defineProperty(WT, "__esModule", {
  value: !0
});
var T4e = vg, j4e = ["mousedown", "mousewheel", "touchmove", "keydown"];
WT.default = {
  subscribe: function(e) {
    return typeof document < "u" && j4e.forEach(function(t) {
      return (0, T4e.addPassiveEventListener)(document, t, e);
    });
  }
};
var bg = {};
Object.defineProperty(bg, "__esModule", {
  value: !0
});
var cS = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      cS.registered[e] = t;
    },
    remove: function(e) {
      cS.registered[e] = null;
    }
  }
};
bg.default = cS;
Object.defineProperty(jC, "__esModule", {
  value: !0
});
var A4e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, B4e = yg;
AC(B4e);
var I4e = UT, b5 = AC(I4e), R4e = WT, N4e = AC(R4e), F4e = bg, aa = AC(F4e);
function AC(e) {
  return e && e.__esModule ? e : { default: e };
}
var Mre = function(e) {
  return b5.default[e.smooth] || b5.default.defaultEasing;
}, z4e = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, U4e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, pS = function() {
  return U4e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Dre = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, _re = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Tre = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, W4e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, H4e = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, V4e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    aa.default.registered.end && aa.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    pS.call(window, i);
    return;
  }
  aa.default.registered.end && aa.default.registered.end(o.to, o.target, o.currentPosition);
}, HT = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, wg = function(e, t, n, r) {
  t.data = t.data || Dre(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (N4e.default.subscribe(o), HT(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? _re(t) : Tre(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    aa.default.registered.end && aa.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = z4e(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Mre(t), a = V4e.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      aa.default.registered.begin && aa.default.registered.begin(t.data.to, t.data.target), pS.call(window, a);
    }, t.delay);
    return;
  }
  aa.default.registered.begin && aa.default.registered.begin(t.data.to, t.data.target), pS.call(window, a);
}, BC = function(e) {
  return e = A4e({}, e), e.data = e.data || Dre(), e.absolute = !0, e;
}, $4e = function(e) {
  wg(0, BC(e));
}, q4e = function(e, t) {
  wg(e, BC(t));
}, Z4e = function(e) {
  e = BC(e), HT(e), wg(e.horizontal ? W4e(e) : H4e(e), e);
}, G4e = function(e, t) {
  t = BC(t), HT(t);
  var n = t.horizontal ? _re(t) : Tre(t);
  wg(e + n, t);
};
jC.default = {
  animateTopScroll: wg,
  getAnimationType: Mre,
  scrollToTop: $4e,
  scrollToBottom: Z4e,
  scrollTo: q4e,
  scrollMore: G4e
};
Object.defineProperty(zp, "__esModule", {
  value: !0
});
var Y4e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, X4e = yg, K4e = VT(X4e), J4e = jC, Q4e = VT(J4e), eqe = bg, Tv = VT(eqe);
function VT(e) {
  return e && e.__esModule ? e : { default: e };
}
var jv = {}, w5 = void 0;
zp.default = {
  unmount: function() {
    jv = {};
  },
  register: function(e, t) {
    jv[e] = t;
  },
  unregister: function(e) {
    delete jv[e];
  },
  get: function(e) {
    return jv[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return w5 = e;
  },
  getActiveLink: function() {
    return w5;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Y4e({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = K4e.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Tv.default.registered.begin && Tv.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Tv.default.registered.end && Tv.default.registered.end(e, n);
      return;
    }
    Q4e.default.animateTopScroll(s, t, e, n);
  }
};
var dS = { exports: {} }, rE = { exports: {} }, Yn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var C5;
function tqe() {
  if (C5) return Yn;
  C5 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Yn.AsyncMode = l, Yn.ConcurrentMode = u, Yn.ContextConsumer = s, Yn.ContextProvider = a, Yn.Element = t, Yn.ForwardRef = c, Yn.Fragment = r, Yn.Lazy = f, Yn.Memo = y, Yn.Portal = n, Yn.Profiler = i, Yn.StrictMode = o, Yn.Suspense = p, Yn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Yn.isConcurrentMode = x, Yn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Yn.isContextProvider = function(m) {
    return D(m) === a;
  }, Yn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Yn.isForwardRef = function(m) {
    return D(m) === c;
  }, Yn.isFragment = function(m) {
    return D(m) === r;
  }, Yn.isLazy = function(m) {
    return D(m) === f;
  }, Yn.isMemo = function(m) {
    return D(m) === y;
  }, Yn.isPortal = function(m) {
    return D(m) === n;
  }, Yn.isProfiler = function(m) {
    return D(m) === i;
  }, Yn.isStrictMode = function(m) {
    return D(m) === o;
  }, Yn.isSuspense = function(m) {
    return D(m) === p;
  }, Yn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, Yn.typeOf = D, Yn;
}
var ir = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O5;
function nqe() {
  return O5 || (O5 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === y || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === L || I.$$typeof === w || I.$$typeof === v);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, N = c, R = r, V = f, $ = y, W = n, Z = i, X = o, K = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(I) || x(I) === l;
    }
    function P(I) {
      return x(I) === u;
    }
    function _(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function M(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function H(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function F(I) {
      return x(I) === y;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function B(I) {
      return x(I) === o;
    }
    function Y(I) {
      return x(I) === p;
    }
    ir.AsyncMode = m, ir.ConcurrentMode = C, ir.ContextConsumer = S, ir.ContextProvider = U, ir.Element = k, ir.ForwardRef = N, ir.Fragment = R, ir.Lazy = V, ir.Memo = $, ir.Portal = W, ir.Profiler = Z, ir.StrictMode = X, ir.Suspense = K, ir.isAsyncMode = J, ir.isConcurrentMode = P, ir.isContextConsumer = _, ir.isContextProvider = z, ir.isElement = M, ir.isForwardRef = H, ir.isFragment = O, ir.isLazy = j, ir.isMemo = F, ir.isPortal = T, ir.isProfiler = q, ir.isStrictMode = B, ir.isSuspense = Y, ir.isValidElementType = D, ir.typeOf = x;
  }()), ir;
}
var x5;
function jre() {
  return x5 || (x5 = 1, process.env.NODE_ENV === "production" ? rE.exports = tqe() : rE.exports = nqe()), rE.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var oE, L5;
function rqe() {
  if (L5) return oE;
  L5 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return oE = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, oE;
}
var iE, E5;
function $T() {
  if (E5) return iE;
  E5 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return iE = e, iE;
}
var k5, P5;
function Are() {
  return P5 || (P5 = 1, k5 = Function.call.bind(Object.prototype.hasOwnProperty)), k5;
}
var sE, S5;
function oqe() {
  if (S5) return sE;
  S5 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = $T(), n = {}, r = Are();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, sE = o, sE;
}
var aE, M5;
function iqe() {
  if (M5) return aE;
  M5 = 1;
  var e = jre(), t = rqe(), n = $T(), r = Are(), o = oqe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return aE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: N(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, j, F, T, q, B, Y) {
        if (T = T || d, B = B || F, Y !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + q + " `" + B + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + q + " `" + B + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, F, T, q, B);
      }
      var H = M.bind(null, !1);
      return H.isRequired = M.bind(null, !0), H;
    }
    function L(P) {
      function _(z, M, H, O, j, F) {
        var T = z[M], q = X(T);
        if (q !== P) {
          var B = K(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + B + "` supplied to `" + H + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var T = X(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var B = P(F, q, H, O, j + "[" + q + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!s(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!e.isValidElementType(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, H, O, j) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, T = J(z[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, H, O, j) {
        for (var F = z[M], T = 0; T < P.length; T++)
          if (f(F, P[T]))
            return null;
        var q = JSON.stringify(P, function(B, Y) {
          var I = K(Y);
          return I === "symbol" ? String(Y) : Y;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + H + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside objectOf.");
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var B = P(F, q, H, O, j + "." + q, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(H, O, j, F, T) {
        for (var q = [], B = 0; B < P.length; B++) {
          var Y = P[B], I = Y(H, O, j, F, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(M);
    }
    function N() {
      function P(_, z, M, H, O) {
        return W(_[z]) ? null : new v("Invalid " + H + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, _, z, M, H) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + H + "`."
      );
    }
    function V(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        for (var q in P) {
          var B = P[q];
          if (typeof B != "function")
            return R(H, O, j, q, K(B));
          var Y = B(F, q, H, O, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var B in q) {
          var Y = P[B];
          if (r(P, B) && typeof Y != "function")
            return R(H, O, j, B, K(Y));
          if (!Y)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + B + "` supplied to `" + H + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var I = Y(F, B, H, O, j + "." + B, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(_);
    }
    function W(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(W);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var H = M.value;
                if (H && !W(H[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function X(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(_, P) ? "symbol" : _;
    }
    function K(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = X(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = K(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, aE;
}
var lE, D5;
function sqe() {
  if (D5) return lE;
  D5 = 1;
  var e = $T();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, lE = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, lE;
}
if (process.env.NODE_ENV !== "production") {
  var aqe = jre(), lqe = !0;
  dS.exports = iqe()(aqe.isElement, lqe);
} else
  dS.exports = sqe()();
var IC = dS.exports, RC = {};
Object.defineProperty(RC, "__esModule", {
  value: !0
});
var uqe = yg, uE = cqe(uqe);
function cqe(e) {
  return e && e.__esModule ? e : { default: e };
}
var pqe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return uE.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && uE.default.getHash() !== e && uE.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
RC.default = pqe;
Object.defineProperty(gg, "__esModule", {
  value: !0
});
var Av = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), fqe = we, _5 = Cg(fqe), hqe = mg, Bv = Cg(hqe), gqe = zp, mqe = Cg(gqe), vqe = IC, ro = Cg(vqe), yqe = RC, kl = Cg(yqe);
function Cg(e) {
  return e && e.__esModule ? e : { default: e };
}
function bqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Cqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var T5 = {
  to: ro.default.string.isRequired,
  containerId: ro.default.string,
  container: ro.default.object,
  activeClass: ro.default.string,
  activeStyle: ro.default.object,
  spy: ro.default.bool,
  horizontal: ro.default.bool,
  smooth: ro.default.oneOfType([ro.default.bool, ro.default.string]),
  offset: ro.default.number,
  delay: ro.default.number,
  isDynamic: ro.default.bool,
  onClick: ro.default.func,
  duration: ro.default.oneOfType([ro.default.number, ro.default.func]),
  absolute: ro.default.bool,
  onSetActive: ro.default.func,
  onSetInactive: ro.default.func,
  ignoreCancelEvents: ro.default.bool,
  hashSpy: ro.default.bool,
  saveHashHistory: ro.default.bool,
  spyThrottle: ro.default.number
};
gg.default = function(e, t) {
  var n = t || mqe.default, r = function(i) {
    Cqe(a, i);
    function a(s) {
      bqe(this, a);
      var l = wqe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return dqe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Bv.default.isMounted(s) || Bv.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (kl.default.isMounted() || kl.default.mount(n), kl.default.mapContainer(this.props.to, s)), Bv.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Bv.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Av({}, this.props.style, this.props.activeStyle) : l = Av({}, this.props.style);
        var u = Av({}, this.props);
        for (var c in T5)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, _5.default.createElement(e, u);
      }
    }]), a;
  }(_5.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Av({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(kl.default.isMounted() && !kl.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, b = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            b = L.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - b + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            x = U.top - C + s, m = x + U.height;
          }
          var k = s - i.props.offset;
          d = k >= Math.floor(x) && k < Math.floor(m), y = k < Math.floor(x) || k >= Math.floor(m);
        }
        var N = n.getActiveLink();
        if (y) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && kl.default.getHash() === c) {
            var R = i.props.saveHashHistory, V = R === void 0 ? !1 : R;
            kl.default.changeHash("", V);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var $ = i.props.saveHashHistory, W = $ === void 0 ? !1 : $;
          i.props.hashSpy && kl.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = T5, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(zT, "__esModule", {
  value: !0
});
var Oqe = we, j5 = Bre(Oqe), xqe = gg, Lqe = Bre(xqe);
function Bre(e) {
  return e && e.__esModule ? e : { default: e };
}
function Eqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function A5(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Pqe = function(e) {
  kqe(t, e);
  function t() {
    var n, r, o, i;
    Eqe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = A5(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return j5.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), A5(o, i);
  }
  return t;
}(j5.default.Component);
zT.default = (0, Lqe.default)(Pqe);
var qT = {};
Object.defineProperty(qT, "__esModule", {
  value: !0
});
var Sqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Mqe = we, B5 = Ire(Mqe), Dqe = gg, _qe = Ire(Dqe);
function Ire(e) {
  return e && e.__esModule ? e : { default: e };
}
function Tqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Aqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Bqe = function(e) {
  Aqe(t, e);
  function t() {
    return Tqe(this, t), jqe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Sqe(t, [{
    key: "render",
    value: function() {
      return B5.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(B5.default.Component);
qT.default = (0, _qe.default)(Bqe);
var ZT = {}, NC = {};
Object.defineProperty(NC, "__esModule", {
  value: !0
});
var Iqe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Rqe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Nqe = we, I5 = FC(Nqe), Fqe = il;
FC(Fqe);
var zqe = zp, R5 = FC(zqe), Uqe = IC, N5 = FC(Uqe);
function FC(e) {
  return e && e.__esModule ? e : { default: e };
}
function Wqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Hqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Vqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
NC.default = function(e) {
  var t = function(n) {
    Vqe(r, n);
    function r(o) {
      Wqe(this, r);
      var i = Hqe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Rqe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        R5.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        R5.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return I5.default.createElement(e, Iqe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(I5.default.Component);
  return t.propTypes = {
    name: N5.default.string,
    id: N5.default.string
  }, t;
};
Object.defineProperty(ZT, "__esModule", {
  value: !0
});
var F5 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $qe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), qqe = we, z5 = GT(qqe), Zqe = NC, Gqe = GT(Zqe), Yqe = IC, U5 = GT(Yqe);
function GT(e) {
  return e && e.__esModule ? e : { default: e };
}
function Xqe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kqe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Jqe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Rre = function(e) {
  Jqe(t, e);
  function t() {
    return Xqe(this, t), Kqe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return $qe(t, [{
    key: "render",
    value: function() {
      var n = this, r = F5({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, z5.default.createElement(
        "div",
        F5({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(z5.default.Component);
Rre.propTypes = {
  name: U5.default.string,
  id: U5.default.string
};
ZT.default = (0, Gqe.default)(Rre);
var cE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, W5 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function H5(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function V5(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $5(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Iv = we, $u = mg, pE = zp, Lo = IC, Pl = RC, q5 = {
  to: Lo.string.isRequired,
  containerId: Lo.string,
  container: Lo.object,
  activeClass: Lo.string,
  spy: Lo.bool,
  smooth: Lo.oneOfType([Lo.bool, Lo.string]),
  offset: Lo.number,
  delay: Lo.number,
  isDynamic: Lo.bool,
  onClick: Lo.func,
  duration: Lo.oneOfType([Lo.number, Lo.func]),
  absolute: Lo.bool,
  onSetActive: Lo.func,
  onSetInactive: Lo.func,
  ignoreCancelEvents: Lo.bool,
  hashSpy: Lo.bool,
  spyThrottle: Lo.number
}, Qqe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || pE, r = function(i) {
      $5(a, i);
      function a(s) {
        H5(this, a);
        var l = V5(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return W5(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            $u.isMounted(s) || $u.mount(s, this.props.spyThrottle), this.props.hashSpy && (Pl.isMounted() || Pl.mount(n), Pl.mapContainer(this.props.to, s)), this.props.spy && $u.addStateHandler(this.stateHandler), $u.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          $u.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = cE({}, this.props);
          for (var u in q5)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Iv.createElement(e, l);
        }
      }]), a;
    }(Iv.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, cE({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Pl.isMounted() && !Pl.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, b = v >= Math.floor(c) && v < Math.floor(p), L = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (L)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Pl.getHash() === l && Pl.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), $u.updateStates();
          if (b && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Pl.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), $u.updateStates();
        }
      };
    };
    return r.propTypes = q5, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      $5(r, n);
      function r(o) {
        H5(this, r);
        var i = V5(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return W5(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          pE.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          pE.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Iv.createElement(e, cE({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Iv.Component);
    return t.propTypes = {
      name: Lo.string,
      id: Lo.string
    }, t;
  }
}, eZe = Qqe;
Object.defineProperty(Fo, "__esModule", {
  value: !0
});
Fo.Helpers = Fo.ScrollElement = Fo.ScrollLink = Fo.animateScroll = Fo.scrollSpy = Fo.Events = Fo.scroller = Fo.Element = Fo.Button = Fo.Link = void 0;
var tZe = zT, Nre = La(tZe), nZe = qT, Fre = La(nZe), rZe = ZT, zre = La(rZe), oZe = zp, Ure = La(oZe), iZe = bg, Wre = La(iZe), sZe = mg, Hre = La(sZe), aZe = jC, Vre = La(aZe), lZe = gg, $re = La(lZe), uZe = NC, qre = La(uZe), cZe = eZe, Zre = La(cZe);
function La(e) {
  return e && e.__esModule ? e : { default: e };
}
Fo.Link = Nre.default;
Fo.Button = Fre.default;
Fo.Element = zre.default;
Fo.scroller = Ure.default;
Fo.Events = Wre.default;
Fo.scrollSpy = Hre.default;
Fo.animateScroll = Vre.default;
Fo.ScrollLink = $re.default;
Fo.ScrollElement = qre.default;
Fo.Helpers = Zre.default;
Fo.default = { Link: Nre.default, Button: Fre.default, Element: zre.default, scroller: Ure.default, Events: Wre.default, scrollSpy: Hre.default, animateScroll: Vre.default, ScrollLink: $re.default, ScrollElement: qre.default, Helpers: Zre.default };
Ve({});
Ve({});
Ve({});
function Ch(e) {
  "@babel/helpers - typeof";
  return Ch = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ch(e);
}
function pZe(e, t) {
  if (Ch(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ch(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dZe(e) {
  var t = pZe(e, "string");
  return Ch(t) == "symbol" ? t : t + "";
}
function Te(e, t, n) {
  return (t = dZe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Gre(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var dE, Z5;
function fZe() {
  if (Z5) return dE;
  Z5 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return dE = t, dE;
}
var hZe = fZe(), Zo = /* @__PURE__ */ Gre(hZe), Ht = Ve(null);
function gZe() {
  Zo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ht);
  return Zo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function mZe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function vZe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function yZe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return vZe(e, i), o;
}
function bZe(e, t, n) {
  var r = mZe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function wZe(e) {
  google.maps.event.removeListener(e);
}
function _n() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(wZe);
}
function Ln(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = bZe(o, i, n);
  return yZe(t, r, o, i), a;
}
function CZe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = ht(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null), [B, Y] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (B !== null && google.maps.event.removeListener(B), Y(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var I = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(I), I !== null && D && D(I), () => {
      I !== null && x && x(I);
    };
  }, []), sr.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: sr.jsx(Ht.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(CZe);
function G5(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Yre(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        G5(i, r, o, a, s, "next", l);
      }
      function s(l) {
        G5(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Xre(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Zo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var bc = typeof document < "u";
function Kre(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return bc ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Y5(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function Jre() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Y5(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Y5(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Ed = !1;
function Qre() {
  return sr.jsx("div", {
    children: "Loading..."
  });
}
var fS = {
  id: "script-loader",
  version: "weekly"
};
class OZe extends pe {
  constructor() {
    super(...arguments), Te(this, "check", zn()), Te(this, "state", {
      loaded: !1
    }), Te(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Te(this, "isCleaningUp", /* @__PURE__ */ Yre(function* () {
      function t(n) {
        if (!Ed)
          n();
        else if (bc)
          var r = window.setInterval(function() {
            Ed || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Te(this, "cleanup", () => {
      Ed = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Te(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && Jre(), Zo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Xre(this.props)
      };
      Kre(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (bc) {
      if (window.google && window.google.maps && !Ed) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), bc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (bc) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Ed = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return sr.jsxs(sr.Fragment, {
      children: [sr.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || sr.jsx(Qre, {})]
    });
  }
}
Te(OZe, "defaultProps", fS);
function xZe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function YT(e, t) {
  if (e == null) return {};
  var n, r, o = xZe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var X5;
function LZe(e) {
  var {
    id: t = fS.id,
    version: n = fS.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = ht(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    bc && u && Jre();
  }, [u]), h(function() {
    f && Zo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Xre({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!bc)
      return;
    function x() {
      y.current && (v(!0), X5 = w);
    }
    if (window.google && window.google.maps && X5 === w) {
      x();
      return;
    }
    Kre({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && L(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = ht();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var EZe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], kZe = sr.jsx(Qre, {});
function PZe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = YT(e, EZe), {
    isLoaded: s,
    loadError: l
  } = LZe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || kZe;
}
me(PZe);
var K5;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(K5 || (K5 = {}));
function J5(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function C0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? J5(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : J5(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Q5 = {}, e4 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function SZe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ht), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(C0(C0({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(SZe);
class MZe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      trafficLayer: null
    }), Te(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(C0(C0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: e4,
      eventMap: Q5,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: e4,
      eventMap: Q5,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), _n(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(MZe, "contextType", Ht);
function DZe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ht), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(DZe);
class _Ze extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      bicyclingLayer: null
    }), Te(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(_Ze, "contextType", Ht);
function TZe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ht), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(TZe);
class jZe extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      transitLayer: null
    }), Te(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(jZe, "contextType", Ht);
function t4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function O0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var n4 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, r4 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function AZe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ht), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Zo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(O0(O0({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && v(google.maps.event.addListener(N, "circlecomplete", r)), o && L(google.maps.event.addListener(N, "markercomplete", o)), i && D(google.maps.event.addListener(N, "overlaycomplete", i)), a && m(google.maps.event.addListener(N, "polygoncomplete", a)), s && S(google.maps.event.addListener(N, "polylinecomplete", s)), l && k(google.maps.event.addListener(N, "rectanglecomplete", l)), y(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(AZe);
class BZe extends pe {
  constructor(t) {
    super(t), Te(this, "registeredEvents", []), Te(this, "state", {
      drawingManager: null
    }), Te(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Zo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(O0(O0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: r4,
      eventMap: n4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: r4,
      eventMap: n4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), _n(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Te(BZe, "contextType", Ht);
function o4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? o4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i4 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, s4 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, x0 = {};
function IZe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: W,
    onFlatChanged: Z,
    onIconChanged: X,
    onPositionChanged: K,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, H = ge(Ht), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null), [oe, Be] = E(null), [We, He] = E(null), [Ie, nt] = E(null), [$e, Ce] = E(null), [Qe, lt] = E(null), [be, Ee] = E(null), [Ae, ze] = E(null), [Re, ot] = E(null), [ve, yt] = E(null), [it, st] = E(null), [ut, bt] = E(null), [ct, wt] = E(null), [tt, gt] = E(null), [rt, Ct] = E(null), [pt, Et] = E(null), [Ot, kt] = E(null), [xt, Pt] = E(null);
  h(() => {
    O !== null && O.setMap(H);
  }, [H]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), He(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Ie !== null && google.maps.event.removeListener(Ie), nt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && N && ($e !== null && google.maps.event.removeListener($e), Ce(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), h(() => {
    O && L && (Qe !== null && google.maps.event.removeListener(Qe), lt(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (be !== null && google.maps.event.removeListener(be), Ee(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && R && (Ae !== null && google.maps.event.removeListener(Ae), ze(google.maps.event.addListener(O, "clickable_changed", R)));
  }, [R]), h(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), ot(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), yt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && W && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), bt(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && X && (ct !== null && google.maps.event.removeListener(ct), wt(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), h(() => {
    O && K && (tt !== null && google.maps.event.removeListener(tt), gt(google.maps.event.addListener(O, "position_changed", K)));
  }, [K]), h(() => {
    O && Q && (rt !== null && google.maps.event.removeListener(rt), Ct(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Et(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Ot !== null && google.maps.event.removeListener(Ot), kt(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (xt !== null && google.maps.event.removeListener(xt), Pt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var mt = sp(sp(sp({}, n || x0), r ? x0 : {
      map: H
    }), {}, {
      position: t
    }), ne = new google.maps.Marker(mt);
    return r ? r.addMarker(ne, !!o) : ne.setMap(H), t && ne.setPosition(t), typeof s < "u" && ne.setVisible(s), typeof a < "u" && ne.setDraggable(a), typeof u < "u" && ne.setClickable(u), typeof c == "string" && ne.setCursor(c), p && ne.setIcon(p), typeof d < "u" && ne.setLabel(d), typeof y < "u" && ne.setOpacity(y), f && ne.setShape(f), typeof v == "string" && ne.setTitle(v), typeof b == "number" && ne.setZIndex(b), w && T(google.maps.event.addListener(ne, "dblclick", w)), x && B(google.maps.event.addListener(ne, "dragend", x)), m && I(google.maps.event.addListener(ne, "dragstart", m)), k && he(google.maps.event.addListener(ne, "mousedown", k)), C && Be(google.maps.event.addListener(ne, "mouseout", C)), S && He(google.maps.event.addListener(ne, "mouseover", S)), U && nt(google.maps.event.addListener(ne, "mouseup", U)), N && Ce(google.maps.event.addListener(ne, "rightclick", N)), L && lt(google.maps.event.addListener(ne, "click", L)), D && Ee(google.maps.event.addListener(ne, "drag", D)), R && ze(google.maps.event.addListener(ne, "clickable_changed", R)), V && ot(google.maps.event.addListener(ne, "cursor_changed", V)), $ && yt(google.maps.event.addListener(ne, "animation_changed", $)), W && st(google.maps.event.addListener(ne, "draggable_changed", W)), Z && bt(google.maps.event.addListener(ne, "flat_changed", Z)), X && wt(google.maps.event.addListener(ne, "icon_changed", X)), K && gt(google.maps.event.addListener(ne, "position_changed", K)), Q && Ct(google.maps.event.addListener(ne, "shape_changed", Q)), J && Et(google.maps.event.addListener(ne, "title_changed", J)), P && kt(google.maps.event.addListener(ne, "visible_changed", P)), _ && Pt(google.maps.event.addListener(ne, "zindex_changed", _)), j(ne), z && z(ne), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), We !== null && google.maps.event.removeListener(We), Ie !== null && google.maps.event.removeListener(Ie), $e !== null && google.maps.event.removeListener($e), Qe !== null && google.maps.event.removeListener(Qe), Ae !== null && google.maps.event.removeListener(Ae), Re !== null && google.maps.event.removeListener(Re), ve !== null && google.maps.event.removeListener(ve), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), Ot !== null && google.maps.event.removeListener(Ot), xt !== null && google.maps.event.removeListener(xt), M && M(ne), r ? r.removeMarker(ne, !!o) : ne && ne.setMap(null);
    };
  }, []);
  var Vt = un(() => i ? at.map(i, (mt) => {
    if (!di(mt))
      return mt;
    var ne = mt;
    return fi(ne, {
      anchor: O
    });
  }) : null, [i, O]);
  return sr.jsx(sr.Fragment, {
    children: Vt
  }) || null;
}
me(IZe);
class RZe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Yre(function* () {
      var n = sp(sp(sp({}, t.props.options || x0), t.props.clusterer ? x0 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Ln({
        updaterMap: s4,
        eventMap: i4,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: s4,
      eventMap: i4,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), _n(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!di(n))
        return n;
      var r = n;
      return fi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Te(RZe, "contextType", Ht);
var NZe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), FZe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new NZe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function zZe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var UZe = 2e3, WZe = 500, HZe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", VZe = "png", $Ze = [53, 56, 66, 78, 90], qZe = "cluster", eoe = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || HZe, this.imageExtension = r.imageExtension || VZe, this.imageSizes = r.imageSizes || $Ze, this.calculator = r.calculator || zZe, this.batchSize = r.batchSize || UZe, this.batchSizeIE = r.batchSizeIE || WZe, this.clusterClass = r.clusterClass || qZe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new FZe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function a4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZZe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Nn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, GZe = {};
function YZe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, N] = E(null), R = ge(Ht), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, zs.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, zs.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, zs.onClick, w)));
  }, [w]), h(() => {
    k && D && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(k, zs.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (X !== null && google.maps.event.removeListener(X), Z(google.maps.event.addListener(k, zs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Nn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Nn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Nn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Nn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Nn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Nn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Nn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Nn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Nn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Nn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Nn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Nn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Nn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Nn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Nn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (R) {
      var z = ZZe({}, n || GZe), M = new eoe(R, [], z);
      return r && Nn.averageCenter(M, r), o && Nn.batchSizeIE(M, o), i && Nn.calculator(M, i), a && Nn.clusterClass(M, a), s && Nn.enableRetinaIcons(M, s), l && Nn.gridSize(M, l), u && Nn.ignoreHidden(M, u), c && Nn.imageExtension(M, c), p && Nn.imagePath(M, p), d && Nn.imageSizes(M, d), y && Nn.maxZoom(M, y), f && Nn.minimumClusterSize(M, f), v && Nn.styles(M, v), b && Nn.title(M, b), L && Nn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, zs.onMouseOut, C)), m && _(google.maps.event.addListener(M, zs.onMouseOver, m)), w && $(google.maps.event.addListener(M, zs.onClick, w)), D && Z(google.maps.event.addListener(M, zs.onClusteringBegin, D)), x && K(google.maps.event.addListener(M, zs.onClusteringEnd, x)), N(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(YZe);
class XZe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      markerClusterer: null
    }), Te(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new eoe(this.context, [], this.props.options);
      this.registeredEvents = Ln({
        updaterMap: Nn,
        eventMap: zs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: Nn,
      eventMap: zs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), _n(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Te(XZe, "contextType", Ht);
function l4(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var toe = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || l4(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, l4));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), KZe = ["position"], JZe = ["position"];
function u4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function L0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var c4 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, p4 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, QZe = {};
function e7e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ht), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var R = r || QZe, {
        position: V
      } = R, $ = YT(R, KZe), W;
      V && !(V instanceof google.maps.LatLng) && (W = new google.maps.LatLng(V.lat, V.lng));
      var Z = new toe(L0(L0({}, $), W ? {
        position: W
      } : {}));
      N.current = document.createElement("div"), v(Z), a && L(google.maps.event.addListener(Z, "closeclick", a)), s && D(google.maps.event.addListener(Z, "domready", s)), l && m(google.maps.event.addListener(Z, "content_changed", l)), u && S(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(y, n) : Z.getPosition() ? Z.open(y) : Zo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(e7e);
class t7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", null), Te(this, "state", {
      infoBox: null
    }), Te(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Zo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Te(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = YT(t, JZe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new toe(L0(L0({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ln({
      updaterMap: p4,
      eventMap: c4,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: p4,
      eventMap: c4,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), _n(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
Te(t7e, "contextType", Ht);
var d4, f4;
function n7e() {
  return f4 || (f4 = 1, d4 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), d4;
}
var r7e = n7e(), h4 = /* @__PURE__ */ Gre(r7e), g4 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], fE = 1, kd = 8;
class XT {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== fE)
      throw new Error("Got v".concat(o, " data when expected v").concat(fE, "."));
    var i = g4[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new XT(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = g4.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, kd, t), this.coords = new this.ArrayType(this.data, kd + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(kd + a + s + l), this.ids = new this.IndexArrayType(this.data, kd, t), this.coords = new this.ArrayType(this.data, kd + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (fE << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return hS(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          m4(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      m4(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function hS(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    noe(e, t, a, r, o, i), hS(e, t, n, r, a - 1, 1 - i), hS(e, t, n, a + 1, o, 1 - i);
  }
}
function noe(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      noe(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Pd(e, t, r, n), t[2 * o + i] > y && Pd(e, t, r, o); f < v; ) {
      for (Pd(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Pd(e, t, r, v) : (v++, Pd(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Pd(e, t, n, r) {
  hE(e, n, r), hE(t, 2 * n, 2 * r), hE(t, 2 * n + 1, 2 * r + 1);
}
function hE(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function m4(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var o7e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, v4 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), qu = 2, $l = 3, gE = 4, Rl = 5, roe = 6;
class i7e {
  constructor(t) {
    this.options = Object.assign(Object.create(o7e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = v4(Rv(u)), d = v4(Nv(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Rv(r), Nv(a), Rv(i), Nv(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Rl] > 1 ? y4(p, f, this.clusterProps) : this.points[p[f + $l]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + gE] === t && p.push(a[y + Rl] > 1 ? y4(a, y, this.clusterProps) : this.points[a[y + $l]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new XT(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Rl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = ooe(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + $l]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Rv(f), d = Nv(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + $l] : L = this.points[n[l + $l]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + qu] <= n)) {
        l[p + qu] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Rl], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + qu] > n && (b += l[w + Rl]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + qu] <= n)) {
              l[k + qu] = n;
              var N = l[k + Rl];
              D += l[k] * N, x += l[k + 1] * N, l[k + gE] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + gE] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + qu] <= n)) {
                l[$ + qu] = n;
                for (var W = 0; W < c; W++) u.push(l[$ + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Rl] > 1) {
      var o = this.clusterProps[t[n + roe]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + $l]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function y4(e, t, n) {
  return {
    type: "Feature",
    id: e[t + $l],
    properties: ooe(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [s7e(e[t]), a7e(e[t + 1])]
    }
  };
}
function ooe(e, t, n) {
  var r = e[t + Rl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + roe], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + $l],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Rv(e) {
  return e / 360 + 0.5;
}
function Nv(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function s7e(e) {
  return (e - 0.5) * 360;
}
function a7e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function l7e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class gs {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class gS {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(gs.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => gs.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (gs.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class u7e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return c7e(n);
  }
}
var c7e = (e) => {
  var t = e.map((n) => new gS({
    position: gs.getPosition(n),
    markers: [n]
  }));
  return t;
};
class p7e extends u7e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = l7e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new i7e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!h4(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = gs.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !h4(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new gS({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new gS({
      markers: [i],
      position: gs.getPosition(i)
    });
  }
}
class d7e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class f7e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (gs.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function h7e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class KT {
  constructor() {
    h7e(KT, google.maps.OverlayView);
  }
}
var Ef;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Ef || (Ef = {}));
var g7e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class m7e extends KT {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new p7e(o),
      renderer: a = new f7e(),
      onClusterClick: s = g7e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (gs.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Ef.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || gs.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => gs.setMap(l, null)));
      }
      google.maps.event.trigger(this, Ef.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => gs.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new d7e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => gs.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Ef.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), gs.setMap(r.marker, n);
    });
  }
}
function b4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function w4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function v7e(e) {
  var t = gZe(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new m7e(w4(w4({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function y7e(e) {
  var {
    children: t,
    options: n
  } = e, r = v7e(n);
  return r !== null ? t(r) : null;
}
me(y7e);
var C4 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, O4 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function b7e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ht), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return v(R), N.current = document.createElement("div"), a && L(google.maps.event.addListener(R, "closeclick", a)), s && D(google.maps.event.addListener(R, "domready", s)), l && m(google.maps.event.addListener(R, "content_changed", l)), u && S(google.maps.event.addListener(R, "position_changed", u)), c && k(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(y, n) : R.getPosition() ? R.open(y) : Zo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(R), R.close();
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(b7e);
class w7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", null), Te(this, "state", {
      infoWindow: null
    }), Te(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Zo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Te(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Ln({
      updaterMap: O4,
      eventMap: C4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: O4,
      eventMap: C4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (_n(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
Te(w7e, "contextType", Ht);
function x4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function E0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L4 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, E4 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, C7e = {};
function O7e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(Ht), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(E0(E0({}, t || C7e), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && k(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && $(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && K(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), b && F(google.maps.event.addListener(T, "drag", b)), m(T), L && L(T), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(O7e);
class x7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      polyline: null
    }), Te(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(E0(E0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: E4,
      eventMap: L4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: E4,
      eventMap: L4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), _n(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Te(x7e, "contextType", Ht);
function k4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function P4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var S4 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, M4 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function L7e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Ht), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var B = new google.maps.Polygon(P4(P4({}, t), {}, {
      map: m
    }));
    return i && B.setPath(i), a && B.setPaths(a), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && k(google.maps.event.addListener(B, "dblclick", s)), l && R(google.maps.event.addListener(B, "dragend", l)), u && $(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && K(google.maps.event.addListener(B, "mousemove", p)), d && J(google.maps.event.addListener(B, "mouseout", d)), y && _(google.maps.event.addListener(B, "mouseover", y)), f && M(google.maps.event.addListener(B, "mouseup", f)), v && O(google.maps.event.addListener(B, "rightclick", v)), b && F(google.maps.event.addListener(B, "click", b)), L && q(google.maps.event.addListener(B, "drag", L)), S(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), D && D(B), B.setMap(null);
    };
  }, []), null;
}
me(L7e);
class E7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Ln({
      updaterMap: M4,
      eventMap: S4,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: M4,
      eventMap: S4,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), _n(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Te(E7e, "contextType", Ht);
function D4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function k0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? D4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : D4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _4 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, T4 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function k7e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Ht), [m, C] = E(null), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var Y = new google.maps.Rectangle(k0(k0({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && U(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && W(google.maps.event.addListener(Y, "mousedown", u)), c && X(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), y && z(google.maps.event.addListener(Y, "mouseup", y)), f && H(google.maps.event.addListener(Y, "rightclick", f)), v && j(google.maps.event.addListener(Y, "click", v)), b && T(google.maps.event.addListener(Y, "drag", b)), L && B(google.maps.event.addListener(Y, "bounds_changed", L)), C(Y), w && w(Y), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(Y), Y.setMap(null);
    };
  }, []), null;
}
me(k7e);
class P7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      rectangle: null
    }), Te(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(k0(k0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: T4,
      eventMap: _4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: T4,
      eventMap: _4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), _n(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Te(P7e, "contextType", Ht);
function j4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function P0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var A4 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, B4 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, S7e = {};
function M7e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Ht), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(P0(P0({}, t || S7e), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), y && z(google.maps.event.addListener(oe, "mouseover", y)), f && H(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), b && T(google.maps.event.addListener(oe, "click", b)), L && B(google.maps.event.addListener(oe, "drag", L)), w && I(google.maps.event.addListener(oe, "center_changed", w)), D && he(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), x && x(oe), () => {
      k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
me(M7e);
class D7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      circle: null
    }), Te(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(P0(P0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: B4,
      eventMap: A4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: B4,
      eventMap: A4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), _n(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Te(D7e, "contextType", Ht);
function I4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function S0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : I4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var R4 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, N4 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function _7e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(Ht), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var B = new google.maps.Data(S0(S0({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(B, "dblclick", r)), o && S(google.maps.event.addListener(B, "mousedown", o)), i && k(google.maps.event.addListener(B, "mousemove", i)), a && R(google.maps.event.addListener(B, "mouseout", a)), s && $(google.maps.event.addListener(B, "mouseover", s)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && K(google.maps.event.addListener(B, "rightclick", u)), n && J(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && O(google.maps.event.addListener(B, "removeproperty", d)), y && F(google.maps.event.addListener(B, "setgeometry", y)), f && q(google.maps.event.addListener(B, "setproperty", f)), D(B), v && v(B);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(_7e);
class T7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      data: null
    }), Te(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(S0(S0({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Ln({
        updaterMap: N4,
        eventMap: R4,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: N4,
      eventMap: R4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), _n(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Te(T7e, "contextType", Ht);
function F4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function z4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? F4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : F4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var U4 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, W4 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class j7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      kmlLayer: null
    }), Te(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(z4(z4({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: W4,
      eventMap: U4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: W4,
      eventMap: U4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), _n(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(j7e, "contextType", Ht);
function ioe(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function A7e(e, t) {
  return new t(e.lat, e.lng);
}
function B7e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function I7e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function R7e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function N7e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function F7e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function soe(e, t, n, r) {
  return n !== void 0 ? N7e(e, t, R7e(n, google.maps.LatLngBounds, B7e)) : F7e(e, t, I7e(r, google.maps.LatLng, A7e));
}
function z7e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function H4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function U7e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function W7e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = U7e({}, this.container ? ioe(this.container, o) : {
        x: 0,
        y: 0
      }), u = soe(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function V4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function H7e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function $4(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function q4(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function V7e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ht), c = un(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = un(() => W7e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), hi.createPortal(l, c);
}
me(V7e);
class Up extends pe {
  constructor(t) {
    super(t), Te(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Te(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Zo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Te(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Te(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = H7e({
        x: 0,
        y: 0
      }, this.containerRef.current ? ioe(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = soe(r, o, this.props.bounds, this.props.position);
      if (!z7e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Te(this, "draw", () => {
      this.onPositionElement();
    }), Te(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = zn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = $4(t.position), r = $4(this.props.position), o = q4(t.bounds), i = q4(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? hi.createPortal(sr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
Te(Up, "FLOAT_PANE", "floatPane");
Te(Up, "MAP_PANE", "mapPane");
Te(Up, "MARKER_LAYER", "markerLayer");
Te(Up, "OVERLAY_LAYER", "overlayLayer");
Te(Up, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Te(Up, "contextType", Ht);
function $7e() {
}
function Z4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function G4(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Z4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Y4 = {
  onDblClick: "dblclick",
  onClick: "click"
}, X4 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function q7e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ht), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = un(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(q7e);
class aoe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      groundOverlay: null
    }), Te(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Zo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, G4(G4({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: X4,
      eventMap: Y4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: X4,
      eventMap: Y4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Te(aoe, "defaultProps", {
  onLoad: $7e
});
Te(aoe, "contextType", Ht);
function K4(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function M0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K4(Object(n), !0).forEach(function(r) {
      Te(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K4(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J4 = {}, Q4 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Z7e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ht), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || Zo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Zo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(M0(M0({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(Z7e);
class G7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      heatmapLayer: null
    }), Te(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Zo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Zo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(M0(M0({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Ln({
      updaterMap: Q4,
      eventMap: J4,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    _n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: Q4,
      eventMap: J4,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), _n(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(G7e, "contextType", Ht);
var eq = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, tq = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Y7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      streetViewPanorama: null
    }), Te(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Ln({
      updaterMap: tq,
      eventMap: eq,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: tq,
      eventMap: eq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), _n(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Te(Y7e, "contextType", Ht);
class X7e extends pe {
  constructor() {
    super(...arguments), Te(this, "state", {
      streetViewService: null
    }), Te(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Te(X7e, "contextType", Ht);
var nq = {
  onDirectionsChanged: "directions_changed"
}, rq = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class K7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "state", {
      directionsRenderer: null
    }), Te(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ln({
      updaterMap: rq,
      eventMap: nq,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: rq,
      eventMap: nq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), _n(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Te(K7e, "contextType", Ht);
var oq = {
  onPlacesChanged: "places_changed"
}, iq = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class J7e extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", zn()), Te(this, "state", {
      searchBox: null
    }), Te(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Zo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Ln({
          updaterMap: iq,
          eventMap: oq,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (_n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: iq,
      eventMap: oq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), _n(this.registeredEvents));
  }
  render() {
    return sr.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
Te(J7e, "contextType", Ht);
var sq = {
  onPlaceChanged: "place_changed"
}, aq = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class loe extends pe {
  constructor() {
    super(...arguments), Te(this, "registeredEvents", []), Te(this, "containerElement", zn()), Te(this, "state", {
      autocomplete: null
    }), Te(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Zo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Ln({
        updaterMap: aq,
        eventMap: sq,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    _n(this.registeredEvents), this.registeredEvents = Ln({
      updaterMap: aq,
      eventMap: sq,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && _n(this.registeredEvents);
  }
  render() {
    return sr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
Te(loe, "defaultProps", {
  className: ""
});
Te(loe, "contextType", Ht);
let Q7e = { data: "" }, eGe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Q7e, tGe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, nGe = /\/\*[^]*?\*\/|  +/g, lq = /\n+/g, tu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? tu(a, i) : i + "{" + tu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += tu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += tu.p ? tu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, za = {}, uoe = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + uoe(e[n]);
    return t;
  }
  return e;
}, rGe = (e, t, n, r, o) => {
  let i = uoe(e), a = za[i] || (za[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!za[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = tGe.exec(u.replace(nGe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(lq, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(lq, " ").trim();
      return d[0];
    })(e);
    za[a] = tu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && za.g ? za.g : null;
  return n && (za.g = za[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(za[a], t, r, s), a;
}, oGe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : tu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function zC(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return rGe(n.unshift ? n.raw ? oGe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, eGe(t.target), t.g, t.o, t.k);
}
let coe, mS, vS;
zC.bind({ g: 1 });
let rl = zC.bind({ k: 1 });
function iGe(e, t, n, r) {
  tu.p = t, coe = e, mS = n, vS = r;
}
function Du(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: mS && mS() }, s), n.o = / *go\d+/.test(l), s.className = zC.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), vS && u[0] && vS(s), coe(u, s);
    }
    return o;
  };
}
var sGe = (e) => typeof e == "function", aGe = (e, t) => sGe(e) ? e(t) : e, lGe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), uGe = rl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, cGe = rl`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, pGe = rl`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, dGe = Du("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${uGe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${cGe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${pGe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, fGe = rl`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, hGe = Du("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${fGe} 1s linear infinite;
`, gGe = rl`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, mGe = rl`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, vGe = Du("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${gGe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${mGe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, yGe = Du("div")`
  position: absolute;
`, bGe = Du("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, wGe = rl`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, CGe = Du("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${wGe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, OGe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(CGe, null, t) : t : n === "blank" ? null : Ne.createElement(bGe, null, Ne.createElement(hGe, { ...r }), n !== "loading" && Ne.createElement(yGe, null, n === "error" ? Ne.createElement(dGe, { ...r }) : Ne.createElement(vGe, { ...r })));
}, xGe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, LGe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, EGe = "0%{opacity:0;} 100%{opacity:1;}", kGe = "0%{opacity:1;} 100%{opacity:0;}", PGe = Du("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, SGe = Du("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, MGe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = lGe() ? [EGe, kGe] : [xGe(n), LGe(n)];
  return { animation: t ? `${rl(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${rl(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? MGe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(OGe, { toast: e }), a = Ne.createElement(SGe, { ...e.ariaProps }, aGe(e.message, e));
  return Ne.createElement(PGe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
iGe(Ne.createElement);
zC`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function DGe(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ re.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function _Ge(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ re.jsx("strong", { className: o.trim(), children: t });
}
function TGe(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, a] = E(!1), s = ht(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (f) => {
    if (r || !i || !s.current) return;
    const v = s.current.getBoundingClientRect(), b = f.clientX - v.left, L = Math.min(Math.max(b / v.width * 100, 0), 100);
    t(L);
  }, p = (f) => {
    if (!s.current) return;
    const v = s.current.getBoundingClientRect(), b = f.clientX - v.left, L = Math.min(Math.max(b / v.width * 100, 0), 100);
    t(L);
  };
  h(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const y = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ re.jsxs(
    "div",
    {
      className: y,
      ref: s,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ re.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ re.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function jGe(e) {
  var S, U, k, N;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = e, [l, u] = E(0), c = ht(null), [p, d] = E(!1), [y, f] = E(!1);
  h(() => {
    const R = c.current;
    if (!R) return;
    const V = () => {
      const $ = R.duration, Z = R.currentTime / $ * 100;
      u(Z);
    };
    return R.addEventListener("timeupdate", V), () => {
      R.removeEventListener("timeupdate", V);
    };
  }, []);
  function v(R) {
    const V = c.current;
    if (!V) return;
    const $ = V.duration, W = R / 100 * $;
    V.currentTime = W;
  }
  function b() {
    var R;
    (R = c.current) == null || R.play(), f(!0);
  }
  function L() {
    var R;
    (R = c.current) == null || R.pause(), f(!1);
  }
  function w() {
    y ? L() : b();
  }
  const D = (S = c.current) == null ? void 0 : S.currentTime, x = (U = c.current) == null ? void 0 : U.duration;
  function m(R) {
    if (!R) return "00:00";
    const V = Math.floor(R / 60), $ = Math.floor(R % 60), W = String(V).padStart(2, "0"), Z = String($).padStart(2, "0");
    return `${W}:${Z}`;
  }
  p || !y ? (k = c.current) == null || k.pause() : y && ((N = c.current) == null || N.play());
  function C() {
    if (n) return;
    const R = document.createElement("input");
    R.type = "file", R.accept = r, R.onchange = (V) => {
      var W;
      const $ = (W = V.target.files) == null ? void 0 : W[0];
      $ && o($);
    }, R.click();
  }
  return /* @__PURE__ */ re.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ re.jsx("audio", { ref: c, src: t, onEnded: L }),
    /* @__PURE__ */ re.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ re.jsxs("button", { type: "button", onClick: w, children: [
        y && /* @__PURE__ */ re.jsx(nse, {}),
        !y && /* @__PURE__ */ re.jsx(rse, {})
      ] }),
      /* @__PURE__ */ re.jsx("p", { children: m(D) }),
      /* @__PURE__ */ re.jsx(
        TGe,
        {
          value: l,
          onChange: v,
          onDragging: d
        }
      ),
      /* @__PURE__ */ re.jsx("p", { children: m(x) })
    ] }),
    /* @__PURE__ */ re.jsx(Upe, {}),
    /* @__PURE__ */ re.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ re.jsx(g5e, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ re.jsx(
        h5e,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: J7,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ re.jsx(
        yre,
        {
          isLoading: i,
          onClick: C,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function AGe(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ re.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ re.jsx(
      yre,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ re.jsx("p", { children: t })
  ] });
}
function Yrt(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de udio",
    dropAudioText: l = "Ou arraste e solte um arquivo de udio aqui",
    changeAudioButtonText: u = "Trocar arquivo de udio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: y = !1,
    disabled: f = !1
  } = e, b = f5e()[t], [L, w] = E(d), [D, x] = E(""), [m, C] = E(null), [S, U] = E(d), [k, N] = E(!1);
  async function R(K) {
    if (f) return;
    N(!0), C(K), x("");
    const Q = new FormData();
    Q.append(r, K), await fetch(p, { method: o, body: Q }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : w(J == null ? void 0 : J[a]), i && i(J == null ? void 0 : J[a]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar audio");
    }).finally(() => N(!1));
  }
  function V(K) {
    if (!f) {
      if (console.log(K.type), K.type.indexOf("audio") === -1) {
        x("O arquivo selecionado no  um arquivo de udio");
        return;
      }
      U(URL.createObjectURL(K)), R(K);
    }
  }
  const $ = b || D, X = `arkynAudioUpload ${$ ? "hasError" : "noHasError"} ${S ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ re.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ re.jsx(_Ge, { label: n, showAsterisk: y }),
    /* @__PURE__ */ re.jsxs("div", { className: X, children: [
      /* @__PURE__ */ re.jsx("input", { type: "hidden", name: t, value: L || "" }),
      !S && /* @__PURE__ */ re.jsx(
        AGe,
        {
          disabled: f,
          isLoading: k,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: V,
          selectAudioButtonText: s
        }
      ),
      S && /* @__PURE__ */ re.jsx(
        jGe,
        {
          filePath: S,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: V,
          isLoading: k,
          reSendAudio: $ && m ? () => R(m) : void 0
        }
      )
    ] }),
    $ && /* @__PURE__ */ re.jsx(DGe, { error: $ })
  ] });
}
function D0(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, y = { xs: 12, sm: 16, md: 20, lg: 24 }[i], b = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ re.jsxs("button", { className: b, disabled: l || t, ...p, children: [
    /* @__PURE__ */ re.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ re.jsx(va, { size: y, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ re.jsxs("div", { className: "arkynButtonContent", children: [
      by(y, a),
      c,
      by(y, s)
    ] })
  ] });
}
function poe() {
  const e = FS(), t = tG(), n = nG(), [r, o] = E(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const doe = Ve({});
function uq(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = poe(), a = ht(null), s = ((p = a.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[s]) || null, u = Kie(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ re.jsx(doe.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ re.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function ts() {
  return ge(doe);
}
function Xrt(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = ts(), y = o || !!d, [f, v] = E(i || !1), b = typeof a == "boolean" ? a : f, D = `arkynCheckbox ${r} ${y ? "errorTrue" : "errorFalse"} ${b ? "checkedTrue" : "checkedFalse"} ${n}`;
  function x() {
    const m = f;
    v(!m), s && s(m ? "" : l || "checked");
  }
  return /* @__PURE__ */ re.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: D,
      onClick: x,
      ...u,
      children: [
        /* @__PURE__ */ re.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: b ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ re.jsx(RS, {})
      ]
    }
  );
}
function Krt(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = ts();
  return t ? /* @__PURE__ */ re.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ re.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function cq(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = ts(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ re.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function BGe(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ re.jsxs(
    "button",
    {
      disabled: a || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ re.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ re.jsx(va, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ re.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ re.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function IGe(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ re.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ re.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function RGe(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && a(p);
    }, u.click();
  }
  return /* @__PURE__ */ re.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ re.jsx(IGe, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ re.jsx(
          BGe,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: J7,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ re.jsx(
          D0,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function NGe(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ re.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function FGe(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ re.jsx("strong", { className: o.trim(), children: t });
}
function zGe(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ re.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ re.jsx(
      D0,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ re.jsx("p", { children: t })
  ] });
}
function UGe(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: y,
    disabled: f = !1
  } = e, b = poe()[t], [L, w] = E(n), [D, x] = E(""), [m, C] = E(null), [S, U] = E(n), [k, N] = E(!1);
  async function R(K) {
    if (f) return;
    N(!0), C(K), x("");
    const Q = new FormData();
    Q.append(a, K), await fetch(i, { method: s, body: Q }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : w(J == null ? void 0 : J[u]), y && y(J == null ? void 0 : J[u]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar imagem");
    }).finally(() => N(!1));
  }
  function V(K) {
    f || (U(URL.createObjectURL(K)), R(K));
  }
  const $ = b || D, X = `arkynImageUpload ${$ ? "hasError" : "noHasError"} ${S ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ re.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ re.jsx(FGe, { label: r, showAsterisk: o }),
    /* @__PURE__ */ re.jsxs("div", { className: X, children: [
      /* @__PURE__ */ re.jsx("input", { type: "hidden", name: t, value: L || "" }),
      !S && /* @__PURE__ */ re.jsx(
        zGe,
        {
          disabled: f,
          isLoading: k,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: V,
          selectImageButtonText: p
        }
      ),
      S && /* @__PURE__ */ re.jsx(
        RGe,
        {
          disabled: f,
          isLoading: k,
          acceptImage: l,
          filePath: S,
          handleSelectFile: V,
          changeImageButtonText: c,
          reSendImage: $ && m ? () => R(m) : void 0
        }
      )
    ] }),
    $ && /* @__PURE__ */ re.jsx(NGe, { error: $ })
  ] });
}
function iu(e, t, n) {
  if (!e) return /* @__PURE__ */ re.jsx(re.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ re.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ re.jsx("p", { className: n, children: /* @__PURE__ */ re.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function JT(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function foe(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function hoe(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const QT = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, goe = JT(QT.CNPJ).length;
function WGe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: y,
    onFocus: f,
    onBlur: v,
    title: b,
    style: L,
    onChange: w,
    ...D
  } = e;
  function x(W) {
    let Z = JT(W);
    const X = hoe(Z);
    if (!(Z.length > goe))
      return Z = foe(Z, QT[X]), Z;
  }
  const m = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || y || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: iu(s, $, "prefix"),
    sufix: iu(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: x(d || ""),
    disabled: p,
    readOnly: y,
    onFocus: f,
    onBlur: v,
    title: b,
    style: L,
    onChange: w,
    loadingPosition: m,
    iconSize: $,
    Spinner: /* @__PURE__ */ re.jsx(va, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...D
  };
}
function HGe(e) {
  const [t, n] = E(!1), r = ht(null), { inputRef: o, id: i, error: a } = ts(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: b,
    isLoading: L,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    Spinner: S,
    onChange: U,
    value: k,
    defaultValue: N,
    ...R
  } = WGe({ ...e, id: i, isError: l }, t), [V, $] = E(N), W = w && !L, Z = C && !L, X = b === "left" && L, K = b === "right" && L;
  function Q() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function J(z) {
    let M = JT(z.target.value);
    const H = hoe(M);
    M.length > goe || (M = foe(M, QT[H]), z.target.value = M, $(M), U && U(z));
  }
  function P(z) {
    n(!0), x && x(z);
  }
  function _(z) {
    n(!1), m && m(z);
  }
  return /* @__PURE__ */ re.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: Q,
      className: d,
      children: [
        y,
        X && S,
        W && /* @__PURE__ */ re.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsx(
          "input",
          {
            disabled: u || L,
            readOnly: D,
            ref: s,
            value: k || V,
            onFocus: P,
            onChange: J,
            onBlur: _,
            ...R
          }
        ),
        Z && /* @__PURE__ */ re.jsx(C, { size: v, strokeWidth: 2.5 }),
        K && S,
        f
      ]
    }
  );
}
const VGe = 3, $Ge = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? VGe : 0), Fv = 2, pq = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), yS = (e) => {
  let t = e;
  return typeof e == "string" ? (t = pq(e), t % 1 !== 0 && (t = t.toFixed(Fv))) : t = Number.isInteger(e) ? Number(e) * 10 ** Fv : e.toFixed(Fv), pq(t) / 10 ** Fv;
}, dq = (e, t, n) => {
  if (!t) return [0, ""];
  const r = yS(t), o = $Ge(e, r, n);
  return [r, o];
};
function qGe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    // showCents = false,
    max: L = 1e9,
    locale: w = "pt-BR",
    currency: D = "BRL",
    ...x
  } = e, m = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: iu(s, $, "prefix"),
    sufix: iu(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: D,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    max: L,
    // showCents,
    loadingPosition: m,
    iconSize: $,
    Spinner: /* @__PURE__ */ re.jsx(va, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...x
  };
}
function ZGe(e) {
  const [t, n] = E(!1), [r, o] = E("0"), i = ht(null), { inputRef: a, id: s, error: l } = ts(), u = a || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: y,
    className: f,
    prefix: v,
    sufix: b,
    iconSize: L,
    loadingPosition: w,
    isLoading: D,
    LeftIcon: x,
    readOnly: m,
    onFocus: C,
    onBlur: S,
    RightIcon: U,
    Spinner: k,
    value: N,
    max: R,
    onChangeValue: V,
    onKeyPress: $,
    currency: W,
    locale: Z,
    name: X,
    defaultValue: K,
    ...Q
  } = qGe({ ...e, id: s, isError: c }, t), J = x && !D, P = U && !D, _ = w === "left" && D, z = w === "right" && D;
  function M() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function H(q) {
    n(!0), C && C(q);
  }
  function O(q) {
    n(!1), S && S(q);
  }
  const j = (q) => {
    const [B, Y] = dq(
      Z,
      q,
      W
    );
    return !R || B <= R ? (o(Y), [B, Y]) : [yS(r), r];
  }, F = (q) => {
    q.preventDefault();
    const [B, Y] = j(q.target.value);
    V && V(q, String(B), String(Y));
  }, T = (q) => $ && $(q, q.key, q.key);
  return h(() => {
    const q = N || +K || void 0, [, B] = dq(Z, q, W);
    o(B);
  }, [W, K, N]), /* @__PURE__ */ re.jsxs(
    "section",
    {
      title: d,
      style: y,
      onClick: M,
      className: f,
      children: [
        v,
        _ && k,
        J && /* @__PURE__ */ re.jsx(x, { size: L, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsx(
          "input",
          {
            value: r,
            onChange: F,
            onBlur: O,
            onFocus: H,
            onKeyUp: T,
            disabled: p || D,
            readOnly: m,
            ...Q
          }
        ),
        /* @__PURE__ */ re.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: X,
            value: yS(r)
          }
        ),
        z && k,
        P && /* @__PURE__ */ re.jsx(U, { size: L, strokeWidth: 2.5 }),
        b
      ]
    }
  );
}
function GGe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    onChange: L,
    showMask: w = !1,
    type: D,
    ...x
  } = e, m = c ? "right" : "left", R = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, $ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: R,
    prefix: iu(s, $, "prefix"),
    sufix: iu(l, $, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    onChange: L,
    loadingPosition: m,
    iconSize: $,
    showMask: w,
    Spinner: /* @__PURE__ */ re.jsx(va, { className: "spinner", size: $, strokeWidth: 2.5 }),
    ...x
  };
}
const YGe = ma((e, t) => /* @__PURE__ */ re.jsx("input", { ref: t, ...e }));
function XGe(e) {
  const [t, n] = E(!1), r = ht(null), { inputRef: o, id: i, error: a } = ts(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: b,
    isLoading: L,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    Spinner: S,
    ...U
  } = GGe({ ...e, id: i, isError: l }, t), k = w && !L, N = C && !L, R = b === "left" && L, V = b === "right" && L;
  function $() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function W(X) {
    n(!0), x && x(X);
  }
  function Z(X) {
    n(!1), m && m(X);
  }
  return /* @__PURE__ */ re.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: $,
      className: d,
      children: [
        y,
        R && S,
        k && /* @__PURE__ */ re.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsx(
          bse,
          {
            component: YGe,
            ref: s,
            onFocus: W,
            onBlur: Z,
            disabled: u,
            ...U
          }
        ),
        N && /* @__PURE__ */ re.jsx(C, { size: v, strokeWidth: 2.5 }),
        V && S,
        f
      ]
    }
  );
}
function KGe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    onChange: L,
    ...w
  } = e, D = c ? "right" : "left", k = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, R = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: k,
    prefix: iu(s, R, "prefix"),
    sufix: iu(l, R, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: b,
    onChange: L,
    loadingPosition: D,
    iconSize: R,
    Spinner: /* @__PURE__ */ re.jsx(va, { className: "spinner", size: R, strokeWidth: 2.5 }),
    ...w
  };
}
function JGe(e) {
  const [t, n] = E(!1), r = ht(null), { inputRef: o, id: i, error: a } = ts(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: b,
    isLoading: L,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    type: S,
    Spinner: U,
    ...k
  } = KGe({ ...e, id: i, isError: l }, t), N = w && !L, R = C && !L, V = b === "left" && L, $ = b === "right" && L;
  function W() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function Z(K) {
    n(!0), x && x(K);
  }
  function X(K) {
    n(!1), m && m(K);
  }
  return S === "hidden" ? /* @__PURE__ */ re.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...k
    }
  ) : /* @__PURE__ */ re.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: W,
      className: d,
      children: [
        y,
        V && U,
        N && /* @__PURE__ */ re.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsx(
          "input",
          {
            disabled: u || L,
            readOnly: D,
            ref: s,
            onFocus: Z,
            onBlur: X,
            type: S,
            ...k
          }
        ),
        R && /* @__PURE__ */ re.jsx(C, { size: v, strokeWidth: 2.5 }),
        $ && U,
        f
      ]
    }
  );
}
function UC(e) {
  return e.type === "currency" ? /* @__PURE__ */ re.jsx(ZGe, { ...e }) : e.type === "masked" ? /* @__PURE__ */ re.jsx(XGe, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ re.jsx(HGe, { ...e }) : /* @__PURE__ */ re.jsx(JGe, { ...e });
}
function QGe(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ re.jsx(re.Fragment, {}) : /* @__PURE__ */ re.jsx(Q7, { className: l, size: t, strokeWidth: 2.5 });
}
function eYe(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, y = d ? "hasPrefix" : "", f = o ? "errored" : "", v = r || l || i ? "opacity" : "", b = a ? "focused" : "";
  return /* @__PURE__ */ re.jsx(
    "section",
    {
      onClick: n,
      id: p,
      className: `arkynMultiSelectContainer ${y} ${u} ${c} ${v} ${f} ${b} ${s}`,
      children: t
    }
  );
}
function tYe(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ re.jsx("div", { className: r, children: t });
}
function nYe(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ re.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ re.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ re.jsx(NS, {})
      }
    )
  ] });
}
function rYe(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ re.jsxs("div", { onClick: () => r(o), className: s, children: [
    t,
    " ",
    /* @__PURE__ */ re.jsx(RS, {})
  ] });
}
function oYe(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ re.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ re.jsx(
      UC,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: eG,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function iYe(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ re.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function sYe(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ re.jsx(
    va,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function Jrt(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: y,
    onBlur: f,
    notFoundText: v = "Sem opes disponveis",
    onFocus: b,
    disabled: L = !1,
    prefix: w,
    size: D = "md",
    value: x,
    variant: m = "solid"
  } = e, C = ts(), S = ht(null), U = C.inputRef || S, k = C.id, N = s || !!C.error, V = { md: 20, lg: 20 }[D], $ = RG(w, V, "prefix"), [W, Z] = E(""), [X, K] = E(!1), [Q, J] = E(a), P = x || Q;
  function _(T) {
    return P.includes(T);
  }
  function z(T) {
    const q = n.find((B) => B.value === T);
    return (q == null ? void 0 : q.label) || "";
  }
  function M() {
    L || !(U != null && U.current) || X || (K(!0), U.current.focus(), b && b());
  }
  function H() {
    K(!1), f && U.current && U.current.blur();
  }
  function O(T) {
    Z(T), d && d(T);
  }
  function j(T) {
    _(T) ? J(Q.filter((q) => q !== T)) : J([...Q, T]), y && y(Q), i && H();
  }
  const F = n.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(W.toLowerCase())));
  return /* @__PURE__ */ re.jsxs(
    eYe,
    {
      handleContainerFocus: M,
      disabled: L,
      isError: N,
      isFocused: X,
      isLoading: l,
      readOnly: u,
      size: D,
      variant: m,
      className: r,
      prefixExists: !!w,
      id: k,
      children: [
        /* @__PURE__ */ re.jsx(
          "input",
          {
            ref: U,
            name: t,
            value: JSON.stringify(P),
            type: "hidden"
          }
        ),
        $,
        p && /* @__PURE__ */ re.jsx(p, { size: V, strokeWidth: 2.5 }),
        /* @__PURE__ */ re.jsxs(tYe, { size: D, children: [
          P.map((T) => /* @__PURE__ */ re.jsx(
            nYe,
            {
              label: z(T),
              value: T,
              handleChangeValue: j
            },
            T
          )),
          P.length <= 0 && /* @__PURE__ */ re.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ re.jsxs(
          oYe,
          {
            isFocused: X,
            isSearchable: c,
            onSearch: O,
            children: [
              F.map(({ label: T, value: q }) => /* @__PURE__ */ re.jsx(
                rYe,
                {
                  label: T,
                  value: q,
                  size: D,
                  handleChangeValue: j,
                  optionHasSelected: _
                },
                q
              )),
              F.length <= 0 && /* @__PURE__ */ re.jsx("p", { children: v })
            ]
          }
        ),
        /* @__PURE__ */ re.jsx(
          QGe,
          {
            disabled: L,
            isFocused: X,
            readOnly: u,
            iconSize: V,
            isLoading: l
          }
        ),
        /* @__PURE__ */ re.jsx(sYe, { iconSize: V, isLoading: l }),
        /* @__PURE__ */ re.jsx(iYe, { handleBlur: H, isFocused: X })
      ]
    }
  );
}
const moe = Ve({});
function aYe() {
  return ge(moe);
}
function Qrt(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [l, u] = E(t || ""), { inputRef: c, id: p } = ts();
  function d(f) {
    u(f), o && o(f);
  }
  const y = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ re.jsxs(
    moe.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ re.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ re.jsx("div", { className: y.trim(), ...s })
      ]
    }
  );
}
function eot(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: l, value: u } = aYe(), { error: c } = ts(), v = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ re.jsxs("label", { className: v.trim(), children: [
    /* @__PURE__ */ re.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var fl = {};
Object.defineProperty(fl, "__esModule", {
  value: !0
});
var lYe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), mE = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, voe = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: lYe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, ej = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var zv = 1; zv < 20; zv++)
  ej["f" + zv] = 111 + zv;
function WC(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return yoe(a, t);
  }), o = function(s) {
    return r.some(function(l) {
      return boe(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function uYe(e, t) {
  return WC(e, t);
}
function cYe(e, t) {
  return WC(e, { byKey: !0 }, t);
}
function yoe(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in mE)
    r[mE[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = tj(d), v = mE[f];
      if (d.length > 1 && !v && !voe[d] && !ej[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = woe(d)), v && (r[v] = y ? null : !0);
    }
  } catch (b) {
    l = !0, u = b;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function boe(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function woe(e) {
  e = tj(e);
  var t = ej[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function tj(e) {
  return e = e.toLowerCase(), e = voe[e] || e, e;
}
var pYe = fl.default = WC, vE = fl.isHotkey = WC;
fl.isCodeHotkey = uYe;
fl.isKeyHotkey = cYe;
fl.parseHotkey = yoe;
fl.compareHotkey = boe;
fl.toKeyCode = woe;
fl.toKeyName = tj;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function fq(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function dYe(e) {
  var t, n;
  return fq(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(fq(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var fYe = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return dYe(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || ru.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || ru.isOperationList(e.undos[0].operations));
  }
}, yE = /* @__PURE__ */ new WeakMap(), Sd = /* @__PURE__ */ new WeakMap(), wc = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return fYe.isHistory(e.history) && ee.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return Sd.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return yE.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = wc.isMerging(e);
    Sd.set(e, !0), t(), Sd.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = wc.isMerging(e);
    Sd.set(e, !1), t(), Sd.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = wc.isSaving(e);
    yE.set(e, !1), t(), yE.set(e, n);
  }
}, hYe = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && Fe.setSelection(t, i.selectionBefore), wc.withoutSaving(t, () => {
        ee.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      wc.withoutSaving(t, () => {
        ee.withoutNormalizing(t, () => {
          var a = i.operations.map(ru.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && Fe.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = wc.isSaving(t), c = wc.isMerging(t);
    if (u == null && (u = mYe(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = gYe(r, l)), s && c)
        s.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, gYe = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ce.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ce.equals(e.path, t.path)), mYe = (e, t) => e.type !== "set_selection", vYe = wYe, Coe = "---", Ooe = "A-Za-z--------", yYe = new RegExp("^[^" + Ooe + "]*[" + Coe + "]"), bYe = new RegExp("^[^" + Coe + "]*[" + Ooe + "]");
function wYe(e) {
  return e = String(e || ""), yYe.test(e) ? "rtl" : bYe.test(e) ? "ltr" : "neutral";
}
const xoe = /* @__PURE__ */ H0(vYe);
function CYe(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var nj = CYe, OYe = typeof hr == "object" && hr && hr.Object === Object && hr, xYe = OYe, LYe = xYe, EYe = typeof self == "object" && self && self.Object === Object && self, kYe = LYe || EYe || Function("return this")(), Loe = kYe, PYe = Loe, SYe = function() {
  return PYe.Date.now();
}, MYe = SYe, DYe = /\s/;
function _Ye(e) {
  for (var t = e.length; t-- && DYe.test(e.charAt(t)); )
    ;
  return t;
}
var TYe = _Ye, jYe = TYe, AYe = /^\s+/;
function BYe(e) {
  return e && e.slice(0, jYe(e) + 1).replace(AYe, "");
}
var IYe = BYe, RYe = Loe, NYe = RYe.Symbol, Eoe = NYe, hq = Eoe, koe = Object.prototype, FYe = koe.hasOwnProperty, zYe = koe.toString, Md = hq ? hq.toStringTag : void 0;
function UYe(e) {
  var t = FYe.call(e, Md), n = e[Md];
  try {
    e[Md] = void 0;
    var r = !0;
  } catch {
  }
  var o = zYe.call(e);
  return r && (t ? e[Md] = n : delete e[Md]), o;
}
var WYe = UYe, HYe = Object.prototype, VYe = HYe.toString;
function $Ye(e) {
  return VYe.call(e);
}
var qYe = $Ye, gq = Eoe, ZYe = WYe, GYe = qYe, YYe = "[object Null]", XYe = "[object Undefined]", mq = gq ? gq.toStringTag : void 0;
function KYe(e) {
  return e == null ? e === void 0 ? XYe : YYe : mq && mq in Object(e) ? ZYe(e) : GYe(e);
}
var JYe = KYe;
function QYe(e) {
  return e != null && typeof e == "object";
}
var eXe = QYe, tXe = JYe, nXe = eXe, rXe = "[object Symbol]";
function oXe(e) {
  return typeof e == "symbol" || nXe(e) && tXe(e) == rXe;
}
var iXe = oXe, sXe = IYe, vq = nj, aXe = iXe, yq = NaN, lXe = /^[-+]0x[0-9a-f]+$/i, uXe = /^0b[01]+$/i, cXe = /^0o[0-7]+$/i, pXe = parseInt;
function dXe(e) {
  if (typeof e == "number")
    return e;
  if (aXe(e))
    return yq;
  if (vq(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = vq(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = sXe(e);
  var n = uXe.test(e);
  return n || cXe.test(e) ? pXe(e.slice(2), n ? 2 : 8) : lXe.test(e) ? yq : +e;
}
var fXe = dXe, hXe = nj, bE = MYe, bq = fXe, gXe = "Expected a function", mXe = Math.max, vXe = Math.min;
function yXe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(gXe);
  t = bq(t) || 0, hXe(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? mXe(bq(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? vXe(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = bE();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(bE());
  }
  function m() {
    var C = bE(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return clearTimeout(s), s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
var Poe = yXe;
const bXe = /* @__PURE__ */ H0(Poe);
var wXe = Poe, CXe = nj, OXe = "Expected a function";
function xXe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(OXe);
  return CXe(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), wXe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var LXe = xXe;
const EXe = /* @__PURE__ */ H0(LXe), wq = (e) => typeof e == "object" && e != null && e.nodeType === 1, Cq = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", wE = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return Cq(n.overflowY, t) || Cq(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, Uv = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, kXe = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, Oq = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (X) => X !== u;
  if (!wq(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, y = [];
  let f = e;
  for (; wq(f) && p(f); ) {
    if (f = kXe(f), f === d) {
      y.push(f);
      break;
    }
    f != null && f === document.body && wE(f) && !wE(document.documentElement) || f != null && wE(f, c) && y.push(f);
  }
  const v = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, b = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: L, scrollY: w } = window, { height: D, width: x, top: m, right: C, bottom: S, left: U } = e.getBoundingClientRect(), { top: k, right: N, bottom: R, left: V } = ((X) => {
    const K = window.getComputedStyle(X);
    return { top: parseFloat(K.scrollMarginTop) || 0, right: parseFloat(K.scrollMarginRight) || 0, bottom: parseFloat(K.scrollMarginBottom) || 0, left: parseFloat(K.scrollMarginLeft) || 0 };
  })(e);
  let $ = s === "start" || s === "nearest" ? m - k : s === "end" ? S + R : m + D / 2 - k + R, W = l === "center" ? U + x / 2 - V + N : l === "end" ? C + N : U - V;
  const Z = [];
  for (let X = 0; X < y.length; X++) {
    const K = y[X], { height: Q, width: J, top: P, right: _, bottom: z, left: M } = K.getBoundingClientRect();
    if (a === "if-needed" && m >= 0 && U >= 0 && S <= b && C <= v && m >= P && S <= z && U >= M && C <= _) return Z;
    const H = getComputedStyle(K), O = parseInt(H.borderLeftWidth, 10), j = parseInt(H.borderTopWidth, 10), F = parseInt(H.borderRightWidth, 10), T = parseInt(H.borderBottomWidth, 10);
    let q = 0, B = 0;
    const Y = "offsetWidth" in K ? K.offsetWidth - K.clientWidth - O - F : 0, I = "offsetHeight" in K ? K.offsetHeight - K.clientHeight - j - T : 0, le = "offsetWidth" in K ? K.offsetWidth === 0 ? 0 : J / K.offsetWidth : 0, he = "offsetHeight" in K ? K.offsetHeight === 0 ? 0 : Q / K.offsetHeight : 0;
    if (d === K) q = s === "start" ? $ : s === "end" ? $ - b : s === "nearest" ? Uv(w, w + b, b, j, T, w + $, w + $ + D, D) : $ - b / 2, B = l === "start" ? W : l === "center" ? W - v / 2 : l === "end" ? W - v : Uv(L, L + v, v, O, F, L + W, L + W + x, x), q = Math.max(0, q + w), B = Math.max(0, B + L);
    else {
      q = s === "start" ? $ - P - j : s === "end" ? $ - z + T + I : s === "nearest" ? Uv(P, z, Q, j, T + I, $, $ + D, D) : $ - (P + Q / 2) + I / 2, B = l === "start" ? W - M - O : l === "center" ? W - (M + J / 2) + Y / 2 : l === "end" ? W - _ + F + Y : Uv(M, _, J, O, F + Y, W, W + x, x);
      const { scrollLeft: oe, scrollTop: Be } = K;
      q = he === 0 ? 0 : Math.max(0, Math.min(Be + q / he, K.scrollHeight - Q / he + I)), B = le === 0 ? 0 : Math.max(0, Math.min(oe + B / le, K.scrollWidth - J / le + Y)), $ += Be - q, W += oe - B;
    }
    Z.push({ el: K, top: q, left: B });
  }
  return Z;
}, PXe = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function SXe(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(Oq(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of Oq(e, PXe(t))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var xc = [], MXe = function() {
  return xc.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, DXe = function() {
  return xc.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, xq = "ResizeObserver loop completed with undelivered notifications.", _Xe = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: xq
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = xq), window.dispatchEvent(e);
}, Oh;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Oh || (Oh = {}));
var Lc = function(e) {
  return Object.freeze(e);
}, TXe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Lc(this);
  }
  return e;
}(), Soe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Lc(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), rj = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, Moe = function(e) {
  if (rj(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, Lq = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, jXe = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, kf = typeof window < "u" ? window : {}, Wv = /* @__PURE__ */ new WeakMap(), Eq = /auto|scroll/, AXe = /^tb|vertical/, BXe = /msie|trident/i.test(kf.navigator && kf.navigator.userAgent), Qs = function(e) {
  return parseFloat(e || "0");
}, ap = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new TXe((n ? t : e) || 0, (n ? e : t) || 0);
}, kq = Lc({
  devicePixelContentBoxSize: ap(),
  borderBoxSize: ap(),
  contentBoxSize: ap(),
  contentRect: new Soe(0, 0, 0, 0)
}), Doe = function(e, t) {
  if (t === void 0 && (t = !1), Wv.has(e) && !t)
    return Wv.get(e);
  if (Moe(e))
    return Wv.set(e, kq), kq;
  var n = getComputedStyle(e), r = rj(e) && e.ownerSVGElement && e.getBBox(), o = !BXe && n.boxSizing === "border-box", i = AXe.test(n.writingMode || ""), a = !r && Eq.test(n.overflowY || ""), s = !r && Eq.test(n.overflowX || ""), l = r ? 0 : Qs(n.paddingTop), u = r ? 0 : Qs(n.paddingRight), c = r ? 0 : Qs(n.paddingBottom), p = r ? 0 : Qs(n.paddingLeft), d = r ? 0 : Qs(n.borderTopWidth), y = r ? 0 : Qs(n.borderRightWidth), f = r ? 0 : Qs(n.borderBottomWidth), v = r ? 0 : Qs(n.borderLeftWidth), b = p + u, L = l + c, w = v + y, D = d + f, x = s ? e.offsetHeight - D - e.clientHeight : 0, m = a ? e.offsetWidth - w - e.clientWidth : 0, C = o ? b + w : 0, S = o ? L + D : 0, U = r ? r.width : Qs(n.width) - C - m, k = r ? r.height : Qs(n.height) - S - x, N = U + b + m + w, R = k + L + x + D, V = Lc({
    devicePixelContentBoxSize: ap(Math.round(U * devicePixelRatio), Math.round(k * devicePixelRatio), i),
    borderBoxSize: ap(N, R, i),
    contentBoxSize: ap(U, k, i),
    contentRect: new Soe(p, l, U, k)
  });
  return Wv.set(e, V), V;
}, _oe = function(e, t, n) {
  var r = Doe(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case Oh.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case Oh.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, IXe = /* @__PURE__ */ function() {
  function e(t) {
    var n = Doe(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Lc([n.borderBoxSize]), this.contentBoxSize = Lc([n.contentBoxSize]), this.devicePixelContentBoxSize = Lc([n.devicePixelContentBoxSize]);
  }
  return e;
}(), Toe = function(e) {
  if (Moe(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, RXe = function() {
  var e = 1 / 0, t = [];
  xc.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new IXe(u.target), p = Toe(u.target);
        s.push(c), u.lastReportedSize = _oe(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, Pq = function(e) {
  xc.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (Toe(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, NXe = function() {
  var e = 0;
  for (Pq(e); MXe(); )
    e = RXe(), Pq(e);
  return DXe() && _Xe(), e > 0;
}, CE, joe = [], FXe = function() {
  return joe.splice(0).forEach(function(e) {
    return e();
  });
}, zXe = function(e) {
  if (!CE) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return FXe();
    }).observe(n, r), CE = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  joe.push(e), CE();
}, UXe = function(e) {
  zXe(function() {
    requestAnimationFrame(e);
  });
}, py = 0, WXe = function() {
  return !!py;
}, HXe = 250, VXe = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Sq = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], Mq = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, OE = !1, $Xe = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = HXe), !OE) {
      OE = !0;
      var r = Mq(t);
      UXe(function() {
        var o = !1;
        try {
          o = NXe();
        } finally {
          if (OE = !1, t = r - Mq(), !WXe())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, VXe);
    };
    document.body ? n() : kf.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Sq.forEach(function(n) {
      return kf.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), Sq.forEach(function(n) {
      return kf.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), bS = new $Xe(), Dq = function(e) {
  !py && e > 0 && bS.start(), py += e, !py && bS.stop();
}, qXe = function(e) {
  return !rj(e) && !jXe(e) && getComputedStyle(e).display === "inline";
}, ZXe = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || Oh.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = _oe(this.target, this.observedBox, !0);
    return qXe(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), GXe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Hv = /* @__PURE__ */ new WeakMap(), _q = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Vv = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new GXe(t, n);
    Hv.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = Hv.get(t), i = o.observationTargets.length === 0;
    _q(o.observationTargets, n) < 0 && (i && xc.push(o), o.observationTargets.push(new ZXe(n, r && r.box)), Dq(1), bS.schedule());
  }, e.unobserve = function(t, n) {
    var r = Hv.get(t), o = _q(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && xc.splice(xc.indexOf(r), 1), r.observationTargets.splice(o, 1), Dq(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Hv.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), YXe = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Vv.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Lq(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Vv.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Lq(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Vv.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Vv.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function XXe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function yp(e, t) {
  if (e == null) return {};
  var n = XXe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function xh(e) {
  "@babel/helpers - typeof";
  return xh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xh(e);
}
function KXe(e, t) {
  if (xh(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (xh(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function JXe(e) {
  var t = KXe(e, "string");
  return xh(t) === "symbol" ? t : String(t);
}
function Hs(e, t, n) {
  return t = JXe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var oj = /* @__PURE__ */ Ve(null), _u = () => {
  var e = ge(oj);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, xE, LE, Aoe = parseInt(we.version.split(".")[0], 10), Boe = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, Tq = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Oi = typeof navigator < "u" && /Android/.test(navigator.userAgent), Qc = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), oc = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), QXe = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), Ioe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), eKe = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), tKe = Oi && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), nKe = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), rKe = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), oKe = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), dy = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((xE = navigator.userAgent.match(/Version\/(\d+)/)) !== null && xE !== void 0 && xE[1] && parseInt((LE = navigator.userAgent.match(/Version\/(\d+)/)) === null || LE === void 0 ? void 0 : LE[1], 10) < 17);
var Sl = (!eKe || !tKe) && !QXe && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", lp = /* @__PURE__ */ new WeakMap(), ij = /* @__PURE__ */ new WeakMap(), sj = /* @__PURE__ */ new WeakMap(), Roe = /* @__PURE__ */ new WeakMap(), fy = /* @__PURE__ */ new WeakMap(), wS = /* @__PURE__ */ new WeakMap(), Lh = /* @__PURE__ */ new WeakMap(), Ec = /* @__PURE__ */ new WeakMap(), _0 = /* @__PURE__ */ new WeakMap(), HC = /* @__PURE__ */ new WeakMap(), CS = /* @__PURE__ */ new WeakMap(), ou = /* @__PURE__ */ new WeakMap(), Cc = /* @__PURE__ */ new WeakMap(), Pf = /* @__PURE__ */ new WeakMap(), OS = /* @__PURE__ */ new WeakMap(), aj = /* @__PURE__ */ new WeakMap(), Vs = /* @__PURE__ */ new WeakMap(), Ya = /* @__PURE__ */ new WeakMap(), Ti = /* @__PURE__ */ new WeakMap(), ql = /* @__PURE__ */ new WeakMap(), Zl = /* @__PURE__ */ new WeakMap(), Noe = /* @__PURE__ */ new WeakMap(), bp = Symbol("placeholder"), Foe = Symbol("mark-placeholder"), zoe = globalThis.Node, iKe = globalThis.Text, lj = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, sKe = (e) => su(e) && e.nodeType === 8, Ws = (e) => su(e) && e.nodeType === 1, su = (e) => {
  var t = lj(e);
  return !!t && e instanceof t.Node;
}, xS = (e) => {
  var t = e && e.anchorNode && lj(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Uoe = (e) => su(e) && e.nodeType === 3, aKe = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, lKe = (e) => {
  var [t, n] = e;
  if (Ws(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Woe(t, o, r ? "backward" : "forward"), r = o < n; Ws(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = cKe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, uKe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Woe = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (sKe(o) || Ws(o) && o.childNodes.length === 0 || Ws(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, cKe = (e, t, n) => {
  var [r] = Woe(e, t, n);
  return r;
}, Hoe = (e) => {
  var t = "";
  if (Uoe(e) && e.nodeValue)
    return e.nodeValue;
  if (Ws(e)) {
    for (var n of Array.from(e.childNodes))
      t += Hoe(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, pKe = /data-slate-fragment="(.+?)"/m, dKe = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(pKe) || [];
  return n;
}, Sf = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), uj = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ws(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Le.getWindow(e);
  if (o.contains(r))
    return Le.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : uj(e, i, n);
}, fKe = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, jq = (e, t) => !!(e.compareDocumentPosition(t) & zoe.DOCUMENT_POSITION_PRECEDING), hKe = (e, t) => !!(e.compareDocumentPosition(t) & zoe.DOCUMENT_POSITION_FOLLOWING), gKe = 0;
class mKe {
  constructor() {
    Hs(this, "id", void 0), this.id = "".concat(gKe++);
  }
}
var Le = {
  androidPendingDiffs: (e) => Ti.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = aj.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Le.toDOMNode(e, e), n = Le.findDocumentOrShadowRoot(e);
    ou.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Le.findDocumentOrShadowRoot(e), r = Sf(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Fe.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Le.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Le.toSlateNode(e, t.target), a = Le.findPath(e, i);
    if (dt.isElement(i) && ee.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = ee.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? ee.before(e, u) : ee.after(e, u);
      if (c) {
        var p = ee.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = Le.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = Le.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = _0.get(t);
    return n || (n = new mKe(), _0.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = sj.get(r);
      if (o == null) {
        if (ee.isEditor(r))
          return n;
        break;
      }
      var i = ij.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Yo.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!ou.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          Le.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = Le.toDOMNode(t, t), o = Le.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Sf(o), a = Le.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || Fe.select(t, ee.start(t, [])), ou.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Roe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = Le.toDOMNode(t, t), a;
    try {
      a = Ws(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => su(t) && Le.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return ee.hasPath(e, n.path) && ee.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Le.hasEditableTarget(e, t) || Le.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => su(t) && Le.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Cc.get(e),
  isFocused: (e) => !!ou.get(e),
  isReadOnly: (e) => !!CS.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (CS.get(e)) return !1;
    var n = Le.hasTarget(e, t) && Le.toSlateNode(e, t);
    return dt.isElement(n) && ee.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = HC.get(e), r = ee.isEditor(t) ? fy.get(e) : n == null ? void 0 : n.get(Le.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Yo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = ee.node(e, t.path), r = Le.toDOMNode(e, n), o;
    ee.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var b, L = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            L instanceof iKe ? L : v,
            (b = v.textContent) !== null && b !== void 0 && b.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Yo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ye.isBackward(t), i = Le.toDOMPoint(e, n), a = ye.isCollapsed(t) ? i : Le.toDOMPoint(e, r), s = Le.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ws(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ws(p) ? p : p.parentElement, b = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, b ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ws(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Lh.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : lKe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = Le.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, b = l.closest('[contenteditable="false"]'), L = b && y.contains(b) ? b : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = Le.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Oi && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var U = v.querySelectorAll("[data-slate-leaf]"), k = 0; k < U.length; k++) {
          var N = U[k];
          if (Le.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (L) {
        var R = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], V = L.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var $, W = [...R(V), ...R(V == null ? void 0 : V.nextElementSibling)];
          w = ($ = W.find((M) => hKe(L, M))) !== null && $ !== void 0 ? $ : null;
        } else {
          var Z, X = [...R(V == null ? void 0 : V.previousElementSibling), ...R(V)];
          w = (Z = X.findLast((M) => jq(L, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Oi && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Qc && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Oi && !u && !r) {
      var K = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (K && Le.hasDOMNode(e, K, {
        editable: !0
      })) {
        var Q = Le.toSlateNode(e, K), {
          path: J,
          offset: P
        } = ee.start(e, Le.findPath(e, Q));
        return K.querySelector("[data-slate-leaf]") || (P = s), {
          path: J,
          offset: P
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = Le.toSlateNode(e, u), z = Le.findPath(e, _);
    return {
      path: z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = xS(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (xS(t)) {
        if (Qc && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, b = C(f.children[d.startOffset]), L = C(v.children[y.startOffset]);
            c = 0, L.childNodes.length > 0 ? s = L.childNodes[0] : s = L, b.childNodes.length > 0 ? u = b.childNodes[0] : u = b, L instanceof HTMLElement ? l = L.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Ioe && uKe(s) || Qc ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Qc && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Le.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = jq(s, u) || s === u && c < l, x = p ? w : Le.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return ye.isExpanded(m) && ye.isForward(m) && Ws(u) && ee.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = ee.unhangRange(e, m, {
      voids: !0
    })), m;
  }
};
function vKe(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!ee.hasPath(e, n))
    return !1;
  var o = et.get(e, n);
  if (!ft.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ce.next(n);
  if (!ee.hasPath(e, i))
    return !1;
  var a = et.get(e, i);
  return ft.isText(a) && a.text.startsWith(r.text);
}
function Voe(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function yKe(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function bKe(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function $oe(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = yKe(i, o), s = Math.min(i.length - a, o.length - a), l = bKe(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function wKe(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = Voe(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return $oe(e, {
    start: r,
    end: l,
    text: s
  });
}
function CKe(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function LS(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!ee.hasPath(e, n))
    return null;
  var o = et.get(e, n);
  if (!ft.isText(o))
    return null;
  var i = ee.above(e, {
    match: (s) => dt.isElement(s) && ee.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = ee.next(e, {
      at: n,
      match: ft.isText
    });
    if (!a || !ce.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function Aq(e, t) {
  var n = LS(e, t.anchor);
  if (!n)
    return null;
  if (ye.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = LS(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function ES(e, t, n) {
  var r = Ti.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return ce.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return $t.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = $t.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = $t.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ce.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function Bq(e, t, n) {
  var r = ES(e, t.anchor, n);
  if (!r)
    return null;
  if (ye.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = ES(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function OKe(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ce.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ce.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ce.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ce.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ce.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ce.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ce.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ce.transform(n, t)
      };
  }
  var i = ce.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function Iq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $v(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Iq(Object(n), !0).forEach(function(r) {
      Hs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Iq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xKe = 25, LKe = 200, EKe = function() {
}, kKe = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function PKe(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var V = Zl.get(t);
    if (Zl.delete(t), V) {
      var {
        selection: $
      } = t, W = Aq(t, V);
      W && (!$ || !ye.equals(W, $)) && Fe.select(t, W);
    }
  }, p = () => {
    var V = ql.get(t);
    if (ql.delete(t), !!V) {
      if (V.at) {
        var $ = $t.isPoint(V.at) ? LS(t, V.at) : Aq(t, V.at);
        if (!$)
          return;
        var W = ee.range(t, $);
        (!t.selection || !ye.equals(t.selection, W)) && Fe.select(t, $);
      }
      V.run();
    }
  }, d = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !x() && !D()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), D() && (o = "action");
    var V = t.selection && ee.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    Ya.set(t, t.marks), EKe("flush", ql.get(t), Ti.get(t));
    for (var $ = x(), W; W = (Z = Ti.get(t)) === null || Z === void 0 ? void 0 : Z[0]; ) {
      var Z, X, K = Vs.get(t);
      K !== void 0 && (Vs.delete(t), t.marks = K), K && u === !1 && (u = null);
      var Q = CKe(W);
      (!t.selection || !ye.equals(t.selection, Q)) && Fe.select(t, Q), W.diff.text ? ee.insertText(t, W.diff.text) : ee.deleteFragment(t), Ti.set(t, (X = Ti.get(t)) === null || X === void 0 ? void 0 : X.filter((_) => {
        var {
          id: z
        } = _;
        return z !== W.id;
      })), vKe(t, W) || ($ = !1, ql.delete(t), Ya.delete(t), o = "action", Zl.delete(t), n.cancel(), r.cancel(), V == null || V.unref());
    }
    var J = V == null ? void 0 : V.unref();
    if (J && !Zl.get(t) && (!t.selection || !ye.equals(J, t.selection)) && Fe.select(t, J), D()) {
      p();
      return;
    }
    $ && n(), n.flush(), r.flush(), c();
    var P = Ya.get(t);
    Ya.delete(t), P !== void 0 && (t.marks = P, t.onChange());
  }, y = (V) => {
    i && clearTimeout(i), i = setTimeout(() => {
      Cc.set(t, !1), d();
    }, xKe);
  }, f = (V) => {
    Cc.set(t, !0), i && (clearTimeout(i), i = null);
  }, v = function() {
    var $ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, W = wS.get(t);
    if (W) {
      if (x() || $) {
        W.style.display = "none";
        return;
      }
      W.style.removeProperty("display");
    }
  }, b = (V, $) => {
    var W, Z = (W = Ti.get(t)) !== null && W !== void 0 ? W : [];
    Ti.set(t, Z);
    var X = et.leaf(t, V), K = Z.findIndex((P) => ce.equals(P.path, V));
    if (K < 0) {
      var Q = $oe(X.text, $);
      Q && Z.push({
        path: V,
        diff: $,
        id: l++
      }), v();
      return;
    }
    var J = wKe(X.text, Z[K].diff, $);
    if (!J) {
      Z.splice(K, 1), v();
      return;
    }
    Z[K] = $v($v({}, Z[K]), {}, {
      diff: J
    });
  }, L = function($) {
    var {
      at: W
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, Zl.delete(t), n.cancel(), r.cancel(), D() && d(), ql.set(t, {
      at: W,
      run: $
    }), s = setTimeout(d);
  }, w = (V) => {
    var $;
    if (a && (clearTimeout(a), a = null), !lp.get(t)) {
      var {
        inputType: W
      } = V, Z = null, X = V.dataTransfer || V.data || void 0;
      u !== !1 && W !== "insertText" && W !== "insertCompositionText" && (u = !1);
      var [K] = V.getTargetRanges();
      K && (Z = Le.toSlateRange(t, K, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var Q = Le.getWindow(t), J = Q.getSelection();
      if (!Z && J && (K = J, Z = Le.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      })), Z = ($ = Z) !== null && $ !== void 0 ? $ : t.selection, !!Z) {
        var P = !0;
        if (W.startsWith("delete")) {
          if (ye.isExpanded(Z)) {
            var [_, z] = ye.edges(Z), M = et.leaf(t, _.path);
            if (M.text.length === _.offset && z.offset === 0) {
              var H = ee.next(t, {
                at: _.path,
                match: ft.isText
              });
              H && ce.equals(H[1], z.path) && (Z = {
                anchor: z,
                focus: z
              });
            }
          }
          var O = W.endsWith("Backward") ? "backward" : "forward", [j, F] = ye.edges(Z), [T, q] = ee.leaf(t, j.path), B = {
            text: "",
            start: j.offset,
            end: F.offset
          }, Y = Ti.get(t), I = Y == null ? void 0 : Y.find((ze) => ce.equals(ze.path, q)), le = I ? [I.diff, B] : [B], he = Voe(T.text, ...le);
          if (he.length === 0 && (P = !1), ye.isExpanded(Z)) {
            if (P && ce.equals(Z.anchor.path, Z.focus.path)) {
              var oe = {
                path: Z.anchor.path,
                offset: j.offset
              }, Be = ee.range(t, oe, oe);
              return S(Be), b(Z.anchor.path, {
                text: "",
                end: F.offset,
                start: j.offset
              });
            }
            return L(() => ee.deleteFragment(t, {
              direction: O
            }), {
              at: Z
            });
          }
        }
        switch (W) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return L(() => ee.deleteFragment(t), {
              at: Z
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: We
            } = Z;
            if (P && ye.isCollapsed(Z)) {
              var He = et.leaf(t, We.path);
              if (We.offset < He.text.length)
                return b(We.path, {
                  text: "",
                  start: We.offset,
                  end: We.offset + 1
                });
            }
            return L(() => ee.deleteForward(t), {
              at: Z
            });
          }
          case "deleteContentBackward": {
            var Ie, {
              anchor: nt
            } = Z, $e = xS(K) ? K.isCollapsed : !!((Ie = K) !== null && Ie !== void 0 && Ie.collapsed);
            return P && $e && ye.isCollapsed(Z) && nt.offset > 0 ? b(nt.path, {
              text: "",
              start: nt.offset - 1,
              end: nt.offset
            }) : L(() => ee.deleteBackward(t), {
              at: Z
            });
          }
          case "deleteEntireSoftLine":
            return L(() => {
              ee.deleteBackward(t, {
                unit: "line"
              }), ee.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: Z
            });
          case "deleteHardLineBackward":
            return L(() => ee.deleteBackward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineBackward":
            return L(() => ee.deleteBackward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteHardLineForward":
            return L(() => ee.deleteForward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineForward":
            return L(() => ee.deleteForward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteWordBackward":
            return L(() => ee.deleteBackward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "deleteWordForward":
            return L(() => ee.deleteForward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "insertLineBreak":
            return L(() => ee.insertSoftBreak(t), {
              at: Z
            });
          case "insertParagraph":
            return L(() => ee.insertBreak(t), {
              at: Z
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (kKe(X))
              return L(() => Le.insertData(t, X), {
                at: Z
              });
            var Ce = X ?? "";
            if (Vs.get(t) && (Ce = Ce.replace("\uFEFF", "")), W === "insertText" && /.*\n.*\n$/.test(Ce) && (Ce = Ce.slice(0, -1)), Ce.includes(`
`))
              return L(() => {
                var ze = Ce.split(`
`);
                ze.forEach((Re, ot) => {
                  Re && ee.insertText(t, Re), ot !== ze.length - 1 && ee.insertSoftBreak(t);
                });
              }, {
                at: Z
              });
            if (ce.equals(Z.anchor.path, Z.focus.path)) {
              var [Qe, lt] = ye.edges(Z), be = {
                start: Qe.offset,
                end: lt.offset,
                text: Ce
              };
              if (Ce && u && W === "insertCompositionText") {
                var Ee = u.start + u.text.search(/\S|$/), Ae = be.start + be.text.search(/\S|$/);
                Ae === Ee + 1 && be.end === u.start + u.text.length ? (be.start -= 1, u = null, N()) : u = !1;
              } else W === "insertText" ? u === null ? u = be : u && ye.isCollapsed(Z) && u.end + u.text.length === Qe.offset ? u = $v($v({}, u), {}, {
                text: u.text + Ce
              }) : u = !1 : u = !1;
              if (P) {
                b(Qe.path, be);
                return;
              }
            }
            return L(() => ee.insertText(t, Ce), {
              at: Z
            });
          }
        }
      }
    }
  }, D = () => !!ql.get(t), x = () => {
    var V;
    return !!((V = Ti.get(t)) !== null && V !== void 0 && V.length);
  }, m = () => D() || x(), C = () => o, S = (V) => {
    Zl.set(t, V), a && (clearTimeout(a), a = null);
    var {
      selection: $
    } = t;
    if (V) {
      var W = !$ || !ce.equals($.anchor.path, V.anchor.path), Z = !$ || !ce.equals($.anchor.path.slice(0, -1), V.anchor.path.slice(0, -1));
      (W && u || Z) && (u = !1), (W || x()) && (a = setTimeout(d, LKe));
    }
  }, U = () => {
    (D() || !x()) && d();
  }, k = (V) => {
    x() || (v(!0), setTimeout(v));
  }, N = () => {
    D() || (s = setTimeout(d));
  }, R = (V) => {
    if (!(x() || D()) && V.some((W) => uj(t, W, V))) {
      var $;
      ($ = Noe.get(t)) === null || $ === void 0 || $();
    }
  };
  return {
    flush: d,
    scheduleFlush: N,
    hasPendingDiffs: x,
    hasPendingAction: D,
    hasPendingChanges: m,
    isFlushing: C,
    handleUserSelect: S,
    handleCompositionEnd: y,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: k,
    handleDomMutations: R,
    handleInput: U
  };
}
function SKe() {
  var e = ht(!1);
  return h(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Eh = dy ? Qie : h;
function MKe(e, t, n) {
  var [r] = E(() => new MutationObserver(t));
  Eh(() => {
    r.takeRecords();
  }), h(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var DKe = ["node"];
function Rq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _Ke(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rq(Object(n), !0).forEach(function(r) {
      Hs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var TKe = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, jKe = Oi ? (e) => {
  var {
    node: t
  } = e, n = yp(e, DKe);
  if (!Oi)
    return null;
  var r = _u(), o = SKe(), [i] = E(() => PKe(_Ke({
    editor: r
  }, n)));
  return MKe(t, i.handleDomMutations, TKe), aj.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, AKe = ["anchor", "focus"], BKe = ["anchor", "focus"], IKe = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), qoe = (e, t) => {
  var n = yp(e, AKe), r = yp(t, BKe);
  return e[bp] === t[bp] && IKe(n, r);
}, RKe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!ye.equals(r, o) || !qoe(r, o))
      return !1;
  }
  return !0;
}, NKe = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !qoe(r, o))
      return !1;
  }
  return !0;
};
function Nq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FKe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nq(Object(n), !0).forEach(function(r) {
      Hs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zKe = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = _u(), a = Le.findPath(i, o), s = ce.parent(a), l = !!n[Foe];
  return i.isVoid(r) ? /* @__PURE__ */ we.createElement(EE, {
    length: et.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && ee.string(i, s) === "" ? /* @__PURE__ */ we.createElement(EE, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ we.createElement(EE, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ we.createElement(Fq, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ we.createElement(Fq, {
    text: n.text
  });
}, Fq = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = ht(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = E(o);
  return Eh(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ we.createElement(UKe, {
    ref: r
  }, i);
}, UKe = /* @__PURE__ */ me(/* @__PURE__ */ ma((e, t) => /* @__PURE__ */ we.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), EE = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ we.createElement("span", FKe({}, o), !(Oi || Boe) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ we.createElement("br", null) : null);
};
function zq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zoe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zq(Object(n), !0).forEach(function(r) {
      Hs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WKe = Oi ? 300 : 0;
function HKe(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function Uq(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var VKe = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (w) => /* @__PURE__ */ we.createElement(qKe, Zoe({}, w))
  } = e, s = _u(), l = ht(null), u = ht(null), [c, p] = E(!1), d = ht(null), y = Jn((w) => {
    if (HKe(l, w == null), w == null) {
      var D;
      wS.delete(s), (D = t.onPlaceholderResize) === null || D === void 0 || D.call(t, null);
    } else {
      if (wS.set(s, w), !l.current) {
        var x = window.ResizeObserver || YXe;
        l.current = new x(() => {
          var m;
          (m = t.onPlaceholderResize) === null || m === void 0 || m.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, s]), f = /* @__PURE__ */ we.createElement(zKe, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), v = !!t[bp];
  if (h(() => (v ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, WKe)) : (Uq(d), p(!1)), () => Uq(d)), [v, p]), v && c) {
    var b = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: oc ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: y
      }
    };
    f = /* @__PURE__ */ we.createElement(we.Fragment, null, i(b), f);
  }
  var L = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: L,
    children: f,
    leaf: t,
    text: r
  });
}, $Ke = /* @__PURE__ */ we.memo(VKe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && ft.equals(t.leaf, e.leaf) && t.leaf[bp] === e.leaf[bp]), qKe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ we.createElement("span", Zoe({}, t), n);
}, ZKe = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = _u(), l = ht(null), u = ft.decorations(a, t), c = Le.findKey(s, a), p = [], d = 0; d < u.length; d++) {
    var y = u[d];
    p.push(/* @__PURE__ */ we.createElement($Ke, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: y,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = Jn((v) => {
    var b = HC.get(s);
    v ? (b == null || b.set(c, v), Ec.set(a, v), Lh.set(v, a)) : (b == null || b.delete(c), Ec.delete(a), l.current && Lh.delete(l.current)), l.current = v;
  }, [l, s, c, a]);
  return /* @__PURE__ */ we.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, Goe = /* @__PURE__ */ we.memo(ZKe, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && NKe(t.decorations, e.decorations));
function Wq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Wq(Object(n), !0).forEach(function(r) {
      Hs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GKe = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ we.createElement(XKe, kS({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = _u(), l = QKe(), u = s.isInline(n), c = Le.findKey(s, n), p = Jn((w) => {
    var D = HC.get(s);
    w ? (D == null || D.set(c, w), Ec.set(n, w), Lh.set(w, n)) : (D == null || D.delete(c), Ec.delete(n));
  }, [s, c, n]), d = Xoe({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), y = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (y["data-slate-inline"] = !0), !u && ee.hasInlines(s, n)) {
    var f = et.string(n), v = xoe(f);
    v === "rtl" && (y.dir = v);
  }
  if (ee.isVoid(s, n)) {
    y["data-slate-void"] = !0, !l && u && (y.contentEditable = !1);
    var b = u ? "span" : "div", [[L]] = et.texts(n);
    d = /* @__PURE__ */ we.createElement(b, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ we.createElement(Goe, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: L
    })), ij.set(L, 0), sj.set(L, n);
  }
  return r({
    attributes: y,
    children: d,
    element: n
  });
}, YKe = /* @__PURE__ */ we.memo(GKe, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && RKe(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && ye.equals(e.selection, t.selection))), XKe = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = _u(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ we.createElement(i, kS(kS({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, Yoe = /* @__PURE__ */ Ve(() => []), KKe = () => ge(Yoe), JKe = /* @__PURE__ */ Ve(!1), Xoe = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = KKe(), l = _u();
  lp.set(l, !1);
  for (var u = Le.findPath(l, n), c = [], p = dt.isElement(n) && !l.isInline(n) && ee.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var y = u.concat(d), f = n.children[d], v = Le.findKey(l, f), b = ee.range(l, y), L = a && ye.intersection(b, a), w = s([f, y]);
    for (var D of t) {
      var x = ye.intersection(D, b);
      x && w.push(x);
    }
    dt.isElement(f) ? c.push(/* @__PURE__ */ we.createElement(JKe.Provider, {
      key: "provider-".concat(v.id),
      value: !!L
    }, /* @__PURE__ */ we.createElement(YKe, {
      decorations: w,
      element: f,
      key: v.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: L
    }))) : c.push(/* @__PURE__ */ we.createElement(Goe, {
      decorations: w,
      key: v.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), ij.set(f, d), sj.set(f, n);
  }
  return c;
}, Koe = /* @__PURE__ */ Ve(!1), QKe = () => ge(Koe), Joe = /* @__PURE__ */ Ve(null), VC = () => {
  var e = ge(Joe);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function eJe() {
  var e = _u(), t = ht(!1), n = ht(0), r = Jn(() => {
    if (!t.current) {
      t.current = !0;
      var o = Le.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return h(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var tJe = 3, nJe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, rJe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, oJe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, oo = (e) => {
  var t = nJe[e], n = rJe[e], r = oJe[e], o = t && vE(t), i = n && vE(n), a = r && vE(r);
  return (s) => !!(o && o(s) || Tq && i && i(s) || !Tq && a && a(s));
}, lo = {
  isBold: oo("bold"),
  isCompose: oo("compose"),
  isMoveBackward: oo("moveBackward"),
  isMoveForward: oo("moveForward"),
  isDeleteBackward: oo("deleteBackward"),
  isDeleteForward: oo("deleteForward"),
  isDeleteLineBackward: oo("deleteLineBackward"),
  isDeleteLineForward: oo("deleteLineForward"),
  isDeleteWordBackward: oo("deleteWordBackward"),
  isDeleteWordForward: oo("deleteWordForward"),
  isExtendBackward: oo("extendBackward"),
  isExtendForward: oo("extendForward"),
  isExtendLineBackward: oo("extendLineBackward"),
  isExtendLineForward: oo("extendLineForward"),
  isItalic: oo("italic"),
  isMoveLineBackward: oo("moveLineBackward"),
  isMoveLineForward: oo("moveLineForward"),
  isMoveWordBackward: oo("moveWordBackward"),
  isMoveWordForward: oo("moveWordForward"),
  isRedo: oo("redo"),
  isSoftBreak: oo("insertSoftBreak"),
  isSplitBlock: oo("splitBlock"),
  isTransposeCharacter: oo("transposeCharacter"),
  isUndo: oo("undo")
}, iJe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => uj(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, sJe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Qoe extends au {
  constructor() {
    super(...arguments), Hs(this, "context", null), Hs(this, "manager", null), Hs(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, sJe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = iJe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Hs(Qoe, "contextType", oj);
var aJe = Oi ? Qoe : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ we.createElement(we.Fragment, null, t);
}, lJe = /* @__PURE__ */ Ve(!1), uJe = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], cJe = ["text"];
function Hq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ea(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Hq(Object(n), !0).forEach(function(r) {
      Hs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Hq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pJe = (e) => /* @__PURE__ */ we.createElement(we.Fragment, null, Xoe(e)), dJe = /* @__PURE__ */ ma((e, t) => {
  var n = Jn((j) => /* @__PURE__ */ we.createElement(fJe, ea({}, j)), []), {
    autoFocus: r,
    decorate: o = hJe,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = gJe,
    style: d = {},
    as: y = "div",
    disableDefaultStyles: f = !1
  } = e, v = yp(e, uJe), b = VC(), [L, w] = E(!1), D = ht(null), x = ht([]), [m, C] = E(), S = ht(!1), {
    onUserInput: U,
    receivedUserInput: k
  } = eJe(), [, N] = Jie((j) => j + 1, 0);
  Noe.set(b, N), CS.set(b, s);
  var R = un(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  h(() => {
    D.current && r && D.current.focus();
  }, [r]);
  var V = ht(), $ = un(() => EXe(() => {
    if (lp.get(b)) {
      $();
      return;
    }
    var j = Le.toDOMNode(b, b), F = j.getRootNode();
    if (!S.current && oc && F instanceof ShadowRoot) {
      S.current = !0;
      var T = fKe();
      T ? document.execCommand("indent") : Fe.deselect(b), S.current = !1;
      return;
    }
    var q = V.current;
    if ((Oi || !Le.isComposing(b)) && (!R.isUpdatingSelection || q != null && q.isFlushing()) && !R.isDraggingInternally) {
      var B = Le.findDocumentOrShadowRoot(b), {
        activeElement: Y
      } = B, I = Le.toDOMNode(b, b), le = Sf(B);
      if (Y === I ? (R.latestElement = Y, ou.set(b, !0)) : ou.delete(b), !le)
        return Fe.deselect(b);
      var {
        anchorNode: he,
        focusNode: oe
      } = le, Be = Le.hasEditableTarget(b, he) || Le.isTargetInsideNonReadonlyVoid(b, he), We = Le.hasTarget(b, oe);
      if (Be && We) {
        var He = Le.toSlateRange(b, le, {
          exactMatch: !1,
          suppressThrow: !0
        });
        He && (!Le.isComposing(b) && !(q != null && q.hasPendingChanges()) && !(q != null && q.isFlushing()) ? Fe.select(b, He) : q == null || q.handleUserSelect(He));
      }
      s && (!Be || !We) && Fe.deselect(b);
    }
  }, 100), [b, s, R]), W = un(() => bXe($, 0), [$]);
  V.current = jKe({
    node: D,
    onDOMSelectionChange: $,
    scheduleOnDOMSelectionChange: W
  }), Eh(() => {
    var j, F, T;
    D.current && (T = lj(D.current)) ? (Roe.set(b, T), fy.set(b, D.current), Ec.set(b, D.current), Lh.set(D.current, b)) : Ec.delete(b);
    var {
      selection: q
    } = b, B = Le.findDocumentOrShadowRoot(b), Y = Sf(B);
    if (!(!Y || !Le.isFocused(b) || (j = V.current) !== null && j !== void 0 && j.hasPendingAction())) {
      var I = (Be) => {
        var We = Y.type !== "None";
        if (!(!q && !We)) {
          var He = Y.focusNode, Ie;
          if (Qc && Y.rangeCount > 1) {
            var nt = Y.getRangeAt(0), $e = Y.getRangeAt(Y.rangeCount - 1);
            nt.startContainer === He ? Ie = $e.endContainer : Ie = nt.startContainer;
          } else
            Ie = Y.anchorNode;
          var Ce = fy.get(b), Qe = !1;
          if (Ce.contains(Ie) && Ce.contains(He) && (Qe = !0), We && Qe && q && !Be) {
            var lt = Le.toSlateRange(b, Y, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (lt && ye.equals(lt, q)) {
              var be;
              if (!R.hasMarkPlaceholder || (be = Ie) !== null && be !== void 0 && (be = be.parentElement) !== null && be !== void 0 && be.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (q && !Le.hasRange(b, q)) {
            b.selection = Le.toSlateRange(b, Y, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          R.isUpdatingSelection = !0;
          var Ee = q && Le.toDOMRange(b, q);
          return Ee ? (Le.isComposing(b) && !Oi ? Y.collapseToEnd() : ye.isBackward(q) ? Y.setBaseAndExtent(Ee.endContainer, Ee.endOffset, Ee.startContainer, Ee.startOffset) : Y.setBaseAndExtent(Ee.startContainer, Ee.startOffset, Ee.endContainer, Ee.endOffset), p(b, Ee)) : Y.removeAllRanges(), Ee;
        }
      };
      Y.rangeCount <= 1 && I();
      var le = ((F = V.current) === null || F === void 0 ? void 0 : F.isFlushing()) === "action";
      if (!Oi || !le) {
        setTimeout(() => {
          R.isUpdatingSelection = !1;
        });
        return;
      }
      var he = null, oe = requestAnimationFrame(() => {
        if (le) {
          var Be = (We) => {
            try {
              var He = Le.toDOMNode(b, b);
              He.focus(), I(We);
            } catch {
            }
          };
          Be(), he = setTimeout(() => {
            Be(!0), R.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), he && clearTimeout(he);
      };
    }
  });
  var Z = Jn((j) => {
    var F = Le.toDOMNode(b, b), T = F.getRootNode();
    if (S != null && S.current && oc && T instanceof ShadowRoot) {
      var q = j.getTargetRanges(), B = q[0], Y = new window.Range();
      Y.setStart(B.startContainer, B.startOffset), Y.setEnd(B.endContainer, B.endOffset);
      var I = Le.toSlateRange(b, Y, {
        exactMatch: !1,
        suppressThrow: !1
      });
      Fe.select(b, I), j.preventDefault(), j.stopImmediatePropagation();
      return;
    }
    if (U(), !s && Le.hasEditableTarget(b, j.target) && !mJe(j, i)) {
      var le;
      if (V.current)
        return V.current.handleDOMBeforeInput(j);
      W.flush(), $.flush();
      var {
        selection: he
      } = b, {
        inputType: oe
      } = j, Be = j.dataTransfer || j.data || void 0, We = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if (We && Le.isComposing(b))
        return;
      var He = !1;
      if (oe === "insertText" && he && ye.isCollapsed(he) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ) to choose a special character otherwise
      // causes duplicate inserts.
      j.data && j.data.length === 1 && /[a-z ]/i.test(j.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      he.anchor.offset !== 0 && (He = !0, b.marks && (He = !1), !lp.get(b))) {
        var Ie, nt, {
          anchor: $e
        } = he, [Ce, Qe] = Le.toDOMPoint(b, $e), lt = (Ie = Ce.parentElement) === null || Ie === void 0 ? void 0 : Ie.closest("a"), be = Le.getWindow(b);
        if (He && lt && Le.hasDOMNode(b, lt)) {
          var Ee, Ae = be == null ? void 0 : be.document.createTreeWalker(lt, NodeFilter.SHOW_TEXT).lastChild();
          Ae === Ce && ((Ee = Ae.textContent) === null || Ee === void 0 ? void 0 : Ee.length) === Qe && (He = !1);
        }
        if (He && Ce.parentElement && (be == null || (nt = be.getComputedStyle(Ce.parentElement)) === null || nt === void 0 ? void 0 : nt.whiteSpace) === "pre") {
          var ze = ee.above(b, {
            at: $e.path,
            match: (st) => dt.isElement(st) && ee.isBlock(b, st)
          });
          ze && et.string(ze[0]).includes("	") && (He = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !lp.get(b)) {
        var [Re] = j.getTargetRanges();
        if (Re) {
          var ot = Le.toSlateRange(b, Re, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!he || !ye.equals(he, ot)) {
            He = !1;
            var ve = !We && b.selection && ee.rangeRef(b, b.selection);
            Fe.select(b, ot), ve && Pf.set(b, ve);
          }
        }
      }
      if (We)
        return;
      if (He || j.preventDefault(), he && ye.isExpanded(he) && oe.startsWith("delete")) {
        var yt = oe.endsWith("Backward") ? "backward" : "forward";
        ee.deleteFragment(b, {
          direction: yt
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          ee.deleteFragment(b);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          ee.deleteForward(b);
          break;
        }
        case "deleteContentBackward": {
          ee.deleteBackward(b);
          break;
        }
        case "deleteEntireSoftLine": {
          ee.deleteBackward(b, {
            unit: "line"
          }), ee.deleteForward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          ee.deleteBackward(b, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          ee.deleteBackward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          ee.deleteForward(b, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          ee.deleteForward(b, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          ee.deleteBackward(b, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          ee.deleteForward(b, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          ee.insertSoftBreak(b);
          break;
        case "insertParagraph": {
          ee.insertBreak(b);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && Le.isComposing(b) && (w(!1), Cc.set(b, !1)), (Be == null ? void 0 : Be.constructor.name) === "DataTransfer" ? Le.insertData(b, Be) : typeof Be == "string" && (He ? x.current.push(() => ee.insertText(b, Be)) : ee.insertText(b, Be));
          break;
        }
      }
      var it = (le = Pf.get(b)) === null || le === void 0 ? void 0 : le.unref();
      Pf.delete(b), it && (!b.selection || !ye.equals(b.selection, it)) && Fe.select(b, it);
    }
  }, [b, $, U, i, s, W]), X = Jn((j) => {
    j == null ? ($.cancel(), W.cancel(), fy.delete(b), Ec.delete(b), D.current && Sl && D.current.removeEventListener("beforeinput", Z)) : Sl && j.addEventListener("beforeinput", Z), D.current = j, typeof t == "function" ? t(j) : t && (t.current = j);
  }, [$, W, b, Z, t]);
  Eh(() => {
    var j = Le.getWindow(b);
    j.document.addEventListener("selectionchange", W);
    var F = () => {
      R.isDraggingInternally = !1;
    };
    return j.document.addEventListener("dragend", F), j.document.addEventListener("drop", F), () => {
      j.document.removeEventListener("selectionchange", W), j.document.removeEventListener("dragend", F), j.document.removeEventListener("drop", F);
    };
  }, [W, R]);
  var K = o([b, []]), Q = a && b.children.length === 1 && Array.from(et.texts(b)).length === 1 && et.string(b) === "" && !L, J = Jn((j) => {
    if (j && Q) {
      var F;
      C((F = j.getBoundingClientRect()) === null || F === void 0 ? void 0 : F.height);
    } else
      C(void 0);
  }, [Q]);
  if (Q) {
    var P = ee.start(b, []);
    K.push({
      [bp]: !0,
      placeholder: a,
      onPlaceholderResize: J,
      anchor: P,
      focus: P
    });
  }
  var {
    marks: _
  } = b;
  if (R.hasMarkPlaceholder = !1, b.selection && ye.isCollapsed(b.selection) && _) {
    var {
      anchor: z
    } = b.selection, M = et.leaf(b, z.path), H = yp(M, cJe);
    if (!ft.equals(M, _, {
      loose: !0
    })) {
      R.hasMarkPlaceholder = !0;
      var O = Object.fromEntries(Object.keys(H).map((j) => [j, null]));
      K.push(ea(ea(ea({
        [Foe]: !0
      }, O), _), {}, {
        anchor: z,
        focus: z
      }));
    }
  }
  return h(() => {
    setTimeout(() => {
      var {
        selection: j
      } = b;
      if (j) {
        var {
          anchor: F
        } = j, T = et.leaf(b, F.path);
        if (_ && !ft.equals(T, _, {
          loose: !0
        })) {
          Vs.set(b, _);
          return;
        }
      }
      Vs.delete(b);
    });
  }), /* @__PURE__ */ we.createElement(Koe.Provider, {
    value: s
  }, /* @__PURE__ */ we.createElement(lJe.Provider, {
    value: L
  }, /* @__PURE__ */ we.createElement(Yoe.Provider, {
    value: o
  }, /* @__PURE__ */ we.createElement(aJe, {
    node: D,
    receivedUserInput: k
  }, /* @__PURE__ */ we.createElement(y, ea(ea({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, v), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Sl || !dy ? v.spellCheck : !1,
    autoCorrect: Sl || !dy ? v.autoCorrect : "false",
    autoCapitalize: Sl || !dy ? v.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: X,
    style: ea(ea({}, f ? {} : ea({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, m ? {
      minHeight: m
    } : {})), d),
    onBeforeInput: Jn((j) => {
      if (!Sl && !s && !Ci(j, v.onBeforeInput) && Le.hasSelectableTarget(b, j.target) && (j.preventDefault(), !Le.isComposing(b))) {
        var F = j.data;
        ee.insertText(b, F);
      }
    }, [v.onBeforeInput, b, s]),
    onInput: Jn((j) => {
      if (!Ci(j, v.onInput)) {
        if (V.current) {
          V.current.handleInput();
          return;
        }
        for (var F of x.current)
          F();
        if (x.current = [], !Le.isFocused(b)) {
          var T = j.nativeEvent, q = b;
          if (T.inputType === "historyUndo" && typeof q.undo == "function") {
            q.undo();
            return;
          }
          if (T.inputType === "historyRedo" && typeof q.redo == "function") {
            q.redo();
            return;
          }
        }
      }
    }, [v.onInput, b]),
    onBlur: Jn((j) => {
      if (!(s || R.isUpdatingSelection || !Le.hasSelectableTarget(b, j.target) || Ci(j, v.onBlur))) {
        var F = Le.findDocumentOrShadowRoot(b);
        if (R.latestElement !== F.activeElement) {
          var {
            relatedTarget: T
          } = j, q = Le.toDOMNode(b, b);
          if (T !== q && !(Ws(T) && T.hasAttribute("data-slate-spacer"))) {
            if (T != null && su(T) && Le.hasDOMNode(b, T)) {
              var B = Le.toSlateNode(b, T);
              if (dt.isElement(B) && !b.isVoid(B))
                return;
            }
            if (oc) {
              var Y = Sf(F);
              Y == null || Y.removeAllRanges();
            }
            ou.delete(b);
          }
        }
      }
    }, [s, R.isUpdatingSelection, R.latestElement, b, v.onBlur]),
    onClick: Jn((j) => {
      if (Le.hasTarget(b, j.target) && !Ci(j, v.onClick) && su(j.target)) {
        var F = Le.toSlateNode(b, j.target), T = Le.findPath(b, F);
        if (!ee.hasPath(b, T) || et.get(b, T) !== F)
          return;
        if (j.detail === tJe && T.length >= 1) {
          var q = T;
          if (!(dt.isElement(F) && ee.isBlock(b, F))) {
            var B, Y = ee.above(b, {
              match: (He) => dt.isElement(He) && ee.isBlock(b, He),
              at: T
            });
            q = (B = Y == null ? void 0 : Y[1]) !== null && B !== void 0 ? B : T.slice(0, 1);
          }
          var I = ee.range(b, q);
          Fe.select(b, I);
          return;
        }
        if (s)
          return;
        var le = ee.start(b, T), he = ee.end(b, T), oe = ee.void(b, {
          at: le
        }), Be = ee.void(b, {
          at: he
        });
        if (oe && Be && ce.equals(oe[1], Be[1])) {
          var We = ee.range(b, le);
          Fe.select(b, We);
        }
      }
    }, [b, v.onClick, s]),
    onCompositionEnd: Jn((j) => {
      if (Le.hasSelectableTarget(b, j.target)) {
        var F;
        if (Le.isComposing(b) && Promise.resolve().then(() => {
          w(!1), Cc.set(b, !1);
        }), (F = V.current) === null || F === void 0 || F.handleCompositionEnd(j), Ci(j, v.onCompositionEnd) || Oi)
          return;
        if (!oc && !nKe && !Boe && !oKe && !rKe && j.data) {
          var T = Vs.get(b);
          Vs.delete(b), T !== void 0 && (Ya.set(b, b.marks), b.marks = T), ee.insertText(b, j.data);
          var q = Ya.get(b);
          Ya.delete(b), q !== void 0 && (b.marks = q);
        }
      }
    }, [v.onCompositionEnd, b]),
    onCompositionUpdate: Jn((j) => {
      Le.hasSelectableTarget(b, j.target) && !Ci(j, v.onCompositionUpdate) && (Le.isComposing(b) || (w(!0), Cc.set(b, !0)));
    }, [v.onCompositionUpdate, b]),
    onCompositionStart: Jn((j) => {
      if (Le.hasSelectableTarget(b, j.target)) {
        var F;
        if ((F = V.current) === null || F === void 0 || F.handleCompositionStart(j), Ci(j, v.onCompositionStart) || Oi)
          return;
        w(!0);
        var {
          selection: T
        } = b;
        if (T && ye.isExpanded(T)) {
          ee.deleteFragment(b);
          return;
        }
      }
    }, [v.onCompositionStart, b]),
    onCopy: Jn((j) => {
      Le.hasSelectableTarget(b, j.target) && !Ci(j, v.onCopy) && !Vq(j) && (j.preventDefault(), Le.setFragmentData(b, j.clipboardData, "copy"));
    }, [v.onCopy, b]),
    onCut: Jn((j) => {
      if (!s && Le.hasSelectableTarget(b, j.target) && !Ci(j, v.onCut) && !Vq(j)) {
        j.preventDefault(), Le.setFragmentData(b, j.clipboardData, "cut");
        var {
          selection: F
        } = b;
        if (F)
          if (ye.isExpanded(F))
            ee.deleteFragment(b);
          else {
            var T = et.parent(b, F.anchor.path);
            ee.isVoid(b, T) && Fe.delete(b);
          }
      }
    }, [s, b, v.onCut]),
    onDragOver: Jn((j) => {
      if (Le.hasTarget(b, j.target) && !Ci(j, v.onDragOver)) {
        var F = Le.toSlateNode(b, j.target);
        dt.isElement(F) && ee.isVoid(b, F) && j.preventDefault();
      }
    }, [v.onDragOver, b]),
    onDragStart: Jn((j) => {
      if (!s && Le.hasTarget(b, j.target) && !Ci(j, v.onDragStart)) {
        var F = Le.toSlateNode(b, j.target), T = Le.findPath(b, F), q = dt.isElement(F) && ee.isVoid(b, F) || ee.void(b, {
          at: T,
          voids: !0
        });
        if (q) {
          var B = ee.range(b, T);
          Fe.select(b, B);
        }
        R.isDraggingInternally = !0, Le.setFragmentData(b, j.dataTransfer, "drag");
      }
    }, [s, b, v.onDragStart, R]),
    onDrop: Jn((j) => {
      if (!s && Le.hasTarget(b, j.target) && !Ci(j, v.onDrop)) {
        j.preventDefault();
        var F = b.selection, T = Le.findEventRange(b, j), q = j.dataTransfer;
        Fe.select(b, T), R.isDraggingInternally && F && !ye.equals(F, T) && !ee.void(b, {
          at: T,
          voids: !0
        }) && Fe.delete(b, {
          at: F
        }), Le.insertData(b, q), Le.isFocused(b) || Le.focus(b);
      }
    }, [s, b, v.onDrop, R]),
    onDragEnd: Jn((j) => {
      !s && R.isDraggingInternally && v.onDragEnd && Le.hasTarget(b, j.target) && v.onDragEnd(j);
    }, [s, R, v, b]),
    onFocus: Jn((j) => {
      if (!s && !R.isUpdatingSelection && Le.hasEditableTarget(b, j.target) && !Ci(j, v.onFocus)) {
        var F = Le.toDOMNode(b, b), T = Le.findDocumentOrShadowRoot(b);
        if (R.latestElement = T.activeElement, Qc && j.target !== F) {
          F.focus();
          return;
        }
        ou.set(b, !0);
      }
    }, [s, R, b, v.onFocus]),
    onKeyDown: Jn((j) => {
      if (!s && Le.hasEditableTarget(b, j.target)) {
        var F;
        (F = V.current) === null || F === void 0 || F.handleKeyDown(j);
        var {
          nativeEvent: T
        } = j;
        if (Le.isComposing(b) && T.isComposing === !1 && (Cc.set(b, !1), w(!1)), Ci(j, v.onKeyDown) || Le.isComposing(b))
          return;
        var {
          selection: q
        } = b, B = b.children[q !== null ? q.focus.path[0] : 0], Y = xoe(et.string(B)) === "rtl";
        if (lo.isRedo(T)) {
          j.preventDefault();
          var I = b;
          typeof I.redo == "function" && I.redo();
          return;
        }
        if (lo.isUndo(T)) {
          j.preventDefault();
          var le = b;
          typeof le.undo == "function" && le.undo();
          return;
        }
        if (lo.isMoveLineBackward(T)) {
          j.preventDefault(), Fe.move(b, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (lo.isMoveLineForward(T)) {
          j.preventDefault(), Fe.move(b, {
            unit: "line"
          });
          return;
        }
        if (lo.isExtendLineBackward(T)) {
          j.preventDefault(), Fe.move(b, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (lo.isExtendLineForward(T)) {
          j.preventDefault(), Fe.move(b, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (lo.isMoveBackward(T)) {
          j.preventDefault(), q && ye.isCollapsed(q) ? Fe.move(b, {
            reverse: !Y
          }) : Fe.collapse(b, {
            edge: Y ? "end" : "start"
          });
          return;
        }
        if (lo.isMoveForward(T)) {
          j.preventDefault(), q && ye.isCollapsed(q) ? Fe.move(b, {
            reverse: Y
          }) : Fe.collapse(b, {
            edge: Y ? "start" : "end"
          });
          return;
        }
        if (lo.isMoveWordBackward(T)) {
          j.preventDefault(), q && ye.isExpanded(q) && Fe.collapse(b, {
            edge: "focus"
          }), Fe.move(b, {
            unit: "word",
            reverse: !Y
          });
          return;
        }
        if (lo.isMoveWordForward(T)) {
          j.preventDefault(), q && ye.isExpanded(q) && Fe.collapse(b, {
            edge: "focus"
          }), Fe.move(b, {
            unit: "word",
            reverse: Y
          });
          return;
        }
        if (Sl) {
          if ((Ioe || oc) && q && (lo.isDeleteBackward(T) || lo.isDeleteForward(T)) && ye.isCollapsed(q)) {
            var he = et.parent(b, q.anchor.path);
            if (dt.isElement(he) && ee.isVoid(b, he) && (ee.isInline(b, he) || ee.isBlock(b, he))) {
              j.preventDefault(), ee.deleteBackward(b, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (lo.isBold(T) || lo.isItalic(T) || lo.isTransposeCharacter(T)) {
            j.preventDefault();
            return;
          }
          if (lo.isSoftBreak(T)) {
            j.preventDefault(), ee.insertSoftBreak(b);
            return;
          }
          if (lo.isSplitBlock(T)) {
            j.preventDefault(), ee.insertBreak(b);
            return;
          }
          if (lo.isDeleteBackward(T)) {
            j.preventDefault(), q && ye.isExpanded(q) ? ee.deleteFragment(b, {
              direction: "backward"
            }) : ee.deleteBackward(b);
            return;
          }
          if (lo.isDeleteForward(T)) {
            j.preventDefault(), q && ye.isExpanded(q) ? ee.deleteFragment(b, {
              direction: "forward"
            }) : ee.deleteForward(b);
            return;
          }
          if (lo.isDeleteLineBackward(T)) {
            j.preventDefault(), q && ye.isExpanded(q) ? ee.deleteFragment(b, {
              direction: "backward"
            }) : ee.deleteBackward(b, {
              unit: "line"
            });
            return;
          }
          if (lo.isDeleteLineForward(T)) {
            j.preventDefault(), q && ye.isExpanded(q) ? ee.deleteFragment(b, {
              direction: "forward"
            }) : ee.deleteForward(b, {
              unit: "line"
            });
            return;
          }
          if (lo.isDeleteWordBackward(T)) {
            j.preventDefault(), q && ye.isExpanded(q) ? ee.deleteFragment(b, {
              direction: "backward"
            }) : ee.deleteBackward(b, {
              unit: "word"
            });
            return;
          }
          if (lo.isDeleteWordForward(T)) {
            j.preventDefault(), q && ye.isExpanded(q) ? ee.deleteFragment(b, {
              direction: "forward"
            }) : ee.deleteForward(b, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, b, v.onKeyDown]),
    onPaste: Jn((j) => {
      !s && Le.hasEditableTarget(b, j.target) && !Ci(j, v.onPaste) && (!Sl || aKe(j.nativeEvent) || oc) && (j.preventDefault(), Le.insertData(b, j.clipboardData));
    }, [s, b, v.onPaste])
  }), /* @__PURE__ */ we.createElement(pJe, {
    decorations: K,
    node: b,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: b.selection
  }))))));
}), fJe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ we.createElement("span", ea({}, t), n, Oi && /* @__PURE__ */ we.createElement("br", null))
  );
}, hJe = () => [], gJe = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && ye.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), SXe(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, Ci = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, Vq = (e) => su(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), mJe = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, vJe = /* @__PURE__ */ Ve(!1), yJe = /* @__PURE__ */ Ve({});
function bJe(e) {
  var t = ht([]).current, n = ht({
    editor: e
  }).current, r = Jn((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = un(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var wJe = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], CJe = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = yp(e, wJe), [l, u] = we.useState(() => {
    if (!et.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Yo.stringify(a)));
    if (!ee.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Yo.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = bJe(t), d = Jn((v) => {
    var b;
    switch (r && r(t.children), v == null || (b = v.operation) === null || b === void 0 ? void 0 : b.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((L) => ({
      v: L.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  h(() => (OS.set(t, d), () => {
    OS.set(t, () => {
    });
  }), [t, d]);
  var [y, f] = E(Le.isFocused(t));
  return h(() => {
    f(Le.isFocused(t));
  }, [t]), Eh(() => {
    var v = () => f(Le.isFocused(t));
    return Aoe >= 17 ? (document.addEventListener("focusin", v), document.addEventListener("focusout", v), () => {
      document.removeEventListener("focusin", v), document.removeEventListener("focusout", v);
    }) : (document.addEventListener("focus", v, !0), document.addEventListener("blur", v, !0), () => {
      document.removeEventListener("focus", v, !0), document.removeEventListener("blur", v, !0);
    });
  }, []), /* @__PURE__ */ we.createElement(yJe.Provider, {
    value: c
  }, /* @__PURE__ */ we.createElement(Joe.Provider, {
    value: l
  }, /* @__PURE__ */ we.createElement(oj.Provider, {
    value: l.editor
  }, /* @__PURE__ */ we.createElement(vJe.Provider, {
    value: y
  }, n))));
}, $q = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, qq = (e, t, n) => {
  var r = Le.toDOMRange(e, t).getBoundingClientRect(), o = Le.toDOMRange(e, n).getBoundingClientRect();
  return $q(r, o) && $q(o, r);
}, OJe = (e, t) => {
  var n = ee.range(e, ye.end(t)), r = Array.from(ee.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (qq(e, ee.range(e, r[o]), n))
    return ee.range(e, r[o], n);
  if (r.length < 2)
    return ee.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    qq(e, ee.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return ee.range(e, r[i], n);
};
function Zq(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Zq(Object(n), !0).forEach(function(r) {
      Hs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Zq(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xJe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return HC.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = aj.get(r)) === null || p === void 0 || p(), !Vs.get(r) && (d = Ti.get(r)) !== null && d !== void 0 && d.length && Vs.set(r, null), Ya.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !Vs.get(r) && (c = Ti.get(r)) !== null && c !== void 0 && c.length && Vs.set(r, null), Ya.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && ye.isCollapsed(r.selection)) {
      var c = ee.above(r, {
        match: (f) => dt.isElement(f) && ee.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = ee.range(r, p, r.selection.anchor), y = OJe(r, d);
        ye.isCollapsed(y) || Fe.delete(r, {
          at: y
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = Ti.get(r);
    if (d != null && d.length) {
      var y = d.map((W) => OKe(W, u)).filter(Boolean);
      Ti.set(r, y);
    }
    var f = Zl.get(r);
    f && Zl.set(r, Bq(r, f, u));
    var v = ql.get(r);
    if (v != null && v.at) {
      var b = $t.isPoint(v == null ? void 0 : v.at) ? ES(r, v.at, u) : Bq(r, v.at, u);
      ql.set(r, b ? Gq(Gq({}, v), {}, {
        at: b
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...Kc(r, u.path));
        break;
      }
      case "set_selection": {
        var L;
        (L = Pf.get(r)) === null || L === void 0 || L.unref(), Pf.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...Kc(r, ce.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ce.previous(u.path);
        c.push(...Kc(r, w));
        break;
      }
      case "move_node": {
        var D = ce.common(ce.parent(u.path), ce.parent(u.newPath));
        c.push(...Kc(r, D));
        var x;
        ce.isBefore(u.path, u.newPath) ? (c.push(...Kc(r, ce.parent(u.path))), x = u.newPath) : (c.push(...Kc(r, ce.parent(u.newPath))), x = u.path);
        var m = et.get(t, ce.parent(x)), C = Le.findKey(r, m), S = ee.pathRef(r, ce.parent(x));
        p.push([S, C]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        lp.set(r, !0);
    }
    for (var [U, k] of c) {
      var [N] = ee.node(r, U);
      _0.set(N, k);
    }
    for (var [R, V] of p) {
      if (R.current) {
        var [$] = ee.node(r, R.current);
        _0.set($, V);
      }
      R.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = ye.edges(c), y = ee.void(r, {
        at: p.path
      }), f = ee.void(r, {
        at: d.path
      });
      if (!(ye.isCollapsed(c) && !y)) {
        var v = Le.toDOMRange(r, c), b = v.cloneContents(), L = b.childNodes[0];
        if (b.childNodes.forEach((N) => {
          N.textContent && N.textContent.trim() !== "" && (L = N);
        }), f) {
          var [w] = f, D = v.cloneRange(), x = Le.toDOMNode(r, w);
          D.setEndAfter(x), b = D.cloneContents();
        }
        if (y && (L = b.querySelector("[data-slate-spacer]")), Array.from(b.querySelectorAll("[data-slate-zero-width]")).forEach((N) => {
          var R = N.getAttribute("data-slate-zero-width") === "n";
          N.textContent = R ? `
` : "";
        }), Uoe(L)) {
          var m = L.ownerDocument.createElement("span");
          m.style.whiteSpace = "pre", m.appendChild(L), b.appendChild(m), L = m;
        }
        var C = r.getFragment(), S = JSON.stringify(C), U = window.btoa(encodeURIComponent(S));
        L.setAttribute("data-slate-fragment", U), u.setData("application/".concat(n), U);
        var k = b.ownerDocument.createElement("div");
        return k.appendChild(b), k.setAttribute("hidden", "true"), b.ownerDocument.body.appendChild(k), u.setData("text/html", k.innerHTML), u.setData("text/plain", Hoe(k)), b.ownerDocument.body.removeChild(k), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || dKe(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var y of p)
        d && Fe.splitNodes(r, {
          always: !0
        }), r.insertText(y), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = Aoe < 18 ? il.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = OS.get(r);
      p && p(u), i(u);
    });
  }, r;
}, Kc = (e, t) => {
  var n = [];
  for (var [r, o] of ee.levels(e, {
    at: t
  })) {
    var i = Le.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function eie(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    ee.nodes(e, {
      at: ee.unhangRange(e, r),
      match: (i) => !ee.isEditor(i) && dt.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const Yq = ["listItem", "numberedList"], hy = ["left", "center", "right", "justify"];
function LJe(e, t) {
  const n = hy.includes(t) ? "align" : "type", r = eie(e, t, n), o = Yq.includes(t);
  Fe.unwrapNodes(e, {
    match: (a) => !ee.isEditor(a) && dt.isElement(a) && Yq.includes(a.type) && !hy.includes(t),
    split: !0
  });
  let i;
  if (hy.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, Fe.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    Fe.wrapNodes(e, a);
  }
}
function Zu({ format: e, icon: t }) {
  const n = VC(), r = hy.includes(e) ? "align" : "type", i = eie(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), LJe(n, e);
  }
  return /* @__PURE__ */ re.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ re.jsx(t, {})
    }
  );
}
function EJe({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ re.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ re.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ re.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ re.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ re.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ re.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ re.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ re.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ re.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const tie = Ve({});
function kJe(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ re.jsx(tie.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ re.jsx(oG, { children: t && /* @__PURE__ */ re.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ re.jsx(
      Df.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ re.jsx(
      Df.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function PJe(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ re.jsx("footer", { className: o.trim(), ...r });
}
function SJe(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(tie), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ re.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ re.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ re.jsx(NS, { size: 24 })
      }
    )
  ] });
}
const PS = Ve({});
function MJe() {
  if (!PS)
    throw new Error("useTabContext must be used within a TabProvider");
  return ge(PS);
}
function DJe(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = E(r || ""), [l, u] = E(!0), c = ht(null), p = `arkynTabContainer ${o || ""}`, [d, y] = E({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (b, L) => {
    const w = b.getBoundingClientRect(), D = c.current.getBoundingClientRect(), x = L ? void 0 : "none";
    u(!1), y({
      transition: x,
      width: `${w.width}px`,
      left: `${w.left - D.left}px`
    });
  };
  h(() => {
    const b = c.current;
    if (!b) return;
    let L = null;
    L = b.querySelector("button.activeTrue"), L && f(L);
  }, []);
  const v = (b) => {
    const L = b.target;
    L && (s(L.value), L.classList.add("activeTrue"), f(L, !0), n && n(L.value));
  };
  return /* @__PURE__ */ re.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ re.jsx(PS.Provider, { value: { handleTabClick: v, showInitialTab: l, value: a }, children: t }),
    /* @__PURE__ */ re.jsx("div", { className: "activeLine", style: d })
  ] });
}
function Xq(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = MJe(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    s(d), r && r(d);
  }
  return /* @__PURE__ */ re.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function _Je(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = e, l = VC(), [u, c] = E(!1), [p, d] = E(""), [y, f] = E("url");
  function v(b) {
    b.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ re.jsxs(re.Fragment, { children: [
    /* @__PURE__ */ re.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ re.jsx(ose, {})
      }
    ),
    /* @__PURE__ */ re.jsxs(
      kJe,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ re.jsx(SJe, { children: s }),
          /* @__PURE__ */ re.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ re.jsxs(DJe, { defaultActive: y, onClick: f, children: [
              /* @__PURE__ */ re.jsx(Xq, { value: "url", children: n[0] }),
              /* @__PURE__ */ re.jsx(Xq, { value: "file", children: n[1] })
            ] }),
            y === "url" && /* @__PURE__ */ re.jsxs(re.Fragment, { children: [
              /* @__PURE__ */ re.jsxs(uq, { children: [
                /* @__PURE__ */ re.jsx(cq, { children: a }),
                /* @__PURE__ */ re.jsx(
                  UC,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (b) => d(b.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ re.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            y === "file" && /* @__PURE__ */ re.jsxs(uq, { children: [
              /* @__PURE__ */ re.jsx(cq, { children: i }),
              /* @__PURE__ */ re.jsx(
                UGe,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (b) => d(b || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ re.jsxs(PJe, { children: [
            /* @__PURE__ */ re.jsx(
              D0,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ re.jsx(D0, { type: "button", onClick: v, children: o })
          ] })
        ]
      }
    )
  ] });
}
function TJe({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ re.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ re.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ re.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ re.jsx("u", { children: t })), /* @__PURE__ */ re.jsx("span", { ...e, children: t });
}
function nie(e, t) {
  const n = ee.marks(e);
  return n ? n[t] === !0 : !1;
}
function rie(e, t) {
  nie(e, t) ? ee.removeMark(e, t) : ee.addMark(e, t, !0);
}
function qv({ format: e, icon: t }) {
  const n = VC(), o = nie(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), rie(n, e);
  }
  return /* @__PURE__ */ re.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ re.jsx(t, {})
    }
  );
}
function jJe({ children: e }) {
  return /* @__PURE__ */ re.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function Kq(e) {
  return e.map((t) => et.string(t)).join("");
}
const Jq = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, Zv = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function tot(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = e, c = un(() => hYe(xJe(tue())), []), { id: p, inputRef: d, error: y } = ts(), f = ht(null);
  function v() {
    try {
      const K = JSON.parse(o);
      return !Array.isArray(K) || K.length <= 0 ? Zv : K.every(
        (J) => typeof J == "object" && J !== null && "type" in J && "children" in J
      ) ? K : Zv;
    } catch {
      return Zv;
    }
  }
  const b = Kq(v()), [L, w] = E(b.length), [D, x] = E(
    JSON.stringify(v()) || "[]"
  ), [m, C] = E(!1), S = d || f, U = u || !!y, k = Jn(TJe, []), N = Jn(EJe, []);
  function R(K) {
    const Q = Kq(K);
    w(Q.length), a && a(Q.length), !(i && Q.length >= s) && (x(JSON.stringify(K)), l && l(K), c.children = K, Fe.setNodes(c, { children: K }));
  }
  const V = m ? "focusTrue" : "focusFalse", W = `arkynRichText ${U || s < L ? "errorTrue" : "errorFalse"} ${V}`, Z = s - L;
  function X(K) {
    return !(n != null && n.includes(K));
  }
  return /* @__PURE__ */ re.jsxs(
    CJe,
    {
      editor: c,
      initialValue: v(),
      onChange: R,
      onValueChange: R,
      children: [
        /* @__PURE__ */ re.jsxs("div", { className: W, children: [
          /* @__PURE__ */ re.jsxs(jJe, { children: [
            X("headingOne") && /* @__PURE__ */ re.jsx(Zu, { format: "headingOne", icon: ise }),
            X("headingTwo") && /* @__PURE__ */ re.jsx(Zu, { format: "headingTwo", icon: sse }),
            X("blockQuote") && /* @__PURE__ */ re.jsx(Zu, { format: "blockQuote", icon: ase }),
            X("bold") && /* @__PURE__ */ re.jsx(qv, { format: "bold", icon: lse }),
            X("italic") && /* @__PURE__ */ re.jsx(qv, { format: "italic", icon: use }),
            X("underline") && /* @__PURE__ */ re.jsx(qv, { format: "underline", icon: cse }),
            X("code") && /* @__PURE__ */ re.jsx(qv, { format: "code", icon: pse }),
            X("left") && /* @__PURE__ */ re.jsx(Zu, { format: "left", icon: dse }),
            X("right") && /* @__PURE__ */ re.jsx(Zu, { format: "right", icon: fse }),
            X("center") && /* @__PURE__ */ re.jsx(Zu, { format: "center", icon: hse }),
            X("justify") && /* @__PURE__ */ re.jsx(Zu, { format: "justify", icon: gse }),
            r && X("image") && /* @__PURE__ */ re.jsx(_Je, { ...r })
          ] }),
          /* @__PURE__ */ re.jsx(
            dJe,
            {
              className: "editorContainer",
              renderElement: N,
              renderLeaf: k,
              spellCheck: !0,
              id: p,
              onFocus: () => C(!0),
              onBlur: () => C(!1),
              onKeyDown: (K) => {
                for (const Q in Jq)
                  if (pYe(Q, K)) {
                    K.preventDefault();
                    const J = Jq[Q];
                    rie(c, J);
                  }
              }
            }
          ),
          Z < 0 && /* @__PURE__ */ re.jsx("div", { className: "restatesCharacters", children: Z })
        ] }),
        /* @__PURE__ */ re.jsx("input", { type: "hidden", ref: S, name: t, value: D }),
        /* @__PURE__ */ re.jsx("input", { type: "hidden", name: `${t}Count`, value: L })
      ]
    }
  );
}
function AJe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: y,
    style: f,
    closeOnSelect: v = !0,
    ...b
  } = e, m = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, S = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: m,
    prefix: RG(s, S, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: y,
    closeOnSelect: v,
    style: f,
    iconSize: S,
    Spinner: /* @__PURE__ */ re.jsx(va, { className: "spinner", size: S, strokeWidth: 2.5 }),
    ...b
  };
}
function not(e) {
  var j;
  const [t, n] = E(""), [r, o] = E(!1), { inputRef: i, id: a, error: s } = ts(), l = ht(null), u = i || l, c = e.isError || !!s, {
    disabled: p,
    title: d,
    style: y,
    className: f,
    prefix: v,
    iconSize: b,
    isLoading: L,
    LeftIcon: w,
    value: D = null,
    defaultValue: x = "",
    onFocus: m,
    onBlur: C,
    Spinner: S,
    name: U,
    placeholder: k,
    onSelect: N,
    options: R,
    optionMaxHeight: V,
    closeOnSelect: $,
    isSearchable: W,
    onSearch: Z,
    ...X
  } = AJe({ ...e, id: a, isError: c }, r), [K, Q] = E(x);
  function J() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function P(F) {
    r || (o(!0), m && m(F));
  }
  function _() {
    o(!1), C && u.current && u.current.blur();
  }
  function z(F) {
    const { label: T, value: q } = F;
    Q(K !== q ? q : ""), N && N({ label: T, value: q }), $ && _();
  }
  const M = typeof D == "string" ? D : K, H = ((j = R.find((F) => F.value === M)) == null ? void 0 : j.label) || "", O = () => {
    if (!r && H) return !0;
    if (!r && !H) return !1;
    if (r && H) return !0;
    if (r && !H) return !1;
  };
  return /* @__PURE__ */ re.jsxs(re.Fragment, { children: [
    /* @__PURE__ */ re.jsxs(
      "section",
      {
        title: d,
        style: y,
        onClick: J,
        className: `${f} placeholder_dark_${O()}`,
        children: [
          v,
          w && /* @__PURE__ */ re.jsx(w, { size: b, strokeWidth: 2.5 }),
          /* @__PURE__ */ re.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: H || k,
              onFocus: P,
              ...X
            }
          ),
          /* @__PURE__ */ re.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: U,
              value: M || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ re.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: V },
              children: [
                W && /* @__PURE__ */ re.jsx(
                  UC,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: eG,
                    onChange: (F) => n(F.target.value)
                  }
                ),
                R.filter((F) => !!(e.onSearch || !e.isSearchable || F.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: F, value: T }) => /* @__PURE__ */ re.jsxs(
                  "div",
                  {
                    onClick: () => z({ label: F, value: T }),
                    className: M === T ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      F,
                      " ",
                      /* @__PURE__ */ re.jsx(RS, {})
                    ]
                  },
                  T
                )),
                R.length <= 0 && /* @__PURE__ */ re.jsx("p", { children: "Sem opes disponveis" })
              ]
            }
          ),
          !L && /* @__PURE__ */ re.jsx(
            Q7,
            {
              className: "arkyn_select_arrow",
              size: b,
              strokeWidth: 2.5
            }
          ),
          L && S
        ]
      }
    ),
    r && /* @__PURE__ */ re.jsx("aside", { className: "arkyn_select_overlay", onClick: _ })
  ] });
}
function rot(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = e, [c, p] = E(n), { id: d, inputRef: y } = ts(), f = typeof r == "boolean" ? r : c;
  function v() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const L = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ re.jsx("button", { type: "button", onClick: v, className: L, ...u, children: /* @__PURE__ */ re.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: a,
      ref: y,
      onClick: v,
      value: f ? o || "checked" : i
    }
  ) });
}
function oot(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = E(!1), { inputRef: y, id: f, error: v } = ts(), b = ht(null), L = y || b, D = e.isError || !!v ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${D} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function S() {
    o || !(L != null && L.current) || (d(!0), L.current.focus());
  }
  function U(N) {
    d(!0), a && a(N);
  }
  function k(N) {
    d(!1), s && s(N);
  }
  return /* @__PURE__ */ re.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: S,
      className: C,
      children: /* @__PURE__ */ re.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: L,
          onFocus: U,
          onBlur: k,
          ...c
        }
      )
    }
  );
}
function iot(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ re.jsx("nav", { className: r, ...n });
}
function sot(e) {
  const { pathname: t } = zS(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ re.jsxs("p", { className: l, children: [
    /* @__PURE__ */ re.jsx(WE, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ re.jsxs(yse, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ re.jsx(WE, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function oie(e = "") {
  const t = zS(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function Qq(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function aot(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = e, u = rG(), { getParam: c, getScopedSearch: p } = oie(t), d = Number(c("page")) || a, y = Number(c("per_page")) || s, f = Math.ceil(n / y), v = d > 1 ? Qq(d - 1 - i, d - 1) : [], b = d < f ? Qq(
    d,
    Math.min(d + i, f)
  ) : [];
  function L(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ re.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ re.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => L(d - 1),
        children: /* @__PURE__ */ re.jsx(mse, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ re.jsxs(re.Fragment, { children: [
      /* @__PURE__ */ re.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => L(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ re.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ re.jsx(xj, {}) })
    ] }),
    v.length > 0 && v.map((w, D) => /* @__PURE__ */ re.jsx(
      "button",
      {
        onClick: () => L(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      D
    )),
    /* @__PURE__ */ re.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    b.length > 0 && b.map((w, D) => /* @__PURE__ */ re.jsx(
      "button",
      {
        onClick: () => L(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      D
    )),
    d + i < f && /* @__PURE__ */ re.jsxs(re.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ re.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ re.jsx(xj, {}) }),
      /* @__PURE__ */ re.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => L(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ re.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => L(d + 1),
        children: /* @__PURE__ */ re.jsx(WE, {})
      }
    )
  ] });
}
const iie = Ve({});
function lot(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ re.jsx(iie.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ re.jsx(oG, { children: t && /* @__PURE__ */ re.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ re.jsx(
      Df.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ re.jsx(
      Df.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function uot(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(iie), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ re.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ re.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ re.jsx(NS, { size: 24 })
      }
    )
  ] });
}
function cot(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [a, s] = E(!1), u = `arkynPopover ${i} ${a ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    a || s(!0);
  }
  return /* @__PURE__ */ re.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ re.jsx(
      Df.div,
      {
        style: { visibility: a ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: a ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    a && /* @__PURE__ */ re.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function pot(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ re.jsx(K7, {});
      case "danger":
        return /* @__PURE__ */ re.jsx(X7, {});
      default:
        return /* @__PURE__ */ re.jsx(Y7, {});
    }
  }
  return /* @__PURE__ */ re.jsxs("div", { className: r, children: [
    /* @__PURE__ */ re.jsxs("div", { children: [
      /* @__PURE__ */ re.jsx("div", { className: "bg" }),
      /* @__PURE__ */ re.jsx(o, {})
    ] }),
    /* @__PURE__ */ re.jsx("p", { children: /* @__PURE__ */ re.jsx("span", { children: t }) })
  ] });
}
var zo = {}, cj = {}, Og = {}, xg = {}, sie = "Expected a function", eZ = NaN, BJe = "[object Symbol]", IJe = /^\s+|\s+$/g, RJe = /^[-+]0x[0-9a-f]+$/i, NJe = /^0b[01]+$/i, FJe = /^0o[0-7]+$/i, zJe = parseInt, UJe = typeof hr == "object" && hr && hr.Object === Object && hr, WJe = typeof self == "object" && self && self.Object === Object && self, HJe = UJe || WJe || Function("return this")(), VJe = Object.prototype, $Je = VJe.toString, qJe = Math.max, ZJe = Math.min, kE = function() {
  return HJe.Date.now();
};
function GJe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(sie);
  t = tZ(t) || 0, T0(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? qJe(tZ(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, U = o;
    return r = o = void 0, u = C, a = e.apply(U, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(L, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, U = C - u, k = t - S;
    return p ? ZJe(k, i - U) : k;
  }
  function b(C) {
    var S = C - l, U = C - u;
    return l === void 0 || S >= t || S < 0 || p && U >= i;
  }
  function L() {
    var C = kE();
    if (b(C))
      return w(C);
    s = setTimeout(L, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(kE());
  }
  function m() {
    var C = kE(), S = b(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(L, t), y(l);
    }
    return s === void 0 && (s = setTimeout(L, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function YJe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(sie);
  return T0(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), GJe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function T0(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function XJe(e) {
  return !!e && typeof e == "object";
}
function KJe(e) {
  return typeof e == "symbol" || XJe(e) && $Je.call(e) == BJe;
}
function tZ(e) {
  if (typeof e == "number")
    return e;
  if (KJe(e))
    return eZ;
  if (T0(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = T0(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(IJe, "");
  var n = NJe.test(e);
  return n || FJe.test(e) ? zJe(e.slice(2), n ? 2 : 8) : RJe.test(e) ? eZ : +e;
}
var JJe = YJe, Lg = {};
Object.defineProperty(Lg, "__esModule", {
  value: !0
});
Lg.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), gy.has(n) || gy.set(n, /* @__PURE__ */ new Set());
  var i = gy.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
Lg.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), gy.get(n).delete(r.name || n);
};
var gy = /* @__PURE__ */ new Map();
Object.defineProperty(xg, "__esModule", {
  value: !0
});
var QJe = JJe, eQe = nQe(QJe), tQe = Lg;
function nQe(e) {
  return e && e.__esModule ? e : { default: e };
}
var rQe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, eQe.default)(t, n);
}, vo = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = rQe(function(o) {
        vo.scrollHandler(t);
      }, n);
      vo.scrollSpyContainers.push(t), (0, tQe.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return vo.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = vo.scrollSpyContainers[vo.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(vo.currentPositionX(t), vo.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    vo.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = vo.scrollSpyContainers[vo.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(vo.currentPositionX(n), vo.currentPositionY(n));
  },
  updateStates: function() {
    vo.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    vo.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), vo.spySetState && vo.spySetState.length && vo.spySetState.indexOf(t) > -1 && vo.spySetState.splice(vo.spySetState.indexOf(t), 1), document.removeEventListener("scroll", vo.scrollHandler);
  },
  update: function() {
    return vo.scrollSpyContainers.forEach(function(t) {
      return vo.scrollHandler(t);
    });
  }
};
xg.default = vo;
var Wp = {}, Eg = {};
Object.defineProperty(Eg, "__esModule", {
  value: !0
});
var oQe = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, iQe = function() {
  return window.location.hash.replace(/^#/, "");
}, sQe = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, aQe = function(t) {
  return getComputedStyle(t).position !== "static";
}, PE = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, lQe = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (aQe(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = PE(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return PE(n, l).offsetTop - PE(t, l).offsetTop;
};
Eg.default = {
  updateHash: oQe,
  getHash: iQe,
  filterElementInContainer: sQe,
  scrollOffset: lQe
};
var $C = {}, pj = {};
Object.defineProperty(pj, "__esModule", {
  value: !0
});
pj.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var dj = {};
Object.defineProperty(dj, "__esModule", {
  value: !0
});
var uQe = Lg, cQe = ["mousedown", "mousewheel", "touchmove", "keydown"];
dj.default = {
  subscribe: function(t) {
    return typeof document < "u" && cQe.forEach(function(n) {
      return (0, uQe.addPassiveEventListener)(document, n, t);
    });
  }
};
var kg = {};
Object.defineProperty(kg, "__esModule", {
  value: !0
});
var SS = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      SS.registered[t] = n;
    },
    remove: function(t) {
      SS.registered[t] = null;
    }
  }
};
kg.default = SS;
Object.defineProperty($C, "__esModule", {
  value: !0
});
var pQe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, dQe = Eg;
qC(dQe);
var fQe = pj, nZ = qC(fQe), hQe = dj, gQe = qC(hQe), mQe = kg, la = qC(mQe);
function qC(e) {
  return e && e.__esModule ? e : { default: e };
}
var aie = function(t) {
  return nZ.default[t.smooth] || nZ.default.defaultEasing;
}, vQe = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, yQe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, MS = function() {
  return yQe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), lie = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, uie = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, cie = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, bQe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, wQe = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, CQe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    la.default.registered.end && la.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    MS.call(window, i);
    return;
  }
  la.default.registered.end && la.default.registered.end(o.to, o.target, o.currentPosition);
}, fj = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, Pg = function(t, n, r, o) {
  n.data = n.data || lie(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (gQe.default.subscribe(i), fj(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? uie(n) : cie(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    la.default.registered.end && la.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = vQe(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = aie(n), s = CQe.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      la.default.registered.begin && la.default.registered.begin(n.data.to, n.data.target), MS.call(window, s);
    }, n.delay);
    return;
  }
  la.default.registered.begin && la.default.registered.begin(n.data.to, n.data.target), MS.call(window, s);
}, ZC = function(t) {
  return t = pQe({}, t), t.data = t.data || lie(), t.absolute = !0, t;
}, OQe = function(t) {
  Pg(0, ZC(t));
}, xQe = function(t, n) {
  Pg(t, ZC(n));
}, LQe = function(t) {
  t = ZC(t), fj(t), Pg(t.horizontal ? bQe(t) : wQe(t), t);
}, EQe = function(t, n) {
  n = ZC(n), fj(n);
  var r = n.horizontal ? uie(n) : cie(n);
  Pg(t + r, n);
};
$C.default = {
  animateTopScroll: Pg,
  getAnimationType: aie,
  scrollToTop: OQe,
  scrollToBottom: LQe,
  scrollTo: xQe,
  scrollMore: EQe
};
Object.defineProperty(Wp, "__esModule", {
  value: !0
});
var kQe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, PQe = Eg, SQe = hj(PQe), MQe = $C, DQe = hj(MQe), _Qe = kg, Gv = hj(_Qe);
function hj(e) {
  return e && e.__esModule ? e : { default: e };
}
var Yv = {}, rZ = void 0;
Wp.default = {
  unmount: function() {
    Yv = {};
  },
  register: function(t, n) {
    Yv[t] = n;
  },
  unregister: function(t) {
    delete Yv[t];
  },
  get: function(t) {
    return Yv[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return rZ = t;
  },
  getActiveLink: function() {
    return rZ;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = kQe({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = SQe.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      Gv.default.registered.begin && Gv.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, Gv.default.registered.end && Gv.default.registered.end(t, r);
      return;
    }
    DQe.default.animateTopScroll(l, n, t, r);
  }
};
var DS = { exports: {} }, Xv = { exports: {} }, Xn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oZ;
function TQe() {
  if (oZ) return Xn;
  oZ = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Xn.AsyncMode = l, Xn.ConcurrentMode = u, Xn.ContextConsumer = s, Xn.ContextProvider = a, Xn.Element = t, Xn.ForwardRef = c, Xn.Fragment = r, Xn.Lazy = f, Xn.Memo = y, Xn.Portal = n, Xn.Profiler = i, Xn.StrictMode = o, Xn.Suspense = p, Xn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Xn.isConcurrentMode = x, Xn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Xn.isContextProvider = function(m) {
    return D(m) === a;
  }, Xn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Xn.isForwardRef = function(m) {
    return D(m) === c;
  }, Xn.isFragment = function(m) {
    return D(m) === r;
  }, Xn.isLazy = function(m) {
    return D(m) === f;
  }, Xn.isMemo = function(m) {
    return D(m) === y;
  }, Xn.isPortal = function(m) {
    return D(m) === n;
  }, Xn.isProfiler = function(m) {
    return D(m) === i;
  }, Xn.isStrictMode = function(m) {
    return D(m) === o;
  }, Xn.isSuspense = function(m) {
    return D(m) === p;
  }, Xn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === b || m.$$typeof === L || m.$$typeof === w || m.$$typeof === v);
  }, Xn.typeOf = D, Xn;
}
var Kn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iZ;
function jQe() {
  return iZ || (iZ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, b = e ? Symbol.for("react.fundamental") : 60117, L = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(I) {
      return typeof I == "string" || typeof I == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      I === r || I === u || I === i || I === o || I === p || I === d || typeof I == "object" && I !== null && (I.$$typeof === f || I.$$typeof === y || I.$$typeof === a || I.$$typeof === s || I.$$typeof === c || I.$$typeof === b || I.$$typeof === L || I.$$typeof === w || I.$$typeof === v);
    }
    function x(I) {
      if (typeof I == "object" && I !== null) {
        var le = I.$$typeof;
        switch (le) {
          case t:
            var he = I.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return he;
              default:
                var oe = he && he.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return le;
                }
            }
          case n:
            return le;
        }
      }
    }
    var m = l, C = u, S = s, U = a, k = t, N = c, R = r, V = f, $ = y, W = n, Z = i, X = o, K = p, Q = !1;
    function J(I) {
      return Q || (Q = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), P(I) || x(I) === l;
    }
    function P(I) {
      return x(I) === u;
    }
    function _(I) {
      return x(I) === s;
    }
    function z(I) {
      return x(I) === a;
    }
    function M(I) {
      return typeof I == "object" && I !== null && I.$$typeof === t;
    }
    function H(I) {
      return x(I) === c;
    }
    function O(I) {
      return x(I) === r;
    }
    function j(I) {
      return x(I) === f;
    }
    function F(I) {
      return x(I) === y;
    }
    function T(I) {
      return x(I) === n;
    }
    function q(I) {
      return x(I) === i;
    }
    function B(I) {
      return x(I) === o;
    }
    function Y(I) {
      return x(I) === p;
    }
    Kn.AsyncMode = m, Kn.ConcurrentMode = C, Kn.ContextConsumer = S, Kn.ContextProvider = U, Kn.Element = k, Kn.ForwardRef = N, Kn.Fragment = R, Kn.Lazy = V, Kn.Memo = $, Kn.Portal = W, Kn.Profiler = Z, Kn.StrictMode = X, Kn.Suspense = K, Kn.isAsyncMode = J, Kn.isConcurrentMode = P, Kn.isContextConsumer = _, Kn.isContextProvider = z, Kn.isElement = M, Kn.isForwardRef = H, Kn.isFragment = O, Kn.isLazy = j, Kn.isMemo = F, Kn.isPortal = T, Kn.isProfiler = q, Kn.isStrictMode = B, Kn.isSuspense = Y, Kn.isValidElementType = D, Kn.typeOf = x;
  }()), Kn;
}
var sZ;
function pie() {
  return sZ || (sZ = 1, process.env.NODE_ENV === "production" ? Xv.exports = TQe() : Xv.exports = jQe()), Xv.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var SE, aZ;
function AQe() {
  if (aZ) return SE;
  aZ = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return SE = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, SE;
}
var ME, lZ;
function gj() {
  if (lZ) return ME;
  lZ = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ME = e, ME;
}
var DE, uZ;
function die() {
  return uZ || (uZ = 1, DE = Function.call.bind(Object.prototype.hasOwnProperty)), DE;
}
var _E, cZ;
function BQe() {
  if (cZ) return _E;
  cZ = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = gj(), n = {}, r = die();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, _E = o, _E;
}
var TE, pZ;
function IQe() {
  if (pZ) return TE;
  pZ = 1;
  var e = pie(), t = AQe(), n = gj(), r = die(), o = BQe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return TE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(P) {
      var _ = P && (u && P[u] || P[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: L("array"),
      bigint: L("bigint"),
      bool: L("boolean"),
      func: L("function"),
      number: L("number"),
      object: L("object"),
      string: L("string"),
      symbol: L("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: N(),
      objectOf: U,
      oneOf: S,
      oneOfType: k,
      shape: V,
      exact: $
    };
    function f(P, _) {
      return P === _ ? P !== 0 || 1 / P === 1 / _ : P !== P && _ !== _;
    }
    function v(P, _) {
      this.message = P, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function b(P) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, z = 0;
      function M(O, j, F, T, q, B, Y) {
        if (T = T || d, B = B || F, Y !== n) {
          if (l) {
            var I = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw I.name = "Invariant Violation", I;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var le = T + ":" + F;
            !_[le] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[le] = !0, z++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + q + " `" + B + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + q + " `" + B + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : P(j, F, T, q, B);
      }
      var H = M.bind(null, !1);
      return H.isRequired = M.bind(null, !0), H;
    }
    function L(P) {
      function _(z, M, H, O, j, F) {
        var T = z[M], q = X(T);
        if (q !== P) {
          var B = K(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + B + "` supplied to `" + H + "`, expected ") + ("`" + P + "`."),
            { expectedType: P }
          );
        }
        return null;
      }
      return b(_);
    }
    function w() {
      return b(a);
    }
    function D(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside arrayOf.");
        var F = z[M];
        if (!Array.isArray(F)) {
          var T = X(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an array."));
        }
        for (var q = 0; q < F.length; q++) {
          var B = P(F, q, H, O, j + "[" + q + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return b(_);
    }
    function x() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!s(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(P);
    }
    function m() {
      function P(_, z, M, H, O) {
        var j = _[z];
        if (!e.isValidElementType(j)) {
          var F = X(j);
          return new v("Invalid " + H + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(P);
    }
    function C(P) {
      function _(z, M, H, O, j) {
        if (!(z[M] instanceof P)) {
          var F = P.name || d, T = J(z[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return b(_);
    }
    function S(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(z, M, H, O, j) {
        for (var F = z[M], T = 0; T < P.length; T++)
          if (f(F, P[T]))
            return null;
        var q = JSON.stringify(P, function(Y, I) {
          var le = K(I);
          return le === "symbol" ? String(I) : I;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + H + "`, expected one of " + q + "."));
      }
      return b(_);
    }
    function U(P) {
      function _(z, M, H, O, j) {
        if (typeof P != "function")
          return new v("Property `" + j + "` of component `" + H + "` has invalid PropType notation inside objectOf.");
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + H + "`, expected an object."));
        for (var q in F)
          if (r(F, q)) {
            var B = P(F, q, H, O, j + "." + q, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return b(_);
    }
    function k(P) {
      if (!Array.isArray(P))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < P.length; _++) {
        var z = P[_];
        if (typeof z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Q(z) + " at index " + _ + "."
          ), a;
      }
      function M(H, O, j, F, T) {
        for (var q = [], B = 0; B < P.length; B++) {
          var Y = P[B], I = Y(H, O, j, F, T, n);
          if (I == null)
            return null;
          I.data && r(I.data, "expectedType") && q.push(I.data.expectedType);
        }
        var le = q.length > 0 ? ", expected one of type [" + q.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + le + "."));
      }
      return b(M);
    }
    function N() {
      function P(_, z, M, H, O) {
        return W(_[z]) ? null : new v("Invalid " + H + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return b(P);
    }
    function R(P, _, z, M, H) {
      return new v(
        (P || "React class") + ": " + _ + " type `" + z + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + H + "`."
      );
    }
    function V(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        for (var q in P) {
          var B = P[q];
          if (typeof B != "function")
            return R(H, O, j, q, K(B));
          var Y = B(F, q, H, O, j + "." + q, n);
          if (Y)
            return Y;
        }
        return null;
      }
      return b(_);
    }
    function $(P) {
      function _(z, M, H, O, j) {
        var F = z[M], T = X(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + H + "`, expected `object`."));
        var q = t({}, z[M], P);
        for (var B in q) {
          var Y = P[B];
          if (r(P, B) && typeof Y != "function")
            return R(H, O, j, B, K(Y));
          if (!Y)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + B + "` supplied to `" + H + "`.\nBad object: " + JSON.stringify(z[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(P), null, "  ")
            );
          var I = Y(F, B, H, O, j + "." + B, n);
          if (I)
            return I;
        }
        return null;
      }
      return b(_);
    }
    function W(P) {
      switch (typeof P) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !P;
        case "object":
          if (Array.isArray(P))
            return P.every(W);
          if (P === null || s(P))
            return !0;
          var _ = p(P);
          if (_) {
            var z = _.call(P), M;
            if (_ !== P.entries) {
              for (; !(M = z.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = z.next()).done; ) {
                var H = M.value;
                if (H && !W(H[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(P, _) {
      return P === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function X(P) {
      var _ = typeof P;
      return Array.isArray(P) ? "array" : P instanceof RegExp ? "object" : Z(_, P) ? "symbol" : _;
    }
    function K(P) {
      if (typeof P > "u" || P === null)
        return "" + P;
      var _ = X(P);
      if (_ === "object") {
        if (P instanceof Date)
          return "date";
        if (P instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function Q(P) {
      var _ = K(P);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(P) {
      return !P.constructor || !P.constructor.name ? d : P.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, TE;
}
var jE, dZ;
function RQe() {
  if (dZ) return jE;
  dZ = 1;
  var e = gj();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, jE = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, jE;
}
if (process.env.NODE_ENV !== "production") {
  var NQe = pie(), FQe = !0;
  DS.exports = IQe()(NQe.isElement, FQe);
} else
  DS.exports = RQe()();
var GC = DS.exports, YC = {};
Object.defineProperty(YC, "__esModule", {
  value: !0
});
var zQe = Eg, AE = UQe(zQe);
function UQe(e) {
  return e && e.__esModule ? e : { default: e };
}
var WQe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return AE.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && AE.default.getHash() !== t && AE.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
YC.default = WQe;
Object.defineProperty(Og, "__esModule", {
  value: !0
});
var Kv = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, HQe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), VQe = we, fZ = Sg(VQe), $Qe = xg, Jv = Sg($Qe), qQe = Wp, ZQe = Sg(qQe), GQe = GC, io = Sg(GQe), YQe = YC, Ml = Sg(YQe);
function Sg(e) {
  return e && e.__esModule ? e : { default: e };
}
function XQe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KQe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function JQe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var hZ = {
  to: io.default.string.isRequired,
  containerId: io.default.string,
  container: io.default.object,
  activeClass: io.default.string,
  activeStyle: io.default.object,
  spy: io.default.bool,
  horizontal: io.default.bool,
  smooth: io.default.oneOfType([io.default.bool, io.default.string]),
  offset: io.default.number,
  delay: io.default.number,
  isDynamic: io.default.bool,
  onClick: io.default.func,
  duration: io.default.oneOfType([io.default.number, io.default.func]),
  absolute: io.default.bool,
  onSetActive: io.default.func,
  onSetInactive: io.default.func,
  ignoreCancelEvents: io.default.bool,
  hashSpy: io.default.bool,
  saveHashHistory: io.default.bool,
  spyThrottle: io.default.number
};
Og.default = function(e, t) {
  var n = t || ZQe.default, r = function(i) {
    JQe(a, i);
    function a(s) {
      XQe(this, a);
      var l = KQe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return HQe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          Jv.default.isMounted(l) || Jv.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (Ml.default.isMounted() || Ml.default.mount(n), Ml.default.mapContainer(this.props.to, l)), Jv.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Jv.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = Kv({}, this.props.style, this.props.activeStyle) : u = Kv({}, this.props.style);
        var c = Kv({}, this.props);
        for (var p in hZ)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, fZ.default.createElement(e, c);
      }
    }]), a;
  }(fZ.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, Kv({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(Ml.default.isMounted() && !Ml.default.isInitialized())) {
        var c = a.props.horizontal, p = a.props.to, d = null, y = void 0, f = void 0;
        if (c) {
          var v = 0, b = 0, L = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            L = w.left;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var D = d.getBoundingClientRect();
            v = D.left - L + s, b = v + D.width;
          }
          var x = s - a.props.offset;
          y = x >= Math.floor(v) && x < Math.floor(b), f = x < Math.floor(v) || x >= Math.floor(b);
        } else {
          var m = 0, C = 0, S = 0;
          if (u.getBoundingClientRect) {
            var U = u.getBoundingClientRect();
            S = U.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var k = d.getBoundingClientRect();
            m = k.top - S + l, C = m + k.height;
          }
          var N = l - a.props.offset;
          y = N >= Math.floor(m) && N < Math.floor(C), f = N < Math.floor(m) || N >= Math.floor(C);
        }
        var R = n.getActiveLink();
        if (f) {
          if (p === R && n.setActiveLink(void 0), a.props.hashSpy && Ml.default.getHash() === p) {
            var V = a.props.saveHashHistory, $ = V === void 0 ? !1 : V;
            Ml.default.changeHash("", $);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(p, d));
        }
        if (y && (R !== p || a.state.active === !1)) {
          n.setActiveLink(p);
          var W = a.props.saveHashHistory, Z = W === void 0 ? !1 : W;
          a.props.hashSpy && Ml.default.changeHash(p, Z), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = hZ, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(cj, "__esModule", {
  value: !0
});
var QQe = we, gZ = fie(QQe), eet = Og, tet = fie(eet);
function fie(e) {
  return e && e.__esModule ? e : { default: e };
}
function net(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function mZ(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ret(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var oet = function(e) {
  ret(t, e);
  function t() {
    var n, r, o, i;
    net(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = mZ(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return gZ.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), mZ(o, i);
  }
  return t;
}(gZ.default.Component);
cj.default = (0, tet.default)(oet);
var mj = {};
Object.defineProperty(mj, "__esModule", {
  value: !0
});
var iet = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), set = we, vZ = hie(set), aet = Og, uet = hie(aet);
function hie(e) {
  return e && e.__esModule ? e : { default: e };
}
function cet(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function pet(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function det(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fet = function(e) {
  det(t, e);
  function t() {
    return cet(this, t), pet(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return iet(t, [{
    key: "render",
    value: function() {
      return vZ.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(vZ.default.Component);
mj.default = (0, uet.default)(fet);
var vj = {}, XC = {};
Object.defineProperty(XC, "__esModule", {
  value: !0
});
var het = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, get = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), met = we, yZ = KC(met), vet = il;
KC(vet);
var yet = Wp, bZ = KC(yet), bet = GC, wZ = KC(bet);
function KC(e) {
  return e && e.__esModule ? e : { default: e };
}
function wet(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Cet(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Oet(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
XC.default = function(e) {
  var t = function(n) {
    Oet(r, n);
    function r(o) {
      wet(this, r);
      var i = Cet(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return get(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        bZ.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        bZ.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return yZ.default.createElement(e, het({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(yZ.default.Component);
  return t.propTypes = {
    name: wZ.default.string,
    id: wZ.default.string
  }, t;
};
Object.defineProperty(vj, "__esModule", {
  value: !0
});
var CZ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, xet = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Let = we, OZ = yj(Let), Eet = XC, ket = yj(Eet), Pet = GC, xZ = yj(Pet);
function yj(e) {
  return e && e.__esModule ? e : { default: e };
}
function Met(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Det(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function _et(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var gie = function(e) {
  _et(t, e);
  function t() {
    return Met(this, t), Det(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return xet(t, [{
    key: "render",
    value: function() {
      var r = this, o = CZ({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, OZ.default.createElement(
        "div",
        CZ({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(OZ.default.Component);
gie.propTypes = {
  name: xZ.default.string,
  id: xZ.default.string
};
vj.default = (0, ket.default)(gie);
var BE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, LZ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function EZ(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kZ(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function PZ(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Qv = we, Gu = xg, IE = Wp, Eo = GC, Dl = YC, SZ = {
  to: Eo.string.isRequired,
  containerId: Eo.string,
  container: Eo.object,
  activeClass: Eo.string,
  spy: Eo.bool,
  smooth: Eo.oneOfType([Eo.bool, Eo.string]),
  offset: Eo.number,
  delay: Eo.number,
  isDynamic: Eo.bool,
  onClick: Eo.func,
  duration: Eo.oneOfType([Eo.number, Eo.func]),
  absolute: Eo.bool,
  onSetActive: Eo.func,
  onSetInactive: Eo.func,
  ignoreCancelEvents: Eo.bool,
  hashSpy: Eo.bool,
  spyThrottle: Eo.number
}, Tet = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || IE, o = function(a) {
      PZ(s, a);
      function s(l) {
        EZ(this, s);
        var u = kZ(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return LZ(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Gu.isMounted(u) || Gu.mount(u, this.props.spyThrottle), this.props.hashSpy && (Dl.isMounted() || Dl.mount(r), Dl.mapContainer(this.props.to, u)), this.props.spy && Gu.addStateHandler(this.stateHandler), Gu.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Gu.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = BE({}, this.props);
          for (var p in SZ)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, Qv.createElement(t, c);
        }
      }]), s;
    }(Qv.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, BE({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(Dl.isMounted() && !Dl.isInitialized())) {
          var c = s.props.to, p = null, d = 0, y = 0, f = 0;
          if (u.getBoundingClientRect) {
            var v = u.getBoundingClientRect();
            f = v.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var b = p.getBoundingClientRect();
            d = b.top - f + l, y = d + b.height;
          }
          var L = l - s.props.offset, w = L >= Math.floor(d) && L < Math.floor(y), D = L < Math.floor(d) || L >= Math.floor(y), x = r.getActiveLink();
          if (D)
            return c === x && r.setActiveLink(void 0), s.props.hashSpy && Dl.getHash() === c && Dl.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), Gu.updateStates();
          if (w && x !== c)
            return r.setActiveLink(c), s.props.hashSpy && Dl.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), Gu.updateStates();
        }
      };
    };
    return o.propTypes = SZ, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      PZ(o, r);
      function o(i) {
        EZ(this, o);
        var a = kZ(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return LZ(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          IE.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          IE.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Qv.createElement(t, BE({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(Qv.Component);
    return n.propTypes = {
      name: Eo.string,
      id: Eo.string
    }, n;
  }
}, jet = Tet;
Object.defineProperty(zo, "__esModule", {
  value: !0
});
zo.Helpers = zo.ScrollElement = zo.ScrollLink = kie = zo.animateScroll = zo.scrollSpy = zo.Events = zo.scroller = zo.Element = zo.Button = zo.Link = void 0;
var Aet = cj, mie = Ea(Aet), Bet = mj, vie = Ea(Bet), Iet = vj, yie = Ea(Iet), Ret = Wp, bie = Ea(Ret), Net = kg, wie = Ea(Net), Fet = xg, Cie = Ea(Fet), zet = $C, Oie = Ea(zet), Uet = Og, xie = Ea(Uet), Wet = XC, Lie = Ea(Wet), Het = jet, Eie = Ea(Het);
function Ea(e) {
  return e && e.__esModule ? e : { default: e };
}
zo.Link = mie.default;
zo.Button = vie.default;
zo.Element = yie.default;
zo.scroller = bie.default;
zo.Events = wie.default;
zo.scrollSpy = Cie.default;
var kie = zo.animateScroll = Oie.default;
zo.ScrollLink = xie.default;
zo.ScrollElement = Lie.default;
zo.Helpers = Eie.default;
zo.default = { Link: mie.default, Button: vie.default, Element: yie.default, scroller: bie.default, Events: wie.default, scrollSpy: Cie.default, animateScroll: Oie.default, ScrollLink: xie.default, ScrollElement: Lie.default, Helpers: Eie.default };
const bj = Ve({}), Pie = Ve({});
function Vet() {
  const e = ge(Pie);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function MZ(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function dot() {
  const e = FS(), { closeModal: t, closeAll: n } = ge(bj), { showToast: r } = Vet(), { getParam: o } = oie(), { pathname: i } = zS(), a = rG(), s = o("closeAllModals");
  h(() => {
    s === "true" && (n(), a(i));
  }, [s]), h(() => {
    const l = e == null ? void 0 : e.closeModalKey;
    l && t(l);
  }, [e]), h(() => {
    const l = e == null ? void 0 : e.closeAllModals;
    typeof l == "boolean" && l && n();
  }, [e]), h(() => {
    const l = e == null ? void 0 : e.toast, u = e == null ? void 0 : e.message;
    MZ(l) && r(l), !MZ(l) && u && r({ message: u, type: "danger" });
  }, [e]), h(() => {
    var l, u;
    if (typeof ((l = e == null ? void 0 : e.data) == null ? void 0 : l.scrollTo) == "string") {
      const c = document.getElementById((u = e == null ? void 0 : e.data) == null ? void 0 : u.scrollTo);
      c && kie.scrollTo(c.offsetTop - 200);
    }
  }, [e]);
}
const Sie = Ve({});
function fot(e) {
  const t = ge(Sie);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function $et() {
  return () => {
  };
}
function qet() {
  return ese(
    $et,
    () => !0,
    () => !1
  );
}
function hot(e) {
  const t = ge(bj);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function got(e) {
  const { children: t = !1 } = e, [n, r] = E([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((y) => y.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ re.jsx(
    Sie.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function kh(e) {
  "@babel/helpers - typeof";
  return kh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, kh(e);
}
function Zet(e, t) {
  if (kh(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (kh(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Get(e) {
  var t = Zet(e, "string");
  return kh(t) == "symbol" ? t : t + "";
}
function xe(e, t, n) {
  return (t = Get(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Mie(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var RE, DZ;
function Yet() {
  if (DZ) return RE;
  DZ = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, a, s, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, a, s, l, u, c], y = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[y++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return RE = t, RE;
}
var Xet = Yet(), Go = /* @__PURE__ */ Mie(Xet), It = Ve(null);
function Ket() {
  Go(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(It);
  return Go(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Jet(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function Qet(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function ett(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Qet(e, i), o;
}
function ttt(e, t, n) {
  var r = Jet(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function ntt(e) {
  google.maps.event.removeListener(e);
}
function cn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(ntt);
}
function Qt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = ttt(o, i, n);
  return ett(t, r, o, i), a;
}
var _Z = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, TZ = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function rtt(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: b,
    onRightClick: L,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = E(null), S = ht(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null), [B, Y] = E(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && b && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(m, "mouseup", b)));
  }, [b]), h(() => {
    m && L && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", L)));
  }, [L]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (B !== null && google.maps.event.removeListener(B), Y(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var I = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(I), I !== null && D && D(I), () => {
      I !== null && x && x(I);
    };
  }, []), re.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: re.jsx(It.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
me(rtt);
let ott = class extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      map: null
    }), xe(this, "registeredEvents", []), xe(this, "mapRef", null), xe(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), xe(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), xe(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), xe(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = Qt({
      updaterMap: TZ,
      eventMap: _Z,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: TZ,
      eventMap: _Z,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), cn(this.registeredEvents));
  }
  render() {
    return re.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: re.jsx(It.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function jZ(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Die(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        jZ(i, r, o, a, s, "next", l);
      }
      function s(l) {
        jZ(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function _ie(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Go(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Oc = typeof document < "u";
function Tie(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return Oc ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(y) {
          p && p(y), a(y);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), a(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function AZ(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function jie() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return AZ(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return AZ(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var Dd = !1;
function Aie() {
  return re.jsx("div", {
    children: "Loading..."
  });
}
var _S = {
  id: "script-loader",
  version: "weekly"
};
class Bie extends pe {
  constructor() {
    super(...arguments), xe(this, "check", zn()), xe(this, "state", {
      loaded: !1
    }), xe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), xe(this, "isCleaningUp", /* @__PURE__ */ Die(function* () {
      function t(n) {
        if (!Dd)
          n();
        else if (Oc)
          var r = window.setInterval(function() {
            Dd || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), xe(this, "cleanup", () => {
      Dd = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), xe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && jie(), Go(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: _ie(this.props)
      };
      Tie(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (Oc) {
      if (window.google && window.google.maps && !Dd) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Oc && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Oc) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Dd = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return re.jsxs(re.Fragment, {
      children: [re.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || re.jsx(Aie, {})]
    });
  }
}
xe(Bie, "defaultProps", _S);
function itt(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function wj(e, t) {
  if (e == null) return {};
  var n, r, o = itt(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var BZ;
function stt(e) {
  var {
    id: t = _S.id,
    version: n = _S.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = ht(!1), [f, v] = E(!1), [b, L] = E(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    Oc && u && jie();
  }, [u]), h(function() {
    f && Go(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = _ie({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!Oc)
      return;
    function m() {
      y.current && (v(!0), BZ = w);
    }
    if (window.google && window.google.maps && BZ === w) {
      m();
      return;
    }
    Tie({
      id: t,
      url: w,
      nonce: r
    }).then(m).catch(function(S) {
      y.current && L(S), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(S);
    });
  }, [t, w, r]);
  var D = ht();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: b,
    url: w
  };
}
var att = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], ltt = re.jsx(Aie, {});
function utt(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = wj(e, att), {
    isLoaded: s,
    loadError: l
  } = stt(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || ltt;
}
me(utt);
var IZ;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(IZ || (IZ = {}));
function RZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function j0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RZ(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NZ = {}, FZ = {
  options(e, t) {
    e.setOptions(t);
  }
};
function ctt(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(It), [i, a] = E(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(j0(j0({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
me(ctt);
class ptt extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      trafficLayer: null
    }), xe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(j0(j0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: FZ,
      eventMap: NZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: FZ,
      eventMap: NZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), cn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(ptt, "contextType", It);
function dtt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(It), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
me(dtt);
class ftt extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      bicyclingLayer: null
    }), xe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(ftt, "contextType", It);
function htt(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(It), [o, i] = E(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
me(htt);
class gtt extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      transitLayer: null
    }), xe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(gtt, "contextType", It);
function zZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function A0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zZ(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var UZ = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, WZ = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function mtt(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(It), [d, y] = E(null), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Go(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(A0(A0({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && v(google.maps.event.addListener(N, "circlecomplete", r)), o && L(google.maps.event.addListener(N, "markercomplete", o)), i && D(google.maps.event.addListener(N, "overlaycomplete", i)), a && m(google.maps.event.addListener(N, "polygoncomplete", a)), s && S(google.maps.event.addListener(N, "polylinecomplete", s)), l && k(google.maps.event.addListener(N, "rectanglecomplete", l)), y(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), b && google.maps.event.removeListener(b), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
me(mtt);
class vtt extends pe {
  constructor(t) {
    super(t), xe(this, "registeredEvents", []), xe(this, "state", {
      drawingManager: null
    }), xe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Go(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(A0(A0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: WZ,
      eventMap: UZ,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: WZ,
      eventMap: UZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), cn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
xe(vtt, "contextType", It);
function HZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function up(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HZ(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var VZ = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, $Z = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, B0 = {};
function ytt(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: b,
    onClick: L,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: U,
    onMouseDown: k,
    onRightClick: N,
    onClickableChanged: R,
    onCursorChanged: V,
    onAnimationChanged: $,
    onDraggableChanged: W,
    onFlatChanged: Z,
    onIconChanged: X,
    onPositionChanged: K,
    onShapeChanged: Q,
    onTitleChanged: J,
    onVisibleChanged: P,
    onZindexChanged: _,
    onLoad: z,
    onUnmount: M
  } = e, H = ge(It), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null), [oe, Be] = E(null), [We, He] = E(null), [Ie, nt] = E(null), [$e, Ce] = E(null), [Qe, lt] = E(null), [be, Ee] = E(null), [Ae, ze] = E(null), [Re, ot] = E(null), [ve, yt] = E(null), [it, st] = E(null), [ut, bt] = E(null), [ct, wt] = E(null), [tt, gt] = E(null), [rt, Ct] = E(null), [pt, Et] = E(null), [Ot, kt] = E(null), [xt, Pt] = E(null);
  h(() => {
    O !== null && O.setMap(H);
  }, [H]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && b !== void 0 && O.setZIndex(b);
  }, [O, b]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && k && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(O, "mousedown", k)));
  }, [k]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Be(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (We !== null && google.maps.event.removeListener(We), He(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && U && (Ie !== null && google.maps.event.removeListener(Ie), nt(google.maps.event.addListener(O, "mouseup", U)));
  }, [U]), h(() => {
    O && N && ($e !== null && google.maps.event.removeListener($e), Ce(google.maps.event.addListener(O, "rightclick", N)));
  }, [N]), h(() => {
    O && L && (Qe !== null && google.maps.event.removeListener(Qe), lt(google.maps.event.addListener(O, "click", L)));
  }, [L]), h(() => {
    O && D && (be !== null && google.maps.event.removeListener(be), Ee(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && R && (Ae !== null && google.maps.event.removeListener(Ae), ze(google.maps.event.addListener(O, "clickable_changed", R)));
  }, [R]), h(() => {
    O && V && (Re !== null && google.maps.event.removeListener(Re), ot(google.maps.event.addListener(O, "cursor_changed", V)));
  }, [V]), h(() => {
    O && $ && (ve !== null && google.maps.event.removeListener(ve), yt(google.maps.event.addListener(O, "animation_changed", $)));
  }, [$]), h(() => {
    O && W && (it !== null && google.maps.event.removeListener(it), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && Z && (ut !== null && google.maps.event.removeListener(ut), bt(google.maps.event.addListener(O, "flat_changed", Z)));
  }, [Z]), h(() => {
    O && X && (ct !== null && google.maps.event.removeListener(ct), wt(google.maps.event.addListener(O, "icon_changed", X)));
  }, [X]), h(() => {
    O && K && (tt !== null && google.maps.event.removeListener(tt), gt(google.maps.event.addListener(O, "position_changed", K)));
  }, [K]), h(() => {
    O && Q && (rt !== null && google.maps.event.removeListener(rt), Ct(google.maps.event.addListener(O, "shape_changed", Q)));
  }, [Q]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Et(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && P && (Ot !== null && google.maps.event.removeListener(Ot), kt(google.maps.event.addListener(O, "visible_changed", P)));
  }, [P]), h(() => {
    O && _ && (xt !== null && google.maps.event.removeListener(xt), Pt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var mt = up(up(up({}, n || B0), r ? B0 : {
      map: H
    }), {}, {
      position: t
    }), ne = new google.maps.Marker(mt);
    return r ? r.addMarker(ne, !!o) : ne.setMap(H), t && ne.setPosition(t), typeof s < "u" && ne.setVisible(s), typeof a < "u" && ne.setDraggable(a), typeof u < "u" && ne.setClickable(u), typeof c == "string" && ne.setCursor(c), p && ne.setIcon(p), typeof d < "u" && ne.setLabel(d), typeof y < "u" && ne.setOpacity(y), f && ne.setShape(f), typeof v == "string" && ne.setTitle(v), typeof b == "number" && ne.setZIndex(b), w && T(google.maps.event.addListener(ne, "dblclick", w)), x && B(google.maps.event.addListener(ne, "dragend", x)), m && I(google.maps.event.addListener(ne, "dragstart", m)), k && he(google.maps.event.addListener(ne, "mousedown", k)), C && Be(google.maps.event.addListener(ne, "mouseout", C)), S && He(google.maps.event.addListener(ne, "mouseover", S)), U && nt(google.maps.event.addListener(ne, "mouseup", U)), N && Ce(google.maps.event.addListener(ne, "rightclick", N)), L && lt(google.maps.event.addListener(ne, "click", L)), D && Ee(google.maps.event.addListener(ne, "drag", D)), R && ze(google.maps.event.addListener(ne, "clickable_changed", R)), V && ot(google.maps.event.addListener(ne, "cursor_changed", V)), $ && yt(google.maps.event.addListener(ne, "animation_changed", $)), W && st(google.maps.event.addListener(ne, "draggable_changed", W)), Z && bt(google.maps.event.addListener(ne, "flat_changed", Z)), X && wt(google.maps.event.addListener(ne, "icon_changed", X)), K && gt(google.maps.event.addListener(ne, "position_changed", K)), Q && Ct(google.maps.event.addListener(ne, "shape_changed", Q)), J && Et(google.maps.event.addListener(ne, "title_changed", J)), P && kt(google.maps.event.addListener(ne, "visible_changed", P)), _ && Pt(google.maps.event.addListener(ne, "zindex_changed", _)), j(ne), z && z(ne), () => {
      F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), oe !== null && google.maps.event.removeListener(oe), We !== null && google.maps.event.removeListener(We), Ie !== null && google.maps.event.removeListener(Ie), $e !== null && google.maps.event.removeListener($e), Qe !== null && google.maps.event.removeListener(Qe), Ae !== null && google.maps.event.removeListener(Ae), Re !== null && google.maps.event.removeListener(Re), ve !== null && google.maps.event.removeListener(ve), it !== null && google.maps.event.removeListener(it), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), tt !== null && google.maps.event.removeListener(tt), pt !== null && google.maps.event.removeListener(pt), Ot !== null && google.maps.event.removeListener(Ot), xt !== null && google.maps.event.removeListener(xt), M && M(ne), r ? r.removeMarker(ne, !!o) : ne && ne.setMap(null);
    };
  }, []);
  var Vt = un(() => i ? at.map(i, (mt) => {
    if (!di(mt))
      return mt;
    var ne = mt;
    return fi(ne, {
      anchor: O
    });
  }) : null, [i, O]);
  return re.jsx(re.Fragment, {
    children: Vt
  }) || null;
}
me(ytt);
class Iie extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Die(function* () {
      var n = up(up(up({}, t.props.options || B0), t.props.clusterer ? B0 : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Qt({
        updaterMap: $Z,
        eventMap: VZ,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: $Z,
      eventMap: VZ,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), cn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? at.map(this.props.children, (n) => {
      if (!di(n))
        return n;
      var r = n;
      return fi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
xe(Iie, "contextType", It);
var btt = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), wtt = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new btt(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Ctt(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Ott = 2e3, xtt = 500, Ltt = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Ett = "png", ktt = [53, 56, 66, 78, 90], Ptt = "cluster", Rie = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Ltt, this.imageExtension = r.imageExtension || Ett, this.imageSizes = r.imageSizes || ktt, this.calculator = r.calculator || Ctt, this.batchSize = r.batchSize || Ott, this.batchSizeIE = r.batchSizeIE || xtt, this.clusterClass = r.clusterClass || Ptt, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new wtt(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function qZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Stt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qZ(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Us = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Fn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Mtt = {};
function Dtt(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: b,
    zoomOnClick: L,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: U
  } = e, [k, N] = E(null), R = ge(It), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null);
  return h(() => {
    k && C && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(k, Us.onMouseOut, C)));
  }, [C]), h(() => {
    k && m && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(k, Us.onMouseOver, m)));
  }, [m]), h(() => {
    k && w && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(k, Us.onClick, w)));
  }, [w]), h(() => {
    k && D && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(k, Us.onClusteringBegin, D)));
  }, [D]), h(() => {
    k && x && (X !== null && google.maps.event.removeListener(X), Z(google.maps.event.addListener(k, Us.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && k !== null && Fn.averageCenter(k, r);
  }, [k, r]), h(() => {
    typeof o < "u" && k !== null && Fn.batchSizeIE(k, o);
  }, [k, o]), h(() => {
    typeof i < "u" && k !== null && Fn.calculator(k, i);
  }, [k, i]), h(() => {
    typeof a < "u" && k !== null && Fn.clusterClass(k, a);
  }, [k, a]), h(() => {
    typeof s < "u" && k !== null && Fn.enableRetinaIcons(k, s);
  }, [k, s]), h(() => {
    typeof l < "u" && k !== null && Fn.gridSize(k, l);
  }, [k, l]), h(() => {
    typeof u < "u" && k !== null && Fn.ignoreHidden(k, u);
  }, [k, u]), h(() => {
    typeof c < "u" && k !== null && Fn.imageExtension(k, c);
  }, [k, c]), h(() => {
    typeof p < "u" && k !== null && Fn.imagePath(k, p);
  }, [k, p]), h(() => {
    typeof d < "u" && k !== null && Fn.imageSizes(k, d);
  }, [k, d]), h(() => {
    typeof y < "u" && k !== null && Fn.maxZoom(k, y);
  }, [k, y]), h(() => {
    typeof f < "u" && k !== null && Fn.minimumClusterSize(k, f);
  }, [k, f]), h(() => {
    typeof v < "u" && k !== null && Fn.styles(k, v);
  }, [k, v]), h(() => {
    typeof b < "u" && k !== null && Fn.title(k, b);
  }, [k, b]), h(() => {
    typeof L < "u" && k !== null && Fn.zoomOnClick(k, L);
  }, [k, L]), h(() => {
    if (R) {
      var z = Stt({}, n || Mtt), M = new Rie(R, [], z);
      return r && Fn.averageCenter(M, r), o && Fn.batchSizeIE(M, o), i && Fn.calculator(M, i), a && Fn.clusterClass(M, a), s && Fn.enableRetinaIcons(M, s), l && Fn.gridSize(M, l), u && Fn.ignoreHidden(M, u), c && Fn.imageExtension(M, c), p && Fn.imagePath(M, p), d && Fn.imageSizes(M, d), y && Fn.maxZoom(M, y), f && Fn.minimumClusterSize(M, f), v && Fn.styles(M, v), b && Fn.title(M, b), L && Fn.zoomOnClick(M, L), C && J(google.maps.event.addListener(M, Us.onMouseOut, C)), m && _(google.maps.event.addListener(M, Us.onMouseOver, m)), w && $(google.maps.event.addListener(M, Us.onClick, w)), D && Z(google.maps.event.addListener(M, Us.onClusteringBegin, D)), x && K(google.maps.event.addListener(M, Us.onClusteringEnd, x)), N(M), S && S(M), () => {
        Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), U && U(M);
      };
    }
  }, []), k !== null && t(k) || null;
}
me(Dtt);
class _tt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      markerClusterer: null
    }), xe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Rie(this.context, [], this.props.options);
      this.registeredEvents = Qt({
        updaterMap: Fn,
        eventMap: Us,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: Fn,
      eventMap: Us,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), cn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
xe(_tt, "contextType", It);
function ZZ(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Nie = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || ZZ(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, ZZ));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), b = v.fromLatLngToContainerPixel(this.position);
          b !== null && (b.x < -u + y ? r = b.x + u - y : b.x + p + u + y > s && (r = b.x + p + u + y - s), this.alignBottom ? b.y < -c + f + d ? o = b.y + c - f - d : b.y + c + f > l && (o = b.y + c + f - l) : b.y < -c + f ? o = b.y + c - f : b.y + d + c + f > l && (o = b.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Ttt = ["position"], jtt = ["position"];
function GZ(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function I0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GZ(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GZ(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YZ = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, XZ = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Att = {};
function Btt(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(It), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var R = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(R);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var R = r || Att, {
        position: V
      } = R, $ = wj(R, Ttt), W;
      V && !(V instanceof google.maps.LatLng) && (W = new google.maps.LatLng(V.lat, V.lng));
      var Z = new Nie(I0(I0({}, $), W ? {
        position: W
      } : {}));
      N.current = document.createElement("div"), v(Z), a && L(google.maps.event.addListener(Z, "closeclick", a)), s && D(google.maps.event.addListener(Z, "domready", s)), l && m(google.maps.event.addListener(Z, "content_changed", l)), u && S(google.maps.event.addListener(Z, "position_changed", u)), c && k(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(y, n) : Z.getPosition() ? Z.open(y) : Go(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(Btt);
class Itt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", null), xe(this, "state", {
      infoBox: null
    }), xe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Go(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), xe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = wj(t, jtt), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Nie(I0(I0({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Qt({
      updaterMap: XZ,
      eventMap: YZ,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: XZ,
      eventMap: YZ,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), cn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
xe(Itt, "contextType", It);
var NE, KZ;
function Rtt() {
  return KZ || (KZ = 1, NE = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), NE;
}
var Ntt = Rtt(), JZ = /* @__PURE__ */ Mie(Ntt), QZ = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], FE = 1, _d = 8;
class Cj {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== FE)
      throw new Error("Got v".concat(o, " data when expected v").concat(FE, "."));
    var i = QZ[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Cj(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = QZ.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, _d, t), this.coords = new this.ArrayType(this.data, _d + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(_d + a + s + l), this.ids = new this.IndexArrayType(this.data, _d, t), this.coords = new this.ArrayType(this.data, _d + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (FE << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return TS(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var b = d + p >> 1, L = a[2 * b], w = a[2 * b + 1];
      L >= t && L <= r && w >= n && w <= o && u.push(i[b]), (c === 0 ? t <= L : n <= w) && (l.push(d), l.push(b - 1), l.push(1 - c)), (c === 0 ? r >= L : o >= w) && (l.push(b + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          e7(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], b = i[2 * f + 1];
      e7(v, b, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= b) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= b) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function TS(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Fie(e, t, a, r, o, i), TS(e, t, n, r, a - 1, 1 - i), TS(e, t, n, a + 1, o, 1 - i);
  }
}
function Fie(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Fie(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Td(e, t, r, n), t[2 * o + i] > y && Td(e, t, r, o); f < v; ) {
      for (Td(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Td(e, t, r, v) : (v++, Td(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Td(e, t, n, r) {
  zE(e, n, r), zE(t, 2 * n, 2 * r), zE(t, 2 * n + 1, 2 * r + 1);
}
function zE(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function e7(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Ftt = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, t7 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Yu = 2, Gl = 3, UE = 4, Nl = 5, zie = 6;
class ztt {
  constructor(t) {
    this.options = Object.assign(Object.create(Ftt), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = t7(ey(u)), d = t7(ty(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(ey(r), ty(a), ey(i), ty(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Nl] > 1 ? n7(p, f, this.clusterProps) : this.points[p[f + Gl]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + UE] === t && p.push(a[y + Nl] > 1 ? n7(a, y, this.clusterProps) : this.points[a[y + Gl]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Cj(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Nl] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Uie(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Gl]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = ey(f), d = ty(v);
      }
      var b = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, L = void 0;
      u || this.options.generateId ? L = n[l + Gl] : L = this.points[n[l + Gl]].id, L !== void 0 && (b.id = L), a.features.push(b);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Yu] <= n)) {
        l[p + Yu] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Nl], b = v;
        for (var L of f) {
          var w = L * c;
          l[w + Yu] > n && (b += l[w + Nl]);
        }
        if (b > v && b >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var k = U * c;
            if (!(l[k + Yu] <= n)) {
              l[k + Yu] = n;
              var N = l[k + Nl];
              D += l[k] * N, x += l[k + 1] * N, l[k + UE] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, k)));
            }
          }
          l[p + UE] = S, u.push(D / b, x / b, 1 / 0, S, -1, b), i && u.push(C);
        } else {
          for (var R = 0; R < c; R++) u.push(l[p + R]);
          if (b > 1)
            for (var V of f) {
              var $ = V * c;
              if (!(l[$ + Yu] <= n)) {
                l[$ + Yu] = n;
                for (var W = 0; W < c; W++) u.push(l[$ + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Nl] > 1) {
      var o = this.clusterProps[t[n + zie]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Gl]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function n7(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Gl],
    properties: Uie(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Utt(e[t]), Wtt(e[t + 1])]
    }
  };
}
function Uie(e, t, n) {
  var r = e[t + Nl], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + zie], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Gl],
    point_count: r,
    point_count_abbreviated: o
  });
}
function ey(e) {
  return e / 360 + 0.5;
}
function ty(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Utt(e) {
  return (e - 0.5) * 360;
}
function Wtt(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Htt(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ms {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class jS {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(ms.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ms.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ms.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Vtt {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return $tt(n);
  }
}
var $tt = (e) => {
  var t = e.map((n) => new jS({
    position: ms.getPosition(n),
    markers: [n]
  }));
  return t;
};
class qtt extends Vtt {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Htt(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new ztt(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!JZ(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = ms.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !JZ(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new jS({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new jS({
      markers: [i],
      position: ms.getPosition(i)
    });
  }
}
class Ztt {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Gtt {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (ms.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function Ytt(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Oj {
  constructor() {
    Ytt(Oj, google.maps.OverlayView);
  }
}
var Mf;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Mf || (Mf = {}));
var Xtt = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Ktt extends Oj {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new qtt(o),
      renderer: a = new Gtt(),
      onClusterClick: s = Xtt
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ms.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Mf.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ms.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => ms.setMap(l, null)));
      }
      google.maps.event.trigger(this, Mf.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ms.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Ztt(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ms.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Mf.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ms.setMap(r.marker, n);
    });
  }
}
function r7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Jtt(e) {
  var t = Ket(), [n, r] = E(null);
  return h(() => {
    if (t && n === null) {
      var o = new Ktt(o7(o7({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Qtt(e) {
  var {
    children: t,
    options: n
  } = e, r = Jtt(n);
  return r !== null ? t(r) : null;
}
me(Qtt);
var i7 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, s7 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function ent(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(It), [f, v] = E(null), [b, L] = E(null), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), N = ht(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (b !== null && google.maps.event.removeListener(b), L(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var R = new google.maps.InfoWindow(r);
    return v(R), N.current = document.createElement("div"), a && L(google.maps.event.addListener(R, "closeclick", a)), s && D(google.maps.event.addListener(R, "domready", s)), l && m(google.maps.event.addListener(R, "content_changed", l)), u && S(google.maps.event.addListener(R, "position_changed", u)), c && k(google.maps.event.addListener(R, "zindex_changed", c)), R.setContent(N.current), o && R.setPosition(o), i && R.setZIndex(i), n ? R.open(y, n) : R.getPosition() ? R.open(y) : Go(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(R), () => {
      b && google.maps.event.removeListener(b), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), d && d(R), R.close();
    };
  }, []), N.current ? Un(at.only(t), N.current) : null;
}
me(ent);
class tnt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", null), xe(this, "state", {
      infoWindow: null
    }), xe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Go(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), xe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Qt({
      updaterMap: s7,
      eventMap: i7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: s7,
      eventMap: i7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (cn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? Un(at.only(this.props.children), this.containerElement) : null;
  }
}
xe(tnt, "contextType", It);
function a7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function R0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, u7 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, nnt = {};
function rnt(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onLoad: L,
    onUnmount: w
  } = e, D = ge(It), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && b && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", b)));
  }, [b]), h(() => {
    var T = new google.maps.Polyline(R0(R0({}, t || nnt), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && k(google.maps.event.addListener(T, "dragend", s)), l && R(google.maps.event.addListener(T, "dragstart", l)), u && $(google.maps.event.addListener(T, "mousedown", u)), c && Z(google.maps.event.addListener(T, "mousemove", c)), p && K(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), b && F(google.maps.event.addListener(T, "drag", b)), m(T), L && L(T), () => {
      C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), w && w(T), T.setMap(null);
    };
  }, []), null;
}
me(rnt);
class ont extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      polyline: null
    }), xe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(R0(R0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: u7,
      eventMap: l7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: u7,
      eventMap: l7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), cn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
xe(ont, "contextType", It);
function c7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function p7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var d7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, f7 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function int(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(It), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof b == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", b)));
  }, [b]), h(() => {
    C && typeof L == "function" && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(C, "drag", L)));
  }, [L]), h(() => {
    var B = new google.maps.Polygon(p7(p7({}, t), {}, {
      map: m
    }));
    return i && B.setPath(i), a && B.setPaths(a), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && k(google.maps.event.addListener(B, "dblclick", s)), l && R(google.maps.event.addListener(B, "dragend", l)), u && $(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && K(google.maps.event.addListener(B, "mousemove", p)), d && J(google.maps.event.addListener(B, "mouseout", d)), y && _(google.maps.event.addListener(B, "mouseover", y)), f && M(google.maps.event.addListener(B, "mouseup", f)), v && O(google.maps.event.addListener(B, "rightclick", v)), b && F(google.maps.event.addListener(B, "click", b)), L && q(google.maps.event.addListener(B, "drag", L)), S(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), D && D(B), B.setMap(null);
    };
  }, []), null;
}
me(int);
class snt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Qt({
      updaterMap: f7,
      eventMap: d7,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: f7,
      eventMap: d7,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), cn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
xe(snt, "contextType", It);
function h7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? h7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : h7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var g7 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, m7 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function ant(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: b,
    onBoundsChanged: L,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(It), [m, C] = E(null), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), U(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", b)));
  }, [b]), h(() => {
    m && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(m, "bounds_changed", L)));
  }, [L]), h(() => {
    var Y = new google.maps.Rectangle(N0(N0({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && Y.setVisible(i), typeof o < "u" && Y.setEditable(o), typeof r < "u" && Y.setDraggable(r), typeof n < "u" && Y.setBounds(n), a && U(google.maps.event.addListener(Y, "dblclick", a)), s && N(google.maps.event.addListener(Y, "dragend", s)), l && V(google.maps.event.addListener(Y, "dragstart", l)), u && W(google.maps.event.addListener(Y, "mousedown", u)), c && X(google.maps.event.addListener(Y, "mousemove", c)), p && Q(google.maps.event.addListener(Y, "mouseout", p)), d && P(google.maps.event.addListener(Y, "mouseover", d)), y && z(google.maps.event.addListener(Y, "mouseup", y)), f && H(google.maps.event.addListener(Y, "rightclick", f)), v && j(google.maps.event.addListener(Y, "click", v)), b && T(google.maps.event.addListener(Y, "drag", b)), L && B(google.maps.event.addListener(Y, "bounds_changed", L)), C(Y), w && w(Y), () => {
      S !== null && google.maps.event.removeListener(S), k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), q !== null && google.maps.event.removeListener(q), D && D(Y), Y.setMap(null);
    };
  }, []), null;
}
me(ant);
class lnt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      rectangle: null
    }), xe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(N0(N0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: m7,
      eventMap: g7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: m7,
      eventMap: g7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), cn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
xe(lnt, "contextType", It);
function v7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function F0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? v7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : v7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var y7 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, b7 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, unt = {};
function cnt(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: b,
    onDrag: L,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(It), [S, U] = E(null), [k, N] = E(null), [R, V] = E(null), [$, W] = E(null), [Z, X] = E(null), [K, Q] = E(null), [J, P] = E(null), [_, z] = E(null), [M, H] = E(null), [O, j] = E(null), [F, T] = E(null), [q, B] = E(null), [Y, I] = E(null), [le, he] = E(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (k !== null && google.maps.event.removeListener(k), N(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (Z !== null && google.maps.event.removeListener(Z), X(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (K !== null && google.maps.event.removeListener(K), Q(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), P(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), z(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), H(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && b && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", b)));
  }, [b]), h(() => {
    S && L && (q !== null && google.maps.event.removeListener(q), B(google.maps.event.addListener(S, "drag", L)));
  }, [L]), h(() => {
    S && w && (Y !== null && google.maps.event.removeListener(Y), I(google.maps.event.addListener(S, "center_changed", w)));
  }, [b]), h(() => {
    S && D && (le !== null && google.maps.event.removeListener(le), he(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(F0(F0({}, t || unt), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && N(google.maps.event.addListener(oe, "dblclick", s)), l && V(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && X(google.maps.event.addListener(oe, "mousedown", c)), p && Q(google.maps.event.addListener(oe, "mousemove", p)), d && P(google.maps.event.addListener(oe, "mouseout", d)), y && z(google.maps.event.addListener(oe, "mouseover", y)), f && H(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), b && T(google.maps.event.addListener(oe, "click", b)), L && B(google.maps.event.addListener(oe, "drag", L)), w && I(google.maps.event.addListener(oe, "center_changed", w)), D && he(google.maps.event.addListener(oe, "radius_changed", D)), U(oe), x && x(oe), () => {
      k !== null && google.maps.event.removeListener(k), R !== null && google.maps.event.removeListener(R), $ !== null && google.maps.event.removeListener($), Z !== null && google.maps.event.removeListener(Z), K !== null && google.maps.event.removeListener(K), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), le !== null && google.maps.event.removeListener(le), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
me(cnt);
class pnt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      circle: null
    }), xe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(F0(F0({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: b7,
      eventMap: y7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: b7,
      eventMap: y7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), cn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
xe(pnt, "contextType", It);
function w7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function z0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var C7 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, O7 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function dnt(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: b
  } = e, L = ge(It), [w, D] = E(null), [x, m] = E(null), [C, S] = E(null), [U, k] = E(null), [N, R] = E(null), [V, $] = E(null), [W, Z] = E(null), [X, K] = E(null), [Q, J] = E(null), [P, _] = E(null), [z, M] = E(null), [H, O] = E(null), [j, F] = E(null), [T, q] = E(null);
  return h(() => {
    w !== null && w.setMap(L);
  }, [L]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), k(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (N !== null && google.maps.event.removeListener(N), R(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (X !== null && google.maps.event.removeListener(X), K(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (Q !== null && google.maps.event.removeListener(Q), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (P !== null && google.maps.event.removeListener(P), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (z !== null && google.maps.event.removeListener(z), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && (H !== null && google.maps.event.removeListener(H), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), q(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (L !== null) {
      var B = new google.maps.Data(z0(z0({}, t), {}, {
        map: L
      }));
      r && m(google.maps.event.addListener(B, "dblclick", r)), o && S(google.maps.event.addListener(B, "mousedown", o)), i && k(google.maps.event.addListener(B, "mousemove", i)), a && R(google.maps.event.addListener(B, "mouseout", a)), s && $(google.maps.event.addListener(B, "mouseover", s)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && K(google.maps.event.addListener(B, "rightclick", u)), n && J(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && O(google.maps.event.addListener(B, "removeproperty", d)), y && F(google.maps.event.addListener(B, "setgeometry", y)), f && q(google.maps.event.addListener(B, "setproperty", f)), D(B), v && v(B);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), V !== null && google.maps.event.removeListener(V), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), P !== null && google.maps.event.removeListener(P), z !== null && google.maps.event.removeListener(z), H !== null && google.maps.event.removeListener(H), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), b && b(w), w.setMap(null));
    };
  }, []), null;
}
me(dnt);
class fnt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      data: null
    }), xe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(z0(z0({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Qt({
        updaterMap: O7,
        eventMap: C7,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: O7,
      eventMap: C7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), cn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
xe(fnt, "contextType", It);
function x7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function L7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E7 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, k7 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class hnt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      kmlLayer: null
    }), xe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(L7(L7({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: k7,
      eventMap: E7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: k7,
      eventMap: E7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), cn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(hnt, "contextType", It);
function Wie(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function gnt(e, t) {
  return new t(e.lat, e.lng);
}
function mnt(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function vnt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function ynt(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function bnt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function wnt(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function Hie(e, t, n, r) {
  return n !== void 0 ? bnt(e, t, ynt(n, google.maps.LatLngBounds, mnt)) : wnt(e, t, vnt(r, google.maps.LatLng, gnt));
}
function Cnt(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function P7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ont(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function xnt(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Ont({}, this.container ? Wie(this.container, o) : {
        x: 0,
        y: 0
      }), u = Hie(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function S7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lnt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function M7(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function D7(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Ent(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(It), c = un(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = un(() => xnt(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), hi.createPortal(l, c);
}
me(Ent);
class Hp extends pe {
  constructor(t) {
    super(t), xe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), xe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Go(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), xe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), xe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Lnt({
        x: 0,
        y: 0
      }, this.containerRef.current ? Wie(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = Hie(r, o, this.props.bounds, this.props.position);
      if (!Cnt(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), xe(this, "draw", () => {
      this.onPositionElement();
    }), xe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = zn();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = M7(t.position), r = M7(this.props.position), o = D7(t.bounds), i = D7(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? hi.createPortal(re.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: at.only(this.props.children)
    }), t) : null;
  }
}
xe(Hp, "FLOAT_PANE", "floatPane");
xe(Hp, "MAP_PANE", "mapPane");
xe(Hp, "MARKER_LAYER", "markerLayer");
xe(Hp, "OVERLAY_LAYER", "overlayLayer");
xe(Hp, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
xe(Hp, "contextType", It);
function knt() {
}
function _7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function T7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var j7 = {
  onDblClick: "dblclick",
  onClick: "click"
}, A7 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Pnt(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(It), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = un(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
me(Pnt);
class Vie extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      groundOverlay: null
    }), xe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Go(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, T7(T7({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: A7,
      eventMap: j7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: A7,
      eventMap: j7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Vie, "defaultProps", {
  onLoad: knt
});
xe(Vie, "contextType", It);
function B7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function U0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B7(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B7(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var I7 = {}, R7 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Snt(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(It), [a, s] = E(null);
  return h(() => {
    google.maps.visualization || Go(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Go(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(U0(U0({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
me(Snt);
class Mnt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      heatmapLayer: null
    }), xe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Go(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Go(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(U0(U0({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Qt({
      updaterMap: R7,
      eventMap: I7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: R7,
      eventMap: I7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), cn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Mnt, "contextType", It);
var N7 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, F7 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Dnt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      streetViewPanorama: null
    }), xe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Qt({
      updaterMap: F7,
      eventMap: N7,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: F7,
      eventMap: N7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), cn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
xe(Dnt, "contextType", It);
class _nt extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      streetViewService: null
    }), xe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
xe(_nt, "contextType", It);
var z7 = {
  onDirectionsChanged: "directions_changed"
}, U7 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Tnt extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      directionsRenderer: null
    }), xe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Qt({
      updaterMap: U7,
      eventMap: z7,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: U7,
      eventMap: z7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), cn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Tnt, "contextType", It);
var W7 = {
  onPlacesChanged: "places_changed"
}, H7 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class $ie extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", zn()), xe(this, "state", {
      searchBox: null
    }), xe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Go(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Qt({
          updaterMap: H7,
          eventMap: W7,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: H7,
      eventMap: W7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), cn(this.registeredEvents));
  }
  render() {
    return re.jsx("div", {
      ref: this.containerElement,
      children: at.only(this.props.children)
    });
  }
}
xe($ie, "contextType", It);
var V7 = {
  onPlaceChanged: "place_changed"
}, $7 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class qie extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", zn()), xe(this, "state", {
      autocomplete: null
    }), xe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Go(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Qt({
        updaterMap: $7,
        eventMap: V7,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    cn(this.registeredEvents), this.registeredEvents = Qt({
      updaterMap: $7,
      eventMap: V7,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && cn(this.registeredEvents);
  }
  render() {
    return re.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: at.only(this.props.children)
    });
  }
}
xe(qie, "defaultProps", {
  className: ""
});
xe(qie, "contextType", It);
function vot({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ re.jsx(
    Bie,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function yot(e) {
  const { children: t = !1 } = e, [n, r] = E([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ re.jsx(
    bj.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: t
    }
  );
}
let jnt = { data: "" }, Ant = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || jnt, Bnt = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Int = /\/\*[^]*?\*\/|  +/g, q7 = /\n+/g, nu = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? nu(a, i) : i + "{" + nu(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += nu(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += nu.p ? nu.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ua = {}, Zie = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Zie(e[n]);
    return t;
  }
  return e;
}, Rnt = (e, t, n, r, o) => {
  let i = Zie(e), a = Ua[i] || (Ua[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ua[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Bnt.exec(u.replace(Int, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(q7, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(q7, " ").trim();
      return d[0];
    })(e);
    Ua[a] = nu(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ua.g ? Ua.g : null;
  return n && (Ua.g = Ua[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ua[a], t, r, s), a;
}, Nnt = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : nu(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function JC(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Rnt(n.unshift ? n.raw ? Nnt(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Ant(t.target), t.g, t.o, t.k);
}
let Gie, AS, BS;
JC.bind({ g: 1 });
let ol = JC.bind({ k: 1 });
function Fnt(e, t, n, r) {
  nu.p = t, Gie = e, AS = n, BS = r;
}
function Tu(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: AS && AS() }, s), n.o = / *go\d+/.test(l), s.className = JC.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), BS && u[0] && BS(s), Gie(u, s);
    }
    return o;
  };
}
var znt = (e) => typeof e == "function", W0 = (e, t) => znt(e) ? e(t) : e, Unt = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), Yie = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Wnt = 20, my = /* @__PURE__ */ new Map(), Hnt = 1e3, Z7 = (e) => {
  if (my.has(e)) return;
  let t = setTimeout(() => {
    my.delete(e), Xc({ type: 4, toastId: e });
  }, Hnt);
  my.set(e, t);
}, Vnt = (e) => {
  let t = my.get(e);
  t && clearTimeout(t);
}, IS = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, Wnt) };
    case 1:
      return t.toast.id && Vnt(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? IS(e, { type: 1, toast: n }) : IS(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? Z7(r) : e.toasts.forEach((i) => {
        Z7(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, vy = [], yy = { toasts: [], pausedAt: void 0 }, Xc = (e) => {
  yy = IS(yy, e), vy.forEach((t) => {
    t(yy);
  });
}, $nt = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, qnt = (e = {}) => {
  let [t, n] = E(yy);
  h(() => (vy.push(n), () => {
    let o = vy.indexOf(n);
    o > -1 && vy.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, a;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || $nt[o.type], style: { ...e.style, ...(a = e[o.type]) == null ? void 0 : a.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, Znt = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || Unt() }), Mg = (e) => (t, n) => {
  let r = Znt(t, e, n);
  return Xc({ type: 2, toast: r }), r.id;
}, vs = (e, t) => Mg("blank")(e, t);
vs.error = Mg("error");
vs.success = Mg("success");
vs.loading = Mg("loading");
vs.custom = Mg("custom");
vs.dismiss = (e) => {
  Xc({ type: 3, toastId: e });
};
vs.remove = (e) => Xc({ type: 4, toastId: e });
vs.promise = (e, t, n) => {
  let r = vs.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (vs.success(W0(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    vs.error(W0(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var Gnt = (e, t) => {
  Xc({ type: 1, toast: { id: e, height: t } });
}, Ynt = () => {
  Xc({ type: 5, time: Date.now() });
}, Xnt = (e) => {
  let { toasts: t, pausedAt: n } = qnt(e);
  h(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && vs.dismiss(s.id);
        return;
      }
      return setTimeout(() => vs.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = Jn(() => {
    n && Xc({ type: 6, time: Date.now() });
  }, [n]), o = Jn((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((y) => (y.position || u) === (i.position || u) && y.height), p = c.findIndex((y) => y.id === i.id), d = c.filter((y, f) => f < p && y.visible).length;
    return c.filter((y) => y.visible).slice(...s ? [d + 1] : [0, d]).reduce((y, f) => y + (f.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: Gnt, startPause: Ynt, endPause: r, calculateOffset: o } };
}, Knt = ol`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Jnt = ol`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Qnt = ol`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, ert = Tu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Knt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Jnt} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Qnt} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, trt = ol`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, nrt = Tu("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${trt} 1s linear infinite;
`, rrt = ol`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, ort = ol`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, irt = Tu("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${rrt} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${ort} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, srt = Tu("div")`
  position: absolute;
`, art = Tu("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, lrt = ol`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, urt = Tu("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${lrt} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, crt = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ne.createElement(urt, null, t) : t : n === "blank" ? null : Ne.createElement(art, null, Ne.createElement(nrt, { ...r }), n !== "loading" && Ne.createElement(srt, null, n === "error" ? Ne.createElement(ert, { ...r }) : Ne.createElement(irt, { ...r })));
}, prt = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, drt = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, frt = "0%{opacity:0;} 100%{opacity:1;}", hrt = "0%{opacity:1;} 100%{opacity:0;}", grt = Tu("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, mrt = Tu("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, vrt = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Yie() ? [frt, hrt] : [prt(n), drt(n)];
  return { animation: t ? `${ol(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ol(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, yrt = Ne.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? vrt(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ne.createElement(crt, { toast: e }), a = Ne.createElement(mrt, { ...e.ariaProps }, W0(e.message, e));
  return Ne.createElement(grt, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Ne.createElement(Ne.Fragment, null, i, a));
});
Fnt(Ne.createElement);
var brt = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Ne.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Ne.createElement("div", { ref: i, className: t, style: n }, o);
}, wrt = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: Yie() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, Crt = JC`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, ny = 16, Ort = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = Xnt(n);
  return Ne.createElement("div", { style: { position: "fixed", zIndex: 9999, top: ny, left: ny, right: ny, bottom: ny, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = wrt(c, p);
    return Ne.createElement(brt, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? Crt : "", style: d }, u.type === "custom" ? W0(u.message, u) : o ? o(u) : Ne.createElement(yrt, { toast: u, position: c }));
  }));
}, G7 = vs;
function bot({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return G7.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return G7.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ re.jsxs(Pie.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ re.jsx(
      Ort,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function xrt({ children: e, fallback: t = null }) {
  return qet() ? /* @__PURE__ */ re.jsx(re.Fragment, { children: e() }) : /* @__PURE__ */ re.jsx(re.Fragment, { children: t });
}
function wot({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ re.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ re.jsx(
    ott,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ re.jsx(Iie, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ re.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ re.jsx(vse, {}) });
}
function Cot({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = E(null), a = (l) => i(l), s = () => {
    var y, f, v, b;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(L) {
      const w = c.find((D) => D.types[0] === L);
      return w ? w.long_name : "";
    }
    function d(L) {
      const w = c.find((D) => D.types[0] === L);
      return w ? w.short_name : "";
    }
    if (u) {
      const L = p("route"), w = p("street_number"), D = p("sublocality_level_1"), x = p("administrative_area_level_2"), m = p("administrative_area_level_1"), C = d("administrative_area_level_1"), S = p("postal_code"), U = (f = (y = u.geometry) == null ? void 0 : y.location) == null ? void 0 : f.lat(), k = (b = (v = u.geometry) == null ? void 0 : v.location) == null ? void 0 : b.lng();
      t && t({
        street: L,
        city: x,
        state: m,
        district: D,
        cep: S,
        streetNumber: w,
        stateShortName: C,
        coordinates: { lat: U, lng: k }
      });
    }
  };
  return /* @__PURE__ */ re.jsx(
    $ie,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ re.jsx(UC, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function Xie(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function Lrt(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = e, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = Xie({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let Ert = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = Lrt(t), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = Xie({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function krt(e) {
  return new Ert().initialize(e), /* @__PURE__ */ re.jsx(re.Fragment, {});
}
function xot(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {}
  } = e;
  return /* @__PURE__ */ re.jsx(xrt, { children: () => /* @__PURE__ */ re.jsx(
    krt,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  jrt as AlertContainer,
  Art as AlertContent,
  Brt as AlertDescription,
  Irt as AlertIcon,
  Ose as AlertTitle,
  Yrt as AudioUpload,
  zrt as Badge,
  iot as BreadcrumbContainer,
  sot as BreadcrumbLink,
  D0 as Button,
  Urt as Card,
  Xrt as Checkbox,
  xrt as ClientOnly,
  Wrt as Divider,
  lot as DrawerContainer,
  uot as DrawerHeader,
  got as DrawerProvider,
  uq as FormController,
  Krt as FormError,
  cq as FormLabel,
  wot as GoogleMap,
  vot as GoogleProvider,
  Cot as GoogleSearchPlaces,
  xot as GoogleTagManager,
  BGe as IconButton,
  UGe as ImageUpload,
  UC as Input,
  kJe as ModalContainer,
  PJe as ModalFooter,
  SJe as ModalHeader,
  yot as ModalProvider,
  Jrt as MultiSelect,
  aot as Pagination,
  cot as Popover,
  eot as RadioBox,
  Qrt as RadioGroup,
  tot as RichText,
  not as Select,
  Hrt as Skeleton,
  TGe as Slider,
  rot as Switch,
  Xq as TabButton,
  DJe as TabContainer,
  Vrt as TableBody,
  $rt as TableCaption,
  qrt as TableContainer,
  Zrt as TableFooter,
  Grt as TableHeader,
  oot as Textarea,
  pot as Toast,
  bot as ToastProvider,
  IGe as Tooltip,
  Rrt as getHtmlFromRichTextValue,
  Nrt as getRichTextValueFromHtml,
  Frt as isHtml,
  RG as morpheme,
  dot as useAutomation,
  fot as useDrawer,
  poe as useFieldErrors,
  ts as useFormController,
  qet as useHydrated,
  hot as useModal,
  oie as useScopedParams,
  Vet as useToast
};
