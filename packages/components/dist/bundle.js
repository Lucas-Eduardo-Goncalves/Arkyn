import * as We from "react";
import xe, { createContext as qe, useContext as De, Children as Ct, forwardRef as Fs, memo as ke, useState as D, useRef as Ye, useEffect as y, useMemo as Gn, isValidElement as mi, cloneElement as vi, Component as Fp, PureComponent as Oe, createRef as cr, useId as ZB, useCallback as qt, useReducer as KB, useLayoutEffect as GB, useSyncExternalStore as YB } from "react";
import { Info as hS, AlertTriangle as XB, XCircle as gS, CheckCircle2 as mS, Loader2 as vo, Pause as JB, Play as QB, RefreshCw as vS, Check as Gm, ChevronDown as yS, X as Ym, Search as bS, Image as eI, Heading1 as tI, Heading2 as nI, Quote as rI, Bold as oI, Italic as iI, Underline as sI, Code as aI, AlignLeft as lI, AlignRight as uI, AlignCenter as cI, AlignJustify as pI, ChevronRight as yg, ChevronLeft as dI, Ellipsis as xb, MapPinned as fI } from "lucide-react";
import { useActionData as Xm, useNavigation as wS, useFetchers as CS, useLocation as Jm, Link as hI, useNavigate as OS } from "@remix-run/react";
import { InputMask as gI } from "@react-input/mask";
import * as yi from "react-dom";
import wl, { createPortal as pr } from "react-dom";
import { AnimatePresence as ES, motion as Za } from "framer-motion";
var tn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function zp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var bg = { exports: {} }, Js = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lb;
function mI() {
  if (Lb) return Js;
  Lb = 1;
  var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return Js.Fragment = n, Js.jsx = s, Js.jsxs = s, Js;
}
var Qs = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Db;
function vI() {
  return Db || (Db = 1, process.env.NODE_ENV !== "production" && function() {
    var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[g];
      return typeof R == "function" ? R : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, X = new Array(R > 1 ? R - 1 : 0), re = 1; re < R; re++)
          X[re - 1] = arguments[re];
        S("error", b, X);
      }
    }
    function S(b, R, X) {
      {
        var re = C.ReactDebugCurrentFrame, pe = re.getStackAddendum();
        pe !== "" && (R += "%s", X = X.concat([pe]));
        var me = X.map(function(le) {
          return String(le);
        });
        me.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, me);
      }
    }
    var E = !1, v = !1, O = !1, P = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || P || b === m || E || v || O || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function A(b, R, X) {
      var re = b.displayName;
      if (re)
        return re;
      var pe = R.displayName || R.name || "";
      return pe !== "" ? X + "(" + pe + ")" : X;
    }
    function z(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var R = b;
            return z(R) + ".Consumer";
          case s:
            var X = b;
            return z(X._context) + ".Provider";
          case l:
            return A(b, b.render, "ForwardRef");
          case p:
            var re = b.displayName || null;
            return re !== null ? re : V(b.type) || "Memo";
          case d: {
            var pe = b, me = pe._payload, le = pe._init;
            try {
              return V(le(me));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var $ = Object.assign, Z = 0, J, Y, te, ee, k, _, K;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function G() {
      {
        if (Z === 0) {
          J = console.log, Y = console.info, te = console.warn, ee = console.error, k = console.group, _ = console.groupCollapsed, K = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: $({}, b, {
              value: J
            }),
            info: $({}, b, {
              value: Y
            }),
            warn: $({}, b, {
              value: te
            }),
            error: $({}, b, {
              value: ee
            }),
            group: $({}, b, {
              value: k
            }),
            groupCollapsed: $({}, b, {
              value: _
            }),
            groupEnd: $({}, b, {
              value: K
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = C.ReactCurrentDispatcher, F;
    function j(b, R, X) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (pe) {
            var re = pe.stack.trim().match(/\n( *(at )?)/);
            F = re && re[1] || "";
          }
        return `
` + F + b;
      }
    }
    var H = !1, B;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Q();
    }
    function W(b, R) {
      if (!b || H)
        return "";
      {
        var X = B.get(b);
        if (X !== void 0)
          return X;
      }
      var re;
      H = !0;
      var pe = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var me;
      me = T.current, T.current = null, G();
      try {
        if (R) {
          var le = function() {
            throw Error();
          };
          if (Object.defineProperty(le.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(le, []);
            } catch ($e) {
              re = $e;
            }
            Reflect.construct(b, [], le);
          } else {
            try {
              le.call();
            } catch ($e) {
              re = $e;
            }
            b.call(le.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($e) {
            re = $e;
          }
          b();
        }
      } catch ($e) {
        if ($e && re && typeof $e.stack == "string") {
          for (var se = $e.stack.split(`
`), Ie = re.stack.split(`
`), Le = se.length - 1, Pe = Ie.length - 1; Le >= 1 && Pe >= 0 && se[Le] !== Ie[Pe]; )
            Pe--;
          for (; Le >= 1 && Pe >= 0; Le--, Pe--)
            if (se[Le] !== Ie[Pe]) {
              if (Le !== 1 || Pe !== 1)
                do
                  if (Le--, Pe--, Pe < 0 || se[Le] !== Ie[Pe]) {
                    var He = `
` + se[Le].replace(" at new ", " at ");
                    return b.displayName && He.includes("<anonymous>") && (He = He.replace("<anonymous>", b.displayName)), typeof b == "function" && B.set(b, He), He;
                  }
                while (Le >= 1 && Pe >= 0);
              break;
            }
        }
      } finally {
        H = !1, T.current = me, x(), Error.prepareStackTrace = pe;
      }
      var pn = b ? b.displayName || b.name : "", zt = pn ? j(pn) : "";
      return typeof b == "function" && B.set(b, zt), zt;
    }
    function ue(b, R, X) {
      return W(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, X) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return W(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, R, X);
          case d: {
            var re = b, pe = re._payload, me = re._init;
            try {
              return oe(me(pe), R, X);
            } catch {
            }
          }
        }
      return "";
    }
    var _e = Object.prototype.hasOwnProperty, Fe = {}, ze = C.ReactDebugCurrentFrame;
    function Re(b) {
      if (b) {
        var R = b._owner, X = oe(b.type, b._source, R ? R.type : null);
        ze.setExtraStackFrame(X);
      } else
        ze.setExtraStackFrame(null);
    }
    function Ge(b, R, X, re, pe) {
      {
        var me = Function.call.bind(_e);
        for (var le in b)
          if (me(b, le)) {
            var se = void 0;
            try {
              if (typeof b[le] != "function") {
                var Ie = Error((re || "React class") + ": " + X + " type `" + le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              se = b[le](R, le, re, X, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              se = Le;
            }
            se && !(se instanceof Error) && (Re(pe), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", X, le, typeof se), Re(null)), se instanceof Error && !(se.message in Fe) && (Fe[se.message] = !0, Re(pe), w("Failed %s type: %s", X, se.message), Re(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ke(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, X = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return X;
      }
    }
    function rt(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function je(b) {
      if (rt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Se(b);
    }
    var Ne = C.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, ot, Te;
    Te = {};
    function Zt(b) {
      if (_e.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function lt(b) {
      if (_e.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ht(b, R) {
      if (typeof b.ref == "string" && Ne.current && R && Ne.current.stateNode !== R) {
        var X = V(Ne.current.type);
        Te[X] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ne.current.type), b.ref), Te[X] = !0);
      }
    }
    function kt(b, R) {
      {
        var X = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        X.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: X,
          configurable: !0
        });
      }
    }
    function sn(b, R) {
      {
        var X = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        X.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: X,
          configurable: !0
        });
      }
    }
    var St = function(b, R, X, re, pe, me, le) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: X,
        props: le,
        // Record the component responsible for creating this element.
        _owner: me
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: re
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: pe
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function an(b, R, X, re, pe) {
      {
        var me, le = {}, se = null, Ie = null;
        X !== void 0 && (je(X), se = "" + X), lt(R) && (je(R.key), se = "" + R.key), Zt(R) && (Ie = R.ref, ht(R, pe));
        for (me in R)
          _e.call(R, me) && !Ve.hasOwnProperty(me) && (le[me] = R[me]);
        if (b && b.defaultProps) {
          var Le = b.defaultProps;
          for (me in Le)
            le[me] === void 0 && (le[me] = Le[me]);
        }
        if (se || Ie) {
          var Pe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && kt(le, Pe), Ie && sn(le, Pe);
        }
        return St(b, se, Ie, pe, re, Ne.current, le);
      }
    }
    var tt = C.ReactCurrentOwner, Nt = C.ReactDebugCurrentFrame;
    function ut(b) {
      if (b) {
        var R = b._owner, X = oe(b.type, b._source, R ? R.type : null);
        Nt.setExtraStackFrame(X);
      } else
        Nt.setExtraStackFrame(null);
    }
    var ln;
    ln = !1;
    function Mt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Mn() {
      {
        if (tt.current) {
          var b = V(tt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function un(b) {
      return "";
    }
    var Tn = {};
    function cn(b) {
      {
        var R = Mn();
        if (!R) {
          var X = typeof b == "string" ? b : b.displayName || b.name;
          X && (R = `

Check the top-level render call using <` + X + ">.");
        }
        return R;
      }
    }
    function jn(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var X = cn(R);
        if (Tn[X])
          return;
        Tn[X] = !0;
        var re = "";
        b && b._owner && b._owner !== tt.current && (re = " It was passed a child from " + V(b._owner.type) + "."), ut(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', X, re), ut(null);
      }
    }
    function Yn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var X = 0; X < b.length; X++) {
            var re = b[X];
            Mt(re) && jn(re, R);
          }
        else if (Mt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var pe = h(b);
          if (typeof pe == "function" && pe !== b.entries)
            for (var me = pe.call(b), le; !(le = me.next()).done; )
              Mt(le.value) && jn(le.value, R);
        }
      }
    }
    function Ft(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var X;
        if (typeof R == "function")
          X = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          X = R.propTypes;
        else
          return;
        if (X) {
          var re = V(R);
          Ge(X, b.props, "prop", re, b);
        } else if (R.PropTypes !== void 0 && !ln) {
          ln = !0;
          var pe = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", pe || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ie(b) {
      {
        for (var R = Object.keys(b.props), X = 0; X < R.length; X++) {
          var re = R[X];
          if (re !== "children" && re !== "key") {
            ut(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), ut(null);
            break;
          }
        }
        b.ref !== null && (ut(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), ut(null));
      }
    }
    var eo = {};
    function to(b, R, X, re, pe, me) {
      {
        var le = N(b);
        if (!le) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ie = un();
          Ie ? se += Ie : se += Mn();
          var Le;
          b === null ? Le = "null" : Me(b) ? Le = "array" : b !== void 0 && b.$$typeof === t ? (Le = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, se);
        }
        var Pe = an(b, R, X, pe, me);
        if (Pe == null)
          return Pe;
        if (le) {
          var He = R.children;
          if (He !== void 0)
            if (re)
              if (Me(He)) {
                for (var pn = 0; pn < He.length; pn++)
                  Yn(He[pn], b);
                Object.freeze && Object.freeze(He);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Yn(He, b);
        }
        if (_e.call(R, "key")) {
          var zt = V(b), $e = Object.keys(R).filter(function(Ri) {
            return Ri !== "key";
          }), dr = $e.length > 0 ? "{key: someKey, " + $e.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!eo[zt + dr]) {
            var Ii = $e.length > 0 ? "{" + $e.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, dr, zt, Ii, zt), eo[zt + dr] = !0;
          }
        }
        return b === r ? ie(Pe) : Ft(Pe), Pe;
      }
    }
    function ji(b, R, X) {
      return to(b, R, X, !0);
    }
    function _i(b, R, X) {
      return to(b, R, X, !1);
    }
    var Ai = _i, Bi = ji;
    Qs.Fragment = r, Qs.jsx = Ai, Qs.jsxs = Bi;
  }()), Qs;
}
process.env.NODE_ENV === "production" ? bg.exports = mI() : bg.exports = vI();
var q = bg.exports;
function yI(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: r.trim(), ...n });
}
const xS = qe({});
function bI() {
  return De(xS);
}
function qae(e) {
  const { schema: t, children: n, className: r, ...o } = e, a = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === yI ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${a} ${r}`;
  return /* @__PURE__ */ q.jsx(xS.Provider, { value: e, children: /* @__PURE__ */ q.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function Zae(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: r.trim(), ...n });
}
function Kae(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: r.trim(), ...n });
}
function Gae(e) {
  const { className: t, ...n } = e, { schema: r } = bI(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ q.jsx(mS, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ q.jsx(gS, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ q.jsx(XB, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ q.jsx(hS, { className: o, ...n });
  }
}
function Lc(e, t) {
  return t ? /* @__PURE__ */ q.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Pb(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function sr(e) {
  var t, n;
  return Pb(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Pb(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var LS = Symbol.for("immer-nothing"), kb = Symbol.for("immer-draftable"), zr = Symbol.for("immer-state"), wI = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Cr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = wI[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var _s = Object.getPrototypeOf;
function ps(e) {
  return !!e && !!e[zr];
}
function ds(e) {
  var t;
  return e ? DS(e) || Array.isArray(e) || !!e[kb] || !!((t = e.constructor) != null && t[kb]) || Up(e) || Wp(e) : !1;
}
var CI = Object.prototype.constructor.toString();
function DS(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = _s(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === CI;
}
function Dc(e, t) {
  $p(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function $p(e) {
  const t = e[zr];
  return t ? t.type_ : Array.isArray(e) ? 1 : Up(e) ? 2 : Wp(e) ? 3 : 0;
}
function wg(e, t) {
  return $p(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function PS(e, t, n) {
  const r = $p(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function OI(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Up(e) {
  return e instanceof Map;
}
function Wp(e) {
  return e instanceof Set;
}
function Zi(e) {
  return e.copy_ || e.base_;
}
function Cg(e, t) {
  if (Up(e))
    return new Map(e);
  if (Wp(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = DS(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[zr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(_s(e), r);
  } else {
    const r = _s(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Qm(e, t = !1) {
  return Vp(e) || ps(e) || !ds(e) || ($p(e) > 1 && (e.set = e.add = e.clear = e.delete = EI), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Qm(r, !0))), e;
}
function EI() {
  Cr(2);
}
function Vp(e) {
  return Object.isFrozen(e);
}
var xI = {};
function fs(e) {
  const t = xI[e];
  return t || Cr(0, e), t;
}
var Ka;
function kS() {
  return Ka;
}
function LI(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Sb(e, t) {
  t && (fs("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Og(e) {
  Eg(e), e.drafts_.forEach(DI), e.drafts_ = null;
}
function Eg(e) {
  e === Ka && (Ka = e.parent_);
}
function Mb(e) {
  return Ka = LI(Ka, e);
}
function DI(e) {
  const t = e[zr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Tb(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[zr].modified_ && (Og(t), Cr(4)), ds(e) && (e = Pc(t, e), t.parent_ || kc(t, e)), t.patches_ && fs("Patches").generateReplacementPatches_(
    n[zr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Pc(t, n, []), Og(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== LS ? e : void 0;
}
function Pc(e, t, n) {
  if (Vp(t))
    return t;
  const r = t[zr];
  if (!r)
    return Dc(
      t,
      (o, i) => jb(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return kc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Dc(
      i,
      (a, l) => jb(e, r, o, a, l, n, s)
    ), kc(e, o, !1), n && e.patches_ && fs("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function jb(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Cr(5), ps(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !wg(t.assigned_, r) ? i.concat(r) : void 0, l = Pc(e, o, a);
    if (PS(n, r, l), ps(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ds(o) && !Vp(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Pc(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && kc(e, o);
  }
}
function kc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Qm(t, n);
}
function PI(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : kS(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = ev;
  n && (o = [r], i = Ga);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var ev = {
  get(e, t) {
    if (t === zr)
      return e;
    const n = Zi(e);
    if (!wg(n, t))
      return kI(e, n, t);
    const r = n[t];
    return e.finalized_ || !ds(r) ? r : r === Cf(e.base_, t) ? (Of(e), e.copy_[t] = Lg(r, e)) : r;
  },
  has(e, t) {
    return t in Zi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Zi(e));
  },
  set(e, t, n) {
    const r = SS(Zi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Cf(Zi(e), t), i = o == null ? void 0 : o[zr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (OI(n, o) && (n !== void 0 || wg(e.base_, t)))
        return !0;
      Of(e), xg(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Cf(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Of(e), xg(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Zi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Cr(11);
  },
  getPrototypeOf(e) {
    return _s(e.base_);
  },
  setPrototypeOf() {
    Cr(12);
  }
}, Ga = {};
Dc(ev, (e, t) => {
  Ga[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ga.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Cr(13), Ga.set.call(this, e, t, void 0);
};
Ga.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Cr(14), ev.set.call(this, e[0], t, n, e[0]);
};
function Cf(e, t) {
  const n = e[zr];
  return (n ? Zi(n) : e)[t];
}
function kI(e, t, n) {
  var o;
  const r = SS(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function SS(e, t) {
  if (!(t in e))
    return;
  let n = _s(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = _s(n);
  }
}
function xg(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && xg(e.parent_));
}
function Of(e) {
  e.copy_ || (e.copy_ = Cg(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var SI = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(l = i, ...u) {
          return s.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && Cr(6), r !== void 0 && typeof r != "function" && Cr(7);
      let o;
      if (ds(t)) {
        const i = Mb(this), s = Lg(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Og(i) : Eg(i);
        }
        return Sb(i, r), Tb(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === LS && (o = void 0), this.autoFreeze_ && Qm(o, !0), r) {
          const i = [], s = [];
          fs("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Cr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (s, ...a) => this.produceWithPatches(s, (l) => t(l, ...a));
      let r, o;
      return [this.produce(t, n, (s, a) => {
        r = s, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ds(e) || Cr(8), ps(e) && (e = MI(e));
    const t = Mb(this), n = Lg(e, void 0);
    return n[zr].isManual_ = !0, Eg(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[zr];
    (!n || !n.isManual_) && Cr(9);
    const { scope_: r } = n;
    return Sb(r, t), Tb(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = fs("Patches").applyPatches_;
    return ps(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Lg(e, t) {
  const n = Up(e) ? fs("MapSet").proxyMap_(e, t) : Wp(e) ? fs("MapSet").proxySet_(e, t) : PI(e, t);
  return (t ? t.scope_ : kS()).drafts_.push(n), n;
}
function MI(e) {
  return ps(e) || Cr(10, e), MS(e);
}
function MS(e) {
  if (!ds(e) || Vp(e))
    return e;
  const t = e[zr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Cg(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Cg(e, !0);
  return Dc(n, (r, o) => {
    PS(n, r, MS(o));
  }), t && (t.finalized_ = !1), n;
}
var $r = new SI(), tv = $r.produce;
$r.produceWithPatches.bind(
  $r
);
$r.setAutoFreeze.bind($r);
$r.setUseStrictShallowCopy.bind($r);
$r.applyPatches.bind($r);
var _b = $r.createDraft.bind($r), Ab = $r.finishDraft.bind($r), TI = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ne.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, jI = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ct.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, _I = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ae.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Sc = /* @__PURE__ */ new WeakMap(), Mc = /* @__PURE__ */ new WeakMap(), ka = /* @__PURE__ */ new WeakMap(), TS = /* @__PURE__ */ new WeakMap(), Bb = /* @__PURE__ */ new WeakMap(), Ib = /* @__PURE__ */ new WeakMap(), Rb = /* @__PURE__ */ new WeakMap(), ne = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ne.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ne.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ne.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ne.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ne.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ne.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ne.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ne.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ne.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ne.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ne.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ne.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ne.isAncestor(t, e) && !ne.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ne.equals(i, r) || ne.endsBefore(i, r) || ne.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (ne.equals(s, r) || ne.isAncestor(s, r))
          return null;
        ne.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        ne.equals(a, r) || ne.endsBefore(a, r) ? r[a.length - 1] -= 1 : ne.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ne.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ne.endsBefore(u, r) ? r[u.length - 1] += 1 : ne.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ne.equals(p, d))
          return r;
        if (ne.isAncestor(p, r) || ne.equals(p, r)) {
          var m = d.slice();
          return ne.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else ne.isSibling(p, d) && (ne.isAncestor(d, r) || ne.equals(d, r)) ? ne.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ne.endsBefore(d, r) || ne.equals(d, r) || ne.isAncestor(d, r) ? (ne.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ne.endsBefore(p, r) && (ne.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ya(e) {
  "@babel/helpers - typeof";
  return Ya = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ya(e);
}
function AI(e, t) {
  if (Ya(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ya(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function BI(e) {
  var t = AI(e, "string");
  return Ya(t) === "symbol" ? t : String(t);
}
function gr(e, t, n) {
  return t = BI(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Nb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ea(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nb(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var II = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Ee.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of ae.points(t))
          t[l] = ct.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Ee.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of ae.points(t))
          t[h] = ct.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = Ee.get(e, C), S = ne.previous(C), E = Ee.get(e, S), v = Ee.parent(e, C), O = C[C.length - 1];
      if (Be.isText(w) && Be.isText(E))
        E.text += w.text;
      else if (!Be.isText(w) && !Be.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(tr.stringify(w), " ").concat(tr.stringify(E)));
      if (v.children.splice(O, 1), t)
        for (var [P, U] of ae.points(t))
          t[U] = ct.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (ne.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var A = Ee.get(e, L), z = Ee.parent(e, L), V = L[L.length - 1];
      z.children.splice(V, 1);
      var $ = ne.transform(L, n), Z = Ee.get(e, ne.parent($)), J = $[$.length - 1];
      if (Z.children.splice(J, 0, A), t)
        for (var [Y, te] of ae.points(t))
          t[te] = ct.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], _ = Ee.parent(e, ee);
      if (_.children.splice(k, 1), t)
        for (var [K, M] of ae.points(t)) {
          var G = ct.transform(K, n);
          if (t != null && G != null)
            t[M] = G;
          else {
            var x = void 0, T = void 0;
            for (var [F, j] of Ee.texts(e))
              if (ne.compare(j, ee) === -1)
                x = [F, j];
              else {
                T = [F, j];
                break;
              }
            var H = !1;
            x && T && (ne.equals(T[1], ee) ? H = !ne.hasPrevious(T[1]) : H = ne.common(x[1], ee).length < ne.common(T[1], ee).length), x && !H ? (K.path = x[1], K.offset = x[0].text.length) : T ? (K.path = T[1], K.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Q,
        text: W
      } = n;
      if (W.length === 0) break;
      var ue = Ee.leaf(e, B), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + W.length);
      if (ue.text = ye + oe, t)
        for (var [_e, Fe] of ae.points(t))
          t[Fe] = ct.transform(_e, n);
      break;
    }
    case "set_node": {
      var {
        path: ze,
        properties: Re,
        newProperties: Ge
      } = n;
      if (ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = Ee.get(e, ze);
      for (var Me in Ge) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ke = Ge[Me];
        Ke == null ? delete Ze[Me] : Ze[Me] = Ke;
      }
      for (var rt in Re)
        Ge.hasOwnProperty(rt) || delete Ze[rt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!ae.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(tr.stringify(Se), " when there is no current selection."));
          t = ea({}, Se);
        }
        for (var je in Se) {
          var Ne = Se[je];
          if (Ne == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ne;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ue,
        properties: ot
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var Te = Ee.get(e, Ve), Zt = Ee.parent(e, Ve), lt = Ve[Ve.length - 1], ht;
      if (Be.isText(Te)) {
        var kt = Te.text.slice(0, Ue), sn = Te.text.slice(Ue);
        Te.text = kt, ht = ea(ea({}, ot), {}, {
          text: sn
        });
      } else {
        var St = Te.children.slice(0, Ue), an = Te.children.slice(Ue);
        Te.children = St, ht = ea(ea({}, ot), {}, {
          children: an
        });
      }
      if (Zt.children.splice(lt + 1, 0, ht), t)
        for (var [tt, Nt] of ae.points(t))
          t[Nt] = ct.transform(tt, n);
      break;
    }
  }
  return t;
}, RI = {
  transform(e, t) {
    e.children = _b(e.children);
    var n = e.selection && _b(e.selection);
    try {
      n = II(e, n, t);
    } finally {
      e.children = Ab(e.children), n ? e.selection = ps(n) ? Ab(n) : n : e.selection = null;
    }
  }
}, NI = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, FI = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, jS = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (sr(r) && sr(o)) {
      if (!jS(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function zI(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Ao(e, t) {
  if (e == null) return {};
  var n = zI(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var $I = ["anchor", "focus"];
function Fb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function UI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fb(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ae = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ae.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ae.edges(e);
    return t;
  },
  equals(e, t) {
    return ct.equals(e.anchor, t.anchor) && ct.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ae.isRange(t)) {
      if (ae.includes(e, t.anchor) || ae.includes(e, t.focus))
        return !0;
      var [n, r] = ae.edges(e), [o, i] = ae.edges(t);
      return ct.isBefore(n, o) && ct.isAfter(r, i);
    }
    var [s, a] = ae.edges(e), l = !1, u = !1;
    return ct.isPoint(t) ? (l = ct.compare(t, s) >= 0, u = ct.compare(t, a) <= 0) : (l = ne.compare(t, s.path) >= 0, u = ne.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Ao(e, $I), [r, o] = ae.edges(e), [i, s] = ae.edges(t), a = ct.isBefore(r, i) ? i : r, l = ct.isBefore(o, s) ? o : s;
    return ct.isBefore(l, a) ? null : UI({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return ct.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return ct.equals(t, n);
  },
  isExpanded(e) {
    return !ae.isCollapsed(e);
  },
  isForward(e) {
    return !ae.isBackward(e);
  },
  isRange(e) {
    return sr(e) && ct.isPoint(e.anchor) && ct.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ae.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return tv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = ae.isCollapsed(r);
        ae.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? ae.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = ct.transform(r.anchor, t, {
        affinity: i
      }), u = ct.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, zb = (e) => sr(e) && Ee.isNodeList(e.children) && !I.isEditor(e), Ae = {
  isAncestor(e) {
    return sr(e) && Ee.isNodeList(e.children);
  },
  isElement: zb,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ae.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return zb(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, WI = ["children"], VI = ["text"], $b = /* @__PURE__ */ new WeakMap(), Ee = {
  ancestor(e, t) {
    var n = Ee.get(e, t);
    if (Be.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(tr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ne.ancestors(t, n)) {
        var o = Ee.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Be.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(tr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(tr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Ee.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = Ee.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ne.common(t, n), o = Ee.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Ee.get(e, t);
    if (I.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(tr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ee.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ee.nodes(e, t))
        Ae.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ae.isAncestor(e)) {
      var t = Ao(e, WI);
      return t;
    } else {
      var t = Ao(e, VI);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Ee.get(e, n); r && !(Be.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Be.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(tr.stringify(e)));
    var n = tv({
      children: e.children
    }, (r) => {
      var [o, i] = ae.edges(t), s = Ee.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !ae.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!ae.includes(t, a)) {
          var l = Ee.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (ne.equals(a, i.path)) {
          var c = Ee.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (ne.equals(a, o.path)) {
          var p = Ee.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      I.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Be.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(tr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Be.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Be.isText(e) || Ae.isElement(e) || I.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = $b.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Ee.isNode(r));
    return $b.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Ee.get(e, n); r && !(Be.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Ee.get(e, t);
    if (!Be.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(tr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ne.levels(t, n)) {
        var o = Ee.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ae.isElement(e) && Ae.isElementProps(t) && Ae.matches(e, t) || Be.isText(e) && Be.isTextProps(t) && Be.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? ne.isBefore(a, i) : ne.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Be.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          ne.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = Ee.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = ne.next(a);
          if (Ee.has(e, c)) {
            a = c, l = Ee.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = ne.previous(a);
          a = p, l = Ee.get(e, a);
          continue;
        }
        a = ne.parent(a), l = Ee.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ne.parent(t), r = Ee.get(e, n);
    if (Be.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Be.isText(e) ? e.text : e.children.map(Ee.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ee.nodes(e, t))
        Be.isText(n) && (yield [n, r]);
    }();
  }
};
function Ub(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ub(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ub(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var di = {
  isNodeOperation(e) {
    return di.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!sr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ne.isPath(e.path) && Ee.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ne.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ne.isPath(e.path) && sr(e.properties);
      case "move_node":
        return ne.isPath(e.path) && ne.isPath(e.newPath);
      case "remove_node":
        return ne.isPath(e.path) && Ee.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ne.isPath(e.path);
      case "set_node":
        return ne.isPath(e.path) && sr(e.properties) && sr(e.newProperties);
      case "set_selection":
        return e.properties === null && ae.isRange(e.newProperties) || e.newProperties === null && ae.isRange(e.properties) || sr(e.properties) && sr(e.newProperties);
      case "split_node":
        return ne.isPath(e.path) && typeof e.position == "number" && sr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => di.isOperation(t));
  },
  isSelectionOperation(e) {
    return di.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return di.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return yn(yn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return yn(yn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return yn(yn({}, e), {}, {
          type: "split_node",
          path: ne.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ne.equals(t, n))
          return e;
        if (ne.isSibling(n, t))
          return yn(yn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ne.transform(n, e), o = ne.transform(ne.next(n), e);
        return yn(yn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return yn(yn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return yn(yn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return yn(yn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? yn(yn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? yn(yn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : yn(yn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return yn(yn({}, e), {}, {
          type: "merge_node",
          path: ne.next(e.path)
        });
    }
  }
}, Wb = /* @__PURE__ */ new WeakMap(), HI = (e) => {
  var t = Wb.get(e);
  if (t !== void 0)
    return t;
  if (!sr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || sr(e.marks)) && (e.selection === null || ae.isRange(e.selection)) && Ee.isNodeList(e.children) && di.isOperationList(e.operations);
  return Wb.set(e, n), n;
}, I = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return HI(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, qI = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(ne.isPath);
  }
};
function Vb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vb(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ct = {
  compare(e, t) {
    var n = ne.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return ct.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return ct.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ne.equals(e.path, t.path);
  },
  isPoint(e) {
    return sr(e) && typeof e.offset == "number" && ne.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return tv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ne.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ne.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ne.equals(t.path, i) && (r.offset += t.position), r.path = ne.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ne.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ne.equals(t.path, i) || ne.isAncestor(t.path, i))
            return null;
          r.path = ne.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ne.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = ne.transform(i, t, Hb(Hb({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ne.transform(i, t, n);
          break;
        }
      }
    });
  }
}, qb = void 0, tr = {
  setScrubber(e) {
    qb = e;
  },
  stringify(e) {
    return JSON.stringify(e, qb);
  }
}, ZI = ["text"], KI = ["anchor", "focus"];
function Zb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Oo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Zb(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Zb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Be = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Ao(i, ZI);
      return s;
    }
    return jS(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return sr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Be.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Oo({}, e)];
    for (var r of t) {
      var o = Ao(r, KI), [i, s] = ae.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var C = c - m;
          h = Oo(Oo({}, f), {}, {
            text: f.text.slice(C)
          }), f = Oo(Oo({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > m) {
          var w = u - m;
          g = Oo(Oo({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Oo(Oo({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, nv = (e) => e.selection ? e.selection : e.children.length > 0 ? I.end(e, []) : [0], zs = (e, t) => {
  var [n] = I.node(e, t);
  return (r) => r === n;
}, rv = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? eR(t) : t, i = Xe.None, s = Xe.None, a = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = dR(c, p);
    if ([i, s] = r ? [s, d] : [d, i], Ls(i, Xe.ZWJ) && Ls(s, Xe.ExtPict) && (r ? l = Kb(t.substring(0, a)) : l = Kb(t.substring(0, t.length - a)), !l) || Ls(i, Xe.RI) && Ls(s, Xe.RI) && (u !== null ? u = !u : r ? u = !0 : u = vR(t.substring(0, t.length - a)), !u) || i !== Xe.None && s !== Xe.None && hR(i, s))
      break;
    a += c.length;
  }
  return a || 1;
}, GI = /\s/, YI = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, XI = /['\u2018\u2019]/, JI = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = rv(t, n), [s, a] = ov(t, i, n);
    if (QI(s, a, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = a;
  }
  return r;
}, ov = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, QI = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (GI.test(t))
    return !1;
  if (XI.test(t)) {
    var o = rv(n, r), [i, s] = ov(n, o, r);
    if (e(i, s, r))
      return !0;
  }
  return !YI.test(t);
}, eR = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (nR(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (tR(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, tR = (e) => e >= 55296 && e <= 56319, nR = (e) => e >= 56320 && e <= 57343, Xe;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Xe || (Xe = {}));
var rR = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, oR = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, iR = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, sR = /^[\u1100-\u115F\uA960-\uA97C]$/, aR = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, lR = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, uR = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, cR = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, pR = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, dR = (e, t) => {
  var n = Xe.Any;
  return e.search(rR) !== -1 && (n |= Xe.Extend), t === 8205 && (n |= Xe.ZWJ), t >= 127462 && t <= 127487 && (n |= Xe.RI), e.search(oR) !== -1 && (n |= Xe.Prepend), e.search(iR) !== -1 && (n |= Xe.SpacingMark), e.search(sR) !== -1 && (n |= Xe.L), e.search(aR) !== -1 && (n |= Xe.V), e.search(lR) !== -1 && (n |= Xe.T), e.search(uR) !== -1 && (n |= Xe.LV), e.search(cR) !== -1 && (n |= Xe.LVT), e.search(pR) !== -1 && (n |= Xe.ExtPict), n;
};
function Ls(e, t) {
  return (e & t) !== 0;
}
var fR = [
  // GB6
  [Xe.L, Xe.L | Xe.V | Xe.LV | Xe.LVT],
  // GB7
  [Xe.LV | Xe.V, Xe.V | Xe.T],
  // GB8
  [Xe.LVT | Xe.T, Xe.T],
  // GB9
  [Xe.Any, Xe.Extend | Xe.ZWJ],
  // GB9a
  [Xe.Any, Xe.SpacingMark],
  // GB9b
  [Xe.Prepend, Xe.Any],
  // GB11
  [Xe.ZWJ, Xe.ExtPict],
  // GB12 and GB13
  [Xe.RI, Xe.RI]
];
function hR(e, t) {
  return fR.findIndex((n) => Ls(e, n[0]) && Ls(t, n[1])) === -1;
}
var gR = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, Kb = (e) => e.search(gR) !== -1, mR = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, vR = (e) => {
  var t = e.match(mR);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, yR = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    I.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = nv(e)
      } = n;
      if (ne.isPath(o) && (o = I.range(e, o)), ae.isRange(o))
        if (ae.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ae.end(o);
          if (!r && I.void(e, {
            at: i
          }))
            return;
          var s = ae.start(o), a = I.pointRef(e, s), l = I.pointRef(e, i);
          ve.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, ve.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && I.void(e, {
        at: o
      }) || I.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function Gb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Gb(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Gb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ve = Yl(Yl(Yl(Yl({}, RI), NI), FI), yR), fc = /* @__PURE__ */ new WeakMap(), bR = (e) => fc.get(e) || !1, wR = (e, t, n) => {
  var r = fc.get(e) || !1;
  fc.set(e, !0);
  try {
    t(), n();
  } finally {
    fc.set(e, r);
  }
};
function _S(e, t, n) {
  var r = Sc.get(e) || [], o = Mc.get(e) || /* @__PURE__ */ new Set(), i, s, a = (p) => {
    if (p) {
      var d = p.join(",");
      s.has(d) || (s.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], s = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      a(u);
    }
  } else
    i = r, s = o;
  for (var c of t)
    a(c);
  Sc.set(e, i), Mc.set(e, s);
}
var CR = (e, t) => {
  for (var n of I.pathRefs(e))
    TI.transform(n, t);
  for (var r of I.pointRefs(e))
    jI.transform(r, t);
  for (var o of I.rangeRefs(e))
    _I.transform(o, t);
  if (!bR(e)) {
    var i = ne.operationCanTransformPath(t) ? (s) => ne.transform(s, t) : void 0;
    _S(e, e.getDirtyPaths(t), i);
  }
  ve.transform(e, t), e.operations.push(t), I.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), ka.get(e) || (ka.set(e, !0), Promise.resolve().then(() => {
    ka.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, OR = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return ne.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = ne.levels(o), s = Be.isText(r) ? [] : Array.from(Ee.nodes(r), (N) => {
        var [, A] = N;
        return o.concat(A);
      });
      return [...i, ...s];
    }
    case "merge_node": {
      var {
        path: a
      } = t, l = ne.ancestors(a), u = ne.previous(a);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (ne.equals(c, p))
        return [];
      var d = [], m = [];
      for (var f of ne.ancestors(c)) {
        var g = ne.transform(f, t);
        d.push(g);
      }
      for (var h of ne.ancestors(p)) {
        var C = ne.transform(h, t);
        m.push(C);
      }
      var w = m[m.length - 1], S = p[p.length - 1], E = w.concat(S);
      return [...d, ...m, E];
    }
    case "remove_node": {
      var {
        path: v
      } = t, O = ne.ancestors(v);
      return [...O];
    }
    case "split_node": {
      var {
        path: P
      } = t, U = ne.levels(P), L = ne.next(P);
      return [...U, L];
    }
    default:
      return [];
  }
}, ER = (e) => {
  var {
    selection: t
  } = e;
  return t ? Ee.fragment(e, t) : [];
}, xR = (e, t) => {
  var [n, r] = t;
  if (!Be.isText(n)) {
    if (Ae.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      ve.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = I.isEditor(n) ? !1 : Ae.isElement(n) && (e.isInline(n) || n.children.length === 0 || Be.isText(n.children[0]) || e.isInline(n.children[0])), s = 0, a = 0; a < n.children.length; a++, s++) {
      var l = Ee.get(e, r);
      if (!Be.isText(l)) {
        var u = l.children[s], c = l.children[s - 1], p = a === n.children.length - 1, d = Be.isText(u) || Ae.isElement(u) && e.isInline(u);
        if (d !== i)
          ve.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--;
        else if (Ae.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !Be.isText(c)) {
              var m = {
                text: ""
              };
              ve.insertNodes(e, m, {
                at: r.concat(s),
                voids: !0
              }), s++;
            } else if (p) {
              var f = {
                text: ""
              };
              ve.insertNodes(e, f, {
                at: r.concat(s + 1),
                voids: !0
              }), s++;
            }
          }
        } else {
          if (!Be.isText(u) && !("children" in u)) {
            var g = u;
            g.children = [];
          }
          c != null && Be.isText(c) && (Be.equals(u, c, {
            loose: !0
          }) ? (ve.mergeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--) : c.text === "" ? (ve.removeNodes(e, {
            at: r.concat(s - 1),
            voids: !0
          }), s--) : u.text === "" && (ve.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--));
        }
      }
    }
  }
}, LR = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, DR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: s
  } = n;
  if (i) {
    var a = I.path(t, i), l = o === "lowest";
    for (var [u, c] of I.levels(t, {
      at: a,
      voids: r,
      match: s,
      reverse: l
    }))
      if (!Be.isText(u)) {
        if (ae.isRange(i)) {
          if (ne.isAncestor(c, i.anchor.path) && ne.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!ne.equals(a, c))
          return [u, c];
      }
  }
};
function Yb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yb(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PR = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!Be.isText(p))
        return !1;
      var [m, f] = I.parent(e, d);
      return !e.isVoid(m) || e.markableVoid(m);
    }, i = ae.isExpanded(r), s = !1;
    if (!i) {
      var [a, l] = I.node(e, r);
      if (a && o(a, l)) {
        var [u] = I.parent(e, l);
        s = u && e.markableVoid(u);
      }
    }
    if (i || s)
      ve.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = Xb(Xb({}, I.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, ka.get(e) || e.onChange();
    }
  }
};
function Jb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jb(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = I.point(t, n, {
    edge: "end"
  }), i = I.end(t, []), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of I.positions(t, Qb(Qb({}, r), {}, {
    at: s
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function e0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function t0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e0(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = I.start(t, []), i = I.point(t, n, {
    edge: "start"
  }), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of I.positions(t, t0(t0({}, r), {}, {
    at: s,
    reverse: !0
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, MR = (e, t) => {
  var {
    selection: n
  } = e;
  n && ae.isCollapsed(n) && ve.delete(e, {
    unit: t,
    reverse: !0
  });
}, TR = (e, t) => {
  var {
    selection: n
  } = e;
  n && ae.isCollapsed(n) && ve.delete(e, {
    unit: t
  });
}, jR = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && ae.isExpanded(r) && ve.delete(t, {
    reverse: n === "backward"
  });
}, _R = (e, t) => [I.start(e, t), I.end(e, t)];
function n0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function r0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? n0(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : n0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var AR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return I.above(t, r0(r0({}, n), {}, {
    match: (r) => Ae.isElement(r) && I.isElementReadOnly(t, r)
  }));
}, BR = (e, t) => I.point(e, t, {
  edge: "end"
}), IR = (e, t) => {
  var n = I.path(e, t, {
    edge: "start"
  });
  return I.node(e, n);
}, RR = (e, t) => {
  var n = I.range(e, t);
  return Ee.fragment(e, n);
};
function o0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function i0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? o0(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NR = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return I.above(t, i0(i0({}, n), {}, {
    match: (r) => Ae.isElement(r) && I.isVoid(t, r)
  }));
}, FR = (e, t) => t.children.some((n) => Ae.isElement(n) && I.isBlock(e, n)), zR = (e, t) => t.children.some((n) => Be.isText(n) || I.isInline(e, n)), $R = (e, t) => Ee.has(e, t), UR = (e, t) => t.children.every((n) => Be.isText(n)), WR = (e) => {
  ve.splitNodes(e, {
    always: !0
  });
}, VR = (e, t, n) => {
  ve.insertNodes(e, t, n);
}, HR = (e) => {
  ve.splitNodes(e, {
    always: !0
  });
};
function s0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s0(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZR = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var s = qR({
        text: n
      }, i);
      ve.insertNodes(t, s, {
        at: r.at,
        voids: r.voids
      });
    } else
      ve.insertText(t, n, r);
    t.marks = null;
  }
}, KR = (e, t) => !e.isInline(t), GR = (e, t, n) => I.isStart(e, t, n) || I.isEnd(e, t, n), YR = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && Be.isText(r) && r.text === "" && !e.isVoid(t);
}, XR = (e, t, n) => {
  var r = I.end(e, n);
  return ct.equals(t, r);
}, JR = (e) => {
  var t = TS.get(e);
  return t === void 0 ? !0 : t;
}, QR = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = I.start(e, n);
  return ct.equals(t, r);
}, eN = (e, t) => {
  var n = I.path(e, t, {
    edge: "end"
  });
  return I.node(e, n);
}, tN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = I.path(t, n, r), i = Ee.leaf(t, o);
  return [i, o];
};
function nN(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var s = [], a = I.path(e, n);
      for (var [l, u] of Ee.levels(e, a))
        if (i(l, u) && (s.push([l, u]), !o && Ae.isElement(l) && I.isVoid(e, l)))
          break;
      r && s.reverse(), yield* s;
    }
  }();
}
var rN = ["text"], oN = ["text"], iN = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (ae.isExpanded(r)) {
    var s = I.isEnd(t, o, o.path);
    if (s) {
      var a = I.after(t, o);
      a && (o = a);
    }
    var [l] = I.nodes(t, {
      match: Be.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Ao(u, rN);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = I.leaf(t, p);
  if (o.offset === 0) {
    var m = I.previous(t, {
      at: p,
      match: Be.isText
    }), f = I.above(t, {
      match: (E) => Ae.isElement(E) && I.isVoid(t, E) && t.markableVoid(E)
    });
    if (!f) {
      var g = I.above(t, {
        match: (E) => Ae.isElement(E) && I.isBlock(t, E)
      });
      if (m && g) {
        var [h, C] = m, [, w] = g;
        ne.isAncestor(w, C) && (d = h);
      }
    }
  }
  var S = Ao(d, oN);
  return S;
}, sN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = I.after(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = I.last(t, []), u = [a.path, l];
      if (ne.isPath(s) && s.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (ne.isPath(s)) {
          var [c] = I.parent(t, s);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = I.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, aN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = I.path(t, n, r), i = Ee.get(t, o);
  return [i, o];
};
function lN(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: s = !1,
      ignoreNonSelectable: a = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (qI.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = I.path(e, n, {
          edge: "start"
        }), d = I.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var m = Ee.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (E) => {
          var [v] = E;
          return Ae.isElement(v) ? !!(!s && (I.isVoid(e, v) || I.isElementReadOnly(e, v)) || a && !I.isSelectable(e, v)) : !1;
        }
      }), f = [], g;
      for (var [h, C] of m)
        if (!(a && Ae.isElement(h) && !I.isSelectable(e, h))) {
          var w = g && ne.compare(C, g[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(h, C)) {
              if (o && !w && Be.isText(h))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              g = [h, C];
              continue;
            }
            var S = r === "lowest" ? g : [h, C];
            S && (o ? f.push(S) : yield S), g = [h, C];
          }
        }
      r === "lowest" && g && (o ? f.push(g) : yield g), o && (yield* f);
    }
  }();
}
var uN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Sc.get(c) || [], s = (c) => Mc.get(c) || /* @__PURE__ */ new Set(), a = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return s(c).delete(d), p;
  };
  if (I.isNormalizing(t)) {
    if (r) {
      var l = Array.from(Ee.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      Sc.set(t, l), Mc.set(t, u);
    }
    i(t).length !== 0 && I.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (Ee.has(t, c)) {
          var p = I.node(t, c), [d, m] = p;
          Ae.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), g = f.length, h = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: h,
          initialDirtyPathsLength: g,
          operation: o
        }))
          return;
        var C = a(t);
        if (Ee.has(t, C)) {
          var w = I.node(t, C);
          t.normalizeNode(w, {
            operation: o
          });
        }
        h++, f = i(t);
      }
    });
  }
}, cN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = I.path(t, n, r), i = ne.parent(o), s = I.node(t, i);
  return s;
}, pN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = I.pathRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = I.pathRefs(t);
  return s.add(i), i;
}, dN = (e) => {
  var t = Bb.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Bb.set(e, t)), t;
}, fN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (ne.isPath(n)) {
    if (i === "start") {
      var [, s] = Ee.first(t, n);
      n = s;
    } else if (i === "end") {
      var [, a] = Ee.last(t, n);
      n = a;
    }
  }
  return ae.isRange(n) && (i === "start" ? n = ae.start(n) : i === "end" ? n = ae.end(n) : n = ne.common(n.anchor.path, n.focus.path)), ct.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, hN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = I.pointRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = I.pointRefs(t);
  return s.add(i), i;
}, gN = (e) => {
  var t = Ib.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Ib.set(e, t)), t;
}, mN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (ne.isPath(n)) {
    var i;
    if (o === "end") {
      var [, s] = Ee.last(t, n);
      i = s;
    } else {
      var [, a] = Ee.first(t, n);
      i = a;
    }
    var l = Ee.get(t, i);
    if (!Be.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (ae.isRange(n)) {
    var [u, c] = ae.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function vN(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: s = !1
    } = t;
    if (!n)
      return;
    var a = I.range(e, n), [l, u] = ae.edges(a), c = o ? u : l, p = !1, d = "", m = 0, f = 0, g = 0;
    for (var [h, C] of I.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: s
    })) {
      if (Ae.isElement(h)) {
        if (!i && (e.isVoid(h) || e.isElementReadOnly(h))) {
          yield I.start(e, C);
          continue;
        }
        if (e.isInline(h)) continue;
        if (I.hasInlines(e, h)) {
          var w = ne.isAncestor(C, u.path) ? u : I.end(e, C), S = ne.isAncestor(C, l.path) ? l : I.start(e, C);
          d = I.string(e, {
            anchor: S,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (Be.isText(h)) {
        var E = ne.equals(C, c.path);
        for (E ? (f = o ? c.offset : h.text.length - c.offset, g = c.offset) : (f = h.text.length, g = o ? f : 0), (E || p || r === "offset") && (yield {
          path: C,
          offset: g
        }, p = !1); ; ) {
          if (m === 0) {
            if (d === "") break;
            m = v(d, r, o), d = ov(d, m, o)[1];
          }
          if (g = o ? g - m : g + m, f = f - m, f < 0) {
            m = -f;
            break;
          }
          m = 0, yield {
            path: C,
            offset: g
          };
        }
      }
    }
    function v(O, P, U) {
      return P === "character" ? rv(O, U) : P === "word" ? JI(O, U) : P === "line" || P === "block" ? O.length : 1;
    }
  }();
}
var yN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = I.before(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = I.first(t, []), u = [a.path, l];
      if (ne.isPath(s) && s.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (ne.isPath(s)) {
          var [c] = I.parent(t, s);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = I.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, bN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = I.rangeRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = I.rangeRefs(t);
  return s.add(i), i;
}, wN = (e) => {
  var t = Rb.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Rb.set(e, t)), t;
}, CN = (e, t, n) => {
  if (ae.isRange(t) && !n)
    return t;
  var r = I.start(e, t), o = I.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function a0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ON(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a0(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EN = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!Be.isText(c))
        return !1;
      var [d, m] = I.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = ae.isExpanded(n), i = !1;
    if (!o) {
      var [s, a] = I.node(e, n);
      if (s && r(s, a)) {
        var [l] = I.parent(e, a);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      ve.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = ON({}, I.marks(e) || {});
      delete u[t], e.marks = u, ka.get(e) || e.onChange();
    }
  }
}, xN = (e, t) => {
  TS.set(e, t);
}, LN = (e, t) => I.point(e, t, {
  edge: "start"
}), DN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = I.range(t, n), [s, a] = ae.edges(i), l = "";
  for (var [u, c] of I.nodes(t, {
    at: i,
    match: Be.isText,
    voids: o
  })) {
    var p = u.text;
    ne.equals(c, a.path) && (p = p.slice(0, a.offset)), ne.equals(c, s.path) && (p = p.slice(s.offset)), l += p;
  }
  return l;
}, PN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, s] = ae.edges(n);
  if (i.offset !== 0 || s.offset !== 0 || ae.isCollapsed(n) || ne.hasPrevious(s.path))
    return n;
  var a = I.above(t, {
    at: s,
    match: (f) => Ae.isElement(f) && I.isBlock(t, f),
    voids: o
  }), l = a ? a[1] : [], u = I.start(t, i), c = {
    anchor: u,
    focus: s
  }, p = !0;
  for (var [d, m] of I.nodes(t, {
    at: c,
    match: Be.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || ne.isBefore(m, l)) {
      s = {
        path: m,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: s
  };
}, kN = (e, t) => {
  var n = I.isNormalizing(e);
  I.setNormalizing(e, !1);
  try {
    t();
  } finally {
    I.setNormalizing(e, n);
  }
  I.normalize(e);
}, SN = (e, t, n) => {
  var [r, o] = t;
  return Ae.isElement(r) && I.isEmpty(e, r) || Be.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, MN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  I.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: s = "character",
      distance: a = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (ae.isRange(u) && ae.isCollapsed(u) && (p = !0, u = u.anchor), ct.isPoint(u)) {
        var d = I.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, m] = d;
          u = m;
        } else {
          var f = {
            unit: s,
            distance: a
          }, g = i ? I.before(t, u, f) || I.start(t, []) : I.after(t, u, f) || I.end(t, []);
          u = {
            anchor: u,
            focus: g
          }, c = !0;
        }
      }
      if (ne.isPath(u)) {
        ve.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!ae.isCollapsed(u)) {
        if (!c) {
          var [, h] = ae.edges(u), C = I.end(t, []);
          ct.equals(h, C) || (u = I.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, S] = ae.edges(u), E = I.above(t, {
          match: (ye) => Ae.isElement(ye) && I.isBlock(t, ye),
          at: w,
          voids: l
        }), v = I.above(t, {
          match: (ye) => Ae.isElement(ye) && I.isBlock(t, ye),
          at: S,
          voids: l
        }), O = E && v && !ne.equals(E[1], v[1]), P = ne.equals(w.path, S.path), U = l ? null : (r = I.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : I.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), L = l ? null : (o = I.void(t, {
          at: S,
          mode: "highest"
        })) !== null && o !== void 0 ? o : I.elementReadOnly(t, {
          at: S,
          mode: "highest"
        });
        if (U) {
          var N = I.before(t, w);
          N && E && ne.isAncestor(E[1], N.path) && (w = N);
        }
        if (L) {
          var A = I.after(t, S);
          A && v && ne.isAncestor(v[1], A.path) && (S = A);
        }
        var z = [], V;
        for (var $ of I.nodes(t, {
          at: u,
          voids: l
        })) {
          var [Z, J] = $;
          V && ne.compare(J, V) === 0 || (!l && Ae.isElement(Z) && (I.isVoid(t, Z) || I.isElementReadOnly(t, Z)) || !ne.isCommon(J, w.path) && !ne.isCommon(J, S.path)) && (z.push($), V = J);
        }
        var Y = Array.from(z, (ye) => {
          var [, oe] = ye;
          return I.pathRef(t, oe);
        }), te = I.pointRef(t, w), ee = I.pointRef(t, S), k = "";
        if (!P && !U) {
          var _ = te.current, [K] = I.leaf(t, _), {
            path: M
          } = _, {
            offset: G
          } = w, x = K.text.slice(G);
          x.length > 0 && (t.apply({
            type: "remove_text",
            path: M,
            offset: G,
            text: x
          }), k = x);
        }
        if (Y.reverse().map((ye) => ye.unref()).filter((ye) => ye !== null).forEach((ye) => ve.removeNodes(t, {
          at: ye,
          voids: l
        })), !L) {
          var T = ee.current, [F] = I.leaf(t, T), {
            path: j
          } = T, H = P ? w.offset : 0, B = F.text.slice(H, S.offset);
          B.length > 0 && (t.apply({
            type: "remove_text",
            path: j,
            offset: H,
            text: B
          }), k = B);
        }
        !P && O && ee.current && te.current && ve.mergeNodes(t, {
          at: ee.current,
          hanging: !0,
          voids: l
        }), p && i && s === "character" && k.length > 1 && k.match(/[\u0E00-\u0E7F]+/) && ve.insertText(t, k.slice(0, k.length - a));
        var Q = te.unref(), W = ee.unref(), ue = i ? Q || W : W || Q;
        n.at == null && ue && ve.select(t, ue);
      }
    }
  });
}, TN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  I.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: s = nv(t),
      batchDirty: a = !0
    } = r;
    if (n.length) {
      if (ae.isRange(s))
        if (o || (s = I.unhangRange(t, s, {
          voids: i
        })), ae.isCollapsed(s))
          s = s.anchor;
        else {
          var [, l] = ae.edges(s);
          if (!i && I.void(t, {
            at: l
          }))
            return;
          var u = I.pointRef(t, l);
          ve.delete(t, {
            at: s
          }), s = u.unref();
        }
      else ne.isPath(s) && (s = I.start(t, s));
      if (!(!i && I.void(t, {
        at: s
      }))) {
        var c = I.above(t, {
          at: s,
          match: (x) => Ae.isElement(x) && I.isInline(t, x),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (I.isEnd(t, s, p)) {
            var d = I.after(t, p);
            s = d;
          } else if (I.isStart(t, s, p)) {
            var m = I.before(t, p);
            s = m;
          }
        }
        var f = I.above(t, {
          match: (x) => Ae.isElement(x) && I.isBlock(t, x),
          at: s,
          voids: i
        }), [, g] = f, h = I.isStart(t, s, g), C = I.isEnd(t, s, g), w = h && C, S = !h || h && C, E = !C, [, v] = Ee.first({
          children: n
        }, []), [, O] = Ee.last({
          children: n
        }, []), P = [], U = (x) => {
          var [T, F] = x, j = F.length === 0;
          return j ? !1 : w ? !0 : !(S && ne.isAncestor(F, v) && Ae.isElement(T) && !t.isVoid(T) && !t.isInline(T) || E && ne.isAncestor(F, O) && Ae.isElement(T) && !t.isVoid(T) && !t.isInline(T));
        };
        for (var L of Ee.nodes({
          children: n
        }, {
          pass: U
        }))
          U(L) && P.push(L);
        var N = [], A = [], z = [], V = !0, $ = !1;
        for (var [Z] of P)
          Ae.isElement(Z) && !t.isInline(Z) ? (V = !1, $ = !0, A.push(Z)) : V ? N.push(Z) : z.push(Z);
        var [J] = I.nodes(t, {
          at: s,
          match: (x) => Be.isText(x) || I.isInline(t, x),
          mode: "highest",
          voids: i
        }), [, Y] = J, te = I.isStart(t, s, Y), ee = I.isEnd(t, s, Y), k = I.pathRef(t, C && !z.length ? ne.next(g) : g), _ = I.pathRef(t, ee ? ne.next(Y) : Y);
        ve.splitNodes(t, {
          at: s,
          match: (x) => $ ? Ae.isElement(x) && I.isBlock(t, x) : Be.isText(x) || I.isInline(t, x),
          mode: $ ? "lowest" : "highest",
          always: $ && (!h || N.length > 0) && (!C || z.length > 0),
          voids: i
        });
        var K = I.pathRef(t, !te || te && ee ? ne.next(Y) : Y);
        if (ve.insertNodes(t, N, {
          at: K.current,
          match: (x) => Be.isText(x) || I.isInline(t, x),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), w && !N.length && A.length && !z.length && ve.delete(t, {
          at: g,
          voids: i
        }), ve.insertNodes(t, A, {
          at: k.current,
          match: (x) => Ae.isElement(x) && I.isBlock(t, x),
          mode: "lowest",
          voids: i,
          batchDirty: a
        }), ve.insertNodes(t, z, {
          at: _.current,
          match: (x) => Be.isText(x) || I.isInline(t, x),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), !r.at) {
          var M;
          if (z.length > 0 && _.current ? M = ne.previous(_.current) : A.length > 0 && k.current ? M = ne.previous(k.current) : K.current && (M = ne.previous(K.current)), M) {
            var G = I.end(t, M);
            ve.select(t, G);
          }
        }
        K.unref(), k.unref(), _.unref();
      }
    }
  });
}, jN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      ve.select(t, o.anchor);
    else if (r === "focus")
      ve.select(t, o.focus);
    else if (r === "start") {
      var [i] = ae.edges(o);
      ve.select(t, i);
    } else if (r === "end") {
      var [, s] = ae.edges(o);
      ve.select(t, s);
    }
  } else return;
}, _N = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, AN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: s = !1
  } = n, {
    edge: a = null
  } = n;
  if (r) {
    a === "start" && (a = ae.isBackward(r) ? "focus" : "anchor"), a === "end" && (a = ae.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (a == null || a === "anchor") {
      var d = s ? I.before(t, l, c) : I.after(t, l, c);
      d && (p.anchor = d);
    }
    if (a == null || a === "focus") {
      var m = s ? I.before(t, u, c) : I.after(t, u, c);
      m && (p.focus = m);
    }
    ve.setSelection(t, p);
  }
}, BN = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = I.range(e, t), n) {
    ve.setSelection(e, t);
    return;
  }
  if (!ae.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(tr.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function l0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function u0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? l0(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = ae.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = ae.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: s,
      focus: a
    } = o, l = i === "anchor" ? s : a;
    ve.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: u0(u0({}, l), n)
    });
  }
}, RN = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !ct.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !ct.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, NN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  I.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: s = "lowest",
      batchDirty: a = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (Ee.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = nv(t), c !== !1 && (c = !0)), c == null && (c = !1), ae.isRange(l))
        if (o || (l = I.unhangRange(t, l, {
          voids: i
        })), ae.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = ae.edges(l), m = I.pointRef(t, d);
          ve.delete(t, {
            at: l
          }), l = m.unref();
        }
      if (ct.isPoint(l)) {
        u == null && (Be.isText(p) ? u = (N) => Be.isText(N) : t.isInline(p) ? u = (N) => Be.isText(N) || I.isInline(t, N) : u = (N) => Ae.isElement(N) && I.isBlock(t, N));
        var [f] = I.nodes(t, {
          at: l.path,
          match: u,
          mode: s,
          voids: i
        });
        if (f) {
          var [, g] = f, h = I.pathRef(t, g), C = I.isEnd(t, l, g);
          ve.splitNodes(t, {
            at: l,
            match: u,
            mode: s,
            voids: i
          });
          var w = h.unref();
          l = C ? ne.next(w) : w;
        } else
          return;
      }
      var S = ne.parent(l), E = l[l.length - 1];
      if (!(!i && I.void(t, {
        at: S
      }))) {
        if (a) {
          var v = [], O = ne.levels(S);
          wR(t, () => {
            var N = function() {
              var V = S.concat(E);
              E++;
              var $ = {
                type: "insert_node",
                path: V,
                node: A
              };
              t.apply($), l = ne.next(l), v.push($), Be.isText ? O.push(...Array.from(Ee.nodes(A), (Z) => {
                var [, J] = Z;
                return V.concat(J);
              })) : O.push(V);
            };
            for (var A of n)
              N();
          }, () => {
            _S(t, O, (N) => {
              var A = N;
              for (var z of v)
                if (ne.operationCanTransformPath(z) && (A = ne.transform(A, z), !A))
                  return null;
              return A;
            });
          });
        } else
          for (var P of n) {
            var U = S.concat(E);
            E++, t.apply({
              type: "insert_node",
              path: U,
              node: P
            }), l = ne.next(l);
          }
        if (l = ne.previous(l), c) {
          var L = I.end(t, l);
          L && ve.select(t, L);
        }
      }
    }
  });
}, FN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  I.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: s
    } = n;
    if (s == null && (s = ne.isPath(r) ? zs(t, r) : (E) => Ae.isElement(E) && I.isBlock(t, E)), !!r) {
      var a = I.nodes(t, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), l = Array.from(a, (E) => {
        var [, v] = E;
        return I.pathRef(t, v);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = I.node(t, ne.parent(c)), [d, m] = p, f = c[c.length - 1], {
          length: g
        } = d.children;
        if (g === 1) {
          var h = ne.next(m);
          ve.moveNodes(t, {
            at: c,
            to: h,
            voids: i
          }), ve.removeNodes(t, {
            at: m,
            voids: i
          });
        } else if (f === 0)
          ve.moveNodes(t, {
            at: c,
            to: m,
            voids: i
          });
        else if (f === g - 1) {
          var C = ne.next(m);
          ve.moveNodes(t, {
            at: c,
            to: C,
            voids: i
          });
        } else {
          var w = ne.next(c), S = ne.next(m);
          ve.splitNodes(t, {
            at: w,
            voids: i
          }), ve.moveNodes(t, {
            at: c,
            to: S,
            voids: i
          });
        }
      }
    }
  });
}, zN = ["text"], $N = ["children"], AS = (e, t) => {
  if (Ae.isElement(t)) {
    var n = t;
    return I.isVoid(e, t) ? !0 : n.children.length === 1 ? AS(e, n.children[0]) : !1;
  } else return !I.isEditor(t);
}, UN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  I.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: s = !1,
      mode: a = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (ne.isPath(o)) {
          var [l] = I.parent(t, o);
          r = (N) => l.children.includes(N);
        } else
          r = (N) => Ae.isElement(N) && I.isBlock(t, N);
      if (!i && ae.isRange(o) && (o = I.unhangRange(t, o, {
        voids: s
      })), ae.isRange(o))
        if (ae.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = ae.edges(o), c = I.pointRef(t, u);
          ve.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && ve.select(t, o);
        }
      var [p] = I.nodes(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      }), d = I.previous(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      });
      if (!(!p || !d)) {
        var [m, f] = p, [g, h] = d;
        if (!(f.length === 0 || h.length === 0)) {
          var C = ne.next(h), w = ne.common(f, h), S = ne.isSibling(f, h), E = Array.from(I.levels(t, {
            at: f
          }), (N) => {
            var [A] = N;
            return A;
          }).slice(w.length).slice(0, -1), v = I.above(t, {
            at: f,
            mode: "highest",
            match: (N) => E.includes(N) && AS(t, N)
          }), O = v && I.pathRef(t, v[1]), P, U;
          if (Be.isText(m) && Be.isText(g)) {
            var L = Ao(m, zN);
            U = g.text.length, P = L;
          } else if (Ae.isElement(m) && Ae.isElement(g)) {
            var L = Ao(m, $N);
            U = g.children.length, P = L;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(tr.stringify(m), " ").concat(tr.stringify(g)));
          S || ve.moveNodes(t, {
            at: f,
            to: C,
            voids: s
          }), O && ve.removeNodes(t, {
            at: O.current,
            voids: s
          }), I.shouldMergeNodesRemovePrevNode(t, d, p) ? ve.removeNodes(t, {
            at: h,
            voids: s
          }) : t.apply({
            type: "merge_node",
            path: C,
            position: U,
            properties: P
          }), O && O.unref();
        }
      }
    }
  });
}, WN = (e, t) => {
  I.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: s
    } = t;
    if (r) {
      s == null && (s = ne.isPath(r) ? zs(e, r) : (m) => Ae.isElement(m) && I.isBlock(e, m));
      var a = I.pathRef(e, n), l = I.nodes(e, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), u = Array.from(l, (m) => {
        var [, f] = m;
        return I.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = a.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), a.current && ne.isSibling(d, p) && ne.isAfter(d, p) && (a.current = ne.next(a.current));
      }
      a.unref();
    }
  });
}, VN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  I.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = ne.isPath(s) ? zs(t, s) : (m) => Ae.isElement(m) && I.isBlock(t, m)), !r && ae.isRange(s) && (s = I.unhangRange(t, s, {
        voids: o
      }));
      var l = I.nodes(t, {
        at: s,
        match: a,
        mode: i,
        voids: o
      }), u = Array.from(l, (m) => {
        var [, f] = m;
        return I.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = I.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, HN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  I.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: s,
      merge: a
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = ne.isPath(i) ? zs(t, i) : (U) => Ae.isElement(U) && I.isBlock(t, U)), !l && ae.isRange(i) && (i = I.unhangRange(t, i, {
        voids: p
      })), c && ae.isRange(i)) {
        if (ae.isCollapsed(i) && I.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = I.rangeRef(t, i, {
          affinity: "inward"
        }), [m, f] = ae.edges(i), g = u === "lowest" ? "lowest" : "highest", h = I.isEnd(t, f, f.path);
        ve.splitNodes(t, {
          at: f,
          match: o,
          mode: g,
          voids: p,
          always: !h
        });
        var C = I.isStart(t, m, m.path);
        ve.splitNodes(t, {
          at: m,
          match: o,
          mode: g,
          voids: p,
          always: !C
        }), i = d.unref(), r.at == null && ve.select(t, i);
      }
      s || (s = (U, L) => U !== L);
      for (var [w, S] of I.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var E = {}, v = {};
        if (S.length !== 0) {
          var O = !1;
          for (var P in n)
            P === "children" || P === "text" || s(n[P], w[P]) && (O = !0, w.hasOwnProperty(P) && (E[P] = w[P]), a ? n[P] != null && (v[P] = a(w[P], n[P])) : n[P] != null && (v[P] = n[P]));
          O && t.apply({
            type: "set_node",
            path: S,
            properties: E,
            newProperties: v
          });
        }
      }
    }
  });
}, qN = (e, t) => {
  if (ae.isCollapsed(t))
    return t.anchor;
  var [, n] = ae.edges(t), r = I.pointRef(e, n);
  return ve.delete(e, {
    at: t
  }), r.unref();
}, ZN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  I.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: s = t.selection,
      height: a = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (ee) => Ae.isElement(ee) && I.isBlock(t, ee)), ae.isRange(s) && (s = qN(t, s)), ne.isPath(s)) {
      var u = s, c = I.point(t, u), [p] = I.parent(t, u);
      i = (ee) => ee === p, a = c.path.length - u.length + 1, s = c, l = !0;
    }
    if (s) {
      var d = I.pointRef(t, s, {
        affinity: "backward"
      }), m;
      try {
        var [f] = I.nodes(t, {
          at: s,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var g = I.void(t, {
          at: s,
          mode: "highest"
        }), h = 0;
        if (!o && g) {
          var [C, w] = g;
          if (Ae.isElement(C) && t.isInline(C)) {
            var S = I.after(t, w);
            if (!S) {
              var E = {
                text: ""
              }, v = ne.next(w);
              ve.insertNodes(t, E, {
                at: v,
                voids: o
              }), S = I.point(t, v);
            }
            s = S, l = !0;
          }
          var O = s.path.length - w.length;
          a = O + 1, l = !0;
        }
        m = I.pointRef(t, s);
        var P = s.path.length - a, [, U] = f, L = s.path.slice(0, P), N = a === 0 ? s.offset : s.path[P] + h;
        for (var [A, z] of I.levels(t, {
          at: L,
          reverse: !0,
          voids: o
        })) {
          var V = !1;
          if (z.length < U.length || z.length === 0 || !o && Ae.isElement(A) && I.isVoid(t, A))
            break;
          var $ = d.current, Z = I.isEnd(t, $, z);
          if (l || !d || !I.isEdge(t, $, z)) {
            V = !0;
            var J = Ee.extractProps(A);
            t.apply({
              type: "split_node",
              path: z,
              position: N,
              properties: J
            });
          }
          N = z[z.length - 1] + (V || Z ? 1 : 0);
        }
        if (n.at == null) {
          var Y = m.current || I.end(t, []);
          ve.select(t, Y);
        }
      } finally {
        var te;
        d.unref(), (te = m) === null || te === void 0 || te.unref();
      }
    }
  });
}, KN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  ve.setNodes(t, o, r);
}, GN = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  I.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = ne.isPath(s) ? zs(t, s) : (m) => Ae.isElement(m) && I.isBlock(t, m)), ne.isPath(s) && (s = I.range(t, s));
      var l = ae.isRange(s) ? I.rangeRef(t, s) : null, u = I.nodes(t, {
        at: s,
        match: a,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (m) => {
          var [, f] = m;
          return I.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [g] = I.node(t, f), h = I.range(t, f);
        o && l && (h = ae.intersection(l.current, h)), ve.liftNodes(t, {
          at: h,
          match: (C) => Ae.isAncestor(g) && g.children.includes(C),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function c0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function p0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c0(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YN = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  I.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: s = !1
    } = r, {
      match: a,
      at: l = t.selection
    } = r;
    if (l) {
      if (a == null && (ne.isPath(l) ? a = zs(t, l) : t.isInline(n) ? a = (h) => Ae.isElement(h) && I.isInline(t, h) || Be.isText(h) : a = (h) => Ae.isElement(h) && I.isBlock(t, h)), i && ae.isRange(l)) {
        var [u, c] = ae.edges(l), p = I.rangeRef(t, l, {
          affinity: "inward"
        });
        ve.splitNodes(t, {
          at: c,
          match: a,
          voids: s
        }), ve.splitNodes(t, {
          at: u,
          match: a,
          voids: s
        }), l = p.unref(), r.at == null && ve.select(t, l);
      }
      var d = Array.from(I.nodes(t, {
        at: l,
        match: t.isInline(n) ? (h) => Ae.isElement(h) && I.isBlock(t, h) : (h) => I.isEditor(h),
        mode: "lowest",
        voids: s
      })), m = function() {
        var C = ae.isRange(l) ? ae.intersection(l, I.range(t, g)) : l;
        if (!C)
          return 0;
        var w = Array.from(I.nodes(t, {
          at: C,
          match: a,
          mode: o,
          voids: s
        }));
        if (w.length > 0) {
          var [S] = w, E = w[w.length - 1], [, v] = S, [, O] = E;
          if (v.length === 0 && O.length === 0)
            return 0;
          var P = ne.equals(v, O) ? ne.parent(v) : ne.common(v, O), U = I.range(t, v, O), L = I.node(t, P), [N] = L, A = P.length + 1, z = ne.next(O.slice(0, A)), V = p0(p0({}, n), {}, {
            children: []
          });
          ve.insertNodes(t, V, {
            at: z,
            voids: s
          }), ve.moveNodes(t, {
            at: U,
            match: ($) => Ae.isAncestor(N) && N.children.includes($),
            to: z.concat(0),
            voids: s
          });
        }
      }, f;
      for (var [, g] of d)
        f = m();
    }
  });
}, XN = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CR(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PR(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MR(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TR(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jR(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ER(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WR(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return HR(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TN(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VR(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZR(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xR(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EN(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OR(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LR(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DR(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kR(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SR(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jN(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MN(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _N(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _R(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AR(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BR(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IR(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RR(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iN(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FR(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zR(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $R(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UR(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NN(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return KR(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GR(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return YR(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return XR(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return JR(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return QR(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eN(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tN(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nN(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FN(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UN(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AN(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WN(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sN(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aN(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lN(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uN(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cN(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fN(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pN(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dN(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mN(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hN(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gN(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vN(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yN(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CN(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bN(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wN(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VN(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BN(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return HN(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xN(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IN(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RN(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZN(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LN(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DN(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PN(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return KN(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GN(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NR(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kN(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return YN(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SN(e, ...r);
    }
  };
  return e;
};
const BS = (e) => {
  if (Be.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (Ae.isElement(e)) {
    const t = e.children.map((r) => BS(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, Yae = (e) => e.map((t) => BS(t)).join("");
var IS = {}, iv = {}, sv = {};
Object.defineProperty(sv, "__esModule", { value: !0 });
sv.default = tF;
var d0 = "html", f0 = "head", Xl = "body", JN = /<([a-zA-Z]+[0-9]?)/, h0 = /<head[^]*>/i, g0 = /<body[^]*>/i, Tc = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Dg = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, m0 = typeof window == "object" && window.DOMParser;
if (typeof m0 == "function") {
  var QN = new m0(), eF = "text/html";
  Dg = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), QN.parseFromString(e, eF);
  }, Tc = Dg;
}
if (typeof document == "object" && document.implementation) {
  var Jl = document.implementation.createHTMLDocument();
  Tc = function(e, t) {
    if (t) {
      var n = Jl.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Jl;
    }
    return Jl.documentElement.innerHTML = e, Jl;
  };
}
var Ql = typeof document == "object" && document.createElement("template"), Pg;
Ql && Ql.content && (Pg = function(e) {
  return Ql.innerHTML = e, Ql.content.childNodes;
});
function tF(e) {
  var t, n, r = e.match(JN), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case d0: {
      var i = Dg(e);
      if (!h0.test(e)) {
        var s = i.querySelector(f0);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!g0.test(e)) {
        var s = i.querySelector(Xl);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(d0);
    }
    case f0:
    case Xl: {
      var a = Tc(e).querySelectorAll(o);
      return g0.test(e) && h0.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Pg)
        return Pg(e);
      var s = Tc(e, Xl).querySelector(Xl);
      return s.childNodes;
    }
  }
}
var Hp = {}, av = {}, lv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(lv);
var mt = {}, bi = tn && tn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Sa = tn && tn.__assign || function() {
  return Sa = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Sa.apply(this, arguments);
};
Object.defineProperty(mt, "__esModule", { value: !0 });
mt.cloneNode = mt.hasChildren = mt.isDocument = mt.isDirective = mt.isComment = mt.isText = mt.isCDATA = mt.isTag = mt.Element = mt.Document = mt.CDATA = mt.NodeWithChildren = mt.ProcessingInstruction = mt.Comment = mt.Text = mt.DataNode = mt.Node = void 0;
var Pr = lv, uv = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), cv(this, t);
    }, e;
  }()
);
mt.Node = uv;
var qp = (
  /** @class */
  function(e) {
    bi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uv)
);
mt.DataNode = qp;
var RS = (
  /** @class */
  function(e) {
    bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Pr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qp)
);
mt.Text = RS;
var NS = (
  /** @class */
  function(e) {
    bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Pr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qp)
);
mt.Comment = NS;
var FS = (
  /** @class */
  function(e) {
    bi(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Pr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qp)
);
mt.ProcessingInstruction = FS;
var Zp = (
  /** @class */
  function(e) {
    bi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uv)
);
mt.NodeWithChildren = Zp;
var zS = (
  /** @class */
  function(e) {
    bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Pr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zp)
);
mt.CDATA = zS;
var $S = (
  /** @class */
  function(e) {
    bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Pr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zp)
);
mt.Document = $S;
var US = (
  /** @class */
  function(e) {
    bi(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Pr.ElementType.Script : n === "style" ? Pr.ElementType.Style : Pr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zp)
);
mt.Element = US;
function WS(e) {
  return (0, Pr.isTag)(e);
}
mt.isTag = WS;
function VS(e) {
  return e.type === Pr.ElementType.CDATA;
}
mt.isCDATA = VS;
function HS(e) {
  return e.type === Pr.ElementType.Text;
}
mt.isText = HS;
function qS(e) {
  return e.type === Pr.ElementType.Comment;
}
mt.isComment = qS;
function ZS(e) {
  return e.type === Pr.ElementType.Directive;
}
mt.isDirective = ZS;
function KS(e) {
  return e.type === Pr.ElementType.Root;
}
mt.isDocument = KS;
function nF(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
mt.hasChildren = nF;
function cv(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (HS(e))
    n = new RS(e.data);
  else if (qS(e))
    n = new NS(e.data);
  else if (WS(e)) {
    var r = t ? Ef(e.children) : [], o = new US(e.name, Sa({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Sa({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Sa({}, e["x-attribsPrefix"])), n = o;
  } else if (VS(e)) {
    var r = t ? Ef(e.children) : [], i = new zS(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (KS(e)) {
    var r = t ? Ef(e.children) : [], s = new $S(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (ZS(e)) {
    var a = new FS(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
mt.cloneNode = cv;
function Ef(e) {
  for (var t = e.map(function(r) {
    return cv(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = tn && tn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = tn && tn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = lv, o = mt;
  n(mt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(av);
var GS = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(GS);
Object.defineProperty(Hp, "__esModule", { value: !0 });
Hp.formatAttributes = YS;
Hp.formatDOM = XS;
var eu = av, rF = GS;
function oF(e) {
  return rF.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function YS(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function iF(e) {
  e = e.toLowerCase();
  var t = oF(e);
  return t || e;
}
function XS(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = iF(a.nodeName);
        o = new eu.Element(l, YS(a.attributes)), o.children = XS(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new eu.Text(a.nodeValue);
        break;
      case 8:
        o = new eu.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new eu.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var sF = tn && tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(iv, "__esModule", { value: !0 });
iv.default = cF;
var aF = sF(sv), lF = Hp, uF = /<(![a-zA-Z\s]+)>/;
function cF(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(uF), n = t ? t[1] : void 0;
  return (0, lF.formatDOM)((0, aF.default)(e), null, n);
}
var Kp = {}, ro = {}, Gp = {}, pF = 0;
Gp.SAME = pF;
var dF = 1;
Gp.CAMELCASE = dF;
Gp.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const JS = 0, wi = 1, Yp = 2, Xp = 3, pv = 4, QS = 5, eM = 6;
function fF(e) {
  return nr.hasOwnProperty(e) ? nr[e] : null;
}
function mr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === Yp || t === Xp || t === pv, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const nr = {}, hF = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
hF.forEach((e) => {
  nr[e] = new mr(
    e,
    JS,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  nr[e] = new mr(
    e,
    wi,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  nr[e] = new mr(
    e,
    Yp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  nr[e] = new mr(
    e,
    Yp,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  nr[e] = new mr(
    e,
    Xp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  nr[e] = new mr(
    e,
    Xp,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  nr[e] = new mr(
    e,
    pv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  nr[e] = new mr(
    e,
    eM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  nr[e] = new mr(
    e,
    QS,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const dv = /[\-\:]([a-z])/g, fv = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dv, fv);
  nr[t] = new mr(
    t,
    wi,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dv, fv);
  nr[t] = new mr(
    t,
    wi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dv, fv);
  nr[t] = new mr(
    t,
    wi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  nr[e] = new mr(
    e,
    wi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const gF = "xlinkHref";
nr[gF] = new mr(
  "xlinkHref",
  wi,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  nr[e] = new mr(
    e,
    wi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: mF,
  SAME: vF,
  possibleStandardNames: v0
} = Gp, yF = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", bF = yF + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", wF = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + bF + "]*$")
), CF = Object.keys(
  v0
).reduce((e, t) => {
  const n = v0[t];
  return n === vF ? e[t] = t : n === mF ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ro.BOOLEAN = Xp;
ro.BOOLEANISH_STRING = Yp;
ro.NUMERIC = QS;
ro.OVERLOADED_BOOLEAN = pv;
ro.POSITIVE_NUMERIC = eM;
ro.RESERVED = JS;
ro.STRING = wi;
ro.getPropertyInfo = fF;
ro.isCustomAttribute = wF;
ro.possibleStandardNames = CF;
var hv = {}, gv = {}, y0 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, OF = /\n/g, EF = /^\s*/, xF = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, LF = /^:\s*/, DF = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, PF = /^[;\s]*/, kF = /^\s+|\s+$/g, SF = `
`, b0 = "/", w0 = "*", Ji = "", MF = "comment", TF = "declaration", jF = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(OF);
    g && (n += g.length);
    var h = f.lastIndexOf(SF);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(EF);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(b0 != e.charAt(0) || w0 != e.charAt(1))) {
      for (var g = 2; Ji != e.charAt(g) && (w0 != e.charAt(g) || b0 != e.charAt(g + 1)); )
        ++g;
      if (g += 2, Ji === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: MF,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(xF);
    if (g) {
      if (p(), !l(LF)) return a("property missing ':'");
      var h = l(DF), C = f({
        type: TF,
        property: C0(g[0].replace(y0, Ji)),
        value: h ? C0(h[0].replace(y0, Ji)) : Ji
      });
      return l(PF), C;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function C0(e) {
  return e ? e.replace(kF, Ji) : Ji;
}
var _F = tn && tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gv, "__esModule", { value: !0 });
gv.default = BF;
var AF = _F(jF);
function BF(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, AF.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Jp = {};
Object.defineProperty(Jp, "__esModule", { value: !0 });
Jp.camelCase = void 0;
var IF = /^--[a-zA-Z0-9_-]+$/, RF = /-([a-z])/g, NF = /^[^-]+$/, FF = /^-(webkit|moz|ms|o|khtml)-/, zF = /^-(ms)-/, $F = function(e) {
  return !e || NF.test(e) || IF.test(e);
}, UF = function(e, t) {
  return t.toUpperCase();
}, O0 = function(e, t) {
  return "".concat(t, "-");
}, WF = function(e, t) {
  return t === void 0 && (t = {}), $F(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(zF, O0) : e = e.replace(FF, O0), e.replace(RF, UF));
};
Jp.camelCase = WF;
var VF = tn && tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, HF = VF(gv), qF = Jp;
function kg(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, HF.default)(e, function(r, o) {
    r && o && (n[(0, qF.camelCase)(r, t)] = o);
  }), n;
}
kg.default = kg;
var ZF = kg;
(function(e) {
  var t = tn && tn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = xe, r = t(ZF), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(hv);
Object.defineProperty(Kp, "__esModule", { value: !0 });
Kp.default = XF;
var Ca = ro, E0 = hv, KF = ["checked", "value"], GF = ["input", "select", "textarea"], YF = {
  reset: !0,
  submit: !0
};
function XF(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && YF[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ca.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = x0(s);
    if (a) {
      var l = (0, Ca.getPropertyInfo)(a);
      switch (KF.includes(a) && GF.includes(t) && !r && (a = x0("default" + s)), n[a] = i, l && l.type) {
        case Ca.BOOLEAN:
          n[a] = !0;
          break;
        case Ca.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    E0.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, E0.setStyleProp)(e.style, n), n;
}
function x0(e) {
  return Ca.possibleStandardNames[e];
}
var mv = {}, JF = tn && tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(mv, "__esModule", { value: !0 });
mv.default = tM;
var xf = xe, QF = JF(Kp), Ma = hv, e2 = {
  cloneElement: xf.cloneElement,
  createElement: xf.createElement,
  isValidElement: xf.isValidElement
};
function tM(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ma.returnFirstArg, i = t.library || e2, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, Ma.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    t2(f) ? ((0, Ma.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, QF.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = tM(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function t2(e) {
  return Ma.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ma.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = tn && tn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(iv);
  e.htmlToDOM = n.default;
  var r = t(Kp);
  e.attributesToProps = r.default;
  var o = t(mv);
  e.domToReact = o.default;
  var i = av;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(IS);
const L0 = /* @__PURE__ */ zp(IS), n2 = L0.default || L0, Sg = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => Sg(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, Xae = (e) => {
  const t = n2(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : Sg(n)) : typeof t == "string" ? [{ text: t }] : [Sg(t)];
}, Jae = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function nM(e, t, n) {
  if (!e) return /* @__PURE__ */ q.jsx(q.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ q.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ q.jsx("p", { className: n, children: /* @__PURE__ */ q.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function Qae(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: s = "",
    children: a,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${s}`;
  return /* @__PURE__ */ q.jsxs("div", { className: p.trim(), ...l, children: [
    Lc(c, o),
    a,
    Lc(c, o)
  ] });
}
function ele(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: r.trim(), ...n });
}
function tle(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ q.jsx("div", { className: o.trim(), ...r });
}
function nle(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ q.jsx("aside", { className: r.trim(), ...n });
}
function rle(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, s = Ct.count(r) === 0;
  return /* @__PURE__ */ q.jsx("tbody", { className: i.trim(), ...o, children: s ? /* @__PURE__ */ q.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ q.jsx("td", { colSpan: 100, children: /* @__PURE__ */ q.jsx("div", { children: t }) }) }) : r });
}
function ole(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ q.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ q.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function ile(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ q.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ q.jsx("table", { children: t }) });
}
function sle(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ q.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ q.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ q.jsx("tr", { children: /* @__PURE__ */ q.jsx("th", { colSpan: 100, children: /* @__PURE__ */ q.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function ale(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ q.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ q.jsx("tr", { children: n }),
    /* @__PURE__ */ q.jsx("tr", { className: "spacingRow" })
  ] });
}
var nn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function r2(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Mg = { exports: {} }, ta = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var D0;
function o2() {
  if (D0) return ta;
  D0 = 1;
  var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return ta.Fragment = n, ta.jsx = s, ta.jsxs = s, ta;
}
var tu = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var P0;
function i2() {
  return P0 || (P0 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[g];
      return typeof R == "function" ? R : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, X = new Array(R > 1 ? R - 1 : 0), re = 1; re < R; re++)
          X[re - 1] = arguments[re];
        S("error", b, X);
      }
    }
    function S(b, R, X) {
      {
        var re = C.ReactDebugCurrentFrame, pe = re.getStackAddendum();
        pe !== "" && (R += "%s", X = X.concat([pe]));
        var me = X.map(function(le) {
          return String(le);
        });
        me.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, me);
      }
    }
    var E = !1, v = !1, O = !1, P = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || P || b === m || E || v || O || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function A(b, R, X) {
      var re = b.displayName;
      if (re)
        return re;
      var pe = R.displayName || R.name || "";
      return pe !== "" ? X + "(" + pe + ")" : X;
    }
    function z(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var R = b;
            return z(R) + ".Consumer";
          case s:
            var X = b;
            return z(X._context) + ".Provider";
          case l:
            return A(b, b.render, "ForwardRef");
          case p:
            var re = b.displayName || null;
            return re !== null ? re : V(b.type) || "Memo";
          case d: {
            var pe = b, me = pe._payload, le = pe._init;
            try {
              return V(le(me));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var $ = Object.assign, Z = 0, J, Y, te, ee, k, _, K;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function G() {
      {
        if (Z === 0) {
          J = console.log, Y = console.info, te = console.warn, ee = console.error, k = console.group, _ = console.groupCollapsed, K = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: $({}, b, {
              value: J
            }),
            info: $({}, b, {
              value: Y
            }),
            warn: $({}, b, {
              value: te
            }),
            error: $({}, b, {
              value: ee
            }),
            group: $({}, b, {
              value: k
            }),
            groupCollapsed: $({}, b, {
              value: _
            }),
            groupEnd: $({}, b, {
              value: K
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = C.ReactCurrentDispatcher, F;
    function j(b, R, X) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (pe) {
            var re = pe.stack.trim().match(/\n( *(at )?)/);
            F = re && re[1] || "";
          }
        return `
` + F + b;
      }
    }
    var H = !1, B;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Q();
    }
    function W(b, R) {
      if (!b || H)
        return "";
      {
        var X = B.get(b);
        if (X !== void 0)
          return X;
      }
      var re;
      H = !0;
      var pe = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var me;
      me = T.current, T.current = null, G();
      try {
        if (R) {
          var le = function() {
            throw Error();
          };
          if (Object.defineProperty(le.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(le, []);
            } catch ($e) {
              re = $e;
            }
            Reflect.construct(b, [], le);
          } else {
            try {
              le.call();
            } catch ($e) {
              re = $e;
            }
            b.call(le.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($e) {
            re = $e;
          }
          b();
        }
      } catch ($e) {
        if ($e && re && typeof $e.stack == "string") {
          for (var se = $e.stack.split(`
`), Ie = re.stack.split(`
`), Le = se.length - 1, Pe = Ie.length - 1; Le >= 1 && Pe >= 0 && se[Le] !== Ie[Pe]; )
            Pe--;
          for (; Le >= 1 && Pe >= 0; Le--, Pe--)
            if (se[Le] !== Ie[Pe]) {
              if (Le !== 1 || Pe !== 1)
                do
                  if (Le--, Pe--, Pe < 0 || se[Le] !== Ie[Pe]) {
                    var He = `
` + se[Le].replace(" at new ", " at ");
                    return b.displayName && He.includes("<anonymous>") && (He = He.replace("<anonymous>", b.displayName)), typeof b == "function" && B.set(b, He), He;
                  }
                while (Le >= 1 && Pe >= 0);
              break;
            }
        }
      } finally {
        H = !1, T.current = me, x(), Error.prepareStackTrace = pe;
      }
      var pn = b ? b.displayName || b.name : "", zt = pn ? j(pn) : "";
      return typeof b == "function" && B.set(b, zt), zt;
    }
    function ue(b, R, X) {
      return W(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, X) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return W(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, R, X);
          case d: {
            var re = b, pe = re._payload, me = re._init;
            try {
              return oe(me(pe), R, X);
            } catch {
            }
          }
        }
      return "";
    }
    var _e = Object.prototype.hasOwnProperty, Fe = {}, ze = C.ReactDebugCurrentFrame;
    function Re(b) {
      if (b) {
        var R = b._owner, X = oe(b.type, b._source, R ? R.type : null);
        ze.setExtraStackFrame(X);
      } else
        ze.setExtraStackFrame(null);
    }
    function Ge(b, R, X, re, pe) {
      {
        var me = Function.call.bind(_e);
        for (var le in b)
          if (me(b, le)) {
            var se = void 0;
            try {
              if (typeof b[le] != "function") {
                var Ie = Error((re || "React class") + ": " + X + " type `" + le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              se = b[le](R, le, re, X, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              se = Le;
            }
            se && !(se instanceof Error) && (Re(pe), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", X, le, typeof se), Re(null)), se instanceof Error && !(se.message in Fe) && (Fe[se.message] = !0, Re(pe), w("Failed %s type: %s", X, se.message), Re(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ke(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, X = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return X;
      }
    }
    function rt(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function je(b) {
      if (rt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Se(b);
    }
    var Ne = C.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, ot, Te;
    Te = {};
    function Zt(b) {
      if (_e.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function lt(b) {
      if (_e.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ht(b, R) {
      if (typeof b.ref == "string" && Ne.current && R && Ne.current.stateNode !== R) {
        var X = V(Ne.current.type);
        Te[X] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ne.current.type), b.ref), Te[X] = !0);
      }
    }
    function kt(b, R) {
      {
        var X = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        X.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: X,
          configurable: !0
        });
      }
    }
    function sn(b, R) {
      {
        var X = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        X.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: X,
          configurable: !0
        });
      }
    }
    var St = function(b, R, X, re, pe, me, le) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: X,
        props: le,
        // Record the component responsible for creating this element.
        _owner: me
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: re
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: pe
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function an(b, R, X, re, pe) {
      {
        var me, le = {}, se = null, Ie = null;
        X !== void 0 && (je(X), se = "" + X), lt(R) && (je(R.key), se = "" + R.key), Zt(R) && (Ie = R.ref, ht(R, pe));
        for (me in R)
          _e.call(R, me) && !Ve.hasOwnProperty(me) && (le[me] = R[me]);
        if (b && b.defaultProps) {
          var Le = b.defaultProps;
          for (me in Le)
            le[me] === void 0 && (le[me] = Le[me]);
        }
        if (se || Ie) {
          var Pe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && kt(le, Pe), Ie && sn(le, Pe);
        }
        return St(b, se, Ie, pe, re, Ne.current, le);
      }
    }
    var tt = C.ReactCurrentOwner, Nt = C.ReactDebugCurrentFrame;
    function ut(b) {
      if (b) {
        var R = b._owner, X = oe(b.type, b._source, R ? R.type : null);
        Nt.setExtraStackFrame(X);
      } else
        Nt.setExtraStackFrame(null);
    }
    var ln;
    ln = !1;
    function Mt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Mn() {
      {
        if (tt.current) {
          var b = V(tt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function un(b) {
      return "";
    }
    var Tn = {};
    function cn(b) {
      {
        var R = Mn();
        if (!R) {
          var X = typeof b == "string" ? b : b.displayName || b.name;
          X && (R = `

Check the top-level render call using <` + X + ">.");
        }
        return R;
      }
    }
    function jn(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var X = cn(R);
        if (Tn[X])
          return;
        Tn[X] = !0;
        var re = "";
        b && b._owner && b._owner !== tt.current && (re = " It was passed a child from " + V(b._owner.type) + "."), ut(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', X, re), ut(null);
      }
    }
    function Yn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var X = 0; X < b.length; X++) {
            var re = b[X];
            Mt(re) && jn(re, R);
          }
        else if (Mt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var pe = h(b);
          if (typeof pe == "function" && pe !== b.entries)
            for (var me = pe.call(b), le; !(le = me.next()).done; )
              Mt(le.value) && jn(le.value, R);
        }
      }
    }
    function Ft(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var X;
        if (typeof R == "function")
          X = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          X = R.propTypes;
        else
          return;
        if (X) {
          var re = V(R);
          Ge(X, b.props, "prop", re, b);
        } else if (R.PropTypes !== void 0 && !ln) {
          ln = !0;
          var pe = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", pe || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ie(b) {
      {
        for (var R = Object.keys(b.props), X = 0; X < R.length; X++) {
          var re = R[X];
          if (re !== "children" && re !== "key") {
            ut(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), ut(null);
            break;
          }
        }
        b.ref !== null && (ut(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), ut(null));
      }
    }
    var eo = {};
    function to(b, R, X, re, pe, me) {
      {
        var le = N(b);
        if (!le) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ie = un();
          Ie ? se += Ie : se += Mn();
          var Le;
          b === null ? Le = "null" : Me(b) ? Le = "array" : b !== void 0 && b.$$typeof === t ? (Le = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, se);
        }
        var Pe = an(b, R, X, pe, me);
        if (Pe == null)
          return Pe;
        if (le) {
          var He = R.children;
          if (He !== void 0)
            if (re)
              if (Me(He)) {
                for (var pn = 0; pn < He.length; pn++)
                  Yn(He[pn], b);
                Object.freeze && Object.freeze(He);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Yn(He, b);
        }
        if (_e.call(R, "key")) {
          var zt = V(b), $e = Object.keys(R).filter(function(Ri) {
            return Ri !== "key";
          }), dr = $e.length > 0 ? "{key: someKey, " + $e.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!eo[zt + dr]) {
            var Ii = $e.length > 0 ? "{" + $e.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, dr, zt, Ii, zt), eo[zt + dr] = !0;
          }
        }
        return b === r ? ie(Pe) : Ft(Pe), Pe;
      }
    }
    function ji(b, R, X) {
      return to(b, R, X, !0);
    }
    function _i(b, R, X) {
      return to(b, R, X, !1);
    }
    var Ai = _i, Bi = ji;
    tu.Fragment = r, tu.jsx = Ai, tu.jsxs = Bi;
  }()), tu;
}
process.env.NODE_ENV === "production" ? Mg.exports = o2() : Mg.exports = i2();
var Xt = Mg.exports;
qe({});
function k0(e, t) {
  return t ? /* @__PURE__ */ Xt.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Xt.jsx(Xt.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function S0(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ar(e) {
  var t, n;
  return S0(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(S0(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var rM = Symbol.for("immer-nothing"), M0 = Symbol.for("immer-draftable"), Ur = Symbol.for("immer-state"), s2 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Or(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = s2[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var As = Object.getPrototypeOf;
function hs(e) {
  return !!e && !!e[Ur];
}
function gs(e) {
  var t;
  return e ? oM(e) || Array.isArray(e) || !!e[M0] || !!((t = e.constructor) != null && t[M0]) || ed(e) || td(e) : !1;
}
var a2 = Object.prototype.constructor.toString();
function oM(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = As(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === a2;
}
function jc(e, t) {
  Qp(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Qp(e) {
  const t = e[Ur];
  return t ? t.type_ : Array.isArray(e) ? 1 : ed(e) ? 2 : td(e) ? 3 : 0;
}
function Tg(e, t) {
  return Qp(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function iM(e, t, n) {
  const r = Qp(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function l2(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function ed(e) {
  return e instanceof Map;
}
function td(e) {
  return e instanceof Set;
}
function Ki(e) {
  return e.copy_ || e.base_;
}
function jg(e, t) {
  if (ed(e))
    return new Map(e);
  if (td(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = oM(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ur];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(As(e), r);
  } else {
    const r = As(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function vv(e, t = !1) {
  return nd(e) || hs(e) || !gs(e) || (Qp(e) > 1 && (e.set = e.add = e.clear = e.delete = u2), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => vv(r, !0))), e;
}
function u2() {
  Or(2);
}
function nd(e) {
  return Object.isFrozen(e);
}
var c2 = {};
function ms(e) {
  const t = c2[e];
  return t || Or(0, e), t;
}
var Xa;
function sM() {
  return Xa;
}
function p2(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function T0(e, t) {
  t && (ms("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function _g(e) {
  Ag(e), e.drafts_.forEach(d2), e.drafts_ = null;
}
function Ag(e) {
  e === Xa && (Xa = e.parent_);
}
function j0(e) {
  return Xa = p2(Xa, e);
}
function d2(e) {
  const t = e[Ur];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function _0(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ur].modified_ && (_g(t), Or(4)), gs(e) && (e = _c(t, e), t.parent_ || Ac(t, e)), t.patches_ && ms("Patches").generateReplacementPatches_(
    n[Ur].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = _c(t, n, []), _g(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== rM ? e : void 0;
}
function _c(e, t, n) {
  if (nd(t))
    return t;
  const r = t[Ur];
  if (!r)
    return jc(
      t,
      (o, i) => A0(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Ac(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), jc(
      i,
      (a, l) => A0(e, r, o, a, l, n, s)
    ), Ac(e, o, !1), n && e.patches_ && ms("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function A0(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Or(5), hs(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Tg(t.assigned_, r) ? i.concat(r) : void 0, l = _c(e, o, a);
    if (iM(n, r, l), hs(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (gs(o) && !nd(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    _c(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Ac(e, o);
  }
}
function Ac(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && vv(t, n);
}
function f2(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : sM(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = yv;
  n && (o = [r], i = Ja);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var yv = {
  get(e, t) {
    if (t === Ur)
      return e;
    const n = Ki(e);
    if (!Tg(n, t))
      return h2(e, n, t);
    const r = n[t];
    return e.finalized_ || !gs(r) ? r : r === Lf(e.base_, t) ? (Df(e), e.copy_[t] = Ig(r, e)) : r;
  },
  has(e, t) {
    return t in Ki(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ki(e));
  },
  set(e, t, n) {
    const r = aM(Ki(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Lf(Ki(e), t), i = o == null ? void 0 : o[Ur];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (l2(n, o) && (n !== void 0 || Tg(e.base_, t)))
        return !0;
      Df(e), Bg(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Lf(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Df(e), Bg(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ki(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Or(11);
  },
  getPrototypeOf(e) {
    return As(e.base_);
  },
  setPrototypeOf() {
    Or(12);
  }
}, Ja = {};
jc(yv, (e, t) => {
  Ja[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ja.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Or(13), Ja.set.call(this, e, t, void 0);
};
Ja.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Or(14), yv.set.call(this, e[0], t, n, e[0]);
};
function Lf(e, t) {
  const n = e[Ur];
  return (n ? Ki(n) : e)[t];
}
function h2(e, t, n) {
  var r;
  const o = aM(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function aM(e, t) {
  if (!(t in e))
    return;
  let n = As(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = As(n);
  }
}
function Bg(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Bg(e.parent_));
}
function Df(e) {
  e.copy_ || (e.copy_ = jg(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var g2 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Or(6), r !== void 0 && typeof r != "function" && Or(7);
      let o;
      if (gs(t)) {
        const i = j0(this), s = Ig(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? _g(i) : Ag(i);
        }
        return T0(i, r), _0(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === rM && (o = void 0), this.autoFreeze_ && vv(o, !0), r) {
          const i = [], s = [];
          ms("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Or(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    gs(e) || Or(8), hs(e) && (e = m2(e));
    const t = j0(this), n = Ig(e, void 0);
    return n[Ur].isManual_ = !0, Ag(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ur];
    (!n || !n.isManual_) && Or(9);
    const { scope_: r } = n;
    return T0(r, t), _0(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ms("Patches").applyPatches_;
    return hs(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Ig(e, t) {
  const n = ed(e) ? ms("MapSet").proxyMap_(e, t) : td(e) ? ms("MapSet").proxySet_(e, t) : f2(e, t);
  return (t ? t.scope_ : sM()).drafts_.push(n), n;
}
function m2(e) {
  return hs(e) || Or(10, e), lM(e);
}
function lM(e) {
  if (!gs(e) || nd(e))
    return e;
  const t = e[Ur];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = jg(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = jg(e, !0);
  return jc(n, (r, o) => {
    iM(n, r, lM(o));
  }), t && (t.finalized_ = !1), n;
}
var Wr = new g2(), bv = Wr.produce;
Wr.produceWithPatches.bind(
  Wr
);
Wr.setAutoFreeze.bind(Wr);
Wr.setUseStrictShallowCopy.bind(Wr);
Wr.applyPatches.bind(Wr);
var B0 = Wr.createDraft.bind(Wr), I0 = Wr.finishDraft.bind(Wr), be = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = be.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return be.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return be.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return be.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return be.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && be.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return be.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && be.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && be.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && be.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && be.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && be.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!be.isAncestor(t, e) && !be.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (be.equals(i, r) || be.endsBefore(i, r) || be.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (be.equals(s, r) || be.isAncestor(s, r))
          return null;
        be.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        be.equals(a, r) || be.endsBefore(a, r) ? r[a.length - 1] -= 1 : be.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (be.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else be.endsBefore(u, r) ? r[u.length - 1] += 1 : be.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (be.equals(p, d))
          return r;
        if (be.isAncestor(p, r) || be.equals(p, r)) {
          var m = d.slice();
          return be.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else be.isSibling(p, d) && (be.isAncestor(d, r) || be.equals(d, r)) ? be.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : be.endsBefore(d, r) || be.equals(d, r) || be.isAncestor(d, r) ? (be.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : be.endsBefore(p, r) && (be.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Qa(e) {
  "@babel/helpers - typeof";
  return Qa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Qa(e);
}
function v2(e, t) {
  if (Qa(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Qa(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function y2(e) {
  var t = v2(e, "string");
  return Qa(t) === "symbol" ? t : String(t);
}
function $s(e, t, n) {
  return t = y2(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function R0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function na(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R0(Object(n), !0).forEach(function(r) {
      $s(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var b2 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Je.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of pt.points(t))
          t[l] = gn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Je.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of pt.points(t))
          t[h] = gn.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = Je.get(e, C), S = be.previous(C), E = Je.get(e, S), v = Je.parent(e, C), O = C[C.length - 1];
      if (Un.isText(w) && Un.isText(E))
        E.text += w.text;
      else if (!Un.isText(w) && !Un.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(jr.stringify(w), " ").concat(jr.stringify(E)));
      if (v.children.splice(O, 1), t)
        for (var [P, U] of pt.points(t))
          t[U] = gn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (be.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var A = Je.get(e, L), z = Je.parent(e, L), V = L[L.length - 1];
      z.children.splice(V, 1);
      var $ = be.transform(L, n), Z = Je.get(e, be.parent($)), J = $[$.length - 1];
      if (Z.children.splice(J, 0, A), t)
        for (var [Y, te] of pt.points(t))
          t[te] = gn.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], _ = Je.parent(e, ee);
      if (_.children.splice(k, 1), t)
        for (var [K, M] of pt.points(t)) {
          var G = gn.transform(K, n);
          if (t != null && G != null)
            t[M] = G;
          else {
            var x = void 0, T = void 0;
            for (var [F, j] of Je.texts(e))
              if (be.compare(j, ee) === -1)
                x = [F, j];
              else {
                T = [F, j];
                break;
              }
            var H = !1;
            x && T && (be.equals(T[1], ee) ? H = !be.hasPrevious(T[1]) : H = be.common(x[1], ee).length < be.common(T[1], ee).length), x && !H ? (K.path = x[1], K.offset = x[0].text.length) : T ? (K.path = T[1], K.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Q,
        text: W
      } = n;
      if (W.length === 0) break;
      var ue = Je.leaf(e, B), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + W.length);
      if (ue.text = ye + oe, t)
        for (var [_e, Fe] of pt.points(t))
          t[Fe] = gn.transform(_e, n);
      break;
    }
    case "set_node": {
      var {
        path: ze,
        properties: Re,
        newProperties: Ge
      } = n;
      if (ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = Je.get(e, ze);
      for (var Me in Ge) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ke = Ge[Me];
        Ke == null ? delete Ze[Me] : Ze[Me] = Ke;
      }
      for (var rt in Re)
        Ge.hasOwnProperty(rt) || delete Ze[rt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!pt.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(jr.stringify(Se), " when there is no current selection."));
          t = na({}, Se);
        }
        for (var je in Se) {
          var Ne = Se[je];
          if (Ne == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ne;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ue,
        properties: ot
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var Te = Je.get(e, Ve), Zt = Je.parent(e, Ve), lt = Ve[Ve.length - 1], ht;
      if (Un.isText(Te)) {
        var kt = Te.text.slice(0, Ue), sn = Te.text.slice(Ue);
        Te.text = kt, ht = na(na({}, ot), {}, {
          text: sn
        });
      } else {
        var St = Te.children.slice(0, Ue), an = Te.children.slice(Ue);
        Te.children = St, ht = na(na({}, ot), {}, {
          children: an
        });
      }
      if (Zt.children.splice(lt + 1, 0, ht), t)
        for (var [tt, Nt] of pt.points(t))
          t[Nt] = gn.transform(tt, n);
      break;
    }
  }
  return t;
}, w2 = {
  transform(e, t) {
    e.children = B0(e.children);
    var n = e.selection && B0(e.selection);
    try {
      n = b2(e, n, t);
    } finally {
      e.children = I0(e.children), n ? e.selection = hs(n) ? I0(n) : n : e.selection = null;
    }
  }
}, C2 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, O2 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, uM = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (ar(r) && ar(o)) {
      if (!uM(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function E2(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function el(e, t) {
  if (e == null) return {};
  var n = E2(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var x2 = ["anchor", "focus"];
function N0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function L2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N0(Object(n), !0).forEach(function(r) {
      $s(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return pt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = pt.edges(e);
    return t;
  },
  equals(e, t) {
    return gn.equals(e.anchor, t.anchor) && gn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (pt.isRange(t)) {
      if (pt.includes(e, t.anchor) || pt.includes(e, t.focus))
        return !0;
      var [n, r] = pt.edges(e), [o, i] = pt.edges(t);
      return gn.isBefore(n, o) && gn.isAfter(r, i);
    }
    var [s, a] = pt.edges(e), l = !1, u = !1;
    return gn.isPoint(t) ? (l = gn.compare(t, s) >= 0, u = gn.compare(t, a) <= 0) : (l = be.compare(t, s.path) >= 0, u = be.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = el(e, x2), [r, o] = pt.edges(e), [i, s] = pt.edges(t), a = gn.isBefore(r, i) ? i : r, l = gn.isBefore(o, s) ? o : s;
    return gn.isBefore(l, a) ? null : L2({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gn.equals(t, n);
  },
  isExpanded(e) {
    return !pt.isCollapsed(e);
  },
  isForward(e) {
    return !pt.isBackward(e);
  },
  isRange(e) {
    return ar(e) && gn.isPoint(e.anchor) && gn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = pt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return bv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = pt.isCollapsed(r);
        pt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? pt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = gn.transform(r.anchor, t, {
        affinity: i
      }), u = gn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, F0 = (e) => ar(e) && Je.isNodeList(e.children) && !Jt.isEditor(e), Mo = {
  isAncestor(e) {
    return ar(e) && Je.isNodeList(e.children);
  },
  isElement: F0,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Mo.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return F0(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, D2 = ["children"], P2 = ["text"], z0 = /* @__PURE__ */ new WeakMap(), Je = {
  ancestor(e, t) {
    var n = Je.get(e, t);
    if (Un.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(jr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of be.ancestors(t, n)) {
        var o = Je.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Un.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(jr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(jr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Je.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = Je.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = be.common(t, n), o = Je.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Je.get(e, t);
    if (Jt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(jr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Je.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Je.nodes(e, t))
        Mo.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Mo.isAncestor(e)) {
      var t = el(e, D2);
      return t;
    } else {
      var t = el(e, P2);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Je.get(e, n); r && !(Un.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Un.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(jr.stringify(e)));
    var n = bv({
      children: e.children
    }, (r) => {
      var [o, i] = pt.edges(t), s = Je.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !pt.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!pt.includes(t, a)) {
          var l = Je.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (be.equals(a, i.path)) {
          var c = Je.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (be.equals(a, o.path)) {
          var p = Je.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      Jt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Un.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(jr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Un.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Un.isText(e) || Mo.isElement(e) || Jt.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = z0.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Je.isNode(r));
    return z0.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Je.get(e, n); r && !(Un.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Je.get(e, t);
    if (!Un.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(jr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of be.levels(t, n)) {
        var o = Je.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Mo.isElement(e) && Mo.isElementProps(t) && Mo.matches(e, t) || Un.isText(e) && Un.isTextProps(t) && Un.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? be.isBefore(a, i) : be.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Un.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          be.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = Je.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = be.next(a);
          if (Je.has(e, c)) {
            a = c, l = Je.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = be.previous(a);
          a = p, l = Je.get(e, a);
          continue;
        }
        a = be.parent(a), l = Je.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = be.parent(t), r = Je.get(e, n);
    if (Un.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Un.isText(e) ? e.text : e.children.map(Je.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Je.nodes(e, t))
        Un.isText(n) && (yield [n, r]);
    }();
  }
};
function $0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $0(Object(n), !0).forEach(function(r) {
      $s(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Oa = {
  isNodeOperation(e) {
    return Oa.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!ar(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return be.isPath(e.path) && Je.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && be.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && be.isPath(e.path) && ar(e.properties);
      case "move_node":
        return be.isPath(e.path) && be.isPath(e.newPath);
      case "remove_node":
        return be.isPath(e.path) && Je.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && be.isPath(e.path);
      case "set_node":
        return be.isPath(e.path) && ar(e.properties) && ar(e.newProperties);
      case "set_selection":
        return e.properties === null && pt.isRange(e.newProperties) || e.newProperties === null && pt.isRange(e.properties) || ar(e.properties) && ar(e.newProperties);
      case "split_node":
        return be.isPath(e.path) && typeof e.position == "number" && ar(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Oa.isOperation(t));
  },
  isSelectionOperation(e) {
    return Oa.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Oa.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return bn(bn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return bn(bn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return bn(bn({}, e), {}, {
          type: "split_node",
          path: be.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (be.equals(t, n))
          return e;
        if (be.isSibling(n, t))
          return bn(bn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = be.transform(n, e), o = be.transform(be.next(n), e);
        return bn(bn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return bn(bn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return bn(bn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return bn(bn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? bn(bn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? bn(bn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : bn(bn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return bn(bn({}, e), {}, {
          type: "merge_node",
          path: be.next(e.path)
        });
    }
  }
}, U0 = /* @__PURE__ */ new WeakMap(), k2 = (e) => {
  var t = U0.get(e);
  if (t !== void 0)
    return t;
  if (!ar(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || ar(e.marks)) && (e.selection === null || pt.isRange(e.selection)) && Je.isNodeList(e.children) && Oa.isOperationList(e.operations);
  return U0.set(e, n), n;
}, Jt = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return k2(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function W0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function V0(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? W0(Object(n), !0).forEach(function(r) {
      $s(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : W0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gn = {
  compare(e, t) {
    var n = be.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return gn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return gn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && be.equals(e.path, t.path);
  },
  isPoint(e) {
    return ar(e) && typeof e.offset == "number" && be.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return bv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = be.transform(i, t, n);
          break;
        }
        case "insert_text": {
          be.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          be.equals(t.path, i) && (r.offset += t.position), r.path = be.transform(i, t, n);
          break;
        }
        case "remove_text": {
          be.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (be.equals(t.path, i) || be.isAncestor(t.path, i))
            return null;
          r.path = be.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (be.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = be.transform(i, t, V0(V0({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = be.transform(i, t, n);
          break;
        }
      }
    });
  }
}, H0 = void 0, jr = {
  setScrubber(e) {
    H0 = e;
  },
  stringify(e) {
    return JSON.stringify(e, H0);
  }
}, S2 = ["text"], M2 = ["anchor", "focus"];
function q0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Eo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q0(Object(n), !0).forEach(function(r) {
      $s(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Un = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = el(i, S2);
      return s;
    }
    return uM(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return ar(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Un.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Eo({}, e)];
    for (var r of t) {
      var o = el(r, M2), [i, s] = pt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var C = c - m;
          h = Eo(Eo({}, f), {}, {
            text: f.text.slice(C)
          }), f = Eo(Eo({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > m) {
          var w = u - m;
          g = Eo(Eo({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Eo(Eo({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, T2 = (e) => e.selection ? e.selection : e.children.length > 0 ? Jt.end(e, []) : [0], dn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(dn || (dn = {}));
dn.L, dn.L | dn.V | dn.LV | dn.LVT, dn.LV | dn.V, dn.V | dn.T, dn.LVT | dn.T, dn.T, dn.Any, dn.Extend | dn.ZWJ, dn.Any, dn.SpacingMark, dn.Prepend, dn.Any, dn.ZWJ, dn.ExtPict, dn.RI, dn.RI;
var j2 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Jt.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = T2(e)
      } = n;
      if (be.isPath(o) && (o = Jt.range(e, o)), pt.isRange(o))
        if (pt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = pt.end(o);
          if (!r && Jt.void(e, {
            at: i
          }))
            return;
          var s = pt.start(o), a = Jt.pointRef(e, s), l = Jt.pointRef(e, i);
          Bc.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Bc.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Jt.void(e, {
        at: o
      }) || Jt.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function Z0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z0(Object(n), !0).forEach(function(r) {
      $s(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Z0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bc = nu(nu(nu(nu({}, w2), C2), O2), j2), cM = {}, wv = {}, Cv = {};
Object.defineProperty(Cv, "__esModule", { value: !0 });
Cv.default = I2;
var K0 = "html", G0 = "head", ru = "body", _2 = /<([a-zA-Z]+[0-9]?)/, Y0 = /<head[^]*>/i, X0 = /<body[^]*>/i, Ic = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Rg = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, J0 = typeof window == "object" && window.DOMParser;
if (typeof J0 == "function") {
  var A2 = new J0(), B2 = "text/html";
  Rg = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), A2.parseFromString(e, B2);
  }, Ic = Rg;
}
if (typeof document == "object" && document.implementation) {
  var ou = document.implementation.createHTMLDocument();
  Ic = function(e, t) {
    if (t) {
      var n = ou.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ou;
    }
    return ou.documentElement.innerHTML = e, ou;
  };
}
var iu = typeof document == "object" && document.createElement("template"), Ng;
iu && iu.content && (Ng = function(e) {
  return iu.innerHTML = e, iu.content.childNodes;
});
function I2(e) {
  var t, n, r = e.match(_2), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case K0: {
      var i = Rg(e);
      if (!Y0.test(e)) {
        var s = i.querySelector(G0);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!X0.test(e)) {
        var s = i.querySelector(ru);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(K0);
    }
    case G0:
    case ru: {
      var a = Ic(e).querySelectorAll(o);
      return X0.test(e) && Y0.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Ng)
        return Ng(e);
      var s = Ic(e, ru).querySelector(ru);
      return s.childNodes;
    }
  }
}
var rd = {}, Ov = {}, Ev = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Ev);
var vt = {}, Ci = nn && nn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ta = nn && nn.__assign || function() {
  return Ta = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ta.apply(this, arguments);
};
Object.defineProperty(vt, "__esModule", { value: !0 });
vt.cloneNode = vt.hasChildren = vt.isDocument = vt.isDirective = vt.isComment = vt.isText = vt.isCDATA = vt.isTag = vt.Element = vt.Document = vt.CDATA = vt.NodeWithChildren = vt.ProcessingInstruction = vt.Comment = vt.Text = vt.DataNode = vt.Node = void 0;
var kr = Ev, xv = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Lv(this, t);
    }, e;
  }()
);
vt.Node = xv;
var od = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(xv)
);
vt.DataNode = od;
var pM = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = kr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(od)
);
vt.Text = pM;
var dM = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = kr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(od)
);
vt.Comment = dM;
var fM = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = kr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(od)
);
vt.ProcessingInstruction = fM;
var id = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(xv)
);
vt.NodeWithChildren = id;
var hM = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = kr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(id)
);
vt.CDATA = hM;
var gM = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = kr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(id)
);
vt.Document = gM;
var mM = (
  /** @class */
  function(e) {
    Ci(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? kr.ElementType.Script : n === "style" ? kr.ElementType.Style : kr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(id)
);
vt.Element = mM;
function vM(e) {
  return (0, kr.isTag)(e);
}
vt.isTag = vM;
function yM(e) {
  return e.type === kr.ElementType.CDATA;
}
vt.isCDATA = yM;
function bM(e) {
  return e.type === kr.ElementType.Text;
}
vt.isText = bM;
function wM(e) {
  return e.type === kr.ElementType.Comment;
}
vt.isComment = wM;
function CM(e) {
  return e.type === kr.ElementType.Directive;
}
vt.isDirective = CM;
function OM(e) {
  return e.type === kr.ElementType.Root;
}
vt.isDocument = OM;
function R2(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
vt.hasChildren = R2;
function Lv(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (bM(e))
    n = new pM(e.data);
  else if (wM(e))
    n = new dM(e.data);
  else if (vM(e)) {
    var r = t ? Pf(e.children) : [], o = new mM(e.name, Ta({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ta({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ta({}, e["x-attribsPrefix"])), n = o;
  } else if (yM(e)) {
    var r = t ? Pf(e.children) : [], i = new hM(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (OM(e)) {
    var r = t ? Pf(e.children) : [], s = new gM(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (CM(e)) {
    var a = new fM(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
vt.cloneNode = Lv;
function Pf(e) {
  for (var t = e.map(function(r) {
    return Lv(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = nn && nn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = nn && nn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Ev, o = vt;
  n(vt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Ov);
var EM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(EM);
Object.defineProperty(rd, "__esModule", { value: !0 });
rd.formatAttributes = xM;
rd.formatDOM = LM;
var su = Ov, N2 = EM;
function F2(e) {
  return N2.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function xM(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function z2(e) {
  e = e.toLowerCase();
  var t = F2(e);
  return t || e;
}
function LM(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = z2(a.nodeName);
        o = new su.Element(l, xM(a.attributes)), o.children = LM(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new su.Text(a.nodeValue);
        break;
      case 8:
        o = new su.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new su.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var $2 = nn && nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wv, "__esModule", { value: !0 });
wv.default = H2;
var U2 = $2(Cv), W2 = rd, V2 = /<(![a-zA-Z\s]+)>/;
function H2(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(V2), n = t ? t[1] : void 0;
  return (0, W2.formatDOM)((0, U2.default)(e), null, n);
}
var sd = {}, oo = {}, ad = {}, q2 = 0;
ad.SAME = q2;
var Z2 = 1;
ad.CAMELCASE = Z2;
ad.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const DM = 0, Oi = 1, ld = 2, ud = 3, Dv = 4, PM = 5, kM = 6;
function K2(e) {
  return rr.hasOwnProperty(e) ? rr[e] : null;
}
function vr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === ld || t === ud || t === Dv, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const rr = {}, G2 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
G2.forEach((e) => {
  rr[e] = new vr(
    e,
    DM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  rr[e] = new vr(
    e,
    Oi,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  rr[e] = new vr(
    e,
    ld,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  rr[e] = new vr(
    e,
    ld,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  rr[e] = new vr(
    e,
    ud,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  rr[e] = new vr(
    e,
    ud,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  rr[e] = new vr(
    e,
    Dv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  rr[e] = new vr(
    e,
    kM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  rr[e] = new vr(
    e,
    PM,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Pv = /[\-\:]([a-z])/g, kv = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Pv, kv);
  rr[t] = new vr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Pv, kv);
  rr[t] = new vr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Pv, kv);
  rr[t] = new vr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  rr[e] = new vr(
    e,
    Oi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Y2 = "xlinkHref";
rr[Y2] = new vr(
  "xlinkHref",
  Oi,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  rr[e] = new vr(
    e,
    Oi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: X2,
  SAME: J2,
  possibleStandardNames: Q0
} = ad, Q2 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ez = Q2 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", tz = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + ez + "]*$")
), nz = Object.keys(
  Q0
).reduce((e, t) => {
  const n = Q0[t];
  return n === J2 ? e[t] = t : n === X2 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
oo.BOOLEAN = ud;
oo.BOOLEANISH_STRING = ld;
oo.NUMERIC = PM;
oo.OVERLOADED_BOOLEAN = Dv;
oo.POSITIVE_NUMERIC = kM;
oo.RESERVED = DM;
oo.STRING = Oi;
oo.getPropertyInfo = K2;
oo.isCustomAttribute = tz;
oo.possibleStandardNames = nz;
var Sv = {}, Mv = {}, ew = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, rz = /\n/g, oz = /^\s*/, iz = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, sz = /^:\s*/, az = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, lz = /^[;\s]*/, uz = /^\s+|\s+$/g, cz = `
`, tw = "/", nw = "*", Qi = "", pz = "comment", dz = "declaration", fz = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(rz);
    g && (n += g.length);
    var h = f.lastIndexOf(cz);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(oz);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(tw != e.charAt(0) || nw != e.charAt(1))) {
      for (var g = 2; Qi != e.charAt(g) && (nw != e.charAt(g) || tw != e.charAt(g + 1)); )
        ++g;
      if (g += 2, Qi === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: pz,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(iz);
    if (g) {
      if (p(), !l(sz)) return a("property missing ':'");
      var h = l(az), C = f({
        type: dz,
        property: rw(g[0].replace(ew, Qi)),
        value: h ? rw(h[0].replace(ew, Qi)) : Qi
      });
      return l(lz), C;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function rw(e) {
  return e ? e.replace(uz, Qi) : Qi;
}
var hz = nn && nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Mv, "__esModule", { value: !0 });
Mv.default = mz;
var gz = hz(fz);
function mz(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, gz.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var cd = {};
Object.defineProperty(cd, "__esModule", { value: !0 });
cd.camelCase = void 0;
var vz = /^--[a-zA-Z0-9_-]+$/, yz = /-([a-z])/g, bz = /^[^-]+$/, wz = /^-(webkit|moz|ms|o|khtml)-/, Cz = /^-(ms)-/, Oz = function(e) {
  return !e || bz.test(e) || vz.test(e);
}, Ez = function(e, t) {
  return t.toUpperCase();
}, ow = function(e, t) {
  return "".concat(t, "-");
}, xz = function(e, t) {
  return t === void 0 && (t = {}), Oz(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Cz, ow) : e = e.replace(wz, ow), e.replace(yz, Ez));
};
cd.camelCase = xz;
var Lz = nn && nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Dz = Lz(Mv), Pz = cd;
function Fg(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Dz.default)(e, function(r, o) {
    r && o && (n[(0, Pz.camelCase)(r, t)] = o);
  }), n;
}
Fg.default = Fg;
var kz = Fg;
(function(e) {
  var t = nn && nn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = xe, r = t(kz), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Sv);
Object.defineProperty(sd, "__esModule", { value: !0 });
sd.default = jz;
var Ea = oo, iw = Sv, Sz = ["checked", "value"], Mz = ["input", "select", "textarea"], Tz = {
  reset: !0,
  submit: !0
};
function jz(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Tz[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ea.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = sw(s);
    if (a) {
      var l = (0, Ea.getPropertyInfo)(a);
      switch (Sz.includes(a) && Mz.includes(t) && !r && (a = sw("default" + s)), n[a] = i, l && l.type) {
        case Ea.BOOLEAN:
          n[a] = !0;
          break;
        case Ea.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    iw.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, iw.setStyleProp)(e.style, n), n;
}
function sw(e) {
  return Ea.possibleStandardNames[e];
}
var Tv = {}, _z = nn && nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Tv, "__esModule", { value: !0 });
Tv.default = SM;
var kf = xe, Az = _z(sd), ja = Sv, Bz = {
  cloneElement: kf.cloneElement,
  createElement: kf.createElement,
  isValidElement: kf.isValidElement
};
function SM(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || ja.returnFirstArg, i = t.library || Bz, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, ja.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    Iz(f) ? ((0, ja.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, Az.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = SM(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Iz(e) {
  return ja.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, ja.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = nn && nn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(wv);
  e.htmlToDOM = n.default;
  var r = t(sd);
  e.attributesToProps = r.default;
  var o = t(Tv);
  e.domToReact = o.default;
  var i = Ov;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(cM);
const aw = /* @__PURE__ */ r2(cM);
aw.default;
function Rz(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ Xt.jsx("div", { className: o.trim(), ...r });
}
var rn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Nz(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var zg = { exports: {} }, ra = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lw;
function Fz() {
  if (lw) return ra;
  lw = 1;
  var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return ra.Fragment = n, ra.jsx = s, ra.jsxs = s, ra;
}
var au = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uw;
function zz() {
  return uw || (uw = 1, process.env.NODE_ENV !== "production" && function() {
    var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[g];
      return typeof R == "function" ? R : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, X = new Array(R > 1 ? R - 1 : 0), re = 1; re < R; re++)
          X[re - 1] = arguments[re];
        S("error", b, X);
      }
    }
    function S(b, R, X) {
      {
        var re = C.ReactDebugCurrentFrame, pe = re.getStackAddendum();
        pe !== "" && (R += "%s", X = X.concat([pe]));
        var me = X.map(function(le) {
          return String(le);
        });
        me.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, me);
      }
    }
    var E = !1, v = !1, O = !1, P = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || P || b === m || E || v || O || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function A(b, R, X) {
      var re = b.displayName;
      if (re)
        return re;
      var pe = R.displayName || R.name || "";
      return pe !== "" ? X + "(" + pe + ")" : X;
    }
    function z(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var R = b;
            return z(R) + ".Consumer";
          case s:
            var X = b;
            return z(X._context) + ".Provider";
          case l:
            return A(b, b.render, "ForwardRef");
          case p:
            var re = b.displayName || null;
            return re !== null ? re : V(b.type) || "Memo";
          case d: {
            var pe = b, me = pe._payload, le = pe._init;
            try {
              return V(le(me));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var $ = Object.assign, Z = 0, J, Y, te, ee, k, _, K;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function G() {
      {
        if (Z === 0) {
          J = console.log, Y = console.info, te = console.warn, ee = console.error, k = console.group, _ = console.groupCollapsed, K = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: $({}, b, {
              value: J
            }),
            info: $({}, b, {
              value: Y
            }),
            warn: $({}, b, {
              value: te
            }),
            error: $({}, b, {
              value: ee
            }),
            group: $({}, b, {
              value: k
            }),
            groupCollapsed: $({}, b, {
              value: _
            }),
            groupEnd: $({}, b, {
              value: K
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = C.ReactCurrentDispatcher, F;
    function j(b, R, X) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (pe) {
            var re = pe.stack.trim().match(/\n( *(at )?)/);
            F = re && re[1] || "";
          }
        return `
` + F + b;
      }
    }
    var H = !1, B;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Q();
    }
    function W(b, R) {
      if (!b || H)
        return "";
      {
        var X = B.get(b);
        if (X !== void 0)
          return X;
      }
      var re;
      H = !0;
      var pe = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var me;
      me = T.current, T.current = null, G();
      try {
        if (R) {
          var le = function() {
            throw Error();
          };
          if (Object.defineProperty(le.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(le, []);
            } catch ($e) {
              re = $e;
            }
            Reflect.construct(b, [], le);
          } else {
            try {
              le.call();
            } catch ($e) {
              re = $e;
            }
            b.call(le.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($e) {
            re = $e;
          }
          b();
        }
      } catch ($e) {
        if ($e && re && typeof $e.stack == "string") {
          for (var se = $e.stack.split(`
`), Ie = re.stack.split(`
`), Le = se.length - 1, Pe = Ie.length - 1; Le >= 1 && Pe >= 0 && se[Le] !== Ie[Pe]; )
            Pe--;
          for (; Le >= 1 && Pe >= 0; Le--, Pe--)
            if (se[Le] !== Ie[Pe]) {
              if (Le !== 1 || Pe !== 1)
                do
                  if (Le--, Pe--, Pe < 0 || se[Le] !== Ie[Pe]) {
                    var He = `
` + se[Le].replace(" at new ", " at ");
                    return b.displayName && He.includes("<anonymous>") && (He = He.replace("<anonymous>", b.displayName)), typeof b == "function" && B.set(b, He), He;
                  }
                while (Le >= 1 && Pe >= 0);
              break;
            }
        }
      } finally {
        H = !1, T.current = me, x(), Error.prepareStackTrace = pe;
      }
      var pn = b ? b.displayName || b.name : "", zt = pn ? j(pn) : "";
      return typeof b == "function" && B.set(b, zt), zt;
    }
    function ue(b, R, X) {
      return W(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, X) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return W(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, R, X);
          case d: {
            var re = b, pe = re._payload, me = re._init;
            try {
              return oe(me(pe), R, X);
            } catch {
            }
          }
        }
      return "";
    }
    var _e = Object.prototype.hasOwnProperty, Fe = {}, ze = C.ReactDebugCurrentFrame;
    function Re(b) {
      if (b) {
        var R = b._owner, X = oe(b.type, b._source, R ? R.type : null);
        ze.setExtraStackFrame(X);
      } else
        ze.setExtraStackFrame(null);
    }
    function Ge(b, R, X, re, pe) {
      {
        var me = Function.call.bind(_e);
        for (var le in b)
          if (me(b, le)) {
            var se = void 0;
            try {
              if (typeof b[le] != "function") {
                var Ie = Error((re || "React class") + ": " + X + " type `" + le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              se = b[le](R, le, re, X, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              se = Le;
            }
            se && !(se instanceof Error) && (Re(pe), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", X, le, typeof se), Re(null)), se instanceof Error && !(se.message in Fe) && (Fe[se.message] = !0, Re(pe), w("Failed %s type: %s", X, se.message), Re(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ke(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, X = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return X;
      }
    }
    function rt(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function je(b) {
      if (rt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Se(b);
    }
    var Ne = C.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, ot, Te;
    Te = {};
    function Zt(b) {
      if (_e.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function lt(b) {
      if (_e.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ht(b, R) {
      if (typeof b.ref == "string" && Ne.current && R && Ne.current.stateNode !== R) {
        var X = V(Ne.current.type);
        Te[X] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ne.current.type), b.ref), Te[X] = !0);
      }
    }
    function kt(b, R) {
      {
        var X = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        X.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: X,
          configurable: !0
        });
      }
    }
    function sn(b, R) {
      {
        var X = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        X.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: X,
          configurable: !0
        });
      }
    }
    var St = function(b, R, X, re, pe, me, le) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: X,
        props: le,
        // Record the component responsible for creating this element.
        _owner: me
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: re
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: pe
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function an(b, R, X, re, pe) {
      {
        var me, le = {}, se = null, Ie = null;
        X !== void 0 && (je(X), se = "" + X), lt(R) && (je(R.key), se = "" + R.key), Zt(R) && (Ie = R.ref, ht(R, pe));
        for (me in R)
          _e.call(R, me) && !Ve.hasOwnProperty(me) && (le[me] = R[me]);
        if (b && b.defaultProps) {
          var Le = b.defaultProps;
          for (me in Le)
            le[me] === void 0 && (le[me] = Le[me]);
        }
        if (se || Ie) {
          var Pe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && kt(le, Pe), Ie && sn(le, Pe);
        }
        return St(b, se, Ie, pe, re, Ne.current, le);
      }
    }
    var tt = C.ReactCurrentOwner, Nt = C.ReactDebugCurrentFrame;
    function ut(b) {
      if (b) {
        var R = b._owner, X = oe(b.type, b._source, R ? R.type : null);
        Nt.setExtraStackFrame(X);
      } else
        Nt.setExtraStackFrame(null);
    }
    var ln;
    ln = !1;
    function Mt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Mn() {
      {
        if (tt.current) {
          var b = V(tt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function un(b) {
      return "";
    }
    var Tn = {};
    function cn(b) {
      {
        var R = Mn();
        if (!R) {
          var X = typeof b == "string" ? b : b.displayName || b.name;
          X && (R = `

Check the top-level render call using <` + X + ">.");
        }
        return R;
      }
    }
    function jn(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var X = cn(R);
        if (Tn[X])
          return;
        Tn[X] = !0;
        var re = "";
        b && b._owner && b._owner !== tt.current && (re = " It was passed a child from " + V(b._owner.type) + "."), ut(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', X, re), ut(null);
      }
    }
    function Yn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var X = 0; X < b.length; X++) {
            var re = b[X];
            Mt(re) && jn(re, R);
          }
        else if (Mt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var pe = h(b);
          if (typeof pe == "function" && pe !== b.entries)
            for (var me = pe.call(b), le; !(le = me.next()).done; )
              Mt(le.value) && jn(le.value, R);
        }
      }
    }
    function Ft(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var X;
        if (typeof R == "function")
          X = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          X = R.propTypes;
        else
          return;
        if (X) {
          var re = V(R);
          Ge(X, b.props, "prop", re, b);
        } else if (R.PropTypes !== void 0 && !ln) {
          ln = !0;
          var pe = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", pe || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ie(b) {
      {
        for (var R = Object.keys(b.props), X = 0; X < R.length; X++) {
          var re = R[X];
          if (re !== "children" && re !== "key") {
            ut(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), ut(null);
            break;
          }
        }
        b.ref !== null && (ut(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), ut(null));
      }
    }
    var eo = {};
    function to(b, R, X, re, pe, me) {
      {
        var le = N(b);
        if (!le) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ie = un();
          Ie ? se += Ie : se += Mn();
          var Le;
          b === null ? Le = "null" : Me(b) ? Le = "array" : b !== void 0 && b.$$typeof === t ? (Le = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, se);
        }
        var Pe = an(b, R, X, pe, me);
        if (Pe == null)
          return Pe;
        if (le) {
          var He = R.children;
          if (He !== void 0)
            if (re)
              if (Me(He)) {
                for (var pn = 0; pn < He.length; pn++)
                  Yn(He[pn], b);
                Object.freeze && Object.freeze(He);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Yn(He, b);
        }
        if (_e.call(R, "key")) {
          var zt = V(b), $e = Object.keys(R).filter(function(Ri) {
            return Ri !== "key";
          }), dr = $e.length > 0 ? "{key: someKey, " + $e.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!eo[zt + dr]) {
            var Ii = $e.length > 0 ? "{" + $e.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, dr, zt, Ii, zt), eo[zt + dr] = !0;
          }
        }
        return b === r ? ie(Pe) : Ft(Pe), Pe;
      }
    }
    function ji(b, R, X) {
      return to(b, R, X, !0);
    }
    function _i(b, R, X) {
      return to(b, R, X, !1);
    }
    var Ai = _i, Bi = ji;
    au.Fragment = r, au.jsx = Ai, au.jsxs = Bi;
  }()), au;
}
process.env.NODE_ENV === "production" ? zg.exports = Fz() : zg.exports = zz();
var Lr = zg.exports;
qe({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function cw(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function lr(e) {
  var t, n;
  return cw(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(cw(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var MM = Symbol.for("immer-nothing"), pw = Symbol.for("immer-draftable"), Vr = Symbol.for("immer-state"), $z = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Er(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = $z[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Bs = Object.getPrototypeOf;
function vs(e) {
  return !!e && !!e[Vr];
}
function ys(e) {
  var t;
  return e ? TM(e) || Array.isArray(e) || !!e[pw] || !!((t = e.constructor) != null && t[pw]) || dd(e) || fd(e) : !1;
}
var Uz = Object.prototype.constructor.toString();
function TM(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Bs(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Uz;
}
function Rc(e, t) {
  pd(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function pd(e) {
  const t = e[Vr];
  return t ? t.type_ : Array.isArray(e) ? 1 : dd(e) ? 2 : fd(e) ? 3 : 0;
}
function $g(e, t) {
  return pd(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function jM(e, t, n) {
  const r = pd(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Wz(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function dd(e) {
  return e instanceof Map;
}
function fd(e) {
  return e instanceof Set;
}
function Gi(e) {
  return e.copy_ || e.base_;
}
function Ug(e, t) {
  if (dd(e))
    return new Map(e);
  if (fd(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = TM(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Vr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Bs(e), r);
  } else {
    const r = Bs(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function jv(e, t = !1) {
  return hd(e) || vs(e) || !ys(e) || (pd(e) > 1 && (e.set = e.add = e.clear = e.delete = Vz), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => jv(r, !0))), e;
}
function Vz() {
  Er(2);
}
function hd(e) {
  return Object.isFrozen(e);
}
var Hz = {};
function bs(e) {
  const t = Hz[e];
  return t || Er(0, e), t;
}
var tl;
function _M() {
  return tl;
}
function qz(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function dw(e, t) {
  t && (bs("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Wg(e) {
  Vg(e), e.drafts_.forEach(Zz), e.drafts_ = null;
}
function Vg(e) {
  e === tl && (tl = e.parent_);
}
function fw(e) {
  return tl = qz(tl, e);
}
function Zz(e) {
  const t = e[Vr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function hw(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Vr].modified_ && (Wg(t), Er(4)), ys(e) && (e = Nc(t, e), t.parent_ || Fc(t, e)), t.patches_ && bs("Patches").generateReplacementPatches_(
    n[Vr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Nc(t, n, []), Wg(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== MM ? e : void 0;
}
function Nc(e, t, n) {
  if (hd(t))
    return t;
  const r = t[Vr];
  if (!r)
    return Rc(
      t,
      (o, i) => gw(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Fc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Rc(
      i,
      (a, l) => gw(e, r, o, a, l, n, s)
    ), Fc(e, o, !1), n && e.patches_ && bs("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function gw(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Er(5), vs(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !$g(t.assigned_, r) ? i.concat(r) : void 0, l = Nc(e, o, a);
    if (jM(n, r, l), vs(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ys(o) && !hd(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Nc(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Fc(e, o);
  }
}
function Fc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && jv(t, n);
}
function Kz(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : _M(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = _v;
  n && (o = [r], i = nl);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var _v = {
  get(e, t) {
    if (t === Vr)
      return e;
    const n = Gi(e);
    if (!$g(n, t))
      return Gz(e, n, t);
    const r = n[t];
    return e.finalized_ || !ys(r) ? r : r === Sf(e.base_, t) ? (Mf(e), e.copy_[t] = qg(r, e)) : r;
  },
  has(e, t) {
    return t in Gi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Gi(e));
  },
  set(e, t, n) {
    const r = AM(Gi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Sf(Gi(e), t), i = o == null ? void 0 : o[Vr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Wz(n, o) && (n !== void 0 || $g(e.base_, t)))
        return !0;
      Mf(e), Hg(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Sf(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Mf(e), Hg(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Gi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Er(11);
  },
  getPrototypeOf(e) {
    return Bs(e.base_);
  },
  setPrototypeOf() {
    Er(12);
  }
}, nl = {};
Rc(_v, (e, t) => {
  nl[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
nl.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Er(13), nl.set.call(this, e, t, void 0);
};
nl.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Er(14), _v.set.call(this, e[0], t, n, e[0]);
};
function Sf(e, t) {
  const n = e[Vr];
  return (n ? Gi(n) : e)[t];
}
function Gz(e, t, n) {
  var r;
  const o = AM(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function AM(e, t) {
  if (!(t in e))
    return;
  let n = Bs(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Bs(n);
  }
}
function Hg(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Hg(e.parent_));
}
function Mf(e) {
  e.copy_ || (e.copy_ = Ug(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Yz = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Er(6), r !== void 0 && typeof r != "function" && Er(7);
      let o;
      if (ys(t)) {
        const i = fw(this), s = qg(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Wg(i) : Vg(i);
        }
        return dw(i, r), hw(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === MM && (o = void 0), this.autoFreeze_ && jv(o, !0), r) {
          const i = [], s = [];
          bs("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Er(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ys(e) || Er(8), vs(e) && (e = Xz(e));
    const t = fw(this), n = qg(e, void 0);
    return n[Vr].isManual_ = !0, Vg(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Vr];
    (!n || !n.isManual_) && Er(9);
    const { scope_: r } = n;
    return dw(r, t), hw(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = bs("Patches").applyPatches_;
    return vs(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function qg(e, t) {
  const n = dd(e) ? bs("MapSet").proxyMap_(e, t) : fd(e) ? bs("MapSet").proxySet_(e, t) : Kz(e, t);
  return (t ? t.scope_ : _M()).drafts_.push(n), n;
}
function Xz(e) {
  return vs(e) || Er(10, e), BM(e);
}
function BM(e) {
  if (!ys(e) || hd(e))
    return e;
  const t = e[Vr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Ug(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Ug(e, !0);
  return Rc(n, (r, o) => {
    jM(n, r, BM(o));
  }), t && (t.finalized_ = !1), n;
}
var Hr = new Yz(), Av = Hr.produce;
Hr.produceWithPatches.bind(
  Hr
);
Hr.setAutoFreeze.bind(Hr);
Hr.setUseStrictShallowCopy.bind(Hr);
Hr.applyPatches.bind(Hr);
var mw = Hr.createDraft.bind(Hr), vw = Hr.finishDraft.bind(Hr), we = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = we.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return we.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return we.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return we.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return we.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && we.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return we.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && we.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && we.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && we.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && we.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && we.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!we.isAncestor(t, e) && !we.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (we.equals(i, r) || we.endsBefore(i, r) || we.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (we.equals(s, r) || we.isAncestor(s, r))
          return null;
        we.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        we.equals(a, r) || we.endsBefore(a, r) ? r[a.length - 1] -= 1 : we.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (we.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else we.endsBefore(u, r) ? r[u.length - 1] += 1 : we.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (we.equals(p, d))
          return r;
        if (we.isAncestor(p, r) || we.equals(p, r)) {
          var m = d.slice();
          return we.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else we.isSibling(p, d) && (we.isAncestor(d, r) || we.equals(d, r)) ? we.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : we.endsBefore(d, r) || we.equals(d, r) || we.isAncestor(d, r) ? (we.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : we.endsBefore(p, r) && (we.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function rl(e) {
  "@babel/helpers - typeof";
  return rl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, rl(e);
}
function Jz(e, t) {
  if (rl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (rl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Qz(e) {
  var t = Jz(e, "string");
  return rl(t) === "symbol" ? t : String(t);
}
function Us(e, t, n) {
  return t = Qz(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yw(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var e$ = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Qe.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of dt.points(t))
          t[l] = mn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Qe.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of dt.points(t))
          t[h] = mn.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = Qe.get(e, C), S = we.previous(C), E = Qe.get(e, S), v = Qe.parent(e, C), O = C[C.length - 1];
      if (Wn.isText(w) && Wn.isText(E))
        E.text += w.text;
      else if (!Wn.isText(w) && !Wn.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(_r.stringify(w), " ").concat(_r.stringify(E)));
      if (v.children.splice(O, 1), t)
        for (var [P, U] of dt.points(t))
          t[U] = mn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (we.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var A = Qe.get(e, L), z = Qe.parent(e, L), V = L[L.length - 1];
      z.children.splice(V, 1);
      var $ = we.transform(L, n), Z = Qe.get(e, we.parent($)), J = $[$.length - 1];
      if (Z.children.splice(J, 0, A), t)
        for (var [Y, te] of dt.points(t))
          t[te] = mn.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], _ = Qe.parent(e, ee);
      if (_.children.splice(k, 1), t)
        for (var [K, M] of dt.points(t)) {
          var G = mn.transform(K, n);
          if (t != null && G != null)
            t[M] = G;
          else {
            var x = void 0, T = void 0;
            for (var [F, j] of Qe.texts(e))
              if (we.compare(j, ee) === -1)
                x = [F, j];
              else {
                T = [F, j];
                break;
              }
            var H = !1;
            x && T && (we.equals(T[1], ee) ? H = !we.hasPrevious(T[1]) : H = we.common(x[1], ee).length < we.common(T[1], ee).length), x && !H ? (K.path = x[1], K.offset = x[0].text.length) : T ? (K.path = T[1], K.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Q,
        text: W
      } = n;
      if (W.length === 0) break;
      var ue = Qe.leaf(e, B), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + W.length);
      if (ue.text = ye + oe, t)
        for (var [_e, Fe] of dt.points(t))
          t[Fe] = mn.transform(_e, n);
      break;
    }
    case "set_node": {
      var {
        path: ze,
        properties: Re,
        newProperties: Ge
      } = n;
      if (ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = Qe.get(e, ze);
      for (var Me in Ge) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ke = Ge[Me];
        Ke == null ? delete Ze[Me] : Ze[Me] = Ke;
      }
      for (var rt in Re)
        Ge.hasOwnProperty(rt) || delete Ze[rt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!dt.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(_r.stringify(Se), " when there is no current selection."));
          t = oa({}, Se);
        }
        for (var je in Se) {
          var Ne = Se[je];
          if (Ne == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ne;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ue,
        properties: ot
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var Te = Qe.get(e, Ve), Zt = Qe.parent(e, Ve), lt = Ve[Ve.length - 1], ht;
      if (Wn.isText(Te)) {
        var kt = Te.text.slice(0, Ue), sn = Te.text.slice(Ue);
        Te.text = kt, ht = oa(oa({}, ot), {}, {
          text: sn
        });
      } else {
        var St = Te.children.slice(0, Ue), an = Te.children.slice(Ue);
        Te.children = St, ht = oa(oa({}, ot), {}, {
          children: an
        });
      }
      if (Zt.children.splice(lt + 1, 0, ht), t)
        for (var [tt, Nt] of dt.points(t))
          t[Nt] = mn.transform(tt, n);
      break;
    }
  }
  return t;
}, t$ = {
  transform(e, t) {
    e.children = mw(e.children);
    var n = e.selection && mw(e.selection);
    try {
      n = e$(e, n, t);
    } finally {
      e.children = vw(e.children), n ? e.selection = vs(n) ? vw(n) : n : e.selection = null;
    }
  }
}, n$ = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, r$ = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, IM = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (lr(r) && lr(o)) {
      if (!IM(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function o$(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ol(e, t) {
  if (e == null) return {};
  var n = o$(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var i$ = ["anchor", "focus"];
function bw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bw(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return dt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = dt.edges(e);
    return t;
  },
  equals(e, t) {
    return mn.equals(e.anchor, t.anchor) && mn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (dt.isRange(t)) {
      if (dt.includes(e, t.anchor) || dt.includes(e, t.focus))
        return !0;
      var [n, r] = dt.edges(e), [o, i] = dt.edges(t);
      return mn.isBefore(n, o) && mn.isAfter(r, i);
    }
    var [s, a] = dt.edges(e), l = !1, u = !1;
    return mn.isPoint(t) ? (l = mn.compare(t, s) >= 0, u = mn.compare(t, a) <= 0) : (l = we.compare(t, s.path) >= 0, u = we.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ol(e, i$), [r, o] = dt.edges(e), [i, s] = dt.edges(t), a = mn.isBefore(r, i) ? i : r, l = mn.isBefore(o, s) ? o : s;
    return mn.isBefore(l, a) ? null : s$({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return mn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return mn.equals(t, n);
  },
  isExpanded(e) {
    return !dt.isCollapsed(e);
  },
  isForward(e) {
    return !dt.isBackward(e);
  },
  isRange(e) {
    return lr(e) && mn.isPoint(e.anchor) && mn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = dt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Av(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = dt.isCollapsed(r);
        dt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? dt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = mn.transform(r.anchor, t, {
        affinity: i
      }), u = mn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, ww = (e) => lr(e) && Qe.isNodeList(e.children) && !Qt.isEditor(e), To = {
  isAncestor(e) {
    return lr(e) && Qe.isNodeList(e.children);
  },
  isElement: ww,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => To.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return ww(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, a$ = ["children"], l$ = ["text"], Cw = /* @__PURE__ */ new WeakMap(), Qe = {
  ancestor(e, t) {
    var n = Qe.get(e, t);
    if (Wn.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(_r.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of we.ancestors(t, n)) {
        var o = Qe.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Wn.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(_r.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(_r.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Qe.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = Qe.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = we.common(t, n), o = Qe.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Qe.get(e, t);
    if (Qt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(_r.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Qe.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Qe.nodes(e, t))
        To.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (To.isAncestor(e)) {
      var t = ol(e, a$);
      return t;
    } else {
      var t = ol(e, l$);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Qe.get(e, n); r && !(Wn.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Wn.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(_r.stringify(e)));
    var n = Av({
      children: e.children
    }, (r) => {
      var [o, i] = dt.edges(t), s = Qe.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !dt.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!dt.includes(t, a)) {
          var l = Qe.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (we.equals(a, i.path)) {
          var c = Qe.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (we.equals(a, o.path)) {
          var p = Qe.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      Qt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Wn.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(_r.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Wn.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Wn.isText(e) || To.isElement(e) || Qt.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Cw.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Qe.isNode(r));
    return Cw.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Qe.get(e, n); r && !(Wn.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Qe.get(e, t);
    if (!Wn.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(_r.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of we.levels(t, n)) {
        var o = Qe.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return To.isElement(e) && To.isElementProps(t) && To.matches(e, t) || Wn.isText(e) && Wn.isTextProps(t) && Wn.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? we.isBefore(a, i) : we.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Wn.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          we.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = Qe.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = we.next(a);
          if (Qe.has(e, c)) {
            a = c, l = Qe.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = we.previous(a);
          a = p, l = Qe.get(e, a);
          continue;
        }
        a = we.parent(a), l = Qe.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = we.parent(t), r = Qe.get(e, n);
    if (Wn.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Wn.isText(e) ? e.text : e.children.map(Qe.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Qe.nodes(e, t))
        Wn.isText(n) && (yield [n, r]);
    }();
  }
};
function Ow(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ow(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ow(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xa = {
  isNodeOperation(e) {
    return xa.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!lr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return we.isPath(e.path) && Qe.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && we.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && we.isPath(e.path) && lr(e.properties);
      case "move_node":
        return we.isPath(e.path) && we.isPath(e.newPath);
      case "remove_node":
        return we.isPath(e.path) && Qe.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && we.isPath(e.path);
      case "set_node":
        return we.isPath(e.path) && lr(e.properties) && lr(e.newProperties);
      case "set_selection":
        return e.properties === null && dt.isRange(e.newProperties) || e.newProperties === null && dt.isRange(e.properties) || lr(e.properties) && lr(e.newProperties);
      case "split_node":
        return we.isPath(e.path) && typeof e.position == "number" && lr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => xa.isOperation(t));
  },
  isSelectionOperation(e) {
    return xa.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return xa.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return wn(wn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return wn(wn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return wn(wn({}, e), {}, {
          type: "split_node",
          path: we.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (we.equals(t, n))
          return e;
        if (we.isSibling(n, t))
          return wn(wn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = we.transform(n, e), o = we.transform(we.next(n), e);
        return wn(wn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return wn(wn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return wn(wn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return wn(wn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? wn(wn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? wn(wn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : wn(wn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return wn(wn({}, e), {}, {
          type: "merge_node",
          path: we.next(e.path)
        });
    }
  }
}, Ew = /* @__PURE__ */ new WeakMap(), u$ = (e) => {
  var t = Ew.get(e);
  if (t !== void 0)
    return t;
  if (!lr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || lr(e.marks)) && (e.selection === null || dt.isRange(e.selection)) && Qe.isNodeList(e.children) && xa.isOperationList(e.operations);
  return Ew.set(e, n), n;
}, Qt = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return u$(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function xw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xw(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mn = {
  compare(e, t) {
    var n = we.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return mn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return mn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && we.equals(e.path, t.path);
  },
  isPoint(e) {
    return lr(e) && typeof e.offset == "number" && we.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Av(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = we.transform(i, t, n);
          break;
        }
        case "insert_text": {
          we.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          we.equals(t.path, i) && (r.offset += t.position), r.path = we.transform(i, t, n);
          break;
        }
        case "remove_text": {
          we.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (we.equals(t.path, i) || we.isAncestor(t.path, i))
            return null;
          r.path = we.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (we.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = we.transform(i, t, Lw(Lw({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = we.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Dw = void 0, _r = {
  setScrubber(e) {
    Dw = e;
  },
  stringify(e) {
    return JSON.stringify(e, Dw);
  }
}, c$ = ["text"], p$ = ["anchor", "focus"];
function Pw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Pw(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wn = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = ol(i, c$);
      return s;
    }
    return IM(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return lr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Wn.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [xo({}, e)];
    for (var r of t) {
      var o = ol(r, p$), [i, s] = dt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var C = c - m;
          h = xo(xo({}, f), {}, {
            text: f.text.slice(C)
          }), f = xo(xo({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > m) {
          var w = u - m;
          g = xo(xo({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = xo(xo({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, d$ = (e) => e.selection ? e.selection : e.children.length > 0 ? Qt.end(e, []) : [0], fn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(fn || (fn = {}));
fn.L, fn.L | fn.V | fn.LV | fn.LVT, fn.LV | fn.V, fn.V | fn.T, fn.LVT | fn.T, fn.T, fn.Any, fn.Extend | fn.ZWJ, fn.Any, fn.SpacingMark, fn.Prepend, fn.Any, fn.ZWJ, fn.ExtPict, fn.RI, fn.RI;
var f$ = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Qt.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = d$(e)
      } = n;
      if (we.isPath(o) && (o = Qt.range(e, o)), dt.isRange(o))
        if (dt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = dt.end(o);
          if (!r && Qt.void(e, {
            at: i
          }))
            return;
          var s = dt.start(o), a = Qt.pointRef(e, s), l = Qt.pointRef(e, i);
          zc.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, zc.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Qt.void(e, {
        at: o
      }) || Qt.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function kw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kw(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zc = lu(lu(lu(lu({}, t$), n$), r$), f$), RM = {}, Bv = {}, Iv = {};
Object.defineProperty(Iv, "__esModule", { value: !0 });
Iv.default = v$;
var Sw = "html", Mw = "head", uu = "body", h$ = /<([a-zA-Z]+[0-9]?)/, Tw = /<head[^]*>/i, jw = /<body[^]*>/i, $c = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Zg = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, _w = typeof window == "object" && window.DOMParser;
if (typeof _w == "function") {
  var g$ = new _w(), m$ = "text/html";
  Zg = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), g$.parseFromString(e, m$);
  }, $c = Zg;
}
if (typeof document == "object" && document.implementation) {
  var cu = document.implementation.createHTMLDocument();
  $c = function(e, t) {
    if (t) {
      var n = cu.documentElement.querySelector(t);
      return n && (n.innerHTML = e), cu;
    }
    return cu.documentElement.innerHTML = e, cu;
  };
}
var pu = typeof document == "object" && document.createElement("template"), Kg;
pu && pu.content && (Kg = function(e) {
  return pu.innerHTML = e, pu.content.childNodes;
});
function v$(e) {
  var t, n, r = e.match(h$), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Sw: {
      var i = Zg(e);
      if (!Tw.test(e)) {
        var s = i.querySelector(Mw);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!jw.test(e)) {
        var s = i.querySelector(uu);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(Sw);
    }
    case Mw:
    case uu: {
      var a = $c(e).querySelectorAll(o);
      return jw.test(e) && Tw.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Kg)
        return Kg(e);
      var s = $c(e, uu).querySelector(uu);
      return s.childNodes;
    }
  }
}
var gd = {}, Rv = {}, Nv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Nv);
var yt = {}, Ei = rn && rn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), _a = rn && rn.__assign || function() {
  return _a = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, _a.apply(this, arguments);
};
Object.defineProperty(yt, "__esModule", { value: !0 });
yt.cloneNode = yt.hasChildren = yt.isDocument = yt.isDirective = yt.isComment = yt.isText = yt.isCDATA = yt.isTag = yt.Element = yt.Document = yt.CDATA = yt.NodeWithChildren = yt.ProcessingInstruction = yt.Comment = yt.Text = yt.DataNode = yt.Node = void 0;
var Sr = Nv, Fv = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), zv(this, t);
    }, e;
  }()
);
yt.Node = Fv;
var md = (
  /** @class */
  function(e) {
    Ei(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Fv)
);
yt.DataNode = md;
var NM = (
  /** @class */
  function(e) {
    Ei(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Sr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(md)
);
yt.Text = NM;
var FM = (
  /** @class */
  function(e) {
    Ei(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Sr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(md)
);
yt.Comment = FM;
var zM = (
  /** @class */
  function(e) {
    Ei(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Sr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(md)
);
yt.ProcessingInstruction = zM;
var vd = (
  /** @class */
  function(e) {
    Ei(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Fv)
);
yt.NodeWithChildren = vd;
var $M = (
  /** @class */
  function(e) {
    Ei(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Sr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(vd)
);
yt.CDATA = $M;
var UM = (
  /** @class */
  function(e) {
    Ei(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Sr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(vd)
);
yt.Document = UM;
var WM = (
  /** @class */
  function(e) {
    Ei(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Sr.ElementType.Script : n === "style" ? Sr.ElementType.Style : Sr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(vd)
);
yt.Element = WM;
function VM(e) {
  return (0, Sr.isTag)(e);
}
yt.isTag = VM;
function HM(e) {
  return e.type === Sr.ElementType.CDATA;
}
yt.isCDATA = HM;
function qM(e) {
  return e.type === Sr.ElementType.Text;
}
yt.isText = qM;
function ZM(e) {
  return e.type === Sr.ElementType.Comment;
}
yt.isComment = ZM;
function KM(e) {
  return e.type === Sr.ElementType.Directive;
}
yt.isDirective = KM;
function GM(e) {
  return e.type === Sr.ElementType.Root;
}
yt.isDocument = GM;
function y$(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
yt.hasChildren = y$;
function zv(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (qM(e))
    n = new NM(e.data);
  else if (ZM(e))
    n = new FM(e.data);
  else if (VM(e)) {
    var r = t ? Tf(e.children) : [], o = new WM(e.name, _a({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = _a({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = _a({}, e["x-attribsPrefix"])), n = o;
  } else if (HM(e)) {
    var r = t ? Tf(e.children) : [], i = new $M(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (GM(e)) {
    var r = t ? Tf(e.children) : [], s = new UM(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (KM(e)) {
    var a = new zM(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
yt.cloneNode = zv;
function Tf(e) {
  for (var t = e.map(function(r) {
    return zv(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = rn && rn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = rn && rn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Nv, o = yt;
  n(yt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Rv);
var YM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(YM);
Object.defineProperty(gd, "__esModule", { value: !0 });
gd.formatAttributes = XM;
gd.formatDOM = JM;
var du = Rv, b$ = YM;
function w$(e) {
  return b$.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function XM(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function C$(e) {
  e = e.toLowerCase();
  var t = w$(e);
  return t || e;
}
function JM(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = C$(a.nodeName);
        o = new du.Element(l, XM(a.attributes)), o.children = JM(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new du.Text(a.nodeValue);
        break;
      case 8:
        o = new du.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new du.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var O$ = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Bv, "__esModule", { value: !0 });
Bv.default = D$;
var E$ = O$(Iv), x$ = gd, L$ = /<(![a-zA-Z\s]+)>/;
function D$(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(L$), n = t ? t[1] : void 0;
  return (0, x$.formatDOM)((0, E$.default)(e), null, n);
}
var yd = {}, io = {}, bd = {}, P$ = 0;
bd.SAME = P$;
var k$ = 1;
bd.CAMELCASE = k$;
bd.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const QM = 0, xi = 1, wd = 2, Cd = 3, $v = 4, eT = 5, tT = 6;
function S$(e) {
  return or.hasOwnProperty(e) ? or[e] : null;
}
function yr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === wd || t === Cd || t === $v, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const or = {}, M$ = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
M$.forEach((e) => {
  or[e] = new yr(
    e,
    QM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  or[e] = new yr(
    e,
    xi,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  or[e] = new yr(
    e,
    wd,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  or[e] = new yr(
    e,
    wd,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  or[e] = new yr(
    e,
    Cd,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  or[e] = new yr(
    e,
    Cd,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  or[e] = new yr(
    e,
    $v,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  or[e] = new yr(
    e,
    tT,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  or[e] = new yr(
    e,
    eT,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Uv = /[\-\:]([a-z])/g, Wv = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Uv, Wv);
  or[t] = new yr(
    t,
    xi,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Uv, Wv);
  or[t] = new yr(
    t,
    xi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Uv, Wv);
  or[t] = new yr(
    t,
    xi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  or[e] = new yr(
    e,
    xi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const T$ = "xlinkHref";
or[T$] = new yr(
  "xlinkHref",
  xi,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  or[e] = new yr(
    e,
    xi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: j$,
  SAME: _$,
  possibleStandardNames: Aw
} = bd, A$ = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", B$ = A$ + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", I$ = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + B$ + "]*$")
), R$ = Object.keys(
  Aw
).reduce((e, t) => {
  const n = Aw[t];
  return n === _$ ? e[t] = t : n === j$ ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
io.BOOLEAN = Cd;
io.BOOLEANISH_STRING = wd;
io.NUMERIC = eT;
io.OVERLOADED_BOOLEAN = $v;
io.POSITIVE_NUMERIC = tT;
io.RESERVED = QM;
io.STRING = xi;
io.getPropertyInfo = S$;
io.isCustomAttribute = I$;
io.possibleStandardNames = R$;
var Vv = {}, Hv = {}, Bw = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, N$ = /\n/g, F$ = /^\s*/, z$ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, $$ = /^:\s*/, U$ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, W$ = /^[;\s]*/, V$ = /^\s+|\s+$/g, H$ = `
`, Iw = "/", Rw = "*", es = "", q$ = "comment", Z$ = "declaration", K$ = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(N$);
    g && (n += g.length);
    var h = f.lastIndexOf(H$);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(F$);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(Iw != e.charAt(0) || Rw != e.charAt(1))) {
      for (var g = 2; es != e.charAt(g) && (Rw != e.charAt(g) || Iw != e.charAt(g + 1)); )
        ++g;
      if (g += 2, es === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: q$,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(z$);
    if (g) {
      if (p(), !l($$)) return a("property missing ':'");
      var h = l(U$), C = f({
        type: Z$,
        property: Nw(g[0].replace(Bw, es)),
        value: h ? Nw(h[0].replace(Bw, es)) : es
      });
      return l(W$), C;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function Nw(e) {
  return e ? e.replace(V$, es) : es;
}
var G$ = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Hv, "__esModule", { value: !0 });
Hv.default = X$;
var Y$ = G$(K$);
function X$(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Y$.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Od = {};
Object.defineProperty(Od, "__esModule", { value: !0 });
Od.camelCase = void 0;
var J$ = /^--[a-zA-Z0-9_-]+$/, Q$ = /-([a-z])/g, e3 = /^[^-]+$/, t3 = /^-(webkit|moz|ms|o|khtml)-/, n3 = /^-(ms)-/, r3 = function(e) {
  return !e || e3.test(e) || J$.test(e);
}, o3 = function(e, t) {
  return t.toUpperCase();
}, Fw = function(e, t) {
  return "".concat(t, "-");
}, i3 = function(e, t) {
  return t === void 0 && (t = {}), r3(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(n3, Fw) : e = e.replace(t3, Fw), e.replace(Q$, o3));
};
Od.camelCase = i3;
var s3 = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, a3 = s3(Hv), l3 = Od;
function Gg(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, a3.default)(e, function(r, o) {
    r && o && (n[(0, l3.camelCase)(r, t)] = o);
  }), n;
}
Gg.default = Gg;
var u3 = Gg;
(function(e) {
  var t = rn && rn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = xe, r = t(u3), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Vv);
Object.defineProperty(yd, "__esModule", { value: !0 });
yd.default = f3;
var La = io, zw = Vv, c3 = ["checked", "value"], p3 = ["input", "select", "textarea"], d3 = {
  reset: !0,
  submit: !0
};
function f3(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && d3[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, La.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = $w(s);
    if (a) {
      var l = (0, La.getPropertyInfo)(a);
      switch (c3.includes(a) && p3.includes(t) && !r && (a = $w("default" + s)), n[a] = i, l && l.type) {
        case La.BOOLEAN:
          n[a] = !0;
          break;
        case La.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    zw.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, zw.setStyleProp)(e.style, n), n;
}
function $w(e) {
  return La.possibleStandardNames[e];
}
var qv = {}, h3 = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(qv, "__esModule", { value: !0 });
qv.default = nT;
var jf = xe, g3 = h3(yd), Aa = Vv, m3 = {
  cloneElement: jf.cloneElement,
  createElement: jf.createElement,
  isValidElement: jf.isValidElement
};
function nT(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Aa.returnFirstArg, i = t.library || m3, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, Aa.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    v3(f) ? ((0, Aa.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, g3.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = nT(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function v3(e) {
  return Aa.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Aa.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = rn && rn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(Bv);
  e.htmlToDOM = n.default;
  var r = t(yd);
  e.attributesToProps = r.default;
  var o = t(qv);
  e.domToReact = o.default;
  var i = Rv;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(RM);
const y3 = /* @__PURE__ */ Nz(RM);
y3.default;
var on = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function b3(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Yg = { exports: {} }, ia = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Uw;
function w3() {
  if (Uw) return ia;
  Uw = 1;
  var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, m = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: m, props: p, _owner: o.current };
  }
  return ia.Fragment = n, ia.jsx = s, ia.jsxs = s, ia;
}
var fu = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ww;
function C3() {
  return Ww || (Ww = 1, process.env.NODE_ENV !== "production" && function() {
    var e = xe, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var R = f && b[f] || b[g];
      return typeof R == "function" ? R : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var R = arguments.length, X = new Array(R > 1 ? R - 1 : 0), re = 1; re < R; re++)
          X[re - 1] = arguments[re];
        S("error", b, X);
      }
    }
    function S(b, R, X) {
      {
        var re = C.ReactDebugCurrentFrame, pe = re.getStackAddendum();
        pe !== "" && (R += "%s", X = X.concat([pe]));
        var me = X.map(function(le) {
          return String(le);
        });
        me.unshift("Warning: " + R), Function.prototype.apply.call(console[b], console, me);
      }
    }
    var E = !1, v = !1, O = !1, P = !1, U = !1, L;
    L = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || U || b === o || b === u || b === c || P || b === m || E || v || O || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function A(b, R, X) {
      var re = b.displayName;
      if (re)
        return re;
      var pe = R.displayName || R.name || "";
      return pe !== "" ? X + "(" + pe + ")" : X;
    }
    function z(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var R = b;
            return z(R) + ".Consumer";
          case s:
            var X = b;
            return z(X._context) + ".Provider";
          case l:
            return A(b, b.render, "ForwardRef");
          case p:
            var re = b.displayName || null;
            return re !== null ? re : V(b.type) || "Memo";
          case d: {
            var pe = b, me = pe._payload, le = pe._init;
            try {
              return V(le(me));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var $ = Object.assign, Z = 0, J, Y, te, ee, k, _, K;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function G() {
      {
        if (Z === 0) {
          J = console.log, Y = console.info, te = console.warn, ee = console.error, k = console.group, _ = console.groupCollapsed, K = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        Z++;
      }
    }
    function x() {
      {
        if (Z--, Z === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: $({}, b, {
              value: J
            }),
            info: $({}, b, {
              value: Y
            }),
            warn: $({}, b, {
              value: te
            }),
            error: $({}, b, {
              value: ee
            }),
            group: $({}, b, {
              value: k
            }),
            groupCollapsed: $({}, b, {
              value: _
            }),
            groupEnd: $({}, b, {
              value: K
            })
          });
        }
        Z < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var T = C.ReactCurrentDispatcher, F;
    function j(b, R, X) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (pe) {
            var re = pe.stack.trim().match(/\n( *(at )?)/);
            F = re && re[1] || "";
          }
        return `
` + F + b;
      }
    }
    var H = !1, B;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      B = new Q();
    }
    function W(b, R) {
      if (!b || H)
        return "";
      {
        var X = B.get(b);
        if (X !== void 0)
          return X;
      }
      var re;
      H = !0;
      var pe = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var me;
      me = T.current, T.current = null, G();
      try {
        if (R) {
          var le = function() {
            throw Error();
          };
          if (Object.defineProperty(le.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(le, []);
            } catch ($e) {
              re = $e;
            }
            Reflect.construct(b, [], le);
          } else {
            try {
              le.call();
            } catch ($e) {
              re = $e;
            }
            b.call(le.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($e) {
            re = $e;
          }
          b();
        }
      } catch ($e) {
        if ($e && re && typeof $e.stack == "string") {
          for (var se = $e.stack.split(`
`), Ie = re.stack.split(`
`), Le = se.length - 1, Pe = Ie.length - 1; Le >= 1 && Pe >= 0 && se[Le] !== Ie[Pe]; )
            Pe--;
          for (; Le >= 1 && Pe >= 0; Le--, Pe--)
            if (se[Le] !== Ie[Pe]) {
              if (Le !== 1 || Pe !== 1)
                do
                  if (Le--, Pe--, Pe < 0 || se[Le] !== Ie[Pe]) {
                    var He = `
` + se[Le].replace(" at new ", " at ");
                    return b.displayName && He.includes("<anonymous>") && (He = He.replace("<anonymous>", b.displayName)), typeof b == "function" && B.set(b, He), He;
                  }
                while (Le >= 1 && Pe >= 0);
              break;
            }
        }
      } finally {
        H = !1, T.current = me, x(), Error.prepareStackTrace = pe;
      }
      var pn = b ? b.displayName || b.name : "", zt = pn ? j(pn) : "";
      return typeof b == "function" && B.set(b, zt), zt;
    }
    function ue(b, R, X) {
      return W(b, !1);
    }
    function ye(b) {
      var R = b.prototype;
      return !!(R && R.isReactComponent);
    }
    function oe(b, R, X) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return W(b, ye(b));
      if (typeof b == "string")
        return j(b);
      switch (b) {
        case u:
          return j("Suspense");
        case c:
          return j("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, R, X);
          case d: {
            var re = b, pe = re._payload, me = re._init;
            try {
              return oe(me(pe), R, X);
            } catch {
            }
          }
        }
      return "";
    }
    var _e = Object.prototype.hasOwnProperty, Fe = {}, ze = C.ReactDebugCurrentFrame;
    function Re(b) {
      if (b) {
        var R = b._owner, X = oe(b.type, b._source, R ? R.type : null);
        ze.setExtraStackFrame(X);
      } else
        ze.setExtraStackFrame(null);
    }
    function Ge(b, R, X, re, pe) {
      {
        var me = Function.call.bind(_e);
        for (var le in b)
          if (me(b, le)) {
            var se = void 0;
            try {
              if (typeof b[le] != "function") {
                var Ie = Error((re || "React class") + ": " + X + " type `" + le + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[le] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              se = b[le](R, le, re, X, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              se = Le;
            }
            se && !(se instanceof Error) && (Re(pe), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", re || "React class", X, le, typeof se), Re(null)), se instanceof Error && !(se.message in Fe) && (Fe[se.message] = !0, Re(pe), w("Failed %s type: %s", X, se.message), Re(null));
          }
      }
    }
    var Ze = Array.isArray;
    function Me(b) {
      return Ze(b);
    }
    function Ke(b) {
      {
        var R = typeof Symbol == "function" && Symbol.toStringTag, X = R && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return X;
      }
    }
    function rt(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function je(b) {
      if (rt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(b)), Se(b);
    }
    var Ne = C.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ue, ot, Te;
    Te = {};
    function Zt(b) {
      if (_e.call(b, "ref")) {
        var R = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function lt(b) {
      if (_e.call(b, "key")) {
        var R = Object.getOwnPropertyDescriptor(b, "key").get;
        if (R && R.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ht(b, R) {
      if (typeof b.ref == "string" && Ne.current && R && Ne.current.stateNode !== R) {
        var X = V(Ne.current.type);
        Te[X] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ne.current.type), b.ref), Te[X] = !0);
      }
    }
    function kt(b, R) {
      {
        var X = function() {
          Ue || (Ue = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        X.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: X,
          configurable: !0
        });
      }
    }
    function sn(b, R) {
      {
        var X = function() {
          ot || (ot = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", R));
        };
        X.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: X,
          configurable: !0
        });
      }
    }
    var St = function(b, R, X, re, pe, me, le) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: R,
        ref: X,
        props: le,
        // Record the component responsible for creating this element.
        _owner: me
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: re
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: pe
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function an(b, R, X, re, pe) {
      {
        var me, le = {}, se = null, Ie = null;
        X !== void 0 && (je(X), se = "" + X), lt(R) && (je(R.key), se = "" + R.key), Zt(R) && (Ie = R.ref, ht(R, pe));
        for (me in R)
          _e.call(R, me) && !Ve.hasOwnProperty(me) && (le[me] = R[me]);
        if (b && b.defaultProps) {
          var Le = b.defaultProps;
          for (me in Le)
            le[me] === void 0 && (le[me] = Le[me]);
        }
        if (se || Ie) {
          var Pe = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          se && kt(le, Pe), Ie && sn(le, Pe);
        }
        return St(b, se, Ie, pe, re, Ne.current, le);
      }
    }
    var tt = C.ReactCurrentOwner, Nt = C.ReactDebugCurrentFrame;
    function ut(b) {
      if (b) {
        var R = b._owner, X = oe(b.type, b._source, R ? R.type : null);
        Nt.setExtraStackFrame(X);
      } else
        Nt.setExtraStackFrame(null);
    }
    var ln;
    ln = !1;
    function Mt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Mn() {
      {
        if (tt.current) {
          var b = V(tt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function un(b) {
      return "";
    }
    var Tn = {};
    function cn(b) {
      {
        var R = Mn();
        if (!R) {
          var X = typeof b == "string" ? b : b.displayName || b.name;
          X && (R = `

Check the top-level render call using <` + X + ">.");
        }
        return R;
      }
    }
    function jn(b, R) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var X = cn(R);
        if (Tn[X])
          return;
        Tn[X] = !0;
        var re = "";
        b && b._owner && b._owner !== tt.current && (re = " It was passed a child from " + V(b._owner.type) + "."), ut(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', X, re), ut(null);
      }
    }
    function Yn(b, R) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var X = 0; X < b.length; X++) {
            var re = b[X];
            Mt(re) && jn(re, R);
          }
        else if (Mt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var pe = h(b);
          if (typeof pe == "function" && pe !== b.entries)
            for (var me = pe.call(b), le; !(le = me.next()).done; )
              Mt(le.value) && jn(le.value, R);
        }
      }
    }
    function Ft(b) {
      {
        var R = b.type;
        if (R == null || typeof R == "string")
          return;
        var X;
        if (typeof R == "function")
          X = R.propTypes;
        else if (typeof R == "object" && (R.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        R.$$typeof === p))
          X = R.propTypes;
        else
          return;
        if (X) {
          var re = V(R);
          Ge(X, b.props, "prop", re, b);
        } else if (R.PropTypes !== void 0 && !ln) {
          ln = !0;
          var pe = V(R);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", pe || "Unknown");
        }
        typeof R.getDefaultProps == "function" && !R.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ie(b) {
      {
        for (var R = Object.keys(b.props), X = 0; X < R.length; X++) {
          var re = R[X];
          if (re !== "children" && re !== "key") {
            ut(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", re), ut(null);
            break;
          }
        }
        b.ref !== null && (ut(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), ut(null));
      }
    }
    var eo = {};
    function to(b, R, X, re, pe, me) {
      {
        var le = N(b);
        if (!le) {
          var se = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ie = un();
          Ie ? se += Ie : se += Mn();
          var Le;
          b === null ? Le = "null" : Me(b) ? Le = "array" : b !== void 0 && b.$$typeof === t ? (Le = "<" + (V(b.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, se);
        }
        var Pe = an(b, R, X, pe, me);
        if (Pe == null)
          return Pe;
        if (le) {
          var He = R.children;
          if (He !== void 0)
            if (re)
              if (Me(He)) {
                for (var pn = 0; pn < He.length; pn++)
                  Yn(He[pn], b);
                Object.freeze && Object.freeze(He);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Yn(He, b);
        }
        if (_e.call(R, "key")) {
          var zt = V(b), $e = Object.keys(R).filter(function(Ri) {
            return Ri !== "key";
          }), dr = $e.length > 0 ? "{key: someKey, " + $e.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!eo[zt + dr]) {
            var Ii = $e.length > 0 ? "{" + $e.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, dr, zt, Ii, zt), eo[zt + dr] = !0;
          }
        }
        return b === r ? ie(Pe) : Ft(Pe), Pe;
      }
    }
    function ji(b, R, X) {
      return to(b, R, X, !0);
    }
    function _i(b, R, X) {
      return to(b, R, X, !1);
    }
    var Ai = _i, Bi = ji;
    fu.Fragment = r, fu.jsx = Ai, fu.jsxs = Bi;
  }()), fu;
}
process.env.NODE_ENV === "production" ? Yg.exports = w3() : Yg.exports = C3();
var Dr = Yg.exports;
qe({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Vw(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ur(e) {
  var t, n;
  return Vw(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Vw(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var rT = Symbol.for("immer-nothing"), Hw = Symbol.for("immer-draftable"), qr = Symbol.for("immer-state"), O3 = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function xr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = O3[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Is = Object.getPrototypeOf;
function ws(e) {
  return !!e && !!e[qr];
}
function Cs(e) {
  var t;
  return e ? oT(e) || Array.isArray(e) || !!e[Hw] || !!((t = e.constructor) != null && t[Hw]) || xd(e) || Ld(e) : !1;
}
var E3 = Object.prototype.constructor.toString();
function oT(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Is(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === E3;
}
function Uc(e, t) {
  Ed(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Ed(e) {
  const t = e[qr];
  return t ? t.type_ : Array.isArray(e) ? 1 : xd(e) ? 2 : Ld(e) ? 3 : 0;
}
function Xg(e, t) {
  return Ed(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function iT(e, t, n) {
  const r = Ed(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function x3(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function xd(e) {
  return e instanceof Map;
}
function Ld(e) {
  return e instanceof Set;
}
function Yi(e) {
  return e.copy_ || e.base_;
}
function Jg(e, t) {
  if (xd(e))
    return new Map(e);
  if (Ld(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = oT(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[qr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Is(e), r);
  } else {
    const r = Is(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Zv(e, t = !1) {
  return Dd(e) || ws(e) || !Cs(e) || (Ed(e) > 1 && (e.set = e.add = e.clear = e.delete = L3), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Zv(r, !0))), e;
}
function L3() {
  xr(2);
}
function Dd(e) {
  return Object.isFrozen(e);
}
var D3 = {};
function Os(e) {
  const t = D3[e];
  return t || xr(0, e), t;
}
var il;
function sT() {
  return il;
}
function P3(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function qw(e, t) {
  t && (Os("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Qg(e) {
  em(e), e.drafts_.forEach(k3), e.drafts_ = null;
}
function em(e) {
  e === il && (il = e.parent_);
}
function Zw(e) {
  return il = P3(il, e);
}
function k3(e) {
  const t = e[qr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Kw(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[qr].modified_ && (Qg(t), xr(4)), Cs(e) && (e = Wc(t, e), t.parent_ || Vc(t, e)), t.patches_ && Os("Patches").generateReplacementPatches_(
    n[qr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Wc(t, n, []), Qg(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== rT ? e : void 0;
}
function Wc(e, t, n) {
  if (Dd(t))
    return t;
  const r = t[qr];
  if (!r)
    return Uc(
      t,
      (o, i) => Gw(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Vc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Uc(
      i,
      (a, l) => Gw(e, r, o, a, l, n, s)
    ), Vc(e, o, !1), n && e.patches_ && Os("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Gw(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && xr(5), ws(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Xg(t.assigned_, r) ? i.concat(r) : void 0, l = Wc(e, o, a);
    if (iT(n, r, l), ws(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (Cs(o) && !Dd(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Wc(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Vc(e, o);
  }
}
function Vc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Zv(t, n);
}
function S3(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : sT(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Kv;
  n && (o = [r], i = sl);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Kv = {
  get(e, t) {
    if (t === qr)
      return e;
    const n = Yi(e);
    if (!Xg(n, t))
      return M3(e, n, t);
    const r = n[t];
    return e.finalized_ || !Cs(r) ? r : r === _f(e.base_, t) ? (Af(e), e.copy_[t] = nm(r, e)) : r;
  },
  has(e, t) {
    return t in Yi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Yi(e));
  },
  set(e, t, n) {
    const r = aT(Yi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = _f(Yi(e), t), i = o == null ? void 0 : o[qr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (x3(n, o) && (n !== void 0 || Xg(e.base_, t)))
        return !0;
      Af(e), tm(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return _f(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Af(e), tm(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Yi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    xr(11);
  },
  getPrototypeOf(e) {
    return Is(e.base_);
  },
  setPrototypeOf() {
    xr(12);
  }
}, sl = {};
Uc(Kv, (e, t) => {
  sl[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
sl.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && xr(13), sl.set.call(this, e, t, void 0);
};
sl.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && xr(14), Kv.set.call(this, e[0], t, n, e[0]);
};
function _f(e, t) {
  const n = e[qr];
  return (n ? Yi(n) : e)[t];
}
function M3(e, t, n) {
  var r;
  const o = aT(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function aT(e, t) {
  if (!(t in e))
    return;
  let n = Is(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Is(n);
  }
}
function tm(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && tm(e.parent_));
}
function Af(e) {
  e.copy_ || (e.copy_ = Jg(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var T3 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && xr(6), r !== void 0 && typeof r != "function" && xr(7);
      let o;
      if (Cs(t)) {
        const i = Zw(this), s = nm(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Qg(i) : em(i);
        }
        return qw(i, r), Kw(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === rT && (o = void 0), this.autoFreeze_ && Zv(o, !0), r) {
          const i = [], s = [];
          Os("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        xr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Cs(e) || xr(8), ws(e) && (e = j3(e));
    const t = Zw(this), n = nm(e, void 0);
    return n[qr].isManual_ = !0, em(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[qr];
    (!n || !n.isManual_) && xr(9);
    const { scope_: r } = n;
    return qw(r, t), Kw(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Os("Patches").applyPatches_;
    return ws(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function nm(e, t) {
  const n = xd(e) ? Os("MapSet").proxyMap_(e, t) : Ld(e) ? Os("MapSet").proxySet_(e, t) : S3(e, t);
  return (t ? t.scope_ : sT()).drafts_.push(n), n;
}
function j3(e) {
  return ws(e) || xr(10, e), lT(e);
}
function lT(e) {
  if (!Cs(e) || Dd(e))
    return e;
  const t = e[qr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Jg(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Jg(e, !0);
  return Uc(n, (r, o) => {
    iT(n, r, lT(o));
  }), t && (t.finalized_ = !1), n;
}
var Zr = new T3(), Gv = Zr.produce;
Zr.produceWithPatches.bind(
  Zr
);
Zr.setAutoFreeze.bind(Zr);
Zr.setUseStrictShallowCopy.bind(Zr);
Zr.applyPatches.bind(Zr);
var Yw = Zr.createDraft.bind(Zr), Xw = Zr.finishDraft.bind(Zr), Ce = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ce.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Ce.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ce.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Ce.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ce.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ce.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ce.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ce.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ce.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ce.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ce.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ce.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ce.isAncestor(t, e) && !Ce.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ce.equals(i, r) || Ce.endsBefore(i, r) || Ce.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Ce.equals(s, r) || Ce.isAncestor(s, r))
          return null;
        Ce.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Ce.equals(a, r) || Ce.endsBefore(a, r) ? r[a.length - 1] -= 1 : Ce.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ce.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ce.endsBefore(u, r) ? r[u.length - 1] += 1 : Ce.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ce.equals(p, d))
          return r;
        if (Ce.isAncestor(p, r) || Ce.equals(p, r)) {
          var m = d.slice();
          return Ce.endsBefore(p, d) && p.length < d.length && (m[p.length - 1] -= 1), m.concat(r.slice(p.length));
        } else Ce.isSibling(p, d) && (Ce.isAncestor(d, r) || Ce.equals(d, r)) ? Ce.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ce.endsBefore(d, r) || Ce.equals(d, r) || Ce.isAncestor(d, r) ? (Ce.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ce.endsBefore(p, r) && (Ce.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function al(e) {
  "@babel/helpers - typeof";
  return al = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, al(e);
}
function _3(e, t) {
  if (al(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (al(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function A3(e) {
  var t = _3(e, "string");
  return al(t) === "symbol" ? t : String(t);
}
function Ws(e, t, n) {
  return t = A3(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Jw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jw(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var B3 = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = et.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of ft.points(t))
          t[l] = vn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = et.leaf(e, u), m = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = m + p + f, t)
        for (var [g, h] of ft.points(t))
          t[h] = vn.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = et.get(e, C), S = Ce.previous(C), E = et.get(e, S), v = et.parent(e, C), O = C[C.length - 1];
      if (Vn.isText(w) && Vn.isText(E))
        E.text += w.text;
      else if (!Vn.isText(w) && !Vn.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(Ar.stringify(w), " ").concat(Ar.stringify(E)));
      if (v.children.splice(O, 1), t)
        for (var [P, U] of ft.points(t))
          t[U] = vn.transform(P, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: N
      } = n;
      if (Ce.isAncestor(L, N))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(N, "] because the destination is inside itself."));
      var A = et.get(e, L), z = et.parent(e, L), V = L[L.length - 1];
      z.children.splice(V, 1);
      var $ = Ce.transform(L, n), Z = et.get(e, Ce.parent($)), J = $[$.length - 1];
      if (Z.children.splice(J, 0, A), t)
        for (var [Y, te] of ft.points(t))
          t[te] = vn.transform(Y, n);
      break;
    }
    case "remove_node": {
      var {
        path: ee
      } = n, k = ee[ee.length - 1], _ = et.parent(e, ee);
      if (_.children.splice(k, 1), t)
        for (var [K, M] of ft.points(t)) {
          var G = vn.transform(K, n);
          if (t != null && G != null)
            t[M] = G;
          else {
            var x = void 0, T = void 0;
            for (var [F, j] of et.texts(e))
              if (Ce.compare(j, ee) === -1)
                x = [F, j];
              else {
                T = [F, j];
                break;
              }
            var H = !1;
            x && T && (Ce.equals(T[1], ee) ? H = !Ce.hasPrevious(T[1]) : H = Ce.common(x[1], ee).length < Ce.common(T[1], ee).length), x && !H ? (K.path = x[1], K.offset = x[0].text.length) : T ? (K.path = T[1], K.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: B,
        offset: Q,
        text: W
      } = n;
      if (W.length === 0) break;
      var ue = et.leaf(e, B), ye = ue.text.slice(0, Q), oe = ue.text.slice(Q + W.length);
      if (ue.text = ye + oe, t)
        for (var [_e, Fe] of ft.points(t))
          t[Fe] = vn.transform(_e, n);
      break;
    }
    case "set_node": {
      var {
        path: ze,
        properties: Re,
        newProperties: Ge
      } = n;
      if (ze.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ze = et.get(e, ze);
      for (var Me in Ge) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Ke = Ge[Me];
        Ke == null ? delete Ze[Me] : Ze[Me] = Ke;
      }
      for (var rt in Re)
        Ge.hasOwnProperty(rt) || delete Ze[rt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!ft.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ar.stringify(Se), " when there is no current selection."));
          t = sa({}, Se);
        }
        for (var je in Se) {
          var Ne = Se[je];
          if (Ne == null) {
            if (je === "anchor" || je === "focus")
              throw new Error('Cannot remove the "'.concat(je, '" selection property'));
            delete t[je];
          } else
            t[je] = Ne;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ue,
        properties: ot
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var Te = et.get(e, Ve), Zt = et.parent(e, Ve), lt = Ve[Ve.length - 1], ht;
      if (Vn.isText(Te)) {
        var kt = Te.text.slice(0, Ue), sn = Te.text.slice(Ue);
        Te.text = kt, ht = sa(sa({}, ot), {}, {
          text: sn
        });
      } else {
        var St = Te.children.slice(0, Ue), an = Te.children.slice(Ue);
        Te.children = St, ht = sa(sa({}, ot), {}, {
          children: an
        });
      }
      if (Zt.children.splice(lt + 1, 0, ht), t)
        for (var [tt, Nt] of ft.points(t))
          t[Nt] = vn.transform(tt, n);
      break;
    }
  }
  return t;
}, I3 = {
  transform(e, t) {
    e.children = Yw(e.children);
    var n = e.selection && Yw(e.selection);
    try {
      n = B3(e, n, t);
    } finally {
      e.children = Xw(e.children), n ? e.selection = ws(n) ? Xw(n) : n : e.selection = null;
    }
  }
}, R3 = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, N3 = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, uT = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (ur(r) && ur(o)) {
      if (!uT(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function F3(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function ll(e, t) {
  if (e == null) return {};
  var n = F3(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var z3 = ["anchor", "focus"];
function Qw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qw(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ft = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ft.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ft.edges(e);
    return t;
  },
  equals(e, t) {
    return vn.equals(e.anchor, t.anchor) && vn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ft.isRange(t)) {
      if (ft.includes(e, t.anchor) || ft.includes(e, t.focus))
        return !0;
      var [n, r] = ft.edges(e), [o, i] = ft.edges(t);
      return vn.isBefore(n, o) && vn.isAfter(r, i);
    }
    var [s, a] = ft.edges(e), l = !1, u = !1;
    return vn.isPoint(t) ? (l = vn.compare(t, s) >= 0, u = vn.compare(t, a) <= 0) : (l = Ce.compare(t, s.path) >= 0, u = Ce.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = ll(e, z3), [r, o] = ft.edges(e), [i, s] = ft.edges(t), a = vn.isBefore(r, i) ? i : r, l = vn.isBefore(o, s) ? o : s;
    return vn.isBefore(l, a) ? null : $3({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return vn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return vn.equals(t, n);
  },
  isExpanded(e) {
    return !ft.isCollapsed(e);
  },
  isForward(e) {
    return !ft.isBackward(e);
  },
  isRange(e) {
    return ur(e) && vn.isPoint(e.anchor) && vn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ft.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Gv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = ft.isCollapsed(r);
        ft.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? ft.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = vn.transform(r.anchor, t, {
        affinity: i
      }), u = vn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, eC = (e) => ur(e) && et.isNodeList(e.children) && !en.isEditor(e), jo = {
  isAncestor(e) {
    return ur(e) && et.isNodeList(e.children);
  },
  isElement: eC,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => jo.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return eC(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, U3 = ["children"], W3 = ["text"], tC = /* @__PURE__ */ new WeakMap(), et = {
  ancestor(e, t) {
    var n = et.get(e, t);
    if (Vn.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ar.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ce.ancestors(t, n)) {
        var o = et.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Vn.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ar.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ar.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = et.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = et.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ce.common(t, n), o = et.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = et.get(e, t);
    if (en.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ar.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        jo.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (jo.isAncestor(e)) {
      var t = ll(e, U3);
      return t;
    } else {
      var t = ll(e, W3);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = et.get(e, n); r && !(Vn.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Vn.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ar.stringify(e)));
    var n = Gv({
      children: e.children
    }, (r) => {
      var [o, i] = ft.edges(t), s = et.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, m] = d;
          return !ft.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!ft.includes(t, a)) {
          var l = et.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Ce.equals(a, i.path)) {
          var c = et.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ce.equals(a, o.path)) {
          var p = et.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      en.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Vn.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ar.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Vn.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Vn.isText(e) || jo.isElement(e) || en.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = tC.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => et.isNode(r));
    return tC.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = et.get(e, n); r && !(Vn.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = et.get(e, t);
    if (!Vn.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ar.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ce.levels(t, n)) {
        var o = et.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return jo.isElement(e) && jo.isElementProps(t) && jo.matches(e, t) || Vn.isText(e) && Vn.isTextProps(t) && Vn.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Ce.isBefore(a, i) : Ce.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Vn.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ce.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = et.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Ce.next(a);
          if (et.has(e, c)) {
            a = c, l = et.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Ce.previous(a);
          a = p, l = et.get(e, a);
          continue;
        }
        a = Ce.parent(a), l = et.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ce.parent(t), r = et.get(e, n);
    if (Vn.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Vn.isText(e) ? e.text : e.children.map(et.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        Vn.isText(n) && (yield [n, r]);
    }();
  }
};
function nC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nC(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Da = {
  isNodeOperation(e) {
    return Da.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!ur(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ce.isPath(e.path) && et.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ce.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ce.isPath(e.path) && ur(e.properties);
      case "move_node":
        return Ce.isPath(e.path) && Ce.isPath(e.newPath);
      case "remove_node":
        return Ce.isPath(e.path) && et.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ce.isPath(e.path);
      case "set_node":
        return Ce.isPath(e.path) && ur(e.properties) && ur(e.newProperties);
      case "set_selection":
        return e.properties === null && ft.isRange(e.newProperties) || e.newProperties === null && ft.isRange(e.properties) || ur(e.properties) && ur(e.newProperties);
      case "split_node":
        return Ce.isPath(e.path) && typeof e.position == "number" && ur(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Da.isOperation(t));
  },
  isSelectionOperation(e) {
    return Da.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Da.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Cn(Cn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Cn(Cn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Cn(Cn({}, e), {}, {
          type: "split_node",
          path: Ce.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ce.equals(t, n))
          return e;
        if (Ce.isSibling(n, t))
          return Cn(Cn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ce.transform(n, e), o = Ce.transform(Ce.next(n), e);
        return Cn(Cn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Cn(Cn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Cn(Cn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Cn(Cn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Cn(Cn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Cn(Cn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Cn(Cn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Cn(Cn({}, e), {}, {
          type: "merge_node",
          path: Ce.next(e.path)
        });
    }
  }
}, rC = /* @__PURE__ */ new WeakMap(), V3 = (e) => {
  var t = rC.get(e);
  if (t !== void 0)
    return t;
  if (!ur(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || ur(e.marks)) && (e.selection === null || ft.isRange(e.selection)) && et.isNodeList(e.children) && Da.isOperationList(e.operations);
  return rC.set(e, n), n;
}, en = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return V3(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function oC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oC(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vn = {
  compare(e, t) {
    var n = Ce.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return vn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return vn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ce.equals(e.path, t.path);
  },
  isPoint(e) {
    return ur(e) && typeof e.offset == "number" && Ce.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Gv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ce.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ce.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ce.equals(t.path, i) && (r.offset += t.position), r.path = Ce.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ce.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ce.equals(t.path, i) || Ce.isAncestor(t.path, i))
            return null;
          r.path = Ce.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ce.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Ce.transform(i, t, iC(iC({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ce.transform(i, t, n);
          break;
        }
      }
    });
  }
}, sC = void 0, Ar = {
  setScrubber(e) {
    sC = e;
  },
  stringify(e) {
    return JSON.stringify(e, sC);
  }
}, H3 = ["text"], q3 = ["anchor", "focus"];
function aC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aC(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vn = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = ll(i, H3);
      return s;
    }
    return uT(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return ur(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Vn.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Lo({}, e)];
    for (var r of t) {
      var o = ll(r, q3), [i, s] = ft.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, m = l;
        if (l += d, u <= m && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(p);
          continue;
        }
        var f = p, g = void 0, h = void 0;
        if (c < l) {
          var C = c - m;
          h = Lo(Lo({}, f), {}, {
            text: f.text.slice(C)
          }), f = Lo(Lo({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > m) {
          var w = u - m;
          g = Lo(Lo({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Lo(Lo({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, Z3 = (e) => e.selection ? e.selection : e.children.length > 0 ? en.end(e, []) : [0], hn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(hn || (hn = {}));
hn.L, hn.L | hn.V | hn.LV | hn.LVT, hn.LV | hn.V, hn.V | hn.T, hn.LVT | hn.T, hn.T, hn.Any, hn.Extend | hn.ZWJ, hn.Any, hn.SpacingMark, hn.Prepend, hn.Any, hn.ZWJ, hn.ExtPict, hn.RI, hn.RI;
var K3 = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    en.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Z3(e)
      } = n;
      if (Ce.isPath(o) && (o = en.range(e, o)), ft.isRange(o))
        if (ft.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ft.end(o);
          if (!r && en.void(e, {
            at: i
          }))
            return;
          var s = ft.start(o), a = en.pointRef(e, s), l = en.pointRef(e, i);
          Hc.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Hc.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && en.void(e, {
        at: o
      }) || en.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function lC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lC(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hc = hu(hu(hu(hu({}, I3), R3), N3), K3), cT = {}, Yv = {}, Xv = {};
Object.defineProperty(Xv, "__esModule", { value: !0 });
Xv.default = J3;
var uC = "html", cC = "head", gu = "body", G3 = /<([a-zA-Z]+[0-9]?)/, pC = /<head[^]*>/i, dC = /<body[^]*>/i, qc = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, rm = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, fC = typeof window == "object" && window.DOMParser;
if (typeof fC == "function") {
  var Y3 = new fC(), X3 = "text/html";
  rm = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Y3.parseFromString(e, X3);
  }, qc = rm;
}
if (typeof document == "object" && document.implementation) {
  var mu = document.implementation.createHTMLDocument();
  qc = function(e, t) {
    if (t) {
      var n = mu.documentElement.querySelector(t);
      return n && (n.innerHTML = e), mu;
    }
    return mu.documentElement.innerHTML = e, mu;
  };
}
var vu = typeof document == "object" && document.createElement("template"), om;
vu && vu.content && (om = function(e) {
  return vu.innerHTML = e, vu.content.childNodes;
});
function J3(e) {
  var t, n, r = e.match(G3), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case uC: {
      var i = rm(e);
      if (!pC.test(e)) {
        var s = i.querySelector(cC);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!dC.test(e)) {
        var s = i.querySelector(gu);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(uC);
    }
    case cC:
    case gu: {
      var a = qc(e).querySelectorAll(o);
      return dC.test(e) && pC.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (om)
        return om(e);
      var s = qc(e, gu).querySelector(gu);
      return s.childNodes;
    }
  }
}
var Pd = {}, Jv = {}, Qv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Qv);
var bt = {}, Li = on && on.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ba = on && on.__assign || function() {
  return Ba = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ba.apply(this, arguments);
};
Object.defineProperty(bt, "__esModule", { value: !0 });
bt.cloneNode = bt.hasChildren = bt.isDocument = bt.isDirective = bt.isComment = bt.isText = bt.isCDATA = bt.isTag = bt.Element = bt.Document = bt.CDATA = bt.NodeWithChildren = bt.ProcessingInstruction = bt.Comment = bt.Text = bt.DataNode = bt.Node = void 0;
var Mr = Qv, ey = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), ty(this, t);
    }, e;
  }()
);
bt.Node = ey;
var kd = (
  /** @class */
  function(e) {
    Li(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ey)
);
bt.DataNode = kd;
var pT = (
  /** @class */
  function(e) {
    Li(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Mr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kd)
);
bt.Text = pT;
var dT = (
  /** @class */
  function(e) {
    Li(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Mr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kd)
);
bt.Comment = dT;
var fT = (
  /** @class */
  function(e) {
    Li(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Mr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kd)
);
bt.ProcessingInstruction = fT;
var Sd = (
  /** @class */
  function(e) {
    Li(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ey)
);
bt.NodeWithChildren = Sd;
var hT = (
  /** @class */
  function(e) {
    Li(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Mr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Sd)
);
bt.CDATA = hT;
var gT = (
  /** @class */
  function(e) {
    Li(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Mr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Sd)
);
bt.Document = gT;
var mT = (
  /** @class */
  function(e) {
    Li(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Mr.ElementType.Script : n === "style" ? Mr.ElementType.Style : Mr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Sd)
);
bt.Element = mT;
function vT(e) {
  return (0, Mr.isTag)(e);
}
bt.isTag = vT;
function yT(e) {
  return e.type === Mr.ElementType.CDATA;
}
bt.isCDATA = yT;
function bT(e) {
  return e.type === Mr.ElementType.Text;
}
bt.isText = bT;
function wT(e) {
  return e.type === Mr.ElementType.Comment;
}
bt.isComment = wT;
function CT(e) {
  return e.type === Mr.ElementType.Directive;
}
bt.isDirective = CT;
function OT(e) {
  return e.type === Mr.ElementType.Root;
}
bt.isDocument = OT;
function Q3(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
bt.hasChildren = Q3;
function ty(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (bT(e))
    n = new pT(e.data);
  else if (wT(e))
    n = new dT(e.data);
  else if (vT(e)) {
    var r = t ? Bf(e.children) : [], o = new mT(e.name, Ba({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ba({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ba({}, e["x-attribsPrefix"])), n = o;
  } else if (yT(e)) {
    var r = t ? Bf(e.children) : [], i = new hT(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (OT(e)) {
    var r = t ? Bf(e.children) : [], s = new gT(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (CT(e)) {
    var a = new fT(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
bt.cloneNode = ty;
function Bf(e) {
  for (var t = e.map(function(r) {
    return ty(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = on && on.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = on && on.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Qv, o = bt;
  n(bt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Jv);
var ET = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(ET);
Object.defineProperty(Pd, "__esModule", { value: !0 });
Pd.formatAttributes = xT;
Pd.formatDOM = LT;
var yu = Jv, eU = ET;
function tU(e) {
  return eU.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function xT(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function nU(e) {
  e = e.toLowerCase();
  var t = tU(e);
  return t || e;
}
function LT(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = nU(a.nodeName);
        o = new yu.Element(l, xT(a.attributes)), o.children = LT(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new yu.Text(a.nodeValue);
        break;
      case 8:
        o = new yu.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new yu.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var rU = on && on.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Yv, "__esModule", { value: !0 });
Yv.default = aU;
var oU = rU(Xv), iU = Pd, sU = /<(![a-zA-Z\s]+)>/;
function aU(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(sU), n = t ? t[1] : void 0;
  return (0, iU.formatDOM)((0, oU.default)(e), null, n);
}
var Md = {}, so = {}, Td = {}, lU = 0;
Td.SAME = lU;
var uU = 1;
Td.CAMELCASE = uU;
Td.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const DT = 0, Di = 1, jd = 2, _d = 3, ny = 4, PT = 5, kT = 6;
function cU(e) {
  return ir.hasOwnProperty(e) ? ir[e] : null;
}
function br(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === jd || t === _d || t === ny, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const ir = {}, pU = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
pU.forEach((e) => {
  ir[e] = new br(
    e,
    DT,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ir[e] = new br(
    e,
    Di,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ir[e] = new br(
    e,
    jd,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ir[e] = new br(
    e,
    jd,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ir[e] = new br(
    e,
    _d,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ir[e] = new br(
    e,
    _d,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ir[e] = new br(
    e,
    ny,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ir[e] = new br(
    e,
    kT,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ir[e] = new br(
    e,
    PT,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const ry = /[\-\:]([a-z])/g, oy = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ry, oy);
  ir[t] = new br(
    t,
    Di,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ry, oy);
  ir[t] = new br(
    t,
    Di,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(ry, oy);
  ir[t] = new br(
    t,
    Di,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ir[e] = new br(
    e,
    Di,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const dU = "xlinkHref";
ir[dU] = new br(
  "xlinkHref",
  Di,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ir[e] = new br(
    e,
    Di,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: fU,
  SAME: hU,
  possibleStandardNames: hC
} = Td, gU = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", mU = gU + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", vU = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + mU + "]*$")
), yU = Object.keys(
  hC
).reduce((e, t) => {
  const n = hC[t];
  return n === hU ? e[t] = t : n === fU ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
so.BOOLEAN = _d;
so.BOOLEANISH_STRING = jd;
so.NUMERIC = PT;
so.OVERLOADED_BOOLEAN = ny;
so.POSITIVE_NUMERIC = kT;
so.RESERVED = DT;
so.STRING = Di;
so.getPropertyInfo = cU;
so.isCustomAttribute = vU;
so.possibleStandardNames = yU;
var iy = {}, sy = {}, gC = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, bU = /\n/g, wU = /^\s*/, CU = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, OU = /^:\s*/, EU = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, xU = /^[;\s]*/, LU = /^\s+|\s+$/g, DU = `
`, mC = "/", vC = "*", ts = "", PU = "comment", kU = "declaration", SU = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(bU);
    g && (n += g.length);
    var h = f.lastIndexOf(DU);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(wU);
  }
  function c(f) {
    var g;
    for (f = f || []; g = p(); )
      g !== !1 && f.push(g);
    return f;
  }
  function p() {
    var f = i();
    if (!(mC != e.charAt(0) || vC != e.charAt(1))) {
      for (var g = 2; ts != e.charAt(g) && (vC != e.charAt(g) || mC != e.charAt(g + 1)); )
        ++g;
      if (g += 2, ts === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: PU,
        comment: h
      });
    }
  }
  function d() {
    var f = i(), g = l(CU);
    if (g) {
      if (p(), !l(OU)) return a("property missing ':'");
      var h = l(EU), C = f({
        type: kU,
        property: yC(g[0].replace(gC, ts)),
        value: h ? yC(h[0].replace(gC, ts)) : ts
      });
      return l(xU), C;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = d(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function yC(e) {
  return e ? e.replace(LU, ts) : ts;
}
var MU = on && on.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(sy, "__esModule", { value: !0 });
sy.default = jU;
var TU = MU(SU);
function jU(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, TU.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Ad = {};
Object.defineProperty(Ad, "__esModule", { value: !0 });
Ad.camelCase = void 0;
var _U = /^--[a-zA-Z0-9_-]+$/, AU = /-([a-z])/g, BU = /^[^-]+$/, IU = /^-(webkit|moz|ms|o|khtml)-/, RU = /^-(ms)-/, NU = function(e) {
  return !e || BU.test(e) || _U.test(e);
}, FU = function(e, t) {
  return t.toUpperCase();
}, bC = function(e, t) {
  return "".concat(t, "-");
}, zU = function(e, t) {
  return t === void 0 && (t = {}), NU(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(RU, bC) : e = e.replace(IU, bC), e.replace(AU, FU));
};
Ad.camelCase = zU;
var $U = on && on.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, UU = $U(sy), WU = Ad;
function im(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, UU.default)(e, function(r, o) {
    r && o && (n[(0, WU.camelCase)(r, t)] = o);
  }), n;
}
im.default = im;
var VU = im;
(function(e) {
  var t = on && on.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = xe, r = t(VU), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(iy);
Object.defineProperty(Md, "__esModule", { value: !0 });
Md.default = KU;
var Pa = so, wC = iy, HU = ["checked", "value"], qU = ["input", "select", "textarea"], ZU = {
  reset: !0,
  submit: !0
};
function KU(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && ZU[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Pa.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = CC(s);
    if (a) {
      var l = (0, Pa.getPropertyInfo)(a);
      switch (HU.includes(a) && qU.includes(t) && !r && (a = CC("default" + s)), n[a] = i, l && l.type) {
        case Pa.BOOLEAN:
          n[a] = !0;
          break;
        case Pa.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    wC.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, wC.setStyleProp)(e.style, n), n;
}
function CC(e) {
  return Pa.possibleStandardNames[e];
}
var ay = {}, GU = on && on.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ay, "__esModule", { value: !0 });
ay.default = ST;
var If = xe, YU = GU(Md), Ia = iy, XU = {
  cloneElement: If.cloneElement,
  createElement: If.createElement,
  isValidElement: If.isValidElement
};
function ST(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ia.returnFirstArg, i = t.library || XU, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var m = !p.data.trim().length;
      if (m && p.parent && !(0, Ia.canTextBeChildOfNode)(p.parent) || t.trim && m)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, g = {};
    JU(f) ? ((0, Ia.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, YU.default)(f.attribs, f.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (g.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? g.defaultValue = p.children[0].data : p.children && p.children.length && (h = ST(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(p.name, g, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function JU(e) {
  return Ia.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ia.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = on && on.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(Yv);
  e.htmlToDOM = n.default;
  var r = t(Md);
  e.attributesToProps = r.default;
  var o = t(ay);
  e.domToReact = o.default;
  var i = Jv;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(cT);
const QU = /* @__PURE__ */ b3(cT);
QU.default;
qe({});
function eW(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const tW = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
eW(tW.CNPJ).length;
Fs((e, t) => /* @__PURE__ */ Dr.jsx("input", { ref: t, ...e }));
qe({});
var Fo = {};
Object.defineProperty(Fo, "__esModule", {
  value: !0
});
var nW = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Rf = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, MT = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: nW ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, ly = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var bu = 1; bu < 20; bu++)
  ly["f" + bu] = 111 + bu;
function Bd(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return TT(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return jT(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function rW(e, t) {
  return Bd(e, t);
}
function oW(e, t) {
  return Bd(e, { byKey: !0 }, t);
}
function TT(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Rf)
    r[Rf[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = uy(d), g = Rf[f];
      if (d.length > 1 && !g && !MT[d] && !ly[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = _T(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function jT(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function _T(e) {
  e = uy(e);
  var t = ly[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function uy(e) {
  return e = e.toLowerCase(), e = MT[e] || e, e;
}
Fo.default = Bd;
var Nf = Fo.isHotkey = Bd;
Fo.isCodeHotkey = rW;
Fo.isKeyHotkey = oW;
Fo.parseHotkey = TT;
Fo.compareHotkey = jT;
Fo.toKeyCode = _T;
Fo.toKeyName = uy;
var iW = typeof on == "object" && on && on.Object === Object && on, sW = iW, aW = sW, lW = typeof self == "object" && self && self.Object === Object && self, uW = aW || lW || Function("return this")(), cW = uW, pW = cW, dW = pW.Symbol, AT = dW, OC = AT;
OC && OC.toStringTag;
var EC = AT;
EC && EC.toStringTag;
var xC;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(xC || (xC = {}));
var cy = function(e) {
  return Object.freeze(e);
}, fW = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, cy(this);
  }
  return e;
}(), hW = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, cy(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), LC = typeof window < "u" ? window : {};
/msie|trident/i.test(LC.navigator && LC.navigator.userAgent);
var Ff = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new fW((n ? t : e) || 0, (n ? e : t) || 0);
};
cy({
  devicePixelContentBoxSize: Ff(),
  borderBoxSize: Ff(),
  contentBoxSize: Ff(),
  contentRect: new hW(0, 0, 0, 0)
});
function ul(e) {
  "@babel/helpers - typeof";
  return ul = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ul(e);
}
function gW(e, t) {
  if (ul(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ul(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function mW(e) {
  var t = gW(e, "string");
  return ul(t) === "symbol" ? t : String(t);
}
function Ra(e, t, n) {
  return t = mW(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var vW = /* @__PURE__ */ qe(null), zf, $f;
parseInt(xe.version.split(".")[0], 10);
var DC = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Uf = typeof navigator < "u" && /Android/.test(navigator.userAgent), wu = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), yW = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (zf = navigator.userAgent.match(/Version\/(\d+)/)) !== null && zf !== void 0 && zf[1] && parseInt(($f = navigator.userAgent.match(/Version\/(\d+)/)) === null || $f === void 0 ? void 0 : $f[1], 10) < 17;
var bW = /* @__PURE__ */ new WeakMap(), wW = /* @__PURE__ */ new WeakMap(), CW = /* @__PURE__ */ new WeakMap(), OW = /* @__PURE__ */ new WeakMap(), EW = /* @__PURE__ */ new WeakMap(), PC = /* @__PURE__ */ new WeakMap(), xW = /* @__PURE__ */ new WeakMap(), kC = /* @__PURE__ */ new WeakMap(), Cu = /* @__PURE__ */ new WeakMap(), LW = /* @__PURE__ */ new WeakMap(), DW = /* @__PURE__ */ new WeakMap(), PW = /* @__PURE__ */ new WeakMap(), BT = globalThis.Node, kW = globalThis.Text, IT = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, SW = (e) => Zc(e) && e.nodeType === 8, ho = (e) => Zc(e) && e.nodeType === 1, Zc = (e) => {
  var t = IT(e);
  return !!t && e instanceof t.Node;
}, SC = (e) => {
  var t = e && e.anchorNode && IT(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, MW = (e) => {
  var [t, n] = e;
  if (ho(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = RT(t, o, r ? "backward" : "forward"), r = o < n; ho(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = jW(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, TW = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, RT = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (SW(o) || ho(o) && o.childNodes.length === 0 || ho(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, jW = (e, t, n) => {
  var [r] = RT(e, t, n);
  return r;
}, MC = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), NT = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ho(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Ot.getWindow(e);
  if (o.contains(r))
    return Ot.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : NT(e, i, n);
}, TC = (e, t) => !!(e.compareDocumentPosition(t) & BT.DOCUMENT_POSITION_PRECEDING), _W = (e, t) => !!(e.compareDocumentPosition(t) & BT.DOCUMENT_POSITION_FOLLOWING), AW = 0;
class BW {
  constructor() {
    Ra(this, "id", void 0), this.id = "".concat(AW++);
  }
}
var Ot = {
  androidPendingDiffs: (e) => PW.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = DW.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Ot.toDOMNode(e, e), n = Ot.findDocumentOrShadowRoot(e);
    Cu.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Ot.findDocumentOrShadowRoot(e), r = MC(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Hc.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Ot.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Ot.toSlateNode(e, t.target), s = Ot.findPath(e, i);
    if (jo.isElement(i) && en.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = en.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? en.before(e, u) : en.after(e, u);
      if (c) {
        var p = en.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = Ot.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = Ot.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = PC.get(t);
    return n || (n = new BW(), PC.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = wW.get(r);
      if (o == null) {
        if (en.isEditor(r))
          return n;
        break;
      }
      var i = bW.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ar.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Cu.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Ot.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Ot.toDOMNode(e, e), r = Ot.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = MC(r), i = Ot.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Hc.select(e, en.start(e, [])), Cu.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = CW.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Ot.toDOMNode(e, e), i;
    try {
      i = ho(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Zc(t) && Ot.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return en.hasPath(e, n.path) && en.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Ot.hasEditableTarget(e, t) || Ot.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Zc(t) && Ot.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!LW.get(e),
  isFocused: (e) => !!Cu.get(e),
  isReadOnly: (e) => !!kC.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (kC.get(e)) return !1;
    var n = Ot.hasTarget(e, t) && Ot.toSlateNode(e, t);
    return jo.isElement(n) && en.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = xW.get(e), r = en.isEditor(t) ? OW.get(e) : n == null ? void 0 : n.get(Ot.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ar.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = en.node(e, t.path), r = Ot.toDOMNode(e, n), o;
    en.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof kW ? C : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ar.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ft.isBackward(t), i = Ot.toDOMPoint(e, n), s = ft.isCollapsed(t) ? i : Ot.toDOMPoint(e, r), a = Ot.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = ho(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = ho(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ho(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? EW.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : MW(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = Ot.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = Ot.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var O = v.cloneContents(), P = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          P.forEach((M) => {
            if (Uf && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = O.textContent.length, S = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var N = U[L];
          if (Ot.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (C) {
        var A = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], z = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, $ = [...A(z), ...A(z == null ? void 0 : z.nextElementSibling)];
          w = (V = $.find((M) => _W(C, M))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, J = [...A(z == null ? void 0 : z.previousElementSibling), ...A(z)];
          w = (Z = J.findLast((M) => TC(C, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Uf && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      wu && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Uf && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && Ot.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var te = Ot.toSlateNode(e, Y), {
          path: ee,
          offset: k
        } = en.start(e, Ot.findPath(e, te));
        return Y.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = Ot.toSlateNode(e, u), K = Ot.findPath(e, _);
    return {
      path: K,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = SC(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (SC(t)) {
        if (wu && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let O = function(P) {
              return P.childElementCount > 0 ? O(P.children[0]) : P;
            };
            var f = d.startContainer, g = m.startContainer, h = O(f.children[d.startOffset]), C = O(g.children[m.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        yW && TW(a) || wu ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    wu && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Ot.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = TC(a, u) || a === u && c < l, E = p ? w : Ot.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return ft.isExpanded(v) && ft.isForward(v) && ho(u) && en.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = en.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, IW = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, RW = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, NW = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, On = (e) => {
  var t = IW[e], n = RW[e], r = NW[e], o = t && Nf(t), i = n && Nf(n), s = r && Nf(r);
  return (a) => !!(o && o(a) || DC && i && i(a) || !DC && s && s(a));
};
On("bold"), On("compose"), On("moveBackward"), On("moveForward"), On("deleteBackward"), On("deleteForward"), On("deleteLineBackward"), On("deleteLineForward"), On("deleteWordBackward"), On("deleteWordForward"), On("extendBackward"), On("extendForward"), On("extendLineBackward"), On("extendLineForward"), On("italic"), On("moveLineBackward"), On("moveLineForward"), On("moveWordBackward"), On("moveWordForward"), On("redo"), On("insertSoftBreak"), On("splitBlock"), On("transposeCharacter"), On("undo");
var FW = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => NT(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, zW = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class $W extends Fp {
  constructor() {
    super(...arguments), Ra(this, "context", null), Ra(this, "manager", null), Ra(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, zW);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = FW(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Ra($W, "contextType", vW);
qe({});
qe({});
qe({});
var Hn = {}, py = {}, Cl = {}, Ol = {}, FT = "Expected a function", jC = NaN, UW = "[object Symbol]", WW = /^\s+|\s+$/g, VW = /^[-+]0x[0-9a-f]+$/i, HW = /^0b[01]+$/i, qW = /^0o[0-7]+$/i, ZW = parseInt, KW = typeof on == "object" && on && on.Object === Object && on, GW = typeof self == "object" && self && self.Object === Object && self, YW = KW || GW || Function("return this")(), XW = Object.prototype, JW = XW.toString, QW = Math.max, e9 = Math.min, Wf = function() {
  return YW.Date.now();
};
function t9(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(FT);
  t = _C(t) || 0, Kc(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? QW(_C(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(O) {
    var P = r, U = o;
    return r = o = void 0, u = O, s = e.apply(U, P), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var P = O - l, U = O - u, L = t - P;
    return p ? e9(L, i - U) : L;
  }
  function h(O) {
    var P = O - l, U = O - u;
    return l === void 0 || P >= t || P < 0 || p && U >= i;
  }
  function C() {
    var O = Wf();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, d && r ? m(O) : (r = o = void 0, s);
  }
  function S() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(Wf());
  }
  function v() {
    var O = Wf(), P = h(O);
    if (r = arguments, o = this, l = O, P) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = S, v.flush = E, v;
}
function n9(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(FT);
  return Kc(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), t9(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Kc(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function r9(e) {
  return !!e && typeof e == "object";
}
function o9(e) {
  return typeof e == "symbol" || r9(e) && JW.call(e) == UW;
}
function _C(e) {
  if (typeof e == "number")
    return e;
  if (o9(e))
    return jC;
  if (Kc(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Kc(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(WW, "");
  var n = HW.test(e);
  return n || qW.test(e) ? ZW(e.slice(2), n ? 2 : 8) : VW.test(e) ? jC : +e;
}
var i9 = n9, El = {};
Object.defineProperty(El, "__esModule", {
  value: !0
});
El.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), hc.has(t) || hc.set(t, /* @__PURE__ */ new Set());
  var o = hc.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
El.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), hc.get(t).delete(n.name || t);
};
var hc = /* @__PURE__ */ new Map();
Object.defineProperty(Ol, "__esModule", {
  value: !0
});
var s9 = i9, a9 = u9(s9), l9 = El;
function u9(e) {
  return e && e.__esModule ? e : { default: e };
}
var c9 = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, a9.default)(e, t);
}, An = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = c9(function(r) {
        An.scrollHandler(e);
      }, t);
      An.scrollSpyContainers.push(e), (0, l9.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return An.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = An.scrollSpyContainers[An.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(An.currentPositionX(e), An.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    An.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = An.scrollSpyContainers[An.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(An.currentPositionX(t), An.currentPositionY(t));
  },
  updateStates: function() {
    An.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    An.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), An.spySetState && An.spySetState.length && An.spySetState.indexOf(e) > -1 && An.spySetState.splice(An.spySetState.indexOf(e), 1), document.removeEventListener("scroll", An.scrollHandler);
  },
  update: function() {
    return An.scrollSpyContainers.forEach(function(e) {
      return An.scrollHandler(e);
    });
  }
};
Ol.default = An;
var Vs = {}, xl = {};
Object.defineProperty(xl, "__esModule", {
  value: !0
});
var p9 = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, d9 = function() {
  return window.location.hash.replace(/^#/, "");
}, f9 = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, h9 = function(e) {
  return getComputedStyle(e).position !== "static";
}, Vf = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, g9 = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (h9(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Vf(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Vf(t, a).offsetTop - Vf(e, a).offsetTop;
};
xl.default = {
  updateHash: p9,
  getHash: d9,
  filterElementInContainer: f9,
  scrollOffset: g9
};
var Id = {}, dy = {};
Object.defineProperty(dy, "__esModule", {
  value: !0
});
dy.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var fy = {};
Object.defineProperty(fy, "__esModule", {
  value: !0
});
var m9 = El, v9 = ["mousedown", "mousewheel", "touchmove", "keydown"];
fy.default = {
  subscribe: function(e) {
    return typeof document < "u" && v9.forEach(function(t) {
      return (0, m9.addPassiveEventListener)(document, t, e);
    });
  }
};
var Ll = {};
Object.defineProperty(Ll, "__esModule", {
  value: !0
});
var sm = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      sm.registered[e] = t;
    },
    remove: function(e) {
      sm.registered[e] = null;
    }
  }
};
Ll.default = sm;
Object.defineProperty(Id, "__esModule", {
  value: !0
});
var y9 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, b9 = xl;
Rd(b9);
var w9 = dy, AC = Rd(w9), C9 = fy, O9 = Rd(C9), E9 = Ll, uo = Rd(E9);
function Rd(e) {
  return e && e.__esModule ? e : { default: e };
}
var zT = function(e) {
  return AC.default[e.smooth] || AC.default.defaultEasing;
}, x9 = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, L9 = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, am = function() {
  return L9() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), $T = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, UT = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, WT = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, D9 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, P9 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, k9 = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    uo.default.registered.end && uo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    am.call(window, i);
    return;
  }
  uo.default.registered.end && uo.default.registered.end(o.to, o.target, o.currentPosition);
}, hy = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Dl = function(e, t, n, r) {
  t.data = t.data || $T(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (O9.default.subscribe(o), hy(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? UT(t) : WT(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    uo.default.registered.end && uo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = x9(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = zT(t), s = k9.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      uo.default.registered.begin && uo.default.registered.begin(t.data.to, t.data.target), am.call(window, s);
    }, t.delay);
    return;
  }
  uo.default.registered.begin && uo.default.registered.begin(t.data.to, t.data.target), am.call(window, s);
}, Nd = function(e) {
  return e = y9({}, e), e.data = e.data || $T(), e.absolute = !0, e;
}, S9 = function(e) {
  Dl(0, Nd(e));
}, M9 = function(e, t) {
  Dl(e, Nd(t));
}, T9 = function(e) {
  e = Nd(e), hy(e), Dl(e.horizontal ? D9(e) : P9(e), e);
}, j9 = function(e, t) {
  t = Nd(t), hy(t);
  var n = t.horizontal ? UT(t) : WT(t);
  Dl(e + n, t);
};
Id.default = {
  animateTopScroll: Dl,
  getAnimationType: zT,
  scrollToTop: S9,
  scrollToBottom: T9,
  scrollTo: M9,
  scrollMore: j9
};
Object.defineProperty(Vs, "__esModule", {
  value: !0
});
var _9 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, A9 = xl, B9 = gy(A9), I9 = Id, R9 = gy(I9), N9 = Ll, Ou = gy(N9);
function gy(e) {
  return e && e.__esModule ? e : { default: e };
}
var Eu = {}, BC = void 0;
Vs.default = {
  unmount: function() {
    Eu = {};
  },
  register: function(e, t) {
    Eu[e] = t;
  },
  unregister: function(e) {
    delete Eu[e];
  },
  get: function(e) {
    return Eu[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return BC = e;
  },
  getActiveLink: function() {
    return BC;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = _9({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = B9.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Ou.default.registered.begin && Ou.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Ou.default.registered.end && Ou.default.registered.end(e, n);
      return;
    }
    R9.default.animateTopScroll(a, t, e, n);
  }
};
var lm = { exports: {} }, Hf = { exports: {} }, $t = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IC;
function F9() {
  if (IC) return $t;
  IC = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(v) {
    if (typeof v == "object" && v !== null) {
      var O = v.$$typeof;
      switch (O) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return v;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(v) {
    return S(v) === u;
  }
  return $t.AsyncMode = l, $t.ConcurrentMode = u, $t.ContextConsumer = a, $t.ContextProvider = s, $t.Element = t, $t.ForwardRef = c, $t.Fragment = r, $t.Lazy = f, $t.Memo = m, $t.Portal = n, $t.Profiler = i, $t.StrictMode = o, $t.Suspense = p, $t.isAsyncMode = function(v) {
    return E(v) || S(v) === l;
  }, $t.isConcurrentMode = E, $t.isContextConsumer = function(v) {
    return S(v) === a;
  }, $t.isContextProvider = function(v) {
    return S(v) === s;
  }, $t.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, $t.isForwardRef = function(v) {
    return S(v) === c;
  }, $t.isFragment = function(v) {
    return S(v) === r;
  }, $t.isLazy = function(v) {
    return S(v) === f;
  }, $t.isMemo = function(v) {
    return S(v) === m;
  }, $t.isPortal = function(v) {
    return S(v) === n;
  }, $t.isProfiler = function(v) {
    return S(v) === i;
  }, $t.isStrictMode = function(v) {
    return S(v) === o;
  }, $t.isSuspense = function(v) {
    return S(v) === p;
  }, $t.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === m || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === g);
  }, $t.typeOf = S, $t;
}
var Kt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RC;
function z9() {
  return RC || (RC = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(W) {
      return typeof W == "string" || typeof W == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      W === r || W === u || W === i || W === o || W === p || W === d || typeof W == "object" && W !== null && (W.$$typeof === f || W.$$typeof === m || W.$$typeof === s || W.$$typeof === a || W.$$typeof === c || W.$$typeof === h || W.$$typeof === C || W.$$typeof === w || W.$$typeof === g);
    }
    function E(W) {
      if (typeof W == "object" && W !== null) {
        var ue = W.$$typeof;
        switch (ue) {
          case t:
            var ye = W.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var v = l, O = u, P = a, U = s, L = t, N = c, A = r, z = f, V = m, $ = n, Z = i, J = o, Y = p, te = !1;
    function ee(W) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(W) || E(W) === l;
    }
    function k(W) {
      return E(W) === u;
    }
    function _(W) {
      return E(W) === a;
    }
    function K(W) {
      return E(W) === s;
    }
    function M(W) {
      return typeof W == "object" && W !== null && W.$$typeof === t;
    }
    function G(W) {
      return E(W) === c;
    }
    function x(W) {
      return E(W) === r;
    }
    function T(W) {
      return E(W) === f;
    }
    function F(W) {
      return E(W) === m;
    }
    function j(W) {
      return E(W) === n;
    }
    function H(W) {
      return E(W) === i;
    }
    function B(W) {
      return E(W) === o;
    }
    function Q(W) {
      return E(W) === p;
    }
    Kt.AsyncMode = v, Kt.ConcurrentMode = O, Kt.ContextConsumer = P, Kt.ContextProvider = U, Kt.Element = L, Kt.ForwardRef = N, Kt.Fragment = A, Kt.Lazy = z, Kt.Memo = V, Kt.Portal = $, Kt.Profiler = Z, Kt.StrictMode = J, Kt.Suspense = Y, Kt.isAsyncMode = ee, Kt.isConcurrentMode = k, Kt.isContextConsumer = _, Kt.isContextProvider = K, Kt.isElement = M, Kt.isForwardRef = G, Kt.isFragment = x, Kt.isLazy = T, Kt.isMemo = F, Kt.isPortal = j, Kt.isProfiler = H, Kt.isStrictMode = B, Kt.isSuspense = Q, Kt.isValidElementType = S, Kt.typeOf = E;
  }()), Kt;
}
var NC;
function VT() {
  return NC || (NC = 1, process.env.NODE_ENV === "production" ? Hf.exports = F9() : Hf.exports = z9()), Hf.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var qf, FC;
function $9() {
  if (FC) return qf;
  FC = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return qf = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, qf;
}
var Zf, zC;
function my() {
  if (zC) return Zf;
  zC = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Zf = e, Zf;
}
var $C, UC;
function HT() {
  return UC || (UC = 1, $C = Function.call.bind(Object.prototype.hasOwnProperty)), $C;
}
var Kf, WC;
function U9() {
  if (WC) return Kf;
  WC = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = my(), n = {}, r = HT();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Kf = o, Kf;
}
var Gf, VC;
function W9() {
  if (VC) return Gf;
  VC = 1;
  var e = VT(), t = $9(), n = my(), r = HT(), o = U9(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Gf = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", m = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: S,
      element: E(),
      elementType: v(),
      instanceOf: O,
      node: N(),
      objectOf: U,
      oneOf: P,
      oneOfType: L,
      shape: z,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function g(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, K = 0;
      function M(x, T, F, j, H, B, Q) {
        if (j = j || d, B = B || F, Q !== n) {
          if (l) {
            var W = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw W.name = "Invariant Violation", W;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            K < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, K++);
          }
        }
        return T[F] == null ? x ? T[F] === null ? new g("The " + H + " `" + B + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new g("The " + H + " `" + B + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : k(T, F, j, H, B);
      }
      var G = M.bind(null, !1);
      return G.isRequired = M.bind(null, !0), G;
    }
    function C(k) {
      function _(K, M, G, x, T, F) {
        var j = K[M], H = J(j);
        if (H !== k) {
          var B = Y(j);
          return new g(
            "Invalid " + x + " `" + T + "` of type " + ("`" + B + "` supplied to `" + G + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(_);
    }
    function w() {
      return h(s);
    }
    function S(k) {
      function _(K, M, G, x, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var F = K[M];
        if (!Array.isArray(F)) {
          var j = J(F);
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var H = 0; H < F.length; H++) {
          var B = k(F, H, G, x, T + "[" + H + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return h(_);
    }
    function E() {
      function k(_, K, M, G, x) {
        var T = _[K];
        if (!a(T)) {
          var F = J(T);
          return new g("Invalid " + G + " `" + x + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function v() {
      function k(_, K, M, G, x) {
        var T = _[K];
        if (!e.isValidElementType(T)) {
          var F = J(T);
          return new g("Invalid " + G + " `" + x + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function O(k) {
      function _(K, M, G, x, T) {
        if (!(K[M] instanceof k)) {
          var F = k.name || d, j = ee(K[M]);
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return h(_);
    }
    function P(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function _(K, M, G, x, T) {
        for (var F = K[M], j = 0; j < k.length; j++)
          if (f(F, k[j]))
            return null;
        var H = JSON.stringify(k, function(B, Q) {
          var W = Y(Q);
          return W === "symbol" ? String(Q) : Q;
        });
        return new g("Invalid " + x + " `" + T + "` of value `" + String(F) + "` " + ("supplied to `" + G + "`, expected one of " + H + "."));
      }
      return h(_);
    }
    function U(k) {
      function _(K, M, G, x, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var H in F)
          if (r(F, H)) {
            var B = k(F, H, G, x, T + "." + H, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return h(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var _ = 0; _ < k.length; _++) {
        var K = k[_];
        if (typeof K != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(K) + " at index " + _ + "."
          ), s;
      }
      function M(G, x, T, F, j) {
        for (var H = [], B = 0; B < k.length; B++) {
          var Q = k[B], W = Q(G, x, T, F, j, n);
          if (W == null)
            return null;
          W.data && r(W.data, "expectedType") && H.push(W.data.expectedType);
        }
        var ue = H.length > 0 ? ", expected one of type [" + H.join(", ") + "]" : "";
        return new g("Invalid " + F + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function N() {
      function k(_, K, M, G, x) {
        return $(_[K]) ? null : new g("Invalid " + G + " `" + x + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function A(k, _, K, M, G) {
      return new g(
        (k || "React class") + ": " + _ + " type `" + K + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function z(k) {
      function _(K, M, G, x, T) {
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var H in k) {
          var B = k[H];
          if (typeof B != "function")
            return A(G, x, T, H, Y(B));
          var Q = B(F, H, G, x, T + "." + H, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(_);
    }
    function V(k) {
      function _(K, M, G, x, T) {
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var H = t({}, K[M], k);
        for (var B in H) {
          var Q = k[B];
          if (r(k, B) && typeof Q != "function")
            return A(G, x, T, B, Y(Q));
          if (!Q)
            return new g(
              "Invalid " + x + " `" + T + "` key `" + B + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(K[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var W = Q(F, B, G, x, T + "." + B, n);
          if (W)
            return W;
        }
        return null;
      }
      return h(_);
    }
    function $(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every($);
          if (k === null || a(k))
            return !0;
          var _ = p(k);
          if (_) {
            var K = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = K.next()).done; )
                if (!$(M.value))
                  return !1;
            } else
              for (; !(M = K.next()).done; ) {
                var G = M.value;
                if (G && !$(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function J(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : Z(_, k) ? "symbol" : _;
    }
    function Y(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = J(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function te(k) {
      var _ = Y(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, Gf;
}
var Yf, HC;
function V9() {
  if (HC) return Yf;
  HC = 1;
  var e = my();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Yf = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Yf;
}
if (process.env.NODE_ENV !== "production") {
  var H9 = VT(), q9 = !0;
  lm.exports = W9()(H9.isElement, q9);
} else
  lm.exports = V9()();
var Fd = lm.exports, zd = {};
Object.defineProperty(zd, "__esModule", {
  value: !0
});
var Z9 = xl, Xf = K9(Z9);
function K9(e) {
  return e && e.__esModule ? e : { default: e };
}
var G9 = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Xf.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Xf.default.getHash() !== e && Xf.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
zd.default = G9;
Object.defineProperty(Cl, "__esModule", {
  value: !0
});
var xu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Y9 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), X9 = xe, qC = Pl(X9), J9 = Ol, Lu = Pl(J9), Q9 = Vs, eV = Pl(Q9), tV = Fd, En = Pl(tV), nV = zd, Wo = Pl(nV);
function Pl(e) {
  return e && e.__esModule ? e : { default: e };
}
function rV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function oV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function iV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ZC = {
  to: En.default.string.isRequired,
  containerId: En.default.string,
  container: En.default.object,
  activeClass: En.default.string,
  activeStyle: En.default.object,
  spy: En.default.bool,
  horizontal: En.default.bool,
  smooth: En.default.oneOfType([En.default.bool, En.default.string]),
  offset: En.default.number,
  delay: En.default.number,
  isDynamic: En.default.bool,
  onClick: En.default.func,
  duration: En.default.oneOfType([En.default.number, En.default.func]),
  absolute: En.default.bool,
  onSetActive: En.default.func,
  onSetInactive: En.default.func,
  ignoreCancelEvents: En.default.bool,
  hashSpy: En.default.bool,
  saveHashHistory: En.default.bool,
  spyThrottle: En.default.number
};
Cl.default = function(e, t) {
  var n = t || eV.default, r = function(i) {
    iV(s, i);
    function s(a) {
      rV(this, s);
      var l = oV(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return Y9(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          Lu.default.isMounted(a) || Lu.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Wo.default.isMounted() || Wo.default.mount(n), Wo.default.mapContainer(this.props.to, a)), Lu.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Lu.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = xu({}, this.props.style, this.props.activeStyle) : l = xu({}, this.props.style);
        var u = xu({}, this.props);
        for (var c in ZC)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, qC.default.createElement(e, u);
      }
    }]), s;
  }(qC.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, xu({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Wo.default.isMounted() && !Wo.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var C = l.getBoundingClientRect();
            h = C.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var S = s - i.props.offset;
          d = S >= Math.floor(f) && S < Math.floor(g), m = S < Math.floor(f) || S >= Math.floor(g);
        } else {
          var E = 0, v = 0, O = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            O = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            E = U.top - O + a, v = E + U.height;
          }
          var L = a - i.props.offset;
          d = L >= Math.floor(E) && L < Math.floor(v), m = L < Math.floor(E) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (m) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Wo.default.getHash() === c) {
            var A = i.props.saveHashHistory, z = A === void 0 ? !1 : A;
            Wo.default.changeHash("", z);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, $ = V === void 0 ? !1 : V;
          i.props.hashSpy && Wo.default.changeHash(c, $), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = ZC, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(py, "__esModule", {
  value: !0
});
var sV = xe, KC = qT(sV), aV = Cl, lV = qT(aV);
function qT(e) {
  return e && e.__esModule ? e : { default: e };
}
function uV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function GC(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var pV = function(e) {
  cV(t, e);
  function t() {
    var n, r, o, i;
    uV(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = GC(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return KC.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), GC(o, i);
  }
  return t;
}(KC.default.Component);
py.default = (0, lV.default)(pV);
var vy = {};
Object.defineProperty(vy, "__esModule", {
  value: !0
});
var dV = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), fV = xe, YC = ZT(fV), hV = Cl, gV = ZT(hV);
function ZT(e) {
  return e && e.__esModule ? e : { default: e };
}
function mV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bV = function(e) {
  yV(t, e);
  function t() {
    return mV(this, t), vV(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return dV(t, [{
    key: "render",
    value: function() {
      return YC.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(YC.default.Component);
vy.default = (0, gV.default)(bV);
var yy = {}, $d = {};
Object.defineProperty($d, "__esModule", {
  value: !0
});
var wV = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, CV = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), OV = xe, XC = Ud(OV), EV = wl;
Ud(EV);
var xV = Vs, JC = Ud(xV), LV = Fd, QC = Ud(LV);
function Ud(e) {
  return e && e.__esModule ? e : { default: e };
}
function DV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function kV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
$d.default = function(e) {
  var t = function(n) {
    kV(r, n);
    function r(o) {
      DV(this, r);
      var i = PV(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return CV(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        JC.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        JC.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return XC.default.createElement(e, wV({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(XC.default.Component);
  return t.propTypes = {
    name: QC.default.string,
    id: QC.default.string
  }, t;
};
Object.defineProperty(yy, "__esModule", {
  value: !0
});
var e1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, SV = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), MV = xe, t1 = by(MV), TV = $d, jV = by(TV), _V = Fd, n1 = by(_V);
function by(e) {
  return e && e.__esModule ? e : { default: e };
}
function AV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function BV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function IV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var KT = function(e) {
  IV(t, e);
  function t() {
    return AV(this, t), BV(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return SV(t, [{
    key: "render",
    value: function() {
      var n = this, r = e1({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, t1.default.createElement(
        "div",
        e1({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(t1.default.Component);
KT.propTypes = {
  name: n1.default.string,
  id: n1.default.string
};
yy.default = (0, jV.default)(KT);
var Jf = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, r1 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function o1(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function i1(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function s1(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Du = xe, Ni = Ol, Qf = Vs, Nn = Fd, Vo = zd, a1 = {
  to: Nn.string.isRequired,
  containerId: Nn.string,
  container: Nn.object,
  activeClass: Nn.string,
  spy: Nn.bool,
  smooth: Nn.oneOfType([Nn.bool, Nn.string]),
  offset: Nn.number,
  delay: Nn.number,
  isDynamic: Nn.bool,
  onClick: Nn.func,
  duration: Nn.oneOfType([Nn.number, Nn.func]),
  absolute: Nn.bool,
  onSetActive: Nn.func,
  onSetInactive: Nn.func,
  ignoreCancelEvents: Nn.bool,
  hashSpy: Nn.bool,
  spyThrottle: Nn.number
}, RV = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Qf, r = function(i) {
      s1(s, i);
      function s(a) {
        o1(this, s);
        var l = i1(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return r1(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Ni.isMounted(a) || Ni.mount(a, this.props.spyThrottle), this.props.hashSpy && (Vo.isMounted() || Vo.mount(n), Vo.mapContainer(this.props.to, a)), this.props.spy && Ni.addStateHandler(this.stateHandler), Ni.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ni.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Jf({}, this.props);
          for (var u in a1)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Du.createElement(e, l);
        }
      }]), s;
    }(Du.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Jf({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Vo.isMounted() && !Vo.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            d = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + s, p = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(p), C = g < Math.floor(c) || g >= Math.floor(p), w = n.getActiveLink();
          if (C)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Vo.getHash() === l && Vo.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ni.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Vo.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ni.updateStates();
        }
      };
    };
    return r.propTypes = a1, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      s1(r, n);
      function r(o) {
        o1(this, r);
        var i = i1(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return r1(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Qf.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Qf.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Du.createElement(e, Jf({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Du.Component);
    return t.propTypes = {
      name: Nn.string,
      id: Nn.string
    }, t;
  }
}, NV = RV;
Object.defineProperty(Hn, "__esModule", {
  value: !0
});
Hn.Helpers = Hn.ScrollElement = Hn.ScrollLink = Hn.animateScroll = Hn.scrollSpy = Hn.Events = Hn.scroller = Hn.Element = Hn.Button = Hn.Link = void 0;
var FV = py, GT = yo(FV), zV = vy, YT = yo(zV), $V = yy, XT = yo($V), UV = Vs, JT = yo(UV), WV = Ll, QT = yo(WV), VV = Ol, ej = yo(VV), HV = Id, tj = yo(HV), qV = Cl, nj = yo(qV), ZV = $d, rj = yo(ZV), KV = NV, oj = yo(KV);
function yo(e) {
  return e && e.__esModule ? e : { default: e };
}
Hn.Link = GT.default;
Hn.Button = YT.default;
Hn.Element = XT.default;
Hn.scroller = JT.default;
Hn.Events = QT.default;
Hn.scrollSpy = ej.default;
Hn.animateScroll = tj.default;
Hn.ScrollLink = nj.default;
Hn.ScrollElement = rj.default;
Hn.Helpers = oj.default;
Hn.default = { Link: GT.default, Button: YT.default, Element: XT.default, scroller: JT.default, Events: QT.default, scrollSpy: ej.default, animateScroll: tj.default, ScrollLink: nj.default, ScrollElement: rj.default, Helpers: oj.default };
qe({});
qe({});
qe({});
function cl(e) {
  "@babel/helpers - typeof";
  return cl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cl(e);
}
function GV(e, t) {
  if (cl(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (cl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function YV(e) {
  var t = GV(e, "string");
  return cl(t) == "symbol" ? t : t + "";
}
function fe(e, t, n) {
  return (t = YV(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function ij(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var eh, l1;
function XV() {
  if (l1) return eh;
  l1 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, s, a, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return eh = t, eh;
}
var JV = XV(), Xn = /* @__PURE__ */ ij(JV), it = qe(null);
function QV() {
  Xn(!!De, "useGoogleMap is React hook and requires React version 16.8+");
  var e = De(it);
  return Xn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function e8(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function t8(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function n8(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return t8(e, i), o;
}
function r8(e, t, n) {
  var r = e8(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function o8(e) {
  google.maps.event.removeListener(e);
}
function Tt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(o8);
}
function Lt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = r8(o, i, n);
  return n8(t, r, o, i), s;
}
function i8(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: E
  } = e, [v, O] = D(null), P = Ye(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null), [B, Q] = D(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && p && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), y(() => {
    v && g && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(v, "mousedown", g)));
  }, [g]), y(() => {
    v && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), y(() => {
    v && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(v, "mouseout", m)));
  }, [m]), y(() => {
    v && f && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (B !== null && google.maps.event.removeListener(B), Q(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var W = P.current === null ? null : new google.maps.Map(P.current, n);
    return O(W), W !== null && S && S(W), () => {
      W !== null && E && E(W);
    };
  }, []), Dr.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Dr.jsx(it.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
ke(i8);
function u1(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function sj(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        u1(i, r, o, s, a, "next", l);
      }
      function a(l) {
        u1(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function aj(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Xn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var ns = typeof document < "u";
function lj(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return ns ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function c1(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function uj() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return c1(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return c1(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var aa = !1;
function cj() {
  return Dr.jsx("div", {
    children: "Loading..."
  });
}
var um = {
  id: "script-loader",
  version: "weekly"
};
class s8 extends Oe {
  constructor() {
    super(...arguments), fe(this, "check", cr()), fe(this, "state", {
      loaded: !1
    }), fe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), fe(this, "isCleaningUp", /* @__PURE__ */ sj(function* () {
      function t(n) {
        if (!aa)
          n();
        else if (ns)
          var r = window.setInterval(function() {
            aa || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), fe(this, "cleanup", () => {
      aa = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), fe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && uj(), Xn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: aj(this.props)
      };
      lj(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (ns) {
      if (window.google && window.google.maps && !aa) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ns && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (ns) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, aa = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Dr.jsxs(Dr.Fragment, {
      children: [Dr.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Dr.jsx(cj, {})]
    });
  }
}
fe(s8, "defaultProps", um);
function a8(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function wy(e, t) {
  if (e == null) return {};
  var n, r, o = a8(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var p1;
function l8(e) {
  var {
    id: t = um.id,
    version: n = um.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Ye(!1), [f, g] = D(!1), [h, C] = D(void 0);
  y(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), y(function() {
    ns && u && uj();
  }, [u]), y(function() {
    f && Xn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = aj({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  y(function() {
    if (!ns)
      return;
    function E() {
      m.current && (g(!0), p1 = w);
    }
    if (window.google && window.google.maps && p1 === w) {
      E();
      return;
    }
    lj({
      id: t,
      url: w,
      nonce: r
    }).then(E).catch(function(v) {
      m.current && C(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var S = Ye();
  return y(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var u8 = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], c8 = Dr.jsx(cj, {});
function p8(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = wy(e, u8), {
    isLoaded: a,
    loadError: l
  } = l8(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || c8;
}
ke(p8);
var d1;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(d1 || (d1 = {}));
function f1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h1 = {}, g1 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function d8(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = De(it), [i, s] = D(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(Gc(Gc({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(d8);
class f8 extends Oe {
  constructor() {
    super(...arguments), fe(this, "state", {
      trafficLayer: null
    }), fe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Gc(Gc({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: g1,
      eventMap: h1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: g1,
      eventMap: h1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Tt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(f8, "contextType", it);
function h8(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = De(it), [o, i] = D(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
ke(h8);
class g8 extends Oe {
  constructor() {
    super(...arguments), fe(this, "state", {
      bicyclingLayer: null
    }), fe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(g8, "contextType", it);
function m8(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = De(it), [o, i] = D(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(m8);
class v8 extends Oe {
  constructor() {
    super(...arguments), fe(this, "state", {
      transitLayer: null
    }), fe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(v8, "contextType", it);
function m1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var v1 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, y1 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function y8(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = De(it), [d, m] = D(null), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null);
  return y(() => {
    d !== null && d.setMap(p);
  }, [p]), y(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), y(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), y(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), y(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), y(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), y(() => {
    d && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), y(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), y(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), y(() => {
    Xn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Yc(Yc({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && g(google.maps.event.addListener(N, "circlecomplete", r)), o && C(google.maps.event.addListener(N, "markercomplete", o)), i && S(google.maps.event.addListener(N, "overlaycomplete", i)), s && v(google.maps.event.addListener(N, "polygoncomplete", s)), a && P(google.maps.event.addListener(N, "polylinecomplete", a)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), m(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(y8);
class b8 extends Oe {
  constructor(t) {
    super(t), fe(this, "registeredEvents", []), fe(this, "state", {
      drawingManager: null
    }), fe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Xn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Yc(Yc({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: y1,
      eventMap: v1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: y1,
      eventMap: v1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Tt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
fe(b8, "contextType", it);
function b1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ps(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? b1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : b1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var w1 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, C1 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Xc = {};
function w8(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: S,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: O,
    onMouseOver: P,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: A,
    onCursorChanged: z,
    onAnimationChanged: V,
    onDraggableChanged: $,
    onFlatChanged: Z,
    onIconChanged: J,
    onPositionChanged: Y,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: K,
    onUnmount: M
  } = e, G = De(it), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null), [Q, W] = D(null), [ue, ye] = D(null), [oe, _e] = D(null), [Fe, ze] = D(null), [Re, Ge] = D(null), [Ze, Me] = D(null), [Ke, rt] = D(null), [Se, je] = D(null), [Ne, Ve] = D(null), [Ue, ot] = D(null), [Te, Zt] = D(null), [lt, ht] = D(null), [kt, sn] = D(null), [St, an] = D(null), [tt, Nt] = D(null), [ut, ln] = D(null), [Mt, Mn] = D(null), [un, Tn] = D(null), [cn, jn] = D(null);
  y(() => {
    x !== null && x.setMap(G);
  }, [G]), y(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), y(() => {
    typeof s < "u" && x !== null && x.setDraggable(s);
  }, [x, s]), y(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), y(() => {
    typeof a < "u" && x !== null && x.setVisible(a);
  }, [x, a]), y(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), y(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), y(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), y(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), y(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), y(() => {
    x && m !== void 0 && x.setOpacity(m);
  }, [x, m]), y(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), y(() => {
    x && g !== void 0 && x.setTitle(g);
  }, [x, g]), y(() => {
    x && h !== void 0 && x.setZIndex(h);
  }, [x, h]), y(() => {
    x && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), y(() => {
    x && E && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(x, "dragend", E)));
  }, [E]), y(() => {
    x && v && (Q !== null && google.maps.event.removeListener(Q), W(google.maps.event.addListener(x, "dragstart", v)));
  }, [v]), y(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), y(() => {
    x && O && (oe !== null && google.maps.event.removeListener(oe), _e(google.maps.event.addListener(x, "mouseout", O)));
  }, [O]), y(() => {
    x && P && (Fe !== null && google.maps.event.removeListener(Fe), ze(google.maps.event.addListener(x, "mouseover", P)));
  }, [P]), y(() => {
    x && U && (Re !== null && google.maps.event.removeListener(Re), Ge(google.maps.event.addListener(x, "mouseup", U)));
  }, [U]), y(() => {
    x && N && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), y(() => {
    x && C && (Ke !== null && google.maps.event.removeListener(Ke), rt(google.maps.event.addListener(x, "click", C)));
  }, [C]), y(() => {
    x && S && (Se !== null && google.maps.event.removeListener(Se), je(google.maps.event.addListener(x, "drag", S)));
  }, [S]), y(() => {
    x && A && (Ne !== null && google.maps.event.removeListener(Ne), Ve(google.maps.event.addListener(x, "clickable_changed", A)));
  }, [A]), y(() => {
    x && z && (Ue !== null && google.maps.event.removeListener(Ue), ot(google.maps.event.addListener(x, "cursor_changed", z)));
  }, [z]), y(() => {
    x && V && (Te !== null && google.maps.event.removeListener(Te), Zt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), y(() => {
    x && $ && (lt !== null && google.maps.event.removeListener(lt), ht(google.maps.event.addListener(x, "draggable_changed", $)));
  }, [$]), y(() => {
    x && Z && (kt !== null && google.maps.event.removeListener(kt), sn(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), y(() => {
    x && J && (St !== null && google.maps.event.removeListener(St), an(google.maps.event.addListener(x, "icon_changed", J)));
  }, [J]), y(() => {
    x && Y && (tt !== null && google.maps.event.removeListener(tt), Nt(google.maps.event.addListener(x, "position_changed", Y)));
  }, [Y]), y(() => {
    x && te && (ut !== null && google.maps.event.removeListener(ut), ln(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), y(() => {
    x && ee && (Mt !== null && google.maps.event.removeListener(Mt), Mn(google.maps.event.addListener(x, "title_changed", ee)));
  }, [ee]), y(() => {
    x && k && (un !== null && google.maps.event.removeListener(un), Tn(google.maps.event.addListener(x, "visible_changed", k)));
  }, [k]), y(() => {
    x && _ && (cn !== null && google.maps.event.removeListener(cn), jn(google.maps.event.addListener(x, "zindex_changed", _)));
  }, [_]), y(() => {
    var Ft = Ps(Ps(Ps({}, n || Xc), r ? Xc : {
      map: G
    }), {}, {
      position: t
    }), ie = new google.maps.Marker(Ft);
    return r ? r.addMarker(ie, !!o) : ie.setMap(G), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof m < "u" && ie.setOpacity(m), f && ie.setShape(f), typeof g == "string" && ie.setTitle(g), typeof h == "number" && ie.setZIndex(h), w && j(google.maps.event.addListener(ie, "dblclick", w)), E && B(google.maps.event.addListener(ie, "dragend", E)), v && W(google.maps.event.addListener(ie, "dragstart", v)), L && ye(google.maps.event.addListener(ie, "mousedown", L)), O && _e(google.maps.event.addListener(ie, "mouseout", O)), P && ze(google.maps.event.addListener(ie, "mouseover", P)), U && Ge(google.maps.event.addListener(ie, "mouseup", U)), N && Me(google.maps.event.addListener(ie, "rightclick", N)), C && rt(google.maps.event.addListener(ie, "click", C)), S && je(google.maps.event.addListener(ie, "drag", S)), A && Ve(google.maps.event.addListener(ie, "clickable_changed", A)), z && ot(google.maps.event.addListener(ie, "cursor_changed", z)), V && Zt(google.maps.event.addListener(ie, "animation_changed", V)), $ && ht(google.maps.event.addListener(ie, "draggable_changed", $)), Z && sn(google.maps.event.addListener(ie, "flat_changed", Z)), J && an(google.maps.event.addListener(ie, "icon_changed", J)), Y && Nt(google.maps.event.addListener(ie, "position_changed", Y)), te && ln(google.maps.event.addListener(ie, "shape_changed", te)), ee && Mn(google.maps.event.addListener(ie, "title_changed", ee)), k && Tn(google.maps.event.addListener(ie, "visible_changed", k)), _ && jn(google.maps.event.addListener(ie, "zindex_changed", _)), T(ie), K && K(ie), () => {
      F !== null && google.maps.event.removeListener(F), H !== null && google.maps.event.removeListener(H), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), Ze !== null && google.maps.event.removeListener(Ze), Ke !== null && google.maps.event.removeListener(Ke), Ne !== null && google.maps.event.removeListener(Ne), Ue !== null && google.maps.event.removeListener(Ue), Te !== null && google.maps.event.removeListener(Te), lt !== null && google.maps.event.removeListener(lt), kt !== null && google.maps.event.removeListener(kt), St !== null && google.maps.event.removeListener(St), tt !== null && google.maps.event.removeListener(tt), Mt !== null && google.maps.event.removeListener(Mt), un !== null && google.maps.event.removeListener(un), cn !== null && google.maps.event.removeListener(cn), M && M(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var Yn = Gn(() => i ? Ct.map(i, (Ft) => {
    if (!mi(Ft))
      return Ft;
    var ie = Ft;
    return vi(ie, {
      anchor: x
    });
  }) : null, [i, x]);
  return Dr.jsx(Dr.Fragment, {
    children: Yn
  }) || null;
}
ke(w8);
class C8 extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return sj(function* () {
      var n = Ps(Ps(Ps({}, t.props.options || Xc), t.props.clusterer ? Xc : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Lt({
        updaterMap: C1,
        eventMap: w1,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: C1,
      eventMap: w1,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Tt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ct.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
fe(C8, "contextType", it);
var O8 = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), E8 = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new O8(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function x8(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var L8 = 2e3, D8 = 500, P8 = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", k8 = "png", S8 = [53, 56, 66, 78, 90], M8 = "cluster", pj = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || P8, this.imageExtension = r.imageExtension || k8, this.imageSizes = r.imageSizes || S8, this.calculator = r.calculator || x8, this.batchSize = r.batchSize || L8, this.batchSizeIE = r.batchSizeIE || D8, this.clusterClass = r.clusterClass || M8, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new E8(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function O1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function T8(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Kr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, At = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, j8 = {};
function _8(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: O,
    onLoad: P,
    onUnmount: U
  } = e, [L, N] = D(null), A = De(it), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null);
  return y(() => {
    L && O && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, Kr.onMouseOut, O)));
  }, [O]), y(() => {
    L && v && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, Kr.onMouseOver, v)));
  }, [v]), y(() => {
    L && w && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(L, Kr.onClick, w)));
  }, [w]), y(() => {
    L && S && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(L, Kr.onClusteringBegin, S)));
  }, [S]), y(() => {
    L && E && (J !== null && google.maps.event.removeListener(J), Z(google.maps.event.addListener(L, Kr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && L !== null && At.averageCenter(L, r);
  }, [L, r]), y(() => {
    typeof o < "u" && L !== null && At.batchSizeIE(L, o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && At.calculator(L, i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && At.clusterClass(L, s);
  }, [L, s]), y(() => {
    typeof a < "u" && L !== null && At.enableRetinaIcons(L, a);
  }, [L, a]), y(() => {
    typeof l < "u" && L !== null && At.gridSize(L, l);
  }, [L, l]), y(() => {
    typeof u < "u" && L !== null && At.ignoreHidden(L, u);
  }, [L, u]), y(() => {
    typeof c < "u" && L !== null && At.imageExtension(L, c);
  }, [L, c]), y(() => {
    typeof p < "u" && L !== null && At.imagePath(L, p);
  }, [L, p]), y(() => {
    typeof d < "u" && L !== null && At.imageSizes(L, d);
  }, [L, d]), y(() => {
    typeof m < "u" && L !== null && At.maxZoom(L, m);
  }, [L, m]), y(() => {
    typeof f < "u" && L !== null && At.minimumClusterSize(L, f);
  }, [L, f]), y(() => {
    typeof g < "u" && L !== null && At.styles(L, g);
  }, [L, g]), y(() => {
    typeof h < "u" && L !== null && At.title(L, h);
  }, [L, h]), y(() => {
    typeof C < "u" && L !== null && At.zoomOnClick(L, C);
  }, [L, C]), y(() => {
    if (A) {
      var K = T8({}, n || j8), M = new pj(A, [], K);
      return r && At.averageCenter(M, r), o && At.batchSizeIE(M, o), i && At.calculator(M, i), s && At.clusterClass(M, s), a && At.enableRetinaIcons(M, a), l && At.gridSize(M, l), u && At.ignoreHidden(M, u), c && At.imageExtension(M, c), p && At.imagePath(M, p), d && At.imageSizes(M, d), m && At.maxZoom(M, m), f && At.minimumClusterSize(M, f), g && At.styles(M, g), h && At.title(M, h), C && At.zoomOnClick(M, C), O && ee(google.maps.event.addListener(M, Kr.onMouseOut, O)), v && _(google.maps.event.addListener(M, Kr.onMouseOver, v)), w && V(google.maps.event.addListener(M, Kr.onClick, w)), S && Z(google.maps.event.addListener(M, Kr.onClusteringBegin, S)), E && Y(google.maps.event.addListener(M, Kr.onClusteringEnd, E)), N(M), P && P(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ke(_8);
class A8 extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      markerClusterer: null
    }), fe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new pj(this.context, [], this.props.options);
      this.registeredEvents = Lt({
        updaterMap: At,
        eventMap: Kr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: At,
      eventMap: Kr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Tt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
fe(A8, "contextType", it);
function E1(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var dj = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || E1(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, E1));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), B8 = ["position"], I8 = ["position"];
function x1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var L1 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, D1 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, R8 = {};
function N8(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = De(it), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), N = Ye(null);
  return y(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var A = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(A);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (m) {
      var A = r || R8, {
        position: z
      } = A, V = wy(A, B8), $;
      z && !(z instanceof google.maps.LatLng) && ($ = new google.maps.LatLng(z.lat, z.lng));
      var Z = new dj(Jc(Jc({}, V), $ ? {
        position: $
      } : {}));
      N.current = document.createElement("div"), g(Z), s && C(google.maps.event.addListener(Z, "closeclick", s)), a && S(google.maps.event.addListener(Z, "domready", a)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(m, n) : Z.getPosition() ? Z.open(m) : Xn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? pr(Ct.only(t), N.current) : null;
}
ke(N8);
class F8 extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "containerElement", null), fe(this, "state", {
      infoBox: null
    }), fe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Xn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), fe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = wy(t, I8), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new dj(Jc(Jc({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Lt({
      updaterMap: D1,
      eventMap: L1,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: D1,
      eventMap: L1,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), Tt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? pr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
fe(F8, "contextType", it);
var P1, k1;
function z8() {
  return k1 || (k1 = 1, P1 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), P1;
}
var $8 = z8(), S1 = /* @__PURE__ */ ij($8), M1 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], th = 1, la = 8;
class Cy {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== th)
      throw new Error("Got v".concat(o, " data when expected v").concat(th, "."));
    var i = M1[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Cy(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = M1.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, la, t), this.coords = new this.ArrayType(this.data, la + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(la + s + a + l), this.ids = new this.IndexArrayType(this.data, la, t), this.coords = new this.ArrayType(this.data, la + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (th << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return cm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          T1(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      T1(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function cm(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    fj(e, t, s, r, o, i), cm(e, t, n, r, s - 1, 1 - i), cm(e, t, n, s + 1, o, 1 - i);
  }
}
function fj(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      fj(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (ua(e, t, r, n), t[2 * o + i] > m && ua(e, t, r, o); f < g; ) {
      for (ua(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? ua(e, t, r, g) : (g++, ua(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function ua(e, t, n, r) {
  nh(e, n, r), nh(t, 2 * n, 2 * r), nh(t, 2 * n + 1, 2 * r + 1);
}
function nh(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function T1(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var U8 = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, j1 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Fi = 2, ni = 3, rh = 4, Jo = 5, hj = 6;
class W8 {
  constructor(t) {
    this.options = Object.assign(Object.create(U8), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = j1(Pu(u)), d = j1(ku(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Pu(r), ku(s), Pu(i), ku(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + Jo] > 1 ? _1(p, f, this.clusterProps) : this.points[p[f + ni]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + rh] === t && p.push(s[m + Jo] > 1 ? _1(s, m, this.clusterProps) : this.points[s[m + ni]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Cy(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + Jo] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = gj(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + ni]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = Pu(f), d = ku(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + ni] : C = this.points[n[l + ni]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Fi] <= n)) {
        l[p + Fi] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + Jo], h = g;
        for (var C of f) {
          var w = C * c;
          l[w + Fi] > n && (h += l[w + Jo]);
        }
        if (h > g && h >= s) {
          var S = d * g, E = m * g, v = void 0, O = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + Fi] <= n)) {
              l[L + Fi] = n;
              var N = l[L + Jo];
              S += l[L] * N, E += l[L + 1] * N, l[L + rh] = P, i && (v || (v = this._map(l, p, !0), O = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + rh] = P, u.push(S / h, E / h, 1 / 0, P, -1, h), i && u.push(O);
        } else {
          for (var A = 0; A < c; A++) u.push(l[p + A]);
          if (h > 1)
            for (var z of f) {
              var V = z * c;
              if (!(l[V + Fi] <= n)) {
                l[V + Fi] = n;
                for (var $ = 0; $ < c; $++) u.push(l[V + $]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Jo] > 1) {
      var o = this.clusterProps[t[n + hj]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ni]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function _1(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ni],
    properties: gj(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [V8(e[t]), H8(e[t + 1])]
    }
  };
}
function gj(e, t, n) {
  var r = e[t + Jo], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + hj], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ni],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Pu(e) {
  return e / 360 + 0.5;
}
function ku(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function V8(e) {
  return (e - 0.5) * 360;
}
function H8(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function q8(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Br {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class pm {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Br.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Br.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Br.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Z8 {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return K8(n);
  }
}
var K8 = (e) => {
  var t = e.map((n) => new pm({
    position: Br.getPosition(n),
    markers: [n]
  }));
  return t;
};
class G8 extends Z8 {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = q8(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new W8(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!S1(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = Br.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !S1(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new pm({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new pm({
      markers: [i],
      position: Br.getPosition(i)
    });
  }
}
class Y8 {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class X8 {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Br.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function J8(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Oy {
  constructor() {
    J8(Oy, google.maps.OverlayView);
  }
}
var Na;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Na || (Na = {}));
var Q8 = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class eH extends Oy {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new G8(o),
      renderer: s = new X8(),
      onClusterClick: a = Q8
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Br.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Na.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Br.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => Br.setMap(l, null)));
      }
      google.maps.event.trigger(this, Na.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Br.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Y8(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Br.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Na.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Br.setMap(r.marker, n);
    });
  }
}
function A1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function B1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function tH(e) {
  var t = QV(), [n, r] = D(null);
  return y(() => {
    if (t && n === null) {
      var o = new eH(B1(B1({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function nH(e) {
  var {
    children: t,
    options: n
  } = e, r = tH(n);
  return r !== null ? t(r) : null;
}
ke(nH);
var I1 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, R1 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function rH(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = De(it), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), N = Ye(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var A = new google.maps.InfoWindow(r);
    return g(A), N.current = document.createElement("div"), s && C(google.maps.event.addListener(A, "closeclick", s)), a && S(google.maps.event.addListener(A, "domready", a)), l && v(google.maps.event.addListener(A, "content_changed", l)), u && P(google.maps.event.addListener(A, "position_changed", u)), c && L(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(N.current), o && A.setPosition(o), i && A.setZIndex(i), n ? A.open(m, n) : A.getPosition() ? A.open(m) : Xn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(A), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), d && d(A), A.close();
    };
  }, []), N.current ? pr(Ct.only(t), N.current) : null;
}
ke(rH);
class oH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "containerElement", null), fe(this, "state", {
      infoWindow: null
    }), fe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Xn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), fe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Lt({
      updaterMap: R1,
      eventMap: I1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: R1,
      eventMap: I1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Tt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? pr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
fe(oH, "contextType", it);
function N1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var F1 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, z1 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, iH = {};
function sH(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, S = De(it), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null);
  return y(() => {
    E !== null && E.setMap(S);
  }, [S]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && p && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(E, "mouseout", p)));
  }, [p]), y(() => {
    E && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(E, "mouseover", d)));
  }, [d]), y(() => {
    E && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(E, "mouseup", m)));
  }, [m]), y(() => {
    E && f && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && g && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && h && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var j = new google.maps.Polyline(Qc(Qc({}, t || iH), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && P(google.maps.event.addListener(j, "dblclick", s)), a && L(google.maps.event.addListener(j, "dragend", a)), l && A(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && Z(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), m && _(google.maps.event.addListener(j, "mouseup", m)), f && M(google.maps.event.addListener(j, "rightclick", f)), g && x(google.maps.event.addListener(j, "click", g)), h && F(google.maps.event.addListener(j, "drag", h)), v(j), C && C(j), () => {
      O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(sH);
class aH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      polyline: null
    }), fe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Qc(Qc({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: z1,
      eventMap: F1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: z1,
      eventMap: F1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Tt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
fe(aH, "contextType", it);
function $1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function U1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var W1 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, V1 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function lH(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: S,
    onEdit: E
  } = e, v = De(it), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null);
  return y(() => {
    O !== null && O.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof s < "u" && O !== null && O.setPaths(s);
  }, [O, s]), y(() => {
    O && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof p == "function" && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(O, "mousemove", p)));
  }, [p]), y(() => {
    O && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseout", d)));
  }, [d]), y(() => {
    O && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(O, "mouseover", m)));
  }, [m]), y(() => {
    O && typeof f == "function" && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(O, "mouseup", f)));
  }, [f]), y(() => {
    O && typeof g == "function" && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(O, "click", h)));
  }, [h]), y(() => {
    O && typeof C == "function" && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(O, "drag", C)));
  }, [C]), y(() => {
    var B = new google.maps.Polygon(U1(U1({}, t), {}, {
      map: v
    }));
    return i && B.setPath(i), s && B.setPaths(s), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), a && L(google.maps.event.addListener(B, "dblclick", a)), l && A(google.maps.event.addListener(B, "dragend", l)), u && V(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && Y(google.maps.event.addListener(B, "mousemove", p)), d && ee(google.maps.event.addListener(B, "mouseout", d)), m && _(google.maps.event.addListener(B, "mouseover", m)), f && M(google.maps.event.addListener(B, "mouseup", f)), g && x(google.maps.event.addListener(B, "rightclick", g)), h && F(google.maps.event.addListener(B, "click", h)), C && H(google.maps.event.addListener(B, "drag", C)), P(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), T !== null && google.maps.event.removeListener(T), S && S(B), B.setMap(null);
    };
  }, []), null;
}
ke(lH);
class uH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Lt({
      updaterMap: V1,
      eventMap: W1,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: V1,
      eventMap: W1,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Tt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
fe(uH, "contextType", it);
function H1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ep(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var q1 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Z1 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function cH(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: S
  } = e, E = De(it), [v, O] = D(null), [P, U] = D(null), [L, N] = D(null), [A, z] = D(null), [V, $] = D(null), [Z, J] = D(null), [Y, te] = D(null), [ee, k] = D(null), [_, K] = D(null), [M, G] = D(null), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (P !== null && google.maps.event.removeListener(P), U(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (A !== null && google.maps.event.removeListener(A), z(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), J(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), te(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), y(() => {
    v && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), y(() => {
    v && m && (_ !== null && google.maps.event.removeListener(_), K(google.maps.event.addListener(v, "mouseup", m)));
  }, [m]), y(() => {
    v && f && (M !== null && google.maps.event.removeListener(M), G(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && g && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(v, "click", g)));
  }, [g]), y(() => {
    v && h && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var Q = new google.maps.Rectangle(ep(ep({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && N(google.maps.event.addListener(Q, "dragend", a)), l && z(google.maps.event.addListener(Q, "dragstart", l)), u && $(google.maps.event.addListener(Q, "mousedown", u)), c && J(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && K(google.maps.event.addListener(Q, "mouseup", m)), f && G(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && j(google.maps.event.addListener(Q, "drag", h)), C && B(google.maps.event.addListener(Q, "bounds_changed", C)), O(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), x !== null && google.maps.event.removeListener(x), F !== null && google.maps.event.removeListener(F), H !== null && google.maps.event.removeListener(H), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke(cH);
class pH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      rectangle: null
    }), fe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(ep(ep({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: Z1,
      eventMap: q1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: Z1,
      eventMap: q1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Tt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
fe(pH, "contextType", it);
function K1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var G1 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Y1 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, dH = {};
function fH(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: E,
    onUnmount: v
  } = e, O = De(it), [P, U] = D(null), [L, N] = D(null), [A, z] = D(null), [V, $] = D(null), [Z, J] = D(null), [Y, te] = D(null), [ee, k] = D(null), [_, K] = D(null), [M, G] = D(null), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null), [Q, W] = D(null), [ue, ye] = D(null);
  return y(() => {
    P !== null && P.setMap(O);
  }, [O]), y(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), y(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), y(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), y(() => {
    typeof s < "u" && P !== null && P.setVisible(s);
  }, [P, s]), y(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), y(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), y(() => {
    P && a && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", a)));
  }, [a]), y(() => {
    P && l && (A !== null && google.maps.event.removeListener(A), z(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), y(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), y(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), J(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), y(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), y(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), y(() => {
    P && m && (_ !== null && google.maps.event.removeListener(_), K(google.maps.event.addListener(P, "mouseover", m)));
  }, [m]), y(() => {
    P && f && (M !== null && google.maps.event.removeListener(M), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), y(() => {
    P && g && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(P, "rightclick", g)));
  }, [g]), y(() => {
    P && h && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), y(() => {
    P && C && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(P, "drag", C)));
  }, [C]), y(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), W(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), y(() => {
    P && S && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), y(() => {
    var oe = new google.maps.Circle(tp(tp({}, t || dH), {}, {
      map: O
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && N(google.maps.event.addListener(oe, "dblclick", a)), l && z(google.maps.event.addListener(oe, "dragend", l)), u && $(google.maps.event.addListener(oe, "dragstart", u)), c && J(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && K(google.maps.event.addListener(oe, "mouseover", m)), f && G(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && j(google.maps.event.addListener(oe, "click", h)), C && B(google.maps.event.addListener(oe, "drag", C)), w && W(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), U(oe), E && E(oe), () => {
      L !== null && google.maps.event.removeListener(L), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), x !== null && google.maps.event.removeListener(x), F !== null && google.maps.event.removeListener(F), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(fH);
class hH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      circle: null
    }), fe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(tp(tp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: Y1,
      eventMap: G1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: Y1,
      eventMap: G1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Tt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
fe(hH, "contextType", it);
function X1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function np(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X1(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J1 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Q1 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function gH(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, C = De(it), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && p && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), y(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), y(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), y(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var B = new google.maps.Data(np(np({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(B, "dblclick", r)), o && P(google.maps.event.addListener(B, "mousedown", o)), i && L(google.maps.event.addListener(B, "mousemove", i)), s && A(google.maps.event.addListener(B, "mouseout", s)), a && V(google.maps.event.addListener(B, "mouseover", a)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && Y(google.maps.event.addListener(B, "rightclick", u)), n && ee(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && x(google.maps.event.addListener(B, "removeproperty", d)), m && F(google.maps.event.addListener(B, "setgeometry", m)), f && H(google.maps.event.addListener(B, "setproperty", f)), S(B), g && g(B);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(gH);
class mH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      data: null
    }), fe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(np(np({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Lt({
        updaterMap: Q1,
        eventMap: J1,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: Q1,
      eventMap: J1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Tt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
fe(mH, "contextType", it);
function eO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nO = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, rO = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class vH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      kmlLayer: null
    }), fe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(tO(tO({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: rO,
      eventMap: nO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: rO,
      eventMap: nO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Tt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(vH, "contextType", it);
function mj(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function yH(e, t) {
  return new t(e.lat, e.lng);
}
function bH(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function wH(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function CH(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function OH(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function EH(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function vj(e, t, n, r) {
  return n !== void 0 ? OH(e, t, CH(n, google.maps.LatLngBounds, bH)) : EH(e, t, wH(r, google.maps.LatLng, yH));
}
function xH(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function oO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function LH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function DH(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = LH({}, this.container ? mj(this.container, o) : {
        x: 0,
        y: 0
      }), u = vj(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function iO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function PH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function sO(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function aO(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function kH(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = De(it), c = Gn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Gn(() => DH(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ke(kH);
class Hs extends Oe {
  constructor(t) {
    super(t), fe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), fe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Xn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), fe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), fe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = PH({
        x: 0,
        y: 0
      }, this.containerRef.current ? mj(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = vj(r, o, this.props.bounds, this.props.position);
      if (!xH(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), fe(this, "draw", () => {
      this.onPositionElement();
    }), fe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = cr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = sO(t.position), r = sO(this.props.position), o = aO(t.bounds), i = aO(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(Dr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ct.only(this.props.children)
    }), t) : null;
  }
}
fe(Hs, "FLOAT_PANE", "floatPane");
fe(Hs, "MAP_PANE", "mapPane");
fe(Hs, "MARKER_LAYER", "markerLayer");
fe(Hs, "OVERLAY_LAYER", "overlayLayer");
fe(Hs, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
fe(Hs, "contextType", it);
function SH() {
}
function lO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uO(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cO = {
  onDblClick: "dblclick",
  onClick: "click"
}, pO = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function MH(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = De(it), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Gn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
ke(MH);
class yj extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      groundOverlay: null
    }), fe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Xn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, uO(uO({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: pO,
      eventMap: cO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: pO,
      eventMap: cO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
fe(yj, "defaultProps", {
  onLoad: SH
});
fe(yj, "contextType", it);
function dO(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dO(Object(n), !0).forEach(function(r) {
      fe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dO(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fO = {}, hO = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function TH(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = De(it), [s, a] = D(null);
  return y(() => {
    google.maps.visualization || Xn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Xn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(rp(rp({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
ke(TH);
class jH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      heatmapLayer: null
    }), fe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Xn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Xn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(rp(rp({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Lt({
      updaterMap: hO,
      eventMap: fO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: hO,
      eventMap: fO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Tt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(jH, "contextType", it);
var gO = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, mO = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class _H extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      streetViewPanorama: null
    }), fe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Lt({
      updaterMap: mO,
      eventMap: gO,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: mO,
      eventMap: gO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Tt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
fe(_H, "contextType", it);
class AH extends Oe {
  constructor() {
    super(...arguments), fe(this, "state", {
      streetViewService: null
    }), fe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
fe(AH, "contextType", it);
var vO = {
  onDirectionsChanged: "directions_changed"
}, yO = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class BH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "state", {
      directionsRenderer: null
    }), fe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Lt({
      updaterMap: yO,
      eventMap: vO,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: yO,
      eventMap: vO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Tt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
fe(BH, "contextType", it);
var bO = {
  onPlacesChanged: "places_changed"
}, wO = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class IH extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "containerElement", cr()), fe(this, "state", {
      searchBox: null
    }), fe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Xn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Lt({
          updaterMap: wO,
          eventMap: bO,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: wO,
      eventMap: bO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Tt(this.registeredEvents));
  }
  render() {
    return Dr.jsx("div", {
      ref: this.containerElement,
      children: Ct.only(this.props.children)
    });
  }
}
fe(IH, "contextType", it);
var CO = {
  onPlaceChanged: "place_changed"
}, OO = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class bj extends Oe {
  constructor() {
    super(...arguments), fe(this, "registeredEvents", []), fe(this, "containerElement", cr()), fe(this, "state", {
      autocomplete: null
    }), fe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Xn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Lt({
        updaterMap: OO,
        eventMap: CO,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    Tt(this.registeredEvents), this.registeredEvents = Lt({
      updaterMap: OO,
      eventMap: CO,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Tt(this.registeredEvents);
  }
  render() {
    return Dr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ct.only(this.props.children)
    });
  }
}
fe(bj, "defaultProps", {
  className: ""
});
fe(bj, "contextType", it);
let RH = { data: "" }, NH = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || RH, FH = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, zH = /\/\*[^]*?\*\/|  +/g, EO = /\n+/g, li = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? li(s, i) : i + "{" + li(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += li(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += li.p ? li.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Do = {}, wj = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + wj(e[n]);
    return t;
  }
  return e;
}, $H = (e, t, n, r, o) => {
  let i = wj(e), s = Do[i] || (Do[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Do[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = FH.exec(u.replace(zH, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(EO, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(EO, " ").trim();
      return d[0];
    })(e);
    Do[s] = li(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Do.g ? Do.g : null;
  return n && (Do.g = Do[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Do[s], t, r, a), s;
}, UH = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : li(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Wd(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return $H(n.unshift ? n.raw ? UH(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, NH(t.target), t.g, t.o, t.k);
}
let Cj, dm, fm;
Wd.bind({ g: 1 });
let Bo = Wd.bind({ k: 1 });
function WH(e, t, n, r) {
  li.p = t, Cj = e, dm = n, fm = r;
}
function Pi(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: dm && dm() }, a), n.o = / *go\d+/.test(l), a.className = Wd.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), fm && u[0] && fm(a), Cj(u, a);
    }
    return o;
  };
}
var VH = (e) => typeof e == "function", HH = (e, t) => VH(e) ? e(t) : e, qH = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), ZH = Bo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, KH = Bo`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, GH = Bo`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, YH = Pi("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${ZH} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${KH} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${GH} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, XH = Bo`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, JH = Pi("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${XH} 1s linear infinite;
`, QH = Bo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, e6 = Bo`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, t6 = Pi("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${QH} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${e6} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, n6 = Pi("div")`
  position: absolute;
`, r6 = Pi("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, o6 = Bo`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, i6 = Pi("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${o6} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, s6 = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? We.createElement(i6, null, t) : t : n === "blank" ? null : We.createElement(r6, null, We.createElement(JH, { ...r }), n !== "loading" && We.createElement(n6, null, n === "error" ? We.createElement(YH, { ...r }) : We.createElement(t6, { ...r })));
}, a6 = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, l6 = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, u6 = "0%{opacity:0;} 100%{opacity:1;}", c6 = "0%{opacity:1;} 100%{opacity:0;}", p6 = Pi("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, d6 = Pi("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, f6 = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = qH() ? [u6, c6] : [a6(n), l6(n)];
  return { animation: t ? `${Bo(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Bo(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
We.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? f6(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = We.createElement(s6, { toast: e }), s = We.createElement(d6, { ...e.ariaProps }, HH(e.message, e));
  return We.createElement(p6, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : We.createElement(We.Fragment, null, i, s));
});
WH(We.createElement);
Wd`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
qe({});
function h6(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const g6 = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
h6(g6.CNPJ).length;
Fs((e, t) => /* @__PURE__ */ Lr.jsx("input", { ref: t, ...e }));
qe({});
var zo = {};
Object.defineProperty(zo, "__esModule", {
  value: !0
});
var m6 = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), oh = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Oj = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: m6 ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Ey = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Su = 1; Su < 20; Su++)
  Ey["f" + Su] = 111 + Su;
function Vd(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return Ej(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return xj(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function v6(e, t) {
  return Vd(e, t);
}
function y6(e, t) {
  return Vd(e, { byKey: !0 }, t);
}
function Ej(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in oh)
    r[oh[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = xy(d), g = oh[f];
      if (d.length > 1 && !g && !Oj[d] && !Ey[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = Lj(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function xj(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Lj(e) {
  e = xy(e);
  var t = Ey[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function xy(e) {
  return e = e.toLowerCase(), e = Oj[e] || e, e;
}
zo.default = Vd;
var ih = zo.isHotkey = Vd;
zo.isCodeHotkey = v6;
zo.isKeyHotkey = y6;
zo.parseHotkey = Ej;
zo.compareHotkey = xj;
zo.toKeyCode = Lj;
zo.toKeyName = xy;
var b6 = typeof rn == "object" && rn && rn.Object === Object && rn, w6 = b6, C6 = w6, O6 = typeof self == "object" && self && self.Object === Object && self, E6 = C6 || O6 || Function("return this")(), x6 = E6, L6 = x6, D6 = L6.Symbol, Dj = D6, xO = Dj;
xO && xO.toStringTag;
var LO = Dj;
LO && LO.toStringTag;
var DO;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(DO || (DO = {}));
var Ly = function(e) {
  return Object.freeze(e);
}, P6 = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Ly(this);
  }
  return e;
}(), k6 = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Ly(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), PO = typeof window < "u" ? window : {};
/msie|trident/i.test(PO.navigator && PO.navigator.userAgent);
var sh = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new P6((n ? t : e) || 0, (n ? e : t) || 0);
};
Ly({
  devicePixelContentBoxSize: sh(),
  borderBoxSize: sh(),
  contentBoxSize: sh(),
  contentRect: new k6(0, 0, 0, 0)
});
function pl(e) {
  "@babel/helpers - typeof";
  return pl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, pl(e);
}
function S6(e, t) {
  if (pl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (pl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function M6(e) {
  var t = S6(e, "string");
  return pl(t) === "symbol" ? t : String(t);
}
function Fa(e, t, n) {
  return t = M6(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var T6 = /* @__PURE__ */ qe(null), ah, lh;
parseInt(xe.version.split(".")[0], 10);
var kO = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), uh = typeof navigator < "u" && /Android/.test(navigator.userAgent), Mu = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), j6 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (ah = navigator.userAgent.match(/Version\/(\d+)/)) !== null && ah !== void 0 && ah[1] && parseInt((lh = navigator.userAgent.match(/Version\/(\d+)/)) === null || lh === void 0 ? void 0 : lh[1], 10) < 17;
var _6 = /* @__PURE__ */ new WeakMap(), A6 = /* @__PURE__ */ new WeakMap(), B6 = /* @__PURE__ */ new WeakMap(), I6 = /* @__PURE__ */ new WeakMap(), R6 = /* @__PURE__ */ new WeakMap(), SO = /* @__PURE__ */ new WeakMap(), N6 = /* @__PURE__ */ new WeakMap(), MO = /* @__PURE__ */ new WeakMap(), Tu = /* @__PURE__ */ new WeakMap(), F6 = /* @__PURE__ */ new WeakMap(), z6 = /* @__PURE__ */ new WeakMap(), $6 = /* @__PURE__ */ new WeakMap(), Pj = globalThis.Node, U6 = globalThis.Text, kj = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, W6 = (e) => op(e) && e.nodeType === 8, go = (e) => op(e) && e.nodeType === 1, op = (e) => {
  var t = kj(e);
  return !!t && e instanceof t.Node;
}, TO = (e) => {
  var t = e && e.anchorNode && kj(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, V6 = (e) => {
  var [t, n] = e;
  if (go(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Sj(t, o, r ? "backward" : "forward"), r = o < n; go(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = q6(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, H6 = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Sj = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (W6(o) || go(o) && o.childNodes.length === 0 || go(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, q6 = (e, t, n) => {
  var [r] = Sj(e, t, n);
  return r;
}, jO = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), Mj = (e, t, n) => {
  var {
    target: r
  } = t;
  if (go(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Et.getWindow(e);
  if (o.contains(r))
    return Et.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : Mj(e, i, n);
}, _O = (e, t) => !!(e.compareDocumentPosition(t) & Pj.DOCUMENT_POSITION_PRECEDING), Z6 = (e, t) => !!(e.compareDocumentPosition(t) & Pj.DOCUMENT_POSITION_FOLLOWING), K6 = 0;
class G6 {
  constructor() {
    Fa(this, "id", void 0), this.id = "".concat(K6++);
  }
}
var Et = {
  androidPendingDiffs: (e) => $6.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = z6.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Et.toDOMNode(e, e), n = Et.findDocumentOrShadowRoot(e);
    Tu.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Et.findDocumentOrShadowRoot(e), r = jO(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && zc.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Et.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Et.toSlateNode(e, t.target), s = Et.findPath(e, i);
    if (To.isElement(i) && Qt.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Qt.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Qt.before(e, u) : Qt.after(e, u);
      if (c) {
        var p = Qt.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = Et.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = Et.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = SO.get(t);
    return n || (n = new G6(), SO.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = A6.get(r);
      if (o == null) {
        if (Qt.isEditor(r))
          return n;
        break;
      }
      var i = _6.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(_r.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Tu.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Et.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Et.toDOMNode(e, e), r = Et.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = jO(r), i = Et.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || zc.select(e, Qt.start(e, [])), Tu.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = B6.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Et.toDOMNode(e, e), i;
    try {
      i = go(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => op(t) && Et.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Qt.hasPath(e, n.path) && Qt.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Et.hasEditableTarget(e, t) || Et.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => op(t) && Et.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!F6.get(e),
  isFocused: (e) => !!Tu.get(e),
  isReadOnly: (e) => !!MO.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (MO.get(e)) return !1;
    var n = Et.hasTarget(e, t) && Et.toSlateNode(e, t);
    return To.isElement(n) && Qt.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = N6.get(e), r = Qt.isEditor(t) ? I6.get(e) : n == null ? void 0 : n.get(Et.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(_r.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Qt.node(e, t.path), r = Et.toDOMNode(e, n), o;
    Qt.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof U6 ? C : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(_r.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = dt.isBackward(t), i = Et.toDOMPoint(e, n), s = dt.isCollapsed(t) ? i : Et.toDOMPoint(e, r), a = Et.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = go(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = go(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = go(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? R6.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : V6(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = Et.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = Et.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var O = v.cloneContents(), P = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          P.forEach((M) => {
            if (uh && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = O.textContent.length, S = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var N = U[L];
          if (Et.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (C) {
        var A = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], z = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, $ = [...A(z), ...A(z == null ? void 0 : z.nextElementSibling)];
          w = (V = $.find((M) => Z6(C, M))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, J = [...A(z == null ? void 0 : z.previousElementSibling), ...A(z)];
          w = (Z = J.findLast((M) => _O(C, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      uh && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Mu && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (uh && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && Et.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var te = Et.toSlateNode(e, Y), {
          path: ee,
          offset: k
        } = Qt.start(e, Et.findPath(e, te));
        return Y.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = Et.toSlateNode(e, u), K = Et.findPath(e, _);
    return {
      path: K,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = TO(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (TO(t)) {
        if (Mu && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let O = function(P) {
              return P.childElementCount > 0 ? O(P.children[0]) : P;
            };
            var f = d.startContainer, g = m.startContainer, h = O(f.children[d.startOffset]), C = O(g.children[m.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        j6 && H6(a) || Mu ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Mu && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = Et.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = _O(a, u) || a === u && c < l, E = p ? w : Et.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return dt.isExpanded(v) && dt.isForward(v) && go(u) && Qt.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = Qt.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, Y6 = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, X6 = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, J6 = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, xn = (e) => {
  var t = Y6[e], n = X6[e], r = J6[e], o = t && ih(t), i = n && ih(n), s = r && ih(r);
  return (a) => !!(o && o(a) || kO && i && i(a) || !kO && s && s(a));
};
xn("bold"), xn("compose"), xn("moveBackward"), xn("moveForward"), xn("deleteBackward"), xn("deleteForward"), xn("deleteLineBackward"), xn("deleteLineForward"), xn("deleteWordBackward"), xn("deleteWordForward"), xn("extendBackward"), xn("extendForward"), xn("extendLineBackward"), xn("extendLineForward"), xn("italic"), xn("moveLineBackward"), xn("moveLineForward"), xn("moveWordBackward"), xn("moveWordForward"), xn("redo"), xn("insertSoftBreak"), xn("splitBlock"), xn("transposeCharacter"), xn("undo");
var Q6 = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => Mj(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, e5 = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class t5 extends Fp {
  constructor() {
    super(...arguments), Fa(this, "context", null), Fa(this, "manager", null), Fa(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, e5);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Q6(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Fa(t5, "contextType", T6);
qe({});
qe({});
qe({});
var qn = {}, Dy = {}, kl = {}, Sl = {}, Tj = "Expected a function", AO = NaN, n5 = "[object Symbol]", r5 = /^\s+|\s+$/g, o5 = /^[-+]0x[0-9a-f]+$/i, i5 = /^0b[01]+$/i, s5 = /^0o[0-7]+$/i, a5 = parseInt, l5 = typeof rn == "object" && rn && rn.Object === Object && rn, u5 = typeof self == "object" && self && self.Object === Object && self, c5 = l5 || u5 || Function("return this")(), p5 = Object.prototype, d5 = p5.toString, f5 = Math.max, h5 = Math.min, ch = function() {
  return c5.Date.now();
};
function g5(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Tj);
  t = BO(t) || 0, ip(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? f5(BO(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(O) {
    var P = r, U = o;
    return r = o = void 0, u = O, s = e.apply(U, P), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var P = O - l, U = O - u, L = t - P;
    return p ? h5(L, i - U) : L;
  }
  function h(O) {
    var P = O - l, U = O - u;
    return l === void 0 || P >= t || P < 0 || p && U >= i;
  }
  function C() {
    var O = ch();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, d && r ? m(O) : (r = o = void 0, s);
  }
  function S() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(ch());
  }
  function v() {
    var O = ch(), P = h(O);
    if (r = arguments, o = this, l = O, P) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = S, v.flush = E, v;
}
function m5(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Tj);
  return ip(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), g5(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function ip(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function v5(e) {
  return !!e && typeof e == "object";
}
function y5(e) {
  return typeof e == "symbol" || v5(e) && d5.call(e) == n5;
}
function BO(e) {
  if (typeof e == "number")
    return e;
  if (y5(e))
    return AO;
  if (ip(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = ip(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(r5, "");
  var n = i5.test(e);
  return n || s5.test(e) ? a5(e.slice(2), n ? 2 : 8) : o5.test(e) ? AO : +e;
}
var b5 = m5, Ml = {};
Object.defineProperty(Ml, "__esModule", {
  value: !0
});
Ml.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), gc.has(t) || gc.set(t, /* @__PURE__ */ new Set());
  var o = gc.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Ml.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), gc.get(t).delete(n.name || t);
};
var gc = /* @__PURE__ */ new Map();
Object.defineProperty(Sl, "__esModule", {
  value: !0
});
var w5 = b5, C5 = E5(w5), O5 = Ml;
function E5(e) {
  return e && e.__esModule ? e : { default: e };
}
var x5 = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, C5.default)(e, t);
}, Bn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = x5(function(r) {
        Bn.scrollHandler(e);
      }, t);
      Bn.scrollSpyContainers.push(e), (0, O5.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Bn.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Bn.scrollSpyContainers[Bn.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Bn.currentPositionX(e), Bn.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Bn.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Bn.scrollSpyContainers[Bn.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Bn.currentPositionX(t), Bn.currentPositionY(t));
  },
  updateStates: function() {
    Bn.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Bn.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Bn.spySetState && Bn.spySetState.length && Bn.spySetState.indexOf(e) > -1 && Bn.spySetState.splice(Bn.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Bn.scrollHandler);
  },
  update: function() {
    return Bn.scrollSpyContainers.forEach(function(e) {
      return Bn.scrollHandler(e);
    });
  }
};
Sl.default = Bn;
var qs = {}, Tl = {};
Object.defineProperty(Tl, "__esModule", {
  value: !0
});
var L5 = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, D5 = function() {
  return window.location.hash.replace(/^#/, "");
}, P5 = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, k5 = function(e) {
  return getComputedStyle(e).position !== "static";
}, ph = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, S5 = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (k5(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = ph(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return ph(t, a).offsetTop - ph(e, a).offsetTop;
};
Tl.default = {
  updateHash: L5,
  getHash: D5,
  filterElementInContainer: P5,
  scrollOffset: S5
};
var Hd = {}, Py = {};
Object.defineProperty(Py, "__esModule", {
  value: !0
});
Py.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var ky = {};
Object.defineProperty(ky, "__esModule", {
  value: !0
});
var M5 = Ml, T5 = ["mousedown", "mousewheel", "touchmove", "keydown"];
ky.default = {
  subscribe: function(e) {
    return typeof document < "u" && T5.forEach(function(t) {
      return (0, M5.addPassiveEventListener)(document, t, e);
    });
  }
};
var jl = {};
Object.defineProperty(jl, "__esModule", {
  value: !0
});
var hm = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      hm.registered[e] = t;
    },
    remove: function(e) {
      hm.registered[e] = null;
    }
  }
};
jl.default = hm;
Object.defineProperty(Hd, "__esModule", {
  value: !0
});
var j5 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _5 = Tl;
qd(_5);
var A5 = Py, IO = qd(A5), B5 = ky, I5 = qd(B5), R5 = jl, co = qd(R5);
function qd(e) {
  return e && e.__esModule ? e : { default: e };
}
var jj = function(e) {
  return IO.default[e.smooth] || IO.default.defaultEasing;
}, N5 = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, F5 = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, gm = function() {
  return F5() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), _j = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Aj = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Bj = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, z5 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, $5 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, U5 = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    co.default.registered.end && co.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    gm.call(window, i);
    return;
  }
  co.default.registered.end && co.default.registered.end(o.to, o.target, o.currentPosition);
}, Sy = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, _l = function(e, t, n, r) {
  t.data = t.data || _j(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (I5.default.subscribe(o), Sy(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Aj(t) : Bj(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    co.default.registered.end && co.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = N5(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = jj(t), s = U5.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      co.default.registered.begin && co.default.registered.begin(t.data.to, t.data.target), gm.call(window, s);
    }, t.delay);
    return;
  }
  co.default.registered.begin && co.default.registered.begin(t.data.to, t.data.target), gm.call(window, s);
}, Zd = function(e) {
  return e = j5({}, e), e.data = e.data || _j(), e.absolute = !0, e;
}, W5 = function(e) {
  _l(0, Zd(e));
}, V5 = function(e, t) {
  _l(e, Zd(t));
}, H5 = function(e) {
  e = Zd(e), Sy(e), _l(e.horizontal ? z5(e) : $5(e), e);
}, q5 = function(e, t) {
  t = Zd(t), Sy(t);
  var n = t.horizontal ? Aj(t) : Bj(t);
  _l(e + n, t);
};
Hd.default = {
  animateTopScroll: _l,
  getAnimationType: jj,
  scrollToTop: W5,
  scrollToBottom: H5,
  scrollTo: V5,
  scrollMore: q5
};
Object.defineProperty(qs, "__esModule", {
  value: !0
});
var Z5 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, K5 = Tl, G5 = My(K5), Y5 = Hd, X5 = My(Y5), J5 = jl, ju = My(J5);
function My(e) {
  return e && e.__esModule ? e : { default: e };
}
var _u = {}, RO = void 0;
qs.default = {
  unmount: function() {
    _u = {};
  },
  register: function(e, t) {
    _u[e] = t;
  },
  unregister: function(e) {
    delete _u[e];
  },
  get: function(e) {
    return _u[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return RO = e;
  },
  getActiveLink: function() {
    return RO;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Z5({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = G5.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      ju.default.registered.begin && ju.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, ju.default.registered.end && ju.default.registered.end(e, n);
      return;
    }
    X5.default.animateTopScroll(a, t, e, n);
  }
};
var mm = { exports: {} }, dh = { exports: {} }, Ut = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NO;
function Q5() {
  if (NO) return Ut;
  NO = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(v) {
    if (typeof v == "object" && v !== null) {
      var O = v.$$typeof;
      switch (O) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return v;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(v) {
    return S(v) === u;
  }
  return Ut.AsyncMode = l, Ut.ConcurrentMode = u, Ut.ContextConsumer = a, Ut.ContextProvider = s, Ut.Element = t, Ut.ForwardRef = c, Ut.Fragment = r, Ut.Lazy = f, Ut.Memo = m, Ut.Portal = n, Ut.Profiler = i, Ut.StrictMode = o, Ut.Suspense = p, Ut.isAsyncMode = function(v) {
    return E(v) || S(v) === l;
  }, Ut.isConcurrentMode = E, Ut.isContextConsumer = function(v) {
    return S(v) === a;
  }, Ut.isContextProvider = function(v) {
    return S(v) === s;
  }, Ut.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Ut.isForwardRef = function(v) {
    return S(v) === c;
  }, Ut.isFragment = function(v) {
    return S(v) === r;
  }, Ut.isLazy = function(v) {
    return S(v) === f;
  }, Ut.isMemo = function(v) {
    return S(v) === m;
  }, Ut.isPortal = function(v) {
    return S(v) === n;
  }, Ut.isProfiler = function(v) {
    return S(v) === i;
  }, Ut.isStrictMode = function(v) {
    return S(v) === o;
  }, Ut.isSuspense = function(v) {
    return S(v) === p;
  }, Ut.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === m || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === g);
  }, Ut.typeOf = S, Ut;
}
var Gt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FO;
function e4() {
  return FO || (FO = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(W) {
      return typeof W == "string" || typeof W == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      W === r || W === u || W === i || W === o || W === p || W === d || typeof W == "object" && W !== null && (W.$$typeof === f || W.$$typeof === m || W.$$typeof === s || W.$$typeof === a || W.$$typeof === c || W.$$typeof === h || W.$$typeof === C || W.$$typeof === w || W.$$typeof === g);
    }
    function E(W) {
      if (typeof W == "object" && W !== null) {
        var ue = W.$$typeof;
        switch (ue) {
          case t:
            var ye = W.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var v = l, O = u, P = a, U = s, L = t, N = c, A = r, z = f, V = m, $ = n, Z = i, J = o, Y = p, te = !1;
    function ee(W) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(W) || E(W) === l;
    }
    function k(W) {
      return E(W) === u;
    }
    function _(W) {
      return E(W) === a;
    }
    function K(W) {
      return E(W) === s;
    }
    function M(W) {
      return typeof W == "object" && W !== null && W.$$typeof === t;
    }
    function G(W) {
      return E(W) === c;
    }
    function x(W) {
      return E(W) === r;
    }
    function T(W) {
      return E(W) === f;
    }
    function F(W) {
      return E(W) === m;
    }
    function j(W) {
      return E(W) === n;
    }
    function H(W) {
      return E(W) === i;
    }
    function B(W) {
      return E(W) === o;
    }
    function Q(W) {
      return E(W) === p;
    }
    Gt.AsyncMode = v, Gt.ConcurrentMode = O, Gt.ContextConsumer = P, Gt.ContextProvider = U, Gt.Element = L, Gt.ForwardRef = N, Gt.Fragment = A, Gt.Lazy = z, Gt.Memo = V, Gt.Portal = $, Gt.Profiler = Z, Gt.StrictMode = J, Gt.Suspense = Y, Gt.isAsyncMode = ee, Gt.isConcurrentMode = k, Gt.isContextConsumer = _, Gt.isContextProvider = K, Gt.isElement = M, Gt.isForwardRef = G, Gt.isFragment = x, Gt.isLazy = T, Gt.isMemo = F, Gt.isPortal = j, Gt.isProfiler = H, Gt.isStrictMode = B, Gt.isSuspense = Q, Gt.isValidElementType = S, Gt.typeOf = E;
  }()), Gt;
}
var zO;
function Ij() {
  return zO || (zO = 1, process.env.NODE_ENV === "production" ? dh.exports = Q5() : dh.exports = e4()), dh.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var fh, $O;
function t4() {
  if ($O) return fh;
  $O = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return fh = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, fh;
}
var hh, UO;
function Ty() {
  if (UO) return hh;
  UO = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return hh = e, hh;
}
var WO, VO;
function Rj() {
  return VO || (VO = 1, WO = Function.call.bind(Object.prototype.hasOwnProperty)), WO;
}
var gh, HO;
function n4() {
  if (HO) return gh;
  HO = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Ty(), n = {}, r = Rj();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, gh = o, gh;
}
var mh, qO;
function r4() {
  if (qO) return mh;
  qO = 1;
  var e = Ij(), t = t4(), n = Ty(), r = Rj(), o = n4(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return mh = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", m = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: S,
      element: E(),
      elementType: v(),
      instanceOf: O,
      node: N(),
      objectOf: U,
      oneOf: P,
      oneOfType: L,
      shape: z,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function g(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, K = 0;
      function M(x, T, F, j, H, B, Q) {
        if (j = j || d, B = B || F, Q !== n) {
          if (l) {
            var W = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw W.name = "Invariant Violation", W;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            K < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, K++);
          }
        }
        return T[F] == null ? x ? T[F] === null ? new g("The " + H + " `" + B + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new g("The " + H + " `" + B + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : k(T, F, j, H, B);
      }
      var G = M.bind(null, !1);
      return G.isRequired = M.bind(null, !0), G;
    }
    function C(k) {
      function _(K, M, G, x, T, F) {
        var j = K[M], H = J(j);
        if (H !== k) {
          var B = Y(j);
          return new g(
            "Invalid " + x + " `" + T + "` of type " + ("`" + B + "` supplied to `" + G + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(_);
    }
    function w() {
      return h(s);
    }
    function S(k) {
      function _(K, M, G, x, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var F = K[M];
        if (!Array.isArray(F)) {
          var j = J(F);
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var H = 0; H < F.length; H++) {
          var B = k(F, H, G, x, T + "[" + H + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return h(_);
    }
    function E() {
      function k(_, K, M, G, x) {
        var T = _[K];
        if (!a(T)) {
          var F = J(T);
          return new g("Invalid " + G + " `" + x + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function v() {
      function k(_, K, M, G, x) {
        var T = _[K];
        if (!e.isValidElementType(T)) {
          var F = J(T);
          return new g("Invalid " + G + " `" + x + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function O(k) {
      function _(K, M, G, x, T) {
        if (!(K[M] instanceof k)) {
          var F = k.name || d, j = ee(K[M]);
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return h(_);
    }
    function P(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function _(K, M, G, x, T) {
        for (var F = K[M], j = 0; j < k.length; j++)
          if (f(F, k[j]))
            return null;
        var H = JSON.stringify(k, function(B, Q) {
          var W = Y(Q);
          return W === "symbol" ? String(Q) : Q;
        });
        return new g("Invalid " + x + " `" + T + "` of value `" + String(F) + "` " + ("supplied to `" + G + "`, expected one of " + H + "."));
      }
      return h(_);
    }
    function U(k) {
      function _(K, M, G, x, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var H in F)
          if (r(F, H)) {
            var B = k(F, H, G, x, T + "." + H, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return h(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var _ = 0; _ < k.length; _++) {
        var K = k[_];
        if (typeof K != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(K) + " at index " + _ + "."
          ), s;
      }
      function M(G, x, T, F, j) {
        for (var H = [], B = 0; B < k.length; B++) {
          var Q = k[B], W = Q(G, x, T, F, j, n);
          if (W == null)
            return null;
          W.data && r(W.data, "expectedType") && H.push(W.data.expectedType);
        }
        var ue = H.length > 0 ? ", expected one of type [" + H.join(", ") + "]" : "";
        return new g("Invalid " + F + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function N() {
      function k(_, K, M, G, x) {
        return $(_[K]) ? null : new g("Invalid " + G + " `" + x + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function A(k, _, K, M, G) {
      return new g(
        (k || "React class") + ": " + _ + " type `" + K + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function z(k) {
      function _(K, M, G, x, T) {
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var H in k) {
          var B = k[H];
          if (typeof B != "function")
            return A(G, x, T, H, Y(B));
          var Q = B(F, H, G, x, T + "." + H, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(_);
    }
    function V(k) {
      function _(K, M, G, x, T) {
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var H = t({}, K[M], k);
        for (var B in H) {
          var Q = k[B];
          if (r(k, B) && typeof Q != "function")
            return A(G, x, T, B, Y(Q));
          if (!Q)
            return new g(
              "Invalid " + x + " `" + T + "` key `" + B + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(K[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var W = Q(F, B, G, x, T + "." + B, n);
          if (W)
            return W;
        }
        return null;
      }
      return h(_);
    }
    function $(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every($);
          if (k === null || a(k))
            return !0;
          var _ = p(k);
          if (_) {
            var K = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = K.next()).done; )
                if (!$(M.value))
                  return !1;
            } else
              for (; !(M = K.next()).done; ) {
                var G = M.value;
                if (G && !$(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function J(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : Z(_, k) ? "symbol" : _;
    }
    function Y(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = J(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function te(k) {
      var _ = Y(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, mh;
}
var vh, ZO;
function o4() {
  if (ZO) return vh;
  ZO = 1;
  var e = Ty();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, vh = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, vh;
}
if (process.env.NODE_ENV !== "production") {
  var i4 = Ij(), s4 = !0;
  mm.exports = r4()(i4.isElement, s4);
} else
  mm.exports = o4()();
var Kd = mm.exports, Gd = {};
Object.defineProperty(Gd, "__esModule", {
  value: !0
});
var a4 = Tl, yh = l4(a4);
function l4(e) {
  return e && e.__esModule ? e : { default: e };
}
var u4 = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return yh.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && yh.default.getHash() !== e && yh.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Gd.default = u4;
Object.defineProperty(kl, "__esModule", {
  value: !0
});
var Au = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, c4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), p4 = xe, KO = Al(p4), d4 = Sl, Bu = Al(d4), f4 = qs, h4 = Al(f4), g4 = Kd, Ln = Al(g4), m4 = Gd, Ho = Al(m4);
function Al(e) {
  return e && e.__esModule ? e : { default: e };
}
function v4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function y4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function b4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var GO = {
  to: Ln.default.string.isRequired,
  containerId: Ln.default.string,
  container: Ln.default.object,
  activeClass: Ln.default.string,
  activeStyle: Ln.default.object,
  spy: Ln.default.bool,
  horizontal: Ln.default.bool,
  smooth: Ln.default.oneOfType([Ln.default.bool, Ln.default.string]),
  offset: Ln.default.number,
  delay: Ln.default.number,
  isDynamic: Ln.default.bool,
  onClick: Ln.default.func,
  duration: Ln.default.oneOfType([Ln.default.number, Ln.default.func]),
  absolute: Ln.default.bool,
  onSetActive: Ln.default.func,
  onSetInactive: Ln.default.func,
  ignoreCancelEvents: Ln.default.bool,
  hashSpy: Ln.default.bool,
  saveHashHistory: Ln.default.bool,
  spyThrottle: Ln.default.number
};
kl.default = function(e, t) {
  var n = t || h4.default, r = function(i) {
    b4(s, i);
    function s(a) {
      v4(this, s);
      var l = y4(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return c4(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          Bu.default.isMounted(a) || Bu.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Ho.default.isMounted() || Ho.default.mount(n), Ho.default.mapContainer(this.props.to, a)), Bu.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Bu.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Au({}, this.props.style, this.props.activeStyle) : l = Au({}, this.props.style);
        var u = Au({}, this.props);
        for (var c in GO)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, KO.default.createElement(e, u);
      }
    }]), s;
  }(KO.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Au({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Ho.default.isMounted() && !Ho.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var C = l.getBoundingClientRect();
            h = C.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var S = s - i.props.offset;
          d = S >= Math.floor(f) && S < Math.floor(g), m = S < Math.floor(f) || S >= Math.floor(g);
        } else {
          var E = 0, v = 0, O = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            O = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            E = U.top - O + a, v = E + U.height;
          }
          var L = a - i.props.offset;
          d = L >= Math.floor(E) && L < Math.floor(v), m = L < Math.floor(E) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (m) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Ho.default.getHash() === c) {
            var A = i.props.saveHashHistory, z = A === void 0 ? !1 : A;
            Ho.default.changeHash("", z);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, $ = V === void 0 ? !1 : V;
          i.props.hashSpy && Ho.default.changeHash(c, $), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = GO, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Dy, "__esModule", {
  value: !0
});
var w4 = xe, YO = Nj(w4), C4 = kl, O4 = Nj(C4);
function Nj(e) {
  return e && e.__esModule ? e : { default: e };
}
function E4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function XO(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function x4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var L4 = function(e) {
  x4(t, e);
  function t() {
    var n, r, o, i;
    E4(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = XO(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return YO.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), XO(o, i);
  }
  return t;
}(YO.default.Component);
Dy.default = (0, O4.default)(L4);
var jy = {};
Object.defineProperty(jy, "__esModule", {
  value: !0
});
var D4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), P4 = xe, JO = Fj(P4), k4 = kl, S4 = Fj(k4);
function Fj(e) {
  return e && e.__esModule ? e : { default: e };
}
function M4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function T4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function j4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _4 = function(e) {
  j4(t, e);
  function t() {
    return M4(this, t), T4(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return D4(t, [{
    key: "render",
    value: function() {
      return JO.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(JO.default.Component);
jy.default = (0, S4.default)(_4);
var _y = {}, Yd = {};
Object.defineProperty(Yd, "__esModule", {
  value: !0
});
var A4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, B4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), I4 = xe, QO = Xd(I4), R4 = wl;
Xd(R4);
var N4 = qs, eE = Xd(N4), F4 = Kd, tE = Xd(F4);
function Xd(e) {
  return e && e.__esModule ? e : { default: e };
}
function z4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function $4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function U4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Yd.default = function(e) {
  var t = function(n) {
    U4(r, n);
    function r(o) {
      z4(this, r);
      var i = $4(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return B4(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        eE.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        eE.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return QO.default.createElement(e, A4({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(QO.default.Component);
  return t.propTypes = {
    name: tE.default.string,
    id: tE.default.string
  }, t;
};
Object.defineProperty(_y, "__esModule", {
  value: !0
});
var nE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, W4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), V4 = xe, rE = Ay(V4), H4 = Yd, q4 = Ay(H4), Z4 = Kd, oE = Ay(Z4);
function Ay(e) {
  return e && e.__esModule ? e : { default: e };
}
function K4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function G4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Y4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var zj = function(e) {
  Y4(t, e);
  function t() {
    return K4(this, t), G4(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return W4(t, [{
    key: "render",
    value: function() {
      var n = this, r = nE({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, rE.default.createElement(
        "div",
        nE({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(rE.default.Component);
zj.propTypes = {
  name: oE.default.string,
  id: oE.default.string
};
_y.default = (0, q4.default)(zj);
var bh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, iE = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function sE(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aE(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function lE(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Iu = xe, zi = Sl, wh = qs, Fn = Kd, qo = Gd, uE = {
  to: Fn.string.isRequired,
  containerId: Fn.string,
  container: Fn.object,
  activeClass: Fn.string,
  spy: Fn.bool,
  smooth: Fn.oneOfType([Fn.bool, Fn.string]),
  offset: Fn.number,
  delay: Fn.number,
  isDynamic: Fn.bool,
  onClick: Fn.func,
  duration: Fn.oneOfType([Fn.number, Fn.func]),
  absolute: Fn.bool,
  onSetActive: Fn.func,
  onSetInactive: Fn.func,
  ignoreCancelEvents: Fn.bool,
  hashSpy: Fn.bool,
  spyThrottle: Fn.number
}, X4 = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || wh, r = function(i) {
      lE(s, i);
      function s(a) {
        sE(this, s);
        var l = aE(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return iE(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            zi.isMounted(a) || zi.mount(a, this.props.spyThrottle), this.props.hashSpy && (qo.isMounted() || qo.mount(n), qo.mapContainer(this.props.to, a)), this.props.spy && zi.addStateHandler(this.stateHandler), zi.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          zi.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = bh({}, this.props);
          for (var u in uE)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Iu.createElement(e, l);
        }
      }]), s;
    }(Iu.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, bh({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(qo.isMounted() && !qo.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            d = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + s, p = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(p), C = g < Math.floor(c) || g >= Math.floor(p), w = n.getActiveLink();
          if (C)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && qo.getHash() === l && qo.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), zi.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && qo.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), zi.updateStates();
        }
      };
    };
    return r.propTypes = uE, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      lE(r, n);
      function r(o) {
        sE(this, r);
        var i = aE(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return iE(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          wh.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          wh.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Iu.createElement(e, bh({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Iu.Component);
    return t.propTypes = {
      name: Fn.string,
      id: Fn.string
    }, t;
  }
}, J4 = X4;
Object.defineProperty(qn, "__esModule", {
  value: !0
});
qn.Helpers = qn.ScrollElement = qn.ScrollLink = qn.animateScroll = qn.scrollSpy = qn.Events = qn.scroller = qn.Element = qn.Button = qn.Link = void 0;
var Q4 = Dy, $j = bo(Q4), e7 = jy, Uj = bo(e7), t7 = _y, Wj = bo(t7), n7 = qs, Vj = bo(n7), r7 = jl, Hj = bo(r7), o7 = Sl, qj = bo(o7), i7 = Hd, Zj = bo(i7), s7 = kl, Kj = bo(s7), a7 = Yd, Gj = bo(a7), l7 = J4, Yj = bo(l7);
function bo(e) {
  return e && e.__esModule ? e : { default: e };
}
qn.Link = $j.default;
qn.Button = Uj.default;
qn.Element = Wj.default;
qn.scroller = Vj.default;
qn.Events = Hj.default;
qn.scrollSpy = qj.default;
qn.animateScroll = Zj.default;
qn.ScrollLink = Kj.default;
qn.ScrollElement = Gj.default;
qn.Helpers = Yj.default;
qn.default = { Link: $j.default, Button: Uj.default, Element: Wj.default, scroller: Vj.default, Events: Hj.default, scrollSpy: qj.default, animateScroll: Zj.default, ScrollLink: Kj.default, ScrollElement: Gj.default, Helpers: Yj.default };
qe({});
qe({});
qe({});
function dl(e) {
  "@babel/helpers - typeof";
  return dl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, dl(e);
}
function u7(e, t) {
  if (dl(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (dl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function c7(e) {
  var t = u7(e, "string");
  return dl(t) == "symbol" ? t : t + "";
}
function he(e, t, n) {
  return (t = c7(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Xj(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ch, cE;
function p7() {
  if (cE) return Ch;
  cE = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, s, a, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Ch = t, Ch;
}
var d7 = p7(), Jn = /* @__PURE__ */ Xj(d7), st = qe(null);
function f7() {
  Jn(!!De, "useGoogleMap is React hook and requires React version 16.8+");
  var e = De(st);
  return Jn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function h7(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function g7(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function m7(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return g7(e, i), o;
}
function v7(e, t, n) {
  var r = h7(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function y7(e) {
  google.maps.event.removeListener(e);
}
function jt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(y7);
}
function Dt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = v7(o, i, n);
  return m7(t, r, o, i), s;
}
function b7(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: E
  } = e, [v, O] = D(null), P = Ye(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null), [B, Q] = D(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && p && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), y(() => {
    v && g && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(v, "mousedown", g)));
  }, [g]), y(() => {
    v && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), y(() => {
    v && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(v, "mouseout", m)));
  }, [m]), y(() => {
    v && f && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (B !== null && google.maps.event.removeListener(B), Q(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var W = P.current === null ? null : new google.maps.Map(P.current, n);
    return O(W), W !== null && S && S(W), () => {
      W !== null && E && E(W);
    };
  }, []), Lr.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Lr.jsx(st.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
ke(b7);
function pE(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Jj(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        pE(i, r, o, s, a, "next", l);
      }
      function a(l) {
        pE(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function Qj(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Jn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var rs = typeof document < "u";
function e_(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return rs ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function dE(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function t_() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return dE(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return dE(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var ca = !1;
function n_() {
  return Lr.jsx("div", {
    children: "Loading..."
  });
}
var vm = {
  id: "script-loader",
  version: "weekly"
};
class w7 extends Oe {
  constructor() {
    super(...arguments), he(this, "check", cr()), he(this, "state", {
      loaded: !1
    }), he(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), he(this, "isCleaningUp", /* @__PURE__ */ Jj(function* () {
      function t(n) {
        if (!ca)
          n();
        else if (rs)
          var r = window.setInterval(function() {
            ca || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), he(this, "cleanup", () => {
      ca = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), he(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && t_(), Jn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Qj(this.props)
      };
      e_(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (rs) {
      if (window.google && window.google.maps && !ca) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), rs && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (rs) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, ca = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Lr.jsxs(Lr.Fragment, {
      children: [Lr.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Lr.jsx(n_, {})]
    });
  }
}
he(w7, "defaultProps", vm);
function C7(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function By(e, t) {
  if (e == null) return {};
  var n, r, o = C7(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var fE;
function O7(e) {
  var {
    id: t = vm.id,
    version: n = vm.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Ye(!1), [f, g] = D(!1), [h, C] = D(void 0);
  y(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), y(function() {
    rs && u && t_();
  }, [u]), y(function() {
    f && Jn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Qj({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  y(function() {
    if (!rs)
      return;
    function E() {
      m.current && (g(!0), fE = w);
    }
    if (window.google && window.google.maps && fE === w) {
      E();
      return;
    }
    e_({
      id: t,
      url: w,
      nonce: r
    }).then(E).catch(function(v) {
      m.current && C(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var S = Ye();
  return y(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var E7 = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], x7 = Lr.jsx(n_, {});
function L7(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = By(e, E7), {
    isLoaded: a,
    loadError: l
  } = O7(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || x7;
}
ke(L7);
var hE;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(hE || (hE = {}));
function gE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mE = {}, vE = {
  options(e, t) {
    e.setOptions(t);
  }
};
function D7(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = De(st), [i, s] = D(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(sp(sp({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(D7);
class P7 extends Oe {
  constructor() {
    super(...arguments), he(this, "state", {
      trafficLayer: null
    }), he(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(sp(sp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dt({
      updaterMap: vE,
      eventMap: mE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: vE,
      eventMap: mE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), jt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(P7, "contextType", st);
function k7(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = De(st), [o, i] = D(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
ke(k7);
class S7 extends Oe {
  constructor() {
    super(...arguments), he(this, "state", {
      bicyclingLayer: null
    }), he(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(S7, "contextType", st);
function M7(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = De(st), [o, i] = D(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(M7);
class T7 extends Oe {
  constructor() {
    super(...arguments), he(this, "state", {
      transitLayer: null
    }), he(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(T7, "contextType", st);
function yE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ap(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bE = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, wE = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function j7(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = De(st), [d, m] = D(null), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null);
  return y(() => {
    d !== null && d.setMap(p);
  }, [p]), y(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), y(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), y(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), y(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), y(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), y(() => {
    d && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), y(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), y(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), y(() => {
    Jn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(ap(ap({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && g(google.maps.event.addListener(N, "circlecomplete", r)), o && C(google.maps.event.addListener(N, "markercomplete", o)), i && S(google.maps.event.addListener(N, "overlaycomplete", i)), s && v(google.maps.event.addListener(N, "polygoncomplete", s)), a && P(google.maps.event.addListener(N, "polylinecomplete", a)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), m(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(j7);
class _7 extends Oe {
  constructor(t) {
    super(t), he(this, "registeredEvents", []), he(this, "state", {
      drawingManager: null
    }), he(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Jn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ap(ap({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dt({
      updaterMap: wE,
      eventMap: bE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: wE,
      eventMap: bE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), jt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
he(_7, "contextType", st);
function CE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ks(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OE = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, EE = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, lp = {};
function A7(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: S,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: O,
    onMouseOver: P,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: A,
    onCursorChanged: z,
    onAnimationChanged: V,
    onDraggableChanged: $,
    onFlatChanged: Z,
    onIconChanged: J,
    onPositionChanged: Y,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: K,
    onUnmount: M
  } = e, G = De(st), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null), [Q, W] = D(null), [ue, ye] = D(null), [oe, _e] = D(null), [Fe, ze] = D(null), [Re, Ge] = D(null), [Ze, Me] = D(null), [Ke, rt] = D(null), [Se, je] = D(null), [Ne, Ve] = D(null), [Ue, ot] = D(null), [Te, Zt] = D(null), [lt, ht] = D(null), [kt, sn] = D(null), [St, an] = D(null), [tt, Nt] = D(null), [ut, ln] = D(null), [Mt, Mn] = D(null), [un, Tn] = D(null), [cn, jn] = D(null);
  y(() => {
    x !== null && x.setMap(G);
  }, [G]), y(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), y(() => {
    typeof s < "u" && x !== null && x.setDraggable(s);
  }, [x, s]), y(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), y(() => {
    typeof a < "u" && x !== null && x.setVisible(a);
  }, [x, a]), y(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), y(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), y(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), y(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), y(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), y(() => {
    x && m !== void 0 && x.setOpacity(m);
  }, [x, m]), y(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), y(() => {
    x && g !== void 0 && x.setTitle(g);
  }, [x, g]), y(() => {
    x && h !== void 0 && x.setZIndex(h);
  }, [x, h]), y(() => {
    x && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), y(() => {
    x && E && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(x, "dragend", E)));
  }, [E]), y(() => {
    x && v && (Q !== null && google.maps.event.removeListener(Q), W(google.maps.event.addListener(x, "dragstart", v)));
  }, [v]), y(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), y(() => {
    x && O && (oe !== null && google.maps.event.removeListener(oe), _e(google.maps.event.addListener(x, "mouseout", O)));
  }, [O]), y(() => {
    x && P && (Fe !== null && google.maps.event.removeListener(Fe), ze(google.maps.event.addListener(x, "mouseover", P)));
  }, [P]), y(() => {
    x && U && (Re !== null && google.maps.event.removeListener(Re), Ge(google.maps.event.addListener(x, "mouseup", U)));
  }, [U]), y(() => {
    x && N && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), y(() => {
    x && C && (Ke !== null && google.maps.event.removeListener(Ke), rt(google.maps.event.addListener(x, "click", C)));
  }, [C]), y(() => {
    x && S && (Se !== null && google.maps.event.removeListener(Se), je(google.maps.event.addListener(x, "drag", S)));
  }, [S]), y(() => {
    x && A && (Ne !== null && google.maps.event.removeListener(Ne), Ve(google.maps.event.addListener(x, "clickable_changed", A)));
  }, [A]), y(() => {
    x && z && (Ue !== null && google.maps.event.removeListener(Ue), ot(google.maps.event.addListener(x, "cursor_changed", z)));
  }, [z]), y(() => {
    x && V && (Te !== null && google.maps.event.removeListener(Te), Zt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), y(() => {
    x && $ && (lt !== null && google.maps.event.removeListener(lt), ht(google.maps.event.addListener(x, "draggable_changed", $)));
  }, [$]), y(() => {
    x && Z && (kt !== null && google.maps.event.removeListener(kt), sn(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), y(() => {
    x && J && (St !== null && google.maps.event.removeListener(St), an(google.maps.event.addListener(x, "icon_changed", J)));
  }, [J]), y(() => {
    x && Y && (tt !== null && google.maps.event.removeListener(tt), Nt(google.maps.event.addListener(x, "position_changed", Y)));
  }, [Y]), y(() => {
    x && te && (ut !== null && google.maps.event.removeListener(ut), ln(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), y(() => {
    x && ee && (Mt !== null && google.maps.event.removeListener(Mt), Mn(google.maps.event.addListener(x, "title_changed", ee)));
  }, [ee]), y(() => {
    x && k && (un !== null && google.maps.event.removeListener(un), Tn(google.maps.event.addListener(x, "visible_changed", k)));
  }, [k]), y(() => {
    x && _ && (cn !== null && google.maps.event.removeListener(cn), jn(google.maps.event.addListener(x, "zindex_changed", _)));
  }, [_]), y(() => {
    var Ft = ks(ks(ks({}, n || lp), r ? lp : {
      map: G
    }), {}, {
      position: t
    }), ie = new google.maps.Marker(Ft);
    return r ? r.addMarker(ie, !!o) : ie.setMap(G), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof m < "u" && ie.setOpacity(m), f && ie.setShape(f), typeof g == "string" && ie.setTitle(g), typeof h == "number" && ie.setZIndex(h), w && j(google.maps.event.addListener(ie, "dblclick", w)), E && B(google.maps.event.addListener(ie, "dragend", E)), v && W(google.maps.event.addListener(ie, "dragstart", v)), L && ye(google.maps.event.addListener(ie, "mousedown", L)), O && _e(google.maps.event.addListener(ie, "mouseout", O)), P && ze(google.maps.event.addListener(ie, "mouseover", P)), U && Ge(google.maps.event.addListener(ie, "mouseup", U)), N && Me(google.maps.event.addListener(ie, "rightclick", N)), C && rt(google.maps.event.addListener(ie, "click", C)), S && je(google.maps.event.addListener(ie, "drag", S)), A && Ve(google.maps.event.addListener(ie, "clickable_changed", A)), z && ot(google.maps.event.addListener(ie, "cursor_changed", z)), V && Zt(google.maps.event.addListener(ie, "animation_changed", V)), $ && ht(google.maps.event.addListener(ie, "draggable_changed", $)), Z && sn(google.maps.event.addListener(ie, "flat_changed", Z)), J && an(google.maps.event.addListener(ie, "icon_changed", J)), Y && Nt(google.maps.event.addListener(ie, "position_changed", Y)), te && ln(google.maps.event.addListener(ie, "shape_changed", te)), ee && Mn(google.maps.event.addListener(ie, "title_changed", ee)), k && Tn(google.maps.event.addListener(ie, "visible_changed", k)), _ && jn(google.maps.event.addListener(ie, "zindex_changed", _)), T(ie), K && K(ie), () => {
      F !== null && google.maps.event.removeListener(F), H !== null && google.maps.event.removeListener(H), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), Ze !== null && google.maps.event.removeListener(Ze), Ke !== null && google.maps.event.removeListener(Ke), Ne !== null && google.maps.event.removeListener(Ne), Ue !== null && google.maps.event.removeListener(Ue), Te !== null && google.maps.event.removeListener(Te), lt !== null && google.maps.event.removeListener(lt), kt !== null && google.maps.event.removeListener(kt), St !== null && google.maps.event.removeListener(St), tt !== null && google.maps.event.removeListener(tt), Mt !== null && google.maps.event.removeListener(Mt), un !== null && google.maps.event.removeListener(un), cn !== null && google.maps.event.removeListener(cn), M && M(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var Yn = Gn(() => i ? Ct.map(i, (Ft) => {
    if (!mi(Ft))
      return Ft;
    var ie = Ft;
    return vi(ie, {
      anchor: x
    });
  }) : null, [i, x]);
  return Lr.jsx(Lr.Fragment, {
    children: Yn
  }) || null;
}
ke(A7);
class B7 extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Jj(function* () {
      var n = ks(ks(ks({}, t.props.options || lp), t.props.clusterer ? lp : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Dt({
        updaterMap: EE,
        eventMap: OE,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: EE,
      eventMap: OE,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), jt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ct.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
he(B7, "contextType", st);
var I7 = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), R7 = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new I7(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function N7(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var F7 = 2e3, z7 = 500, $7 = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", U7 = "png", W7 = [53, 56, 66, 78, 90], V7 = "cluster", r_ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || $7, this.imageExtension = r.imageExtension || U7, this.imageSizes = r.imageSizes || W7, this.calculator = r.calculator || N7, this.batchSize = r.batchSize || F7, this.batchSizeIE = r.batchSizeIE || z7, this.clusterClass = r.clusterClass || V7, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new R7(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function xE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function H7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Gr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Bt = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, q7 = {};
function Z7(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: O,
    onLoad: P,
    onUnmount: U
  } = e, [L, N] = D(null), A = De(st), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null);
  return y(() => {
    L && O && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, Gr.onMouseOut, O)));
  }, [O]), y(() => {
    L && v && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, Gr.onMouseOver, v)));
  }, [v]), y(() => {
    L && w && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(L, Gr.onClick, w)));
  }, [w]), y(() => {
    L && S && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(L, Gr.onClusteringBegin, S)));
  }, [S]), y(() => {
    L && E && (J !== null && google.maps.event.removeListener(J), Z(google.maps.event.addListener(L, Gr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && L !== null && Bt.averageCenter(L, r);
  }, [L, r]), y(() => {
    typeof o < "u" && L !== null && Bt.batchSizeIE(L, o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && Bt.calculator(L, i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && Bt.clusterClass(L, s);
  }, [L, s]), y(() => {
    typeof a < "u" && L !== null && Bt.enableRetinaIcons(L, a);
  }, [L, a]), y(() => {
    typeof l < "u" && L !== null && Bt.gridSize(L, l);
  }, [L, l]), y(() => {
    typeof u < "u" && L !== null && Bt.ignoreHidden(L, u);
  }, [L, u]), y(() => {
    typeof c < "u" && L !== null && Bt.imageExtension(L, c);
  }, [L, c]), y(() => {
    typeof p < "u" && L !== null && Bt.imagePath(L, p);
  }, [L, p]), y(() => {
    typeof d < "u" && L !== null && Bt.imageSizes(L, d);
  }, [L, d]), y(() => {
    typeof m < "u" && L !== null && Bt.maxZoom(L, m);
  }, [L, m]), y(() => {
    typeof f < "u" && L !== null && Bt.minimumClusterSize(L, f);
  }, [L, f]), y(() => {
    typeof g < "u" && L !== null && Bt.styles(L, g);
  }, [L, g]), y(() => {
    typeof h < "u" && L !== null && Bt.title(L, h);
  }, [L, h]), y(() => {
    typeof C < "u" && L !== null && Bt.zoomOnClick(L, C);
  }, [L, C]), y(() => {
    if (A) {
      var K = H7({}, n || q7), M = new r_(A, [], K);
      return r && Bt.averageCenter(M, r), o && Bt.batchSizeIE(M, o), i && Bt.calculator(M, i), s && Bt.clusterClass(M, s), a && Bt.enableRetinaIcons(M, a), l && Bt.gridSize(M, l), u && Bt.ignoreHidden(M, u), c && Bt.imageExtension(M, c), p && Bt.imagePath(M, p), d && Bt.imageSizes(M, d), m && Bt.maxZoom(M, m), f && Bt.minimumClusterSize(M, f), g && Bt.styles(M, g), h && Bt.title(M, h), C && Bt.zoomOnClick(M, C), O && ee(google.maps.event.addListener(M, Gr.onMouseOut, O)), v && _(google.maps.event.addListener(M, Gr.onMouseOver, v)), w && V(google.maps.event.addListener(M, Gr.onClick, w)), S && Z(google.maps.event.addListener(M, Gr.onClusteringBegin, S)), E && Y(google.maps.event.addListener(M, Gr.onClusteringEnd, E)), N(M), P && P(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ke(Z7);
class K7 extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      markerClusterer: null
    }), he(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new r_(this.context, [], this.props.options);
      this.registeredEvents = Dt({
        updaterMap: Bt,
        eventMap: Gr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: Bt,
      eventMap: Gr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), jt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
he(K7, "contextType", st);
function LE(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var o_ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || LE(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, LE));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), G7 = ["position"], Y7 = ["position"];
function DE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function up(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PE = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, kE = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, X7 = {};
function J7(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = De(st), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), N = Ye(null);
  return y(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var A = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(A);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (m) {
      var A = r || X7, {
        position: z
      } = A, V = By(A, G7), $;
      z && !(z instanceof google.maps.LatLng) && ($ = new google.maps.LatLng(z.lat, z.lng));
      var Z = new o_(up(up({}, V), $ ? {
        position: $
      } : {}));
      N.current = document.createElement("div"), g(Z), s && C(google.maps.event.addListener(Z, "closeclick", s)), a && S(google.maps.event.addListener(Z, "domready", a)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(m, n) : Z.getPosition() ? Z.open(m) : Jn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? pr(Ct.only(t), N.current) : null;
}
ke(J7);
class Q7 extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", null), he(this, "state", {
      infoBox: null
    }), he(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Jn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), he(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = By(t, Y7), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new o_(up(up({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Dt({
      updaterMap: kE,
      eventMap: PE,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: kE,
      eventMap: PE,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), jt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? pr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
he(Q7, "contextType", st);
var SE, ME;
function eq() {
  return ME || (ME = 1, SE = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), SE;
}
var tq = eq(), TE = /* @__PURE__ */ Xj(tq), jE = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Oh = 1, pa = 8;
class Iy {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Oh)
      throw new Error("Got v".concat(o, " data when expected v").concat(Oh, "."));
    var i = jE[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Iy(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = jE.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, pa, t), this.coords = new this.ArrayType(this.data, pa + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(pa + s + a + l), this.ids = new this.IndexArrayType(this.data, pa, t), this.coords = new this.ArrayType(this.data, pa + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Oh << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return ym(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          _E(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      _E(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function ym(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    i_(e, t, s, r, o, i), ym(e, t, n, r, s - 1, 1 - i), ym(e, t, n, s + 1, o, 1 - i);
  }
}
function i_(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      i_(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (da(e, t, r, n), t[2 * o + i] > m && da(e, t, r, o); f < g; ) {
      for (da(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? da(e, t, r, g) : (g++, da(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function da(e, t, n, r) {
  Eh(e, n, r), Eh(t, 2 * n, 2 * r), Eh(t, 2 * n + 1, 2 * r + 1);
}
function Eh(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function _E(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var nq = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, AE = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), $i = 2, ri = 3, xh = 4, Qo = 5, s_ = 6;
class rq {
  constructor(t) {
    this.options = Object.assign(Object.create(nq), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = AE(Ru(u)), d = AE(Nu(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Ru(r), Nu(s), Ru(i), Nu(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + Qo] > 1 ? BE(p, f, this.clusterProps) : this.points[p[f + ri]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + xh] === t && p.push(s[m + Qo] > 1 ? BE(s, m, this.clusterProps) : this.points[s[m + ri]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Iy(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + Qo] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = a_(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + ri]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = Ru(f), d = Nu(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + ri] : C = this.points[n[l + ri]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + $i] <= n)) {
        l[p + $i] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + Qo], h = g;
        for (var C of f) {
          var w = C * c;
          l[w + $i] > n && (h += l[w + Qo]);
        }
        if (h > g && h >= s) {
          var S = d * g, E = m * g, v = void 0, O = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + $i] <= n)) {
              l[L + $i] = n;
              var N = l[L + Qo];
              S += l[L] * N, E += l[L + 1] * N, l[L + xh] = P, i && (v || (v = this._map(l, p, !0), O = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + xh] = P, u.push(S / h, E / h, 1 / 0, P, -1, h), i && u.push(O);
        } else {
          for (var A = 0; A < c; A++) u.push(l[p + A]);
          if (h > 1)
            for (var z of f) {
              var V = z * c;
              if (!(l[V + $i] <= n)) {
                l[V + $i] = n;
                for (var $ = 0; $ < c; $++) u.push(l[V + $]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Qo] > 1) {
      var o = this.clusterProps[t[n + s_]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ri]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function BE(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ri],
    properties: a_(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [oq(e[t]), iq(e[t + 1])]
    }
  };
}
function a_(e, t, n) {
  var r = e[t + Qo], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + s_], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ri],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Ru(e) {
  return e / 360 + 0.5;
}
function Nu(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function oq(e) {
  return (e - 0.5) * 360;
}
function iq(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function sq(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ir {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class bm {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ir.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ir.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ir.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class aq {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return lq(n);
  }
}
var lq = (e) => {
  var t = e.map((n) => new bm({
    position: Ir.getPosition(n),
    markers: [n]
  }));
  return t;
};
class uq extends aq {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = sq(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new rq(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!TE(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = Ir.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !TE(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new bm({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new bm({
      markers: [i],
      position: Ir.getPosition(i)
    });
  }
}
class cq {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class pq {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ir.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function dq(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Ry {
  constructor() {
    dq(Ry, google.maps.OverlayView);
  }
}
var za;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(za || (za = {}));
var fq = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class hq extends Ry {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new uq(o),
      renderer: s = new pq(),
      onClusterClick: a = fq
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ir.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, za.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Ir.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => Ir.setMap(l, null)));
      }
      google.maps.event.trigger(this, za.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ir.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new cq(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ir.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, za.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ir.setMap(r.marker, n);
    });
  }
}
function IE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function RE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function gq(e) {
  var t = f7(), [n, r] = D(null);
  return y(() => {
    if (t && n === null) {
      var o = new hq(RE(RE({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function mq(e) {
  var {
    children: t,
    options: n
  } = e, r = gq(n);
  return r !== null ? t(r) : null;
}
ke(mq);
var NE = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, FE = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function vq(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = De(st), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), N = Ye(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var A = new google.maps.InfoWindow(r);
    return g(A), N.current = document.createElement("div"), s && C(google.maps.event.addListener(A, "closeclick", s)), a && S(google.maps.event.addListener(A, "domready", a)), l && v(google.maps.event.addListener(A, "content_changed", l)), u && P(google.maps.event.addListener(A, "position_changed", u)), c && L(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(N.current), o && A.setPosition(o), i && A.setZIndex(i), n ? A.open(m, n) : A.getPosition() ? A.open(m) : Jn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(A), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), d && d(A), A.close();
    };
  }, []), N.current ? pr(Ct.only(t), N.current) : null;
}
ke(vq);
class yq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", null), he(this, "state", {
      infoWindow: null
    }), he(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Jn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), he(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Dt({
      updaterMap: FE,
      eventMap: NE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: FE,
      eventMap: NE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (jt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? pr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
he(yq, "contextType", st);
function zE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $E = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, UE = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, bq = {};
function wq(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, S = De(st), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null);
  return y(() => {
    E !== null && E.setMap(S);
  }, [S]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && p && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(E, "mouseout", p)));
  }, [p]), y(() => {
    E && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(E, "mouseover", d)));
  }, [d]), y(() => {
    E && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(E, "mouseup", m)));
  }, [m]), y(() => {
    E && f && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && g && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && h && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var j = new google.maps.Polyline(cp(cp({}, t || bq), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && P(google.maps.event.addListener(j, "dblclick", s)), a && L(google.maps.event.addListener(j, "dragend", a)), l && A(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && Z(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), m && _(google.maps.event.addListener(j, "mouseup", m)), f && M(google.maps.event.addListener(j, "rightclick", f)), g && x(google.maps.event.addListener(j, "click", g)), h && F(google.maps.event.addListener(j, "drag", h)), v(j), C && C(j), () => {
      O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(wq);
class Cq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      polyline: null
    }), he(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(cp(cp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dt({
      updaterMap: UE,
      eventMap: $E,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: UE,
      eventMap: $E,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), jt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
he(Cq, "contextType", st);
function WE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HE = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, qE = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Oq(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: S,
    onEdit: E
  } = e, v = De(st), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null);
  return y(() => {
    O !== null && O.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof s < "u" && O !== null && O.setPaths(s);
  }, [O, s]), y(() => {
    O && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof p == "function" && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(O, "mousemove", p)));
  }, [p]), y(() => {
    O && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseout", d)));
  }, [d]), y(() => {
    O && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(O, "mouseover", m)));
  }, [m]), y(() => {
    O && typeof f == "function" && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(O, "mouseup", f)));
  }, [f]), y(() => {
    O && typeof g == "function" && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(O, "click", h)));
  }, [h]), y(() => {
    O && typeof C == "function" && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(O, "drag", C)));
  }, [C]), y(() => {
    var B = new google.maps.Polygon(VE(VE({}, t), {}, {
      map: v
    }));
    return i && B.setPath(i), s && B.setPaths(s), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), a && L(google.maps.event.addListener(B, "dblclick", a)), l && A(google.maps.event.addListener(B, "dragend", l)), u && V(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && Y(google.maps.event.addListener(B, "mousemove", p)), d && ee(google.maps.event.addListener(B, "mouseout", d)), m && _(google.maps.event.addListener(B, "mouseover", m)), f && M(google.maps.event.addListener(B, "mouseup", f)), g && x(google.maps.event.addListener(B, "rightclick", g)), h && F(google.maps.event.addListener(B, "click", h)), C && H(google.maps.event.addListener(B, "drag", C)), P(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), T !== null && google.maps.event.removeListener(T), S && S(B), B.setMap(null);
    };
  }, []), null;
}
ke(Oq);
class Eq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Dt({
      updaterMap: qE,
      eventMap: HE,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: qE,
      eventMap: HE,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), jt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
he(Eq, "contextType", st);
function ZE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var KE = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, GE = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function xq(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: S
  } = e, E = De(st), [v, O] = D(null), [P, U] = D(null), [L, N] = D(null), [A, z] = D(null), [V, $] = D(null), [Z, J] = D(null), [Y, te] = D(null), [ee, k] = D(null), [_, K] = D(null), [M, G] = D(null), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (P !== null && google.maps.event.removeListener(P), U(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (A !== null && google.maps.event.removeListener(A), z(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), J(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), te(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), y(() => {
    v && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), y(() => {
    v && m && (_ !== null && google.maps.event.removeListener(_), K(google.maps.event.addListener(v, "mouseup", m)));
  }, [m]), y(() => {
    v && f && (M !== null && google.maps.event.removeListener(M), G(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && g && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(v, "click", g)));
  }, [g]), y(() => {
    v && h && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var Q = new google.maps.Rectangle(pp(pp({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && N(google.maps.event.addListener(Q, "dragend", a)), l && z(google.maps.event.addListener(Q, "dragstart", l)), u && $(google.maps.event.addListener(Q, "mousedown", u)), c && J(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && K(google.maps.event.addListener(Q, "mouseup", m)), f && G(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && j(google.maps.event.addListener(Q, "drag", h)), C && B(google.maps.event.addListener(Q, "bounds_changed", C)), O(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), x !== null && google.maps.event.removeListener(x), F !== null && google.maps.event.removeListener(F), H !== null && google.maps.event.removeListener(H), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke(xq);
class Lq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      rectangle: null
    }), he(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(pp(pp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dt({
      updaterMap: GE,
      eventMap: KE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: GE,
      eventMap: KE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), jt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
he(Lq, "contextType", st);
function YE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XE = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, JE = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Dq = {};
function Pq(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: E,
    onUnmount: v
  } = e, O = De(st), [P, U] = D(null), [L, N] = D(null), [A, z] = D(null), [V, $] = D(null), [Z, J] = D(null), [Y, te] = D(null), [ee, k] = D(null), [_, K] = D(null), [M, G] = D(null), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null), [Q, W] = D(null), [ue, ye] = D(null);
  return y(() => {
    P !== null && P.setMap(O);
  }, [O]), y(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), y(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), y(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), y(() => {
    typeof s < "u" && P !== null && P.setVisible(s);
  }, [P, s]), y(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), y(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), y(() => {
    P && a && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", a)));
  }, [a]), y(() => {
    P && l && (A !== null && google.maps.event.removeListener(A), z(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), y(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), y(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), J(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), y(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), y(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), y(() => {
    P && m && (_ !== null && google.maps.event.removeListener(_), K(google.maps.event.addListener(P, "mouseover", m)));
  }, [m]), y(() => {
    P && f && (M !== null && google.maps.event.removeListener(M), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), y(() => {
    P && g && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(P, "rightclick", g)));
  }, [g]), y(() => {
    P && h && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), y(() => {
    P && C && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(P, "drag", C)));
  }, [C]), y(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), W(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), y(() => {
    P && S && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), y(() => {
    var oe = new google.maps.Circle(dp(dp({}, t || Dq), {}, {
      map: O
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && N(google.maps.event.addListener(oe, "dblclick", a)), l && z(google.maps.event.addListener(oe, "dragend", l)), u && $(google.maps.event.addListener(oe, "dragstart", u)), c && J(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && K(google.maps.event.addListener(oe, "mouseover", m)), f && G(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && j(google.maps.event.addListener(oe, "click", h)), C && B(google.maps.event.addListener(oe, "drag", C)), w && W(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), U(oe), E && E(oe), () => {
      L !== null && google.maps.event.removeListener(L), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), x !== null && google.maps.event.removeListener(x), F !== null && google.maps.event.removeListener(F), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(Pq);
class kq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      circle: null
    }), he(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(dp(dp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dt({
      updaterMap: JE,
      eventMap: XE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: JE,
      eventMap: XE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), jt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
he(kq, "contextType", st);
function QE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QE(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ex = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, tx = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Sq(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, C = De(st), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && p && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), y(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), y(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), y(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var B = new google.maps.Data(fp(fp({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(B, "dblclick", r)), o && P(google.maps.event.addListener(B, "mousedown", o)), i && L(google.maps.event.addListener(B, "mousemove", i)), s && A(google.maps.event.addListener(B, "mouseout", s)), a && V(google.maps.event.addListener(B, "mouseover", a)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && Y(google.maps.event.addListener(B, "rightclick", u)), n && ee(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && x(google.maps.event.addListener(B, "removeproperty", d)), m && F(google.maps.event.addListener(B, "setgeometry", m)), f && H(google.maps.event.addListener(B, "setproperty", f)), S(B), g && g(B);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(Sq);
class Mq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      data: null
    }), he(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(fp(fp({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Dt({
        updaterMap: tx,
        eventMap: ex,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: tx,
      eventMap: ex,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), jt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
he(Mq, "contextType", st);
function nx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nx(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ox = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, ix = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Tq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      kmlLayer: null
    }), he(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(rx(rx({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dt({
      updaterMap: ix,
      eventMap: ox,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: ix,
      eventMap: ox,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), jt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(Tq, "contextType", st);
function l_(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function jq(e, t) {
  return new t(e.lat, e.lng);
}
function _q(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Aq(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Bq(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Iq(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Rq(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function u_(e, t, n, r) {
  return n !== void 0 ? Iq(e, t, Bq(n, google.maps.LatLngBounds, _q)) : Rq(e, t, Aq(r, google.maps.LatLng, jq));
}
function Nq(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function sx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fq(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sx(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function zq(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = Fq({}, this.container ? l_(this.container, o) : {
        x: 0,
        y: 0
      }), u = u_(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function ax(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $q(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ax(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ax(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function lx(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function ux(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Uq(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = De(st), c = Gn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Gn(() => zq(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ke(Uq);
class Zs extends Oe {
  constructor(t) {
    super(t), he(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), he(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Jn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), he(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), he(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = $q({
        x: 0,
        y: 0
      }, this.containerRef.current ? l_(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = u_(r, o, this.props.bounds, this.props.position);
      if (!Nq(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), he(this, "draw", () => {
      this.onPositionElement();
    }), he(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = cr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = lx(t.position), r = lx(this.props.position), o = ux(t.bounds), i = ux(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(Lr.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ct.only(this.props.children)
    }), t) : null;
  }
}
he(Zs, "FLOAT_PANE", "floatPane");
he(Zs, "MAP_PANE", "mapPane");
he(Zs, "MARKER_LAYER", "markerLayer");
he(Zs, "OVERLAY_LAYER", "overlayLayer");
he(Zs, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
he(Zs, "contextType", st);
function Wq() {
}
function cx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function px(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cx(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dx = {
  onDblClick: "dblclick",
  onClick: "click"
}, fx = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Vq(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = De(st), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Gn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
ke(Vq);
class c_ extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      groundOverlay: null
    }), he(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Jn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, px(px({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Dt({
      updaterMap: fx,
      eventMap: dx,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: fx,
      eventMap: dx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
he(c_, "defaultProps", {
  onLoad: Wq
});
he(c_, "contextType", st);
function hx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hx(Object(n), !0).forEach(function(r) {
      he(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gx = {}, mx = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Hq(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = De(st), [s, a] = D(null);
  return y(() => {
    google.maps.visualization || Jn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Jn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(hp(hp({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
ke(Hq);
class qq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      heatmapLayer: null
    }), he(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Jn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Jn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(hp(hp({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Dt({
      updaterMap: mx,
      eventMap: gx,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: mx,
      eventMap: gx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), jt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
he(qq, "contextType", st);
var vx = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, yx = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Zq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      streetViewPanorama: null
    }), he(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Dt({
      updaterMap: yx,
      eventMap: vx,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: yx,
      eventMap: vx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), jt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
he(Zq, "contextType", st);
class Kq extends Oe {
  constructor() {
    super(...arguments), he(this, "state", {
      streetViewService: null
    }), he(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
he(Kq, "contextType", st);
var bx = {
  onDirectionsChanged: "directions_changed"
}, wx = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Gq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "state", {
      directionsRenderer: null
    }), he(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Dt({
      updaterMap: wx,
      eventMap: bx,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: wx,
      eventMap: bx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), jt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
he(Gq, "contextType", st);
var Cx = {
  onPlacesChanged: "places_changed"
}, Ox = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Yq extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", cr()), he(this, "state", {
      searchBox: null
    }), he(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Jn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Dt({
          updaterMap: Ox,
          eventMap: Cx,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: Ox,
      eventMap: Cx,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), jt(this.registeredEvents));
  }
  render() {
    return Lr.jsx("div", {
      ref: this.containerElement,
      children: Ct.only(this.props.children)
    });
  }
}
he(Yq, "contextType", st);
var Ex = {
  onPlaceChanged: "place_changed"
}, xx = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class p_ extends Oe {
  constructor() {
    super(...arguments), he(this, "registeredEvents", []), he(this, "containerElement", cr()), he(this, "state", {
      autocomplete: null
    }), he(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Jn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Dt({
        updaterMap: xx,
        eventMap: Ex,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    jt(this.registeredEvents), this.registeredEvents = Dt({
      updaterMap: xx,
      eventMap: Ex,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && jt(this.registeredEvents);
  }
  render() {
    return Lr.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ct.only(this.props.children)
    });
  }
}
he(p_, "defaultProps", {
  className: ""
});
he(p_, "contextType", st);
let Xq = { data: "" }, Jq = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Xq, Qq = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, eZ = /\/\*[^]*?\*\/|  +/g, Lx = /\n+/g, ui = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ui(s, i) : i + "{" + ui(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ui(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ui.p ? ui.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Po = {}, d_ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + d_(e[n]);
    return t;
  }
  return e;
}, tZ = (e, t, n, r, o) => {
  let i = d_(e), s = Po[i] || (Po[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Po[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Qq.exec(u.replace(eZ, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(Lx, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(Lx, " ").trim();
      return d[0];
    })(e);
    Po[s] = ui(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Po.g ? Po.g : null;
  return n && (Po.g = Po[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Po[s], t, r, a), s;
}, nZ = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ui(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Jd(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return tZ(n.unshift ? n.raw ? nZ(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Jq(t.target), t.g, t.o, t.k);
}
let f_, wm, Cm;
Jd.bind({ g: 1 });
let Io = Jd.bind({ k: 1 });
function rZ(e, t, n, r) {
  ui.p = t, f_ = e, wm = n, Cm = r;
}
function ki(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: wm && wm() }, a), n.o = / *go\d+/.test(l), a.className = Jd.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Cm && u[0] && Cm(a), f_(u, a);
    }
    return o;
  };
}
var oZ = (e) => typeof e == "function", iZ = (e, t) => oZ(e) ? e(t) : e, sZ = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), aZ = Io`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, lZ = Io`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, uZ = Io`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, cZ = ki("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${aZ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${lZ} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${uZ} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, pZ = Io`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, dZ = ki("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${pZ} 1s linear infinite;
`, fZ = Io`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, hZ = Io`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, gZ = ki("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${fZ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${hZ} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, mZ = ki("div")`
  position: absolute;
`, vZ = ki("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, yZ = Io`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, bZ = ki("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${yZ} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, wZ = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? We.createElement(bZ, null, t) : t : n === "blank" ? null : We.createElement(vZ, null, We.createElement(dZ, { ...r }), n !== "loading" && We.createElement(mZ, null, n === "error" ? We.createElement(cZ, { ...r }) : We.createElement(gZ, { ...r })));
}, CZ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, OZ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, EZ = "0%{opacity:0;} 100%{opacity:1;}", xZ = "0%{opacity:1;} 100%{opacity:0;}", LZ = ki("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, DZ = ki("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, PZ = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = sZ() ? [EZ, xZ] : [CZ(n), OZ(n)];
  return { animation: t ? `${Io(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Io(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
We.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? PZ(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = We.createElement(wZ, { toast: e }), s = We.createElement(DZ, { ...e.ariaProps }, iZ(e.message, e));
  return We.createElement(LZ, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : We.createElement(We.Fragment, null, i, s));
});
rZ(We.createElement);
Jd`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function h_(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], m = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Xt.jsxs("button", { className: m, disabled: l || t, ...p, children: [
    /* @__PURE__ */ Xt.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Xt.jsx(vo, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Xt.jsxs("div", { className: "arkynButtonContent", children: [
      k0(d, s),
      c,
      k0(d, a)
    ] })
  ] });
}
function kZ() {
  const e = Xm(), t = wS(), n = CS(), [r, o] = D(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  y(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), y(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
qe({});
function SZ(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ Xt.jsxs(
    "button",
    {
      disabled: s || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Xt.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Xt.jsx(vo, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Xt.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Xt.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function MZ(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Xt.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ Xt.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function TZ(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const jZ = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
TZ(jZ.CNPJ).length;
Fs((e, t) => /* @__PURE__ */ Xt.jsx("input", { ref: t, ...e }));
qe({});
var $o = {};
Object.defineProperty($o, "__esModule", {
  value: !0
});
var _Z = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Lh = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, g_ = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: _Z ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Ny = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Fu = 1; Fu < 20; Fu++)
  Ny["f" + Fu] = 111 + Fu;
function Qd(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return m_(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return v_(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function AZ(e, t) {
  return Qd(e, t);
}
function BZ(e, t) {
  return Qd(e, { byKey: !0 }, t);
}
function m_(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Lh)
    r[Lh[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = Fy(d), g = Lh[f];
      if (d.length > 1 && !g && !g_[d] && !Ny[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = y_(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function v_(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function y_(e) {
  e = Fy(e);
  var t = Ny[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Fy(e) {
  return e = e.toLowerCase(), e = g_[e] || e, e;
}
$o.default = Qd;
var Dh = $o.isHotkey = Qd;
$o.isCodeHotkey = AZ;
$o.isKeyHotkey = BZ;
$o.parseHotkey = m_;
$o.compareHotkey = v_;
$o.toKeyCode = y_;
$o.toKeyName = Fy;
var IZ = typeof nn == "object" && nn && nn.Object === Object && nn, RZ = IZ, NZ = RZ, FZ = typeof self == "object" && self && self.Object === Object && self, zZ = NZ || FZ || Function("return this")(), $Z = zZ, UZ = $Z, WZ = UZ.Symbol, b_ = WZ, Dx = b_;
Dx && Dx.toStringTag;
var Px = b_;
Px && Px.toStringTag;
var kx;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(kx || (kx = {}));
var zy = function(e) {
  return Object.freeze(e);
}, VZ = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, zy(this);
  }
  return e;
}(), HZ = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, zy(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Sx = typeof window < "u" ? window : {};
/msie|trident/i.test(Sx.navigator && Sx.navigator.userAgent);
var Ph = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new VZ((n ? t : e) || 0, (n ? e : t) || 0);
};
zy({
  devicePixelContentBoxSize: Ph(),
  borderBoxSize: Ph(),
  contentBoxSize: Ph(),
  contentRect: new HZ(0, 0, 0, 0)
});
function fl(e) {
  "@babel/helpers - typeof";
  return fl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fl(e);
}
function qZ(e, t) {
  if (fl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (fl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ZZ(e) {
  var t = qZ(e, "string");
  return fl(t) === "symbol" ? t : String(t);
}
function $a(e, t, n) {
  return t = ZZ(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var KZ = /* @__PURE__ */ qe(null), kh, Sh;
parseInt(xe.version.split(".")[0], 10);
var Mx = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Mh = typeof navigator < "u" && /Android/.test(navigator.userAgent), zu = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), GZ = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (kh = navigator.userAgent.match(/Version\/(\d+)/)) !== null && kh !== void 0 && kh[1] && parseInt((Sh = navigator.userAgent.match(/Version\/(\d+)/)) === null || Sh === void 0 ? void 0 : Sh[1], 10) < 17;
var YZ = /* @__PURE__ */ new WeakMap(), XZ = /* @__PURE__ */ new WeakMap(), JZ = /* @__PURE__ */ new WeakMap(), QZ = /* @__PURE__ */ new WeakMap(), eK = /* @__PURE__ */ new WeakMap(), Tx = /* @__PURE__ */ new WeakMap(), tK = /* @__PURE__ */ new WeakMap(), jx = /* @__PURE__ */ new WeakMap(), $u = /* @__PURE__ */ new WeakMap(), nK = /* @__PURE__ */ new WeakMap(), rK = /* @__PURE__ */ new WeakMap(), oK = /* @__PURE__ */ new WeakMap(), w_ = globalThis.Node, iK = globalThis.Text, C_ = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, sK = (e) => gp(e) && e.nodeType === 8, mo = (e) => gp(e) && e.nodeType === 1, gp = (e) => {
  var t = C_(e);
  return !!t && e instanceof t.Node;
}, _x = (e) => {
  var t = e && e.anchorNode && C_(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, aK = (e) => {
  var [t, n] = e;
  if (mo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = O_(t, o, r ? "backward" : "forward"), r = o < n; mo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = uK(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, lK = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, O_ = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (sK(o) || mo(o) && o.childNodes.length === 0 || mo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, uK = (e, t, n) => {
  var [r] = O_(e, t, n);
  return r;
}, Ax = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), E_ = (e, t, n) => {
  var {
    target: r
  } = t;
  if (mo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = xt.getWindow(e);
  if (o.contains(r))
    return xt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : E_(e, i, n);
}, Bx = (e, t) => !!(e.compareDocumentPosition(t) & w_.DOCUMENT_POSITION_PRECEDING), cK = (e, t) => !!(e.compareDocumentPosition(t) & w_.DOCUMENT_POSITION_FOLLOWING), pK = 0;
class dK {
  constructor() {
    $a(this, "id", void 0), this.id = "".concat(pK++);
  }
}
var xt = {
  androidPendingDiffs: (e) => oK.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = rK.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = xt.toDOMNode(e, e), n = xt.findDocumentOrShadowRoot(e);
    $u.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = xt.findDocumentOrShadowRoot(e), r = Ax(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Bc.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = xt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = xt.toSlateNode(e, t.target), s = xt.findPath(e, i);
    if (Mo.isElement(i) && Jt.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Jt.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Jt.before(e, u) : Jt.after(e, u);
      if (c) {
        var p = Jt.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = xt.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = xt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = Tx.get(t);
    return n || (n = new dK(), Tx.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = XZ.get(r);
      if (o == null) {
        if (Jt.isEditor(r))
          return n;
        break;
      }
      var i = YZ.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(jr.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!$u.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          xt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = xt.toDOMNode(e, e), r = xt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Ax(r), i = xt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Bc.select(e, Jt.start(e, [])), $u.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = JZ.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = xt.toDOMNode(e, e), i;
    try {
      i = mo(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => gp(t) && xt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Jt.hasPath(e, n.path) && Jt.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => xt.hasEditableTarget(e, t) || xt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => gp(t) && xt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!nK.get(e),
  isFocused: (e) => !!$u.get(e),
  isReadOnly: (e) => !!jx.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (jx.get(e)) return !1;
    var n = xt.hasTarget(e, t) && xt.toSlateNode(e, t);
    return Mo.isElement(n) && Jt.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = tK.get(e), r = Jt.isEditor(t) ? QZ.get(e) : n == null ? void 0 : n.get(xt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(jr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Jt.node(e, t.path), r = xt.toDOMNode(e, n), o;
    Jt.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof iK ? C : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(jr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = pt.isBackward(t), i = xt.toDOMPoint(e, n), s = pt.isCollapsed(t) ? i : xt.toDOMPoint(e, r), a = xt.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = mo(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = mo(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = mo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? eK.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : aK(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = xt.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = xt.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var O = v.cloneContents(), P = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          P.forEach((M) => {
            if (Mh && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = O.textContent.length, S = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var N = U[L];
          if (xt.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (C) {
        var A = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], z = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, $ = [...A(z), ...A(z == null ? void 0 : z.nextElementSibling)];
          w = (V = $.find((M) => cK(C, M))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, J = [...A(z == null ? void 0 : z.previousElementSibling), ...A(z)];
          w = (Z = J.findLast((M) => Bx(C, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Mh && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      zu && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Mh && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && xt.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var te = xt.toSlateNode(e, Y), {
          path: ee,
          offset: k
        } = Jt.start(e, xt.findPath(e, te));
        return Y.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = xt.toSlateNode(e, u), K = xt.findPath(e, _);
    return {
      path: K,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = _x(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (_x(t)) {
        if (zu && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let O = function(P) {
              return P.childElementCount > 0 ? O(P.children[0]) : P;
            };
            var f = d.startContainer, g = m.startContainer, h = O(f.children[d.startOffset]), C = O(g.children[m.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        GZ && lK(a) || zu ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    zu && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = xt.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = Bx(a, u) || a === u && c < l, E = p ? w : xt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return pt.isExpanded(v) && pt.isForward(v) && mo(u) && Jt.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = Jt.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, fK = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, hK = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, gK = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Dn = (e) => {
  var t = fK[e], n = hK[e], r = gK[e], o = t && Dh(t), i = n && Dh(n), s = r && Dh(r);
  return (a) => !!(o && o(a) || Mx && i && i(a) || !Mx && s && s(a));
};
Dn("bold"), Dn("compose"), Dn("moveBackward"), Dn("moveForward"), Dn("deleteBackward"), Dn("deleteForward"), Dn("deleteLineBackward"), Dn("deleteLineForward"), Dn("deleteWordBackward"), Dn("deleteWordForward"), Dn("extendBackward"), Dn("extendForward"), Dn("extendLineBackward"), Dn("extendLineForward"), Dn("italic"), Dn("moveLineBackward"), Dn("moveLineForward"), Dn("moveWordBackward"), Dn("moveWordForward"), Dn("redo"), Dn("insertSoftBreak"), Dn("splitBlock"), Dn("transposeCharacter"), Dn("undo");
var mK = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => E_(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, vK = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class yK extends Fp {
  constructor() {
    super(...arguments), $a(this, "context", null), $a(this, "manager", null), $a(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, vK);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = mK(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
$a(yK, "contextType", KZ);
qe({});
qe({});
qe({});
var Zn = {}, $y = {}, Bl = {}, Il = {}, x_ = "Expected a function", Ix = NaN, bK = "[object Symbol]", wK = /^\s+|\s+$/g, CK = /^[-+]0x[0-9a-f]+$/i, OK = /^0b[01]+$/i, EK = /^0o[0-7]+$/i, xK = parseInt, LK = typeof nn == "object" && nn && nn.Object === Object && nn, DK = typeof self == "object" && self && self.Object === Object && self, PK = LK || DK || Function("return this")(), kK = Object.prototype, SK = kK.toString, MK = Math.max, TK = Math.min, Th = function() {
  return PK.Date.now();
};
function jK(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(x_);
  t = Rx(t) || 0, mp(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? MK(Rx(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(O) {
    var P = r, U = o;
    return r = o = void 0, u = O, s = e.apply(U, P), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var P = O - l, U = O - u, L = t - P;
    return p ? TK(L, i - U) : L;
  }
  function h(O) {
    var P = O - l, U = O - u;
    return l === void 0 || P >= t || P < 0 || p && U >= i;
  }
  function C() {
    var O = Th();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, d && r ? m(O) : (r = o = void 0, s);
  }
  function S() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(Th());
  }
  function v() {
    var O = Th(), P = h(O);
    if (r = arguments, o = this, l = O, P) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = S, v.flush = E, v;
}
function _K(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(x_);
  return mp(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), jK(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function mp(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function AK(e) {
  return !!e && typeof e == "object";
}
function BK(e) {
  return typeof e == "symbol" || AK(e) && SK.call(e) == bK;
}
function Rx(e) {
  if (typeof e == "number")
    return e;
  if (BK(e))
    return Ix;
  if (mp(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = mp(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(wK, "");
  var n = OK.test(e);
  return n || EK.test(e) ? xK(e.slice(2), n ? 2 : 8) : CK.test(e) ? Ix : +e;
}
var IK = _K, Rl = {};
Object.defineProperty(Rl, "__esModule", {
  value: !0
});
Rl.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), mc.has(t) || mc.set(t, /* @__PURE__ */ new Set());
  var o = mc.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Rl.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), mc.get(t).delete(n.name || t);
};
var mc = /* @__PURE__ */ new Map();
Object.defineProperty(Il, "__esModule", {
  value: !0
});
var RK = IK, NK = zK(RK), FK = Rl;
function zK(e) {
  return e && e.__esModule ? e : { default: e };
}
var $K = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, NK.default)(e, t);
}, In = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = $K(function(r) {
        In.scrollHandler(e);
      }, t);
      In.scrollSpyContainers.push(e), (0, FK.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return In.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = In.scrollSpyContainers[In.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(In.currentPositionX(e), In.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    In.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = In.scrollSpyContainers[In.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(In.currentPositionX(t), In.currentPositionY(t));
  },
  updateStates: function() {
    In.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    In.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), In.spySetState && In.spySetState.length && In.spySetState.indexOf(e) > -1 && In.spySetState.splice(In.spySetState.indexOf(e), 1), document.removeEventListener("scroll", In.scrollHandler);
  },
  update: function() {
    return In.scrollSpyContainers.forEach(function(e) {
      return In.scrollHandler(e);
    });
  }
};
Il.default = In;
var Ks = {}, Nl = {};
Object.defineProperty(Nl, "__esModule", {
  value: !0
});
var UK = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, WK = function() {
  return window.location.hash.replace(/^#/, "");
}, VK = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, HK = function(e) {
  return getComputedStyle(e).position !== "static";
}, jh = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, qK = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (HK(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = jh(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return jh(t, a).offsetTop - jh(e, a).offsetTop;
};
Nl.default = {
  updateHash: UK,
  getHash: WK,
  filterElementInContainer: VK,
  scrollOffset: qK
};
var ef = {}, Uy = {};
Object.defineProperty(Uy, "__esModule", {
  value: !0
});
Uy.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Wy = {};
Object.defineProperty(Wy, "__esModule", {
  value: !0
});
var ZK = Rl, KK = ["mousedown", "mousewheel", "touchmove", "keydown"];
Wy.default = {
  subscribe: function(e) {
    return typeof document < "u" && KK.forEach(function(t) {
      return (0, ZK.addPassiveEventListener)(document, t, e);
    });
  }
};
var Fl = {};
Object.defineProperty(Fl, "__esModule", {
  value: !0
});
var Om = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Om.registered[e] = t;
    },
    remove: function(e) {
      Om.registered[e] = null;
    }
  }
};
Fl.default = Om;
Object.defineProperty(ef, "__esModule", {
  value: !0
});
var GK = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, YK = Nl;
tf(YK);
var XK = Uy, Nx = tf(XK), JK = Wy, QK = tf(JK), eG = Fl, po = tf(eG);
function tf(e) {
  return e && e.__esModule ? e : { default: e };
}
var L_ = function(e) {
  return Nx.default[e.smooth] || Nx.default.defaultEasing;
}, tG = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, nG = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Em = function() {
  return nG() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), D_ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, P_ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, k_ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, rG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, oG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, iG = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    po.default.registered.end && po.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Em.call(window, i);
    return;
  }
  po.default.registered.end && po.default.registered.end(o.to, o.target, o.currentPosition);
}, Vy = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, zl = function(e, t, n, r) {
  t.data = t.data || D_(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (QK.default.subscribe(o), Vy(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? P_(t) : k_(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    po.default.registered.end && po.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = tG(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = L_(t), s = iG.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      po.default.registered.begin && po.default.registered.begin(t.data.to, t.data.target), Em.call(window, s);
    }, t.delay);
    return;
  }
  po.default.registered.begin && po.default.registered.begin(t.data.to, t.data.target), Em.call(window, s);
}, nf = function(e) {
  return e = GK({}, e), e.data = e.data || D_(), e.absolute = !0, e;
}, sG = function(e) {
  zl(0, nf(e));
}, aG = function(e, t) {
  zl(e, nf(t));
}, lG = function(e) {
  e = nf(e), Vy(e), zl(e.horizontal ? rG(e) : oG(e), e);
}, uG = function(e, t) {
  t = nf(t), Vy(t);
  var n = t.horizontal ? P_(t) : k_(t);
  zl(e + n, t);
};
ef.default = {
  animateTopScroll: zl,
  getAnimationType: L_,
  scrollToTop: sG,
  scrollToBottom: lG,
  scrollTo: aG,
  scrollMore: uG
};
Object.defineProperty(Ks, "__esModule", {
  value: !0
});
var cG = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pG = Nl, dG = Hy(pG), fG = ef, hG = Hy(fG), gG = Fl, Uu = Hy(gG);
function Hy(e) {
  return e && e.__esModule ? e : { default: e };
}
var Wu = {}, Fx = void 0;
Ks.default = {
  unmount: function() {
    Wu = {};
  },
  register: function(e, t) {
    Wu[e] = t;
  },
  unregister: function(e) {
    delete Wu[e];
  },
  get: function(e) {
    return Wu[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return Fx = e;
  },
  getActiveLink: function() {
    return Fx;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = cG({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = dG.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Uu.default.registered.begin && Uu.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Uu.default.registered.end && Uu.default.registered.end(e, n);
      return;
    }
    hG.default.animateTopScroll(a, t, e, n);
  }
};
var xm = { exports: {} }, _h = { exports: {} }, Wt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zx;
function mG() {
  if (zx) return Wt;
  zx = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(v) {
    if (typeof v == "object" && v !== null) {
      var O = v.$$typeof;
      switch (O) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return v;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(v) {
    return S(v) === u;
  }
  return Wt.AsyncMode = l, Wt.ConcurrentMode = u, Wt.ContextConsumer = a, Wt.ContextProvider = s, Wt.Element = t, Wt.ForwardRef = c, Wt.Fragment = r, Wt.Lazy = f, Wt.Memo = m, Wt.Portal = n, Wt.Profiler = i, Wt.StrictMode = o, Wt.Suspense = p, Wt.isAsyncMode = function(v) {
    return E(v) || S(v) === l;
  }, Wt.isConcurrentMode = E, Wt.isContextConsumer = function(v) {
    return S(v) === a;
  }, Wt.isContextProvider = function(v) {
    return S(v) === s;
  }, Wt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Wt.isForwardRef = function(v) {
    return S(v) === c;
  }, Wt.isFragment = function(v) {
    return S(v) === r;
  }, Wt.isLazy = function(v) {
    return S(v) === f;
  }, Wt.isMemo = function(v) {
    return S(v) === m;
  }, Wt.isPortal = function(v) {
    return S(v) === n;
  }, Wt.isProfiler = function(v) {
    return S(v) === i;
  }, Wt.isStrictMode = function(v) {
    return S(v) === o;
  }, Wt.isSuspense = function(v) {
    return S(v) === p;
  }, Wt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === m || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === g);
  }, Wt.typeOf = S, Wt;
}
var Yt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $x;
function vG() {
  return $x || ($x = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(W) {
      return typeof W == "string" || typeof W == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      W === r || W === u || W === i || W === o || W === p || W === d || typeof W == "object" && W !== null && (W.$$typeof === f || W.$$typeof === m || W.$$typeof === s || W.$$typeof === a || W.$$typeof === c || W.$$typeof === h || W.$$typeof === C || W.$$typeof === w || W.$$typeof === g);
    }
    function E(W) {
      if (typeof W == "object" && W !== null) {
        var ue = W.$$typeof;
        switch (ue) {
          case t:
            var ye = W.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var v = l, O = u, P = a, U = s, L = t, N = c, A = r, z = f, V = m, $ = n, Z = i, J = o, Y = p, te = !1;
    function ee(W) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(W) || E(W) === l;
    }
    function k(W) {
      return E(W) === u;
    }
    function _(W) {
      return E(W) === a;
    }
    function K(W) {
      return E(W) === s;
    }
    function M(W) {
      return typeof W == "object" && W !== null && W.$$typeof === t;
    }
    function G(W) {
      return E(W) === c;
    }
    function x(W) {
      return E(W) === r;
    }
    function T(W) {
      return E(W) === f;
    }
    function F(W) {
      return E(W) === m;
    }
    function j(W) {
      return E(W) === n;
    }
    function H(W) {
      return E(W) === i;
    }
    function B(W) {
      return E(W) === o;
    }
    function Q(W) {
      return E(W) === p;
    }
    Yt.AsyncMode = v, Yt.ConcurrentMode = O, Yt.ContextConsumer = P, Yt.ContextProvider = U, Yt.Element = L, Yt.ForwardRef = N, Yt.Fragment = A, Yt.Lazy = z, Yt.Memo = V, Yt.Portal = $, Yt.Profiler = Z, Yt.StrictMode = J, Yt.Suspense = Y, Yt.isAsyncMode = ee, Yt.isConcurrentMode = k, Yt.isContextConsumer = _, Yt.isContextProvider = K, Yt.isElement = M, Yt.isForwardRef = G, Yt.isFragment = x, Yt.isLazy = T, Yt.isMemo = F, Yt.isPortal = j, Yt.isProfiler = H, Yt.isStrictMode = B, Yt.isSuspense = Q, Yt.isValidElementType = S, Yt.typeOf = E;
  }()), Yt;
}
var Ux;
function S_() {
  return Ux || (Ux = 1, process.env.NODE_ENV === "production" ? _h.exports = mG() : _h.exports = vG()), _h.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Ah, Wx;
function yG() {
  if (Wx) return Ah;
  Wx = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Ah = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, Ah;
}
var Bh, Vx;
function qy() {
  if (Vx) return Bh;
  Vx = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Bh = e, Bh;
}
var Hx, qx;
function M_() {
  return qx || (qx = 1, Hx = Function.call.bind(Object.prototype.hasOwnProperty)), Hx;
}
var Ih, Zx;
function bG() {
  if (Zx) return Ih;
  Zx = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = qy(), n = {}, r = M_();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Ih = o, Ih;
}
var Rh, Kx;
function wG() {
  if (Kx) return Rh;
  Kx = 1;
  var e = S_(), t = yG(), n = qy(), r = M_(), o = bG(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Rh = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", m = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: S,
      element: E(),
      elementType: v(),
      instanceOf: O,
      node: N(),
      objectOf: U,
      oneOf: P,
      oneOfType: L,
      shape: z,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function g(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, K = 0;
      function M(x, T, F, j, H, B, Q) {
        if (j = j || d, B = B || F, Q !== n) {
          if (l) {
            var W = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw W.name = "Invariant Violation", W;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            K < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, K++);
          }
        }
        return T[F] == null ? x ? T[F] === null ? new g("The " + H + " `" + B + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new g("The " + H + " `" + B + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : k(T, F, j, H, B);
      }
      var G = M.bind(null, !1);
      return G.isRequired = M.bind(null, !0), G;
    }
    function C(k) {
      function _(K, M, G, x, T, F) {
        var j = K[M], H = J(j);
        if (H !== k) {
          var B = Y(j);
          return new g(
            "Invalid " + x + " `" + T + "` of type " + ("`" + B + "` supplied to `" + G + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(_);
    }
    function w() {
      return h(s);
    }
    function S(k) {
      function _(K, M, G, x, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var F = K[M];
        if (!Array.isArray(F)) {
          var j = J(F);
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var H = 0; H < F.length; H++) {
          var B = k(F, H, G, x, T + "[" + H + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return h(_);
    }
    function E() {
      function k(_, K, M, G, x) {
        var T = _[K];
        if (!a(T)) {
          var F = J(T);
          return new g("Invalid " + G + " `" + x + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function v() {
      function k(_, K, M, G, x) {
        var T = _[K];
        if (!e.isValidElementType(T)) {
          var F = J(T);
          return new g("Invalid " + G + " `" + x + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function O(k) {
      function _(K, M, G, x, T) {
        if (!(K[M] instanceof k)) {
          var F = k.name || d, j = ee(K[M]);
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return h(_);
    }
    function P(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function _(K, M, G, x, T) {
        for (var F = K[M], j = 0; j < k.length; j++)
          if (f(F, k[j]))
            return null;
        var H = JSON.stringify(k, function(B, Q) {
          var W = Y(Q);
          return W === "symbol" ? String(Q) : Q;
        });
        return new g("Invalid " + x + " `" + T + "` of value `" + String(F) + "` " + ("supplied to `" + G + "`, expected one of " + H + "."));
      }
      return h(_);
    }
    function U(k) {
      function _(K, M, G, x, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var H in F)
          if (r(F, H)) {
            var B = k(F, H, G, x, T + "." + H, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return h(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var _ = 0; _ < k.length; _++) {
        var K = k[_];
        if (typeof K != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(K) + " at index " + _ + "."
          ), s;
      }
      function M(G, x, T, F, j) {
        for (var H = [], B = 0; B < k.length; B++) {
          var Q = k[B], W = Q(G, x, T, F, j, n);
          if (W == null)
            return null;
          W.data && r(W.data, "expectedType") && H.push(W.data.expectedType);
        }
        var ue = H.length > 0 ? ", expected one of type [" + H.join(", ") + "]" : "";
        return new g("Invalid " + F + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function N() {
      function k(_, K, M, G, x) {
        return $(_[K]) ? null : new g("Invalid " + G + " `" + x + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function A(k, _, K, M, G) {
      return new g(
        (k || "React class") + ": " + _ + " type `" + K + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function z(k) {
      function _(K, M, G, x, T) {
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var H in k) {
          var B = k[H];
          if (typeof B != "function")
            return A(G, x, T, H, Y(B));
          var Q = B(F, H, G, x, T + "." + H, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(_);
    }
    function V(k) {
      function _(K, M, G, x, T) {
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var H = t({}, K[M], k);
        for (var B in H) {
          var Q = k[B];
          if (r(k, B) && typeof Q != "function")
            return A(G, x, T, B, Y(Q));
          if (!Q)
            return new g(
              "Invalid " + x + " `" + T + "` key `" + B + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(K[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var W = Q(F, B, G, x, T + "." + B, n);
          if (W)
            return W;
        }
        return null;
      }
      return h(_);
    }
    function $(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every($);
          if (k === null || a(k))
            return !0;
          var _ = p(k);
          if (_) {
            var K = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = K.next()).done; )
                if (!$(M.value))
                  return !1;
            } else
              for (; !(M = K.next()).done; ) {
                var G = M.value;
                if (G && !$(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function J(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : Z(_, k) ? "symbol" : _;
    }
    function Y(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = J(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function te(k) {
      var _ = Y(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, Rh;
}
var Nh, Gx;
function CG() {
  if (Gx) return Nh;
  Gx = 1;
  var e = qy();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Nh = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Nh;
}
if (process.env.NODE_ENV !== "production") {
  var OG = S_(), EG = !0;
  xm.exports = wG()(OG.isElement, EG);
} else
  xm.exports = CG()();
var rf = xm.exports, of = {};
Object.defineProperty(of, "__esModule", {
  value: !0
});
var xG = Nl, Fh = LG(xG);
function LG(e) {
  return e && e.__esModule ? e : { default: e };
}
var DG = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Fh.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Fh.default.getHash() !== e && Fh.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
of.default = DG;
Object.defineProperty(Bl, "__esModule", {
  value: !0
});
var Vu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, PG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), kG = xe, Yx = $l(kG), SG = Il, Hu = $l(SG), MG = Ks, TG = $l(MG), jG = rf, Pn = $l(jG), _G = of, Zo = $l(_G);
function $l(e) {
  return e && e.__esModule ? e : { default: e };
}
function AG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function BG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function IG(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Xx = {
  to: Pn.default.string.isRequired,
  containerId: Pn.default.string,
  container: Pn.default.object,
  activeClass: Pn.default.string,
  activeStyle: Pn.default.object,
  spy: Pn.default.bool,
  horizontal: Pn.default.bool,
  smooth: Pn.default.oneOfType([Pn.default.bool, Pn.default.string]),
  offset: Pn.default.number,
  delay: Pn.default.number,
  isDynamic: Pn.default.bool,
  onClick: Pn.default.func,
  duration: Pn.default.oneOfType([Pn.default.number, Pn.default.func]),
  absolute: Pn.default.bool,
  onSetActive: Pn.default.func,
  onSetInactive: Pn.default.func,
  ignoreCancelEvents: Pn.default.bool,
  hashSpy: Pn.default.bool,
  saveHashHistory: Pn.default.bool,
  spyThrottle: Pn.default.number
};
Bl.default = function(e, t) {
  var n = t || TG.default, r = function(i) {
    IG(s, i);
    function s(a) {
      AG(this, s);
      var l = BG(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return PG(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          Hu.default.isMounted(a) || Hu.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Zo.default.isMounted() || Zo.default.mount(n), Zo.default.mapContainer(this.props.to, a)), Hu.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Hu.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Vu({}, this.props.style, this.props.activeStyle) : l = Vu({}, this.props.style);
        var u = Vu({}, this.props);
        for (var c in Xx)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, Yx.default.createElement(e, u);
      }
    }]), s;
  }(Yx.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Vu({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Zo.default.isMounted() && !Zo.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var C = l.getBoundingClientRect();
            h = C.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var S = s - i.props.offset;
          d = S >= Math.floor(f) && S < Math.floor(g), m = S < Math.floor(f) || S >= Math.floor(g);
        } else {
          var E = 0, v = 0, O = 0;
          if (l.getBoundingClientRect) {
            var P = l.getBoundingClientRect();
            O = P.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var U = p.getBoundingClientRect();
            E = U.top - O + a, v = E + U.height;
          }
          var L = a - i.props.offset;
          d = L >= Math.floor(E) && L < Math.floor(v), m = L < Math.floor(E) || L >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (m) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Zo.default.getHash() === c) {
            var A = i.props.saveHashHistory, z = A === void 0 ? !1 : A;
            Zo.default.changeHash("", z);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, $ = V === void 0 ? !1 : V;
          i.props.hashSpy && Zo.default.changeHash(c, $), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = Xx, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty($y, "__esModule", {
  value: !0
});
var RG = xe, Jx = T_(RG), NG = Bl, FG = T_(NG);
function T_(e) {
  return e && e.__esModule ? e : { default: e };
}
function zG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Qx(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function $G(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var UG = function(e) {
  $G(t, e);
  function t() {
    var n, r, o, i;
    zG(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = Qx(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return Jx.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), Qx(o, i);
  }
  return t;
}(Jx.default.Component);
$y.default = (0, FG.default)(UG);
var Zy = {};
Object.defineProperty(Zy, "__esModule", {
  value: !0
});
var WG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), VG = xe, eL = j_(VG), HG = Bl, qG = j_(HG);
function j_(e) {
  return e && e.__esModule ? e : { default: e };
}
function ZG(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KG(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function GG(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var YG = function(e) {
  GG(t, e);
  function t() {
    return ZG(this, t), KG(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return WG(t, [{
    key: "render",
    value: function() {
      return eL.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(eL.default.Component);
Zy.default = (0, qG.default)(YG);
var Ky = {}, sf = {};
Object.defineProperty(sf, "__esModule", {
  value: !0
});
var XG = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, JG = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), QG = xe, tL = af(QG), eY = wl;
af(eY);
var tY = Ks, nL = af(tY), nY = rf, rL = af(nY);
function af(e) {
  return e && e.__esModule ? e : { default: e };
}
function rY(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function oY(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function iY(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
sf.default = function(e) {
  var t = function(n) {
    iY(r, n);
    function r(o) {
      rY(this, r);
      var i = oY(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return JG(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        nL.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        nL.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return tL.default.createElement(e, XG({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(tL.default.Component);
  return t.propTypes = {
    name: rL.default.string,
    id: rL.default.string
  }, t;
};
Object.defineProperty(Ky, "__esModule", {
  value: !0
});
var oL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, sY = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), aY = xe, iL = Gy(aY), lY = sf, uY = Gy(lY), cY = rf, sL = Gy(cY);
function Gy(e) {
  return e && e.__esModule ? e : { default: e };
}
function pY(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function dY(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function fY(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var __ = function(e) {
  fY(t, e);
  function t() {
    return pY(this, t), dY(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return sY(t, [{
    key: "render",
    value: function() {
      var n = this, r = oL({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, iL.default.createElement(
        "div",
        oL({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(iL.default.Component);
__.propTypes = {
  name: sL.default.string,
  id: sL.default.string
};
Ky.default = (0, uY.default)(__);
var zh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, aL = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function lL(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cL(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qu = xe, Ui = Il, $h = Ks, zn = rf, Ko = of, pL = {
  to: zn.string.isRequired,
  containerId: zn.string,
  container: zn.object,
  activeClass: zn.string,
  spy: zn.bool,
  smooth: zn.oneOfType([zn.bool, zn.string]),
  offset: zn.number,
  delay: zn.number,
  isDynamic: zn.bool,
  onClick: zn.func,
  duration: zn.oneOfType([zn.number, zn.func]),
  absolute: zn.bool,
  onSetActive: zn.func,
  onSetInactive: zn.func,
  ignoreCancelEvents: zn.bool,
  hashSpy: zn.bool,
  spyThrottle: zn.number
}, hY = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || $h, r = function(i) {
      cL(s, i);
      function s(a) {
        lL(this, s);
        var l = uL(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return aL(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Ui.isMounted(a) || Ui.mount(a, this.props.spyThrottle), this.props.hashSpy && (Ko.isMounted() || Ko.mount(n), Ko.mapContainer(this.props.to, a)), this.props.spy && Ui.addStateHandler(this.stateHandler), Ui.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ui.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = zh({}, this.props);
          for (var u in pL)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, qu.createElement(e, l);
        }
      }]), s;
    }(qu.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, zh({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Ko.isMounted() && !Ko.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            d = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + s, p = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(p), C = g < Math.floor(c) || g >= Math.floor(p), w = n.getActiveLink();
          if (C)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Ko.getHash() === l && Ko.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ui.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Ko.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ui.updateStates();
        }
      };
    };
    return r.propTypes = pL, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      cL(r, n);
      function r(o) {
        lL(this, r);
        var i = uL(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return aL(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          $h.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          $h.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return qu.createElement(e, zh({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(qu.Component);
    return t.propTypes = {
      name: zn.string,
      id: zn.string
    }, t;
  }
}, gY = hY;
Object.defineProperty(Zn, "__esModule", {
  value: !0
});
Zn.Helpers = Zn.ScrollElement = Zn.ScrollLink = Zn.animateScroll = Zn.scrollSpy = Zn.Events = Zn.scroller = Zn.Element = Zn.Button = Zn.Link = void 0;
var mY = $y, A_ = wo(mY), vY = Zy, B_ = wo(vY), yY = Ky, I_ = wo(yY), bY = Ks, R_ = wo(bY), wY = Fl, N_ = wo(wY), CY = Il, F_ = wo(CY), OY = ef, z_ = wo(OY), EY = Bl, $_ = wo(EY), xY = sf, U_ = wo(xY), LY = gY, W_ = wo(LY);
function wo(e) {
  return e && e.__esModule ? e : { default: e };
}
Zn.Link = A_.default;
Zn.Button = B_.default;
Zn.Element = I_.default;
Zn.scroller = R_.default;
Zn.Events = N_.default;
Zn.scrollSpy = F_.default;
Zn.animateScroll = z_.default;
Zn.ScrollLink = $_.default;
Zn.ScrollElement = U_.default;
Zn.Helpers = W_.default;
Zn.default = { Link: A_.default, Button: B_.default, Element: I_.default, scroller: R_.default, Events: N_.default, scrollSpy: F_.default, animateScroll: z_.default, ScrollLink: $_.default, ScrollElement: U_.default, Helpers: W_.default };
qe({});
qe({});
qe({});
function hl(e) {
  "@babel/helpers - typeof";
  return hl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, hl(e);
}
function DY(e, t) {
  if (hl(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (hl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function PY(e) {
  var t = DY(e, "string");
  return hl(t) == "symbol" ? t : t + "";
}
function ge(e, t, n) {
  return (t = PY(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function V_(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Uh, dL;
function kY() {
  if (dL) return Uh;
  dL = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, s, a, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Uh = t, Uh;
}
var SY = kY(), Qn = /* @__PURE__ */ V_(SY), at = qe(null);
function MY() {
  Qn(!!De, "useGoogleMap is React hook and requires React version 16.8+");
  var e = De(at);
  return Qn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function TY(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function jY(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function _Y(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return jY(e, i), o;
}
function AY(e, t, n) {
  var r = TY(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function BY(e) {
  google.maps.event.removeListener(e);
}
function _t() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(BY);
}
function Pt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = AY(o, i, n);
  return _Y(t, r, o, i), s;
}
function IY(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: E
  } = e, [v, O] = D(null), P = Ye(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null), [B, Q] = D(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && p && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), y(() => {
    v && g && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(v, "mousedown", g)));
  }, [g]), y(() => {
    v && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), y(() => {
    v && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(v, "mouseout", m)));
  }, [m]), y(() => {
    v && f && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (B !== null && google.maps.event.removeListener(B), Q(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var W = P.current === null ? null : new google.maps.Map(P.current, n);
    return O(W), W !== null && S && S(W), () => {
      W !== null && E && E(W);
    };
  }, []), Xt.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: Xt.jsx(at.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
ke(IY);
function fL(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function H_(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        fL(i, r, o, s, a, "next", l);
      }
      function a(l) {
        fL(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function q_(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Qn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var os = typeof document < "u";
function Z_(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return os ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function hL(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function K_() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return hL(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return hL(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var fa = !1;
function G_() {
  return Xt.jsx("div", {
    children: "Loading..."
  });
}
var Lm = {
  id: "script-loader",
  version: "weekly"
};
class RY extends Oe {
  constructor() {
    super(...arguments), ge(this, "check", cr()), ge(this, "state", {
      loaded: !1
    }), ge(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ge(this, "isCleaningUp", /* @__PURE__ */ H_(function* () {
      function t(n) {
        if (!fa)
          n();
        else if (os)
          var r = window.setInterval(function() {
            fa || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ge(this, "cleanup", () => {
      fa = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ge(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && K_(), Qn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: q_(this.props)
      };
      Z_(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (os) {
      if (window.google && window.google.maps && !fa) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), os && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (os) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, fa = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Xt.jsxs(Xt.Fragment, {
      children: [Xt.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Xt.jsx(G_, {})]
    });
  }
}
ge(RY, "defaultProps", Lm);
function NY(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Yy(e, t) {
  if (e == null) return {};
  var n, r, o = NY(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var gL;
function FY(e) {
  var {
    id: t = Lm.id,
    version: n = Lm.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Ye(!1), [f, g] = D(!1), [h, C] = D(void 0);
  y(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), y(function() {
    os && u && K_();
  }, [u]), y(function() {
    f && Qn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = q_({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  y(function() {
    if (!os)
      return;
    function E() {
      m.current && (g(!0), gL = w);
    }
    if (window.google && window.google.maps && gL === w) {
      E();
      return;
    }
    Z_({
      id: t,
      url: w,
      nonce: r
    }).then(E).catch(function(v) {
      m.current && C(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var S = Ye();
  return y(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var zY = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], $Y = Xt.jsx(G_, {});
function UY(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = Yy(e, zY), {
    isLoaded: a,
    loadError: l
  } = FY(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || $Y;
}
ke(UY);
var mL;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(mL || (mL = {}));
function vL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yL = {}, bL = {
  options(e, t) {
    e.setOptions(t);
  }
};
function WY(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = De(at), [i, s] = D(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(vp(vp({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(WY);
class VY extends Oe {
  constructor() {
    super(...arguments), ge(this, "state", {
      trafficLayer: null
    }), ge(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(vp(vp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pt({
      updaterMap: bL,
      eventMap: yL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: bL,
      eventMap: yL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), _t(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(VY, "contextType", at);
function HY(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = De(at), [o, i] = D(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
ke(HY);
class qY extends Oe {
  constructor() {
    super(...arguments), ge(this, "state", {
      bicyclingLayer: null
    }), ge(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(qY, "contextType", at);
function ZY(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = De(at), [o, i] = D(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(ZY);
class KY extends Oe {
  constructor() {
    super(...arguments), ge(this, "state", {
      transitLayer: null
    }), ge(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(KY, "contextType", at);
function wL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CL = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, OL = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function GY(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = De(at), [d, m] = D(null), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null);
  return y(() => {
    d !== null && d.setMap(p);
  }, [p]), y(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), y(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), y(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), y(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), y(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), y(() => {
    d && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), y(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), y(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), y(() => {
    Qn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(yp(yp({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && g(google.maps.event.addListener(N, "circlecomplete", r)), o && C(google.maps.event.addListener(N, "markercomplete", o)), i && S(google.maps.event.addListener(N, "overlaycomplete", i)), s && v(google.maps.event.addListener(N, "polygoncomplete", s)), a && P(google.maps.event.addListener(N, "polylinecomplete", a)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), m(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(GY);
class YY extends Oe {
  constructor(t) {
    super(t), ge(this, "registeredEvents", []), ge(this, "state", {
      drawingManager: null
    }), ge(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Qn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(yp(yp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pt({
      updaterMap: OL,
      eventMap: CL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: OL,
      eventMap: CL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), _t(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ge(YY, "contextType", at);
function EL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ss(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? EL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xL = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, LL = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, bp = {};
function XY(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: S,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: O,
    onMouseOver: P,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: A,
    onCursorChanged: z,
    onAnimationChanged: V,
    onDraggableChanged: $,
    onFlatChanged: Z,
    onIconChanged: J,
    onPositionChanged: Y,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: K,
    onUnmount: M
  } = e, G = De(at), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null), [Q, W] = D(null), [ue, ye] = D(null), [oe, _e] = D(null), [Fe, ze] = D(null), [Re, Ge] = D(null), [Ze, Me] = D(null), [Ke, rt] = D(null), [Se, je] = D(null), [Ne, Ve] = D(null), [Ue, ot] = D(null), [Te, Zt] = D(null), [lt, ht] = D(null), [kt, sn] = D(null), [St, an] = D(null), [tt, Nt] = D(null), [ut, ln] = D(null), [Mt, Mn] = D(null), [un, Tn] = D(null), [cn, jn] = D(null);
  y(() => {
    x !== null && x.setMap(G);
  }, [G]), y(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), y(() => {
    typeof s < "u" && x !== null && x.setDraggable(s);
  }, [x, s]), y(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), y(() => {
    typeof a < "u" && x !== null && x.setVisible(a);
  }, [x, a]), y(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), y(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), y(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), y(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), y(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), y(() => {
    x && m !== void 0 && x.setOpacity(m);
  }, [x, m]), y(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), y(() => {
    x && g !== void 0 && x.setTitle(g);
  }, [x, g]), y(() => {
    x && h !== void 0 && x.setZIndex(h);
  }, [x, h]), y(() => {
    x && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), y(() => {
    x && E && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(x, "dragend", E)));
  }, [E]), y(() => {
    x && v && (Q !== null && google.maps.event.removeListener(Q), W(google.maps.event.addListener(x, "dragstart", v)));
  }, [v]), y(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), y(() => {
    x && O && (oe !== null && google.maps.event.removeListener(oe), _e(google.maps.event.addListener(x, "mouseout", O)));
  }, [O]), y(() => {
    x && P && (Fe !== null && google.maps.event.removeListener(Fe), ze(google.maps.event.addListener(x, "mouseover", P)));
  }, [P]), y(() => {
    x && U && (Re !== null && google.maps.event.removeListener(Re), Ge(google.maps.event.addListener(x, "mouseup", U)));
  }, [U]), y(() => {
    x && N && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), y(() => {
    x && C && (Ke !== null && google.maps.event.removeListener(Ke), rt(google.maps.event.addListener(x, "click", C)));
  }, [C]), y(() => {
    x && S && (Se !== null && google.maps.event.removeListener(Se), je(google.maps.event.addListener(x, "drag", S)));
  }, [S]), y(() => {
    x && A && (Ne !== null && google.maps.event.removeListener(Ne), Ve(google.maps.event.addListener(x, "clickable_changed", A)));
  }, [A]), y(() => {
    x && z && (Ue !== null && google.maps.event.removeListener(Ue), ot(google.maps.event.addListener(x, "cursor_changed", z)));
  }, [z]), y(() => {
    x && V && (Te !== null && google.maps.event.removeListener(Te), Zt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), y(() => {
    x && $ && (lt !== null && google.maps.event.removeListener(lt), ht(google.maps.event.addListener(x, "draggable_changed", $)));
  }, [$]), y(() => {
    x && Z && (kt !== null && google.maps.event.removeListener(kt), sn(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), y(() => {
    x && J && (St !== null && google.maps.event.removeListener(St), an(google.maps.event.addListener(x, "icon_changed", J)));
  }, [J]), y(() => {
    x && Y && (tt !== null && google.maps.event.removeListener(tt), Nt(google.maps.event.addListener(x, "position_changed", Y)));
  }, [Y]), y(() => {
    x && te && (ut !== null && google.maps.event.removeListener(ut), ln(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), y(() => {
    x && ee && (Mt !== null && google.maps.event.removeListener(Mt), Mn(google.maps.event.addListener(x, "title_changed", ee)));
  }, [ee]), y(() => {
    x && k && (un !== null && google.maps.event.removeListener(un), Tn(google.maps.event.addListener(x, "visible_changed", k)));
  }, [k]), y(() => {
    x && _ && (cn !== null && google.maps.event.removeListener(cn), jn(google.maps.event.addListener(x, "zindex_changed", _)));
  }, [_]), y(() => {
    var Ft = Ss(Ss(Ss({}, n || bp), r ? bp : {
      map: G
    }), {}, {
      position: t
    }), ie = new google.maps.Marker(Ft);
    return r ? r.addMarker(ie, !!o) : ie.setMap(G), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof m < "u" && ie.setOpacity(m), f && ie.setShape(f), typeof g == "string" && ie.setTitle(g), typeof h == "number" && ie.setZIndex(h), w && j(google.maps.event.addListener(ie, "dblclick", w)), E && B(google.maps.event.addListener(ie, "dragend", E)), v && W(google.maps.event.addListener(ie, "dragstart", v)), L && ye(google.maps.event.addListener(ie, "mousedown", L)), O && _e(google.maps.event.addListener(ie, "mouseout", O)), P && ze(google.maps.event.addListener(ie, "mouseover", P)), U && Ge(google.maps.event.addListener(ie, "mouseup", U)), N && Me(google.maps.event.addListener(ie, "rightclick", N)), C && rt(google.maps.event.addListener(ie, "click", C)), S && je(google.maps.event.addListener(ie, "drag", S)), A && Ve(google.maps.event.addListener(ie, "clickable_changed", A)), z && ot(google.maps.event.addListener(ie, "cursor_changed", z)), V && Zt(google.maps.event.addListener(ie, "animation_changed", V)), $ && ht(google.maps.event.addListener(ie, "draggable_changed", $)), Z && sn(google.maps.event.addListener(ie, "flat_changed", Z)), J && an(google.maps.event.addListener(ie, "icon_changed", J)), Y && Nt(google.maps.event.addListener(ie, "position_changed", Y)), te && ln(google.maps.event.addListener(ie, "shape_changed", te)), ee && Mn(google.maps.event.addListener(ie, "title_changed", ee)), k && Tn(google.maps.event.addListener(ie, "visible_changed", k)), _ && jn(google.maps.event.addListener(ie, "zindex_changed", _)), T(ie), K && K(ie), () => {
      F !== null && google.maps.event.removeListener(F), H !== null && google.maps.event.removeListener(H), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), Ze !== null && google.maps.event.removeListener(Ze), Ke !== null && google.maps.event.removeListener(Ke), Ne !== null && google.maps.event.removeListener(Ne), Ue !== null && google.maps.event.removeListener(Ue), Te !== null && google.maps.event.removeListener(Te), lt !== null && google.maps.event.removeListener(lt), kt !== null && google.maps.event.removeListener(kt), St !== null && google.maps.event.removeListener(St), tt !== null && google.maps.event.removeListener(tt), Mt !== null && google.maps.event.removeListener(Mt), un !== null && google.maps.event.removeListener(un), cn !== null && google.maps.event.removeListener(cn), M && M(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var Yn = Gn(() => i ? Ct.map(i, (Ft) => {
    if (!mi(Ft))
      return Ft;
    var ie = Ft;
    return vi(ie, {
      anchor: x
    });
  }) : null, [i, x]);
  return Xt.jsx(Xt.Fragment, {
    children: Yn
  }) || null;
}
ke(XY);
class JY extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return H_(function* () {
      var n = Ss(Ss(Ss({}, t.props.options || bp), t.props.clusterer ? bp : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = Pt({
        updaterMap: LL,
        eventMap: xL,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: LL,
      eventMap: xL,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), _t(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ct.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ge(JY, "contextType", at);
var QY = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), eX = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new QY(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function tX(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var nX = 2e3, rX = 500, oX = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", iX = "png", sX = [53, 56, 66, 78, 90], aX = "cluster", Y_ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || oX, this.imageExtension = r.imageExtension || iX, this.imageSizes = r.imageSizes || sX, this.calculator = r.calculator || tX, this.batchSize = r.batchSize || nX, this.batchSizeIE = r.batchSizeIE || rX, this.clusterClass = r.clusterClass || aX, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new eX(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function DL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lX(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, It = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, uX = {};
function cX(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: O,
    onLoad: P,
    onUnmount: U
  } = e, [L, N] = D(null), A = De(at), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null);
  return y(() => {
    L && O && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, Yr.onMouseOut, O)));
  }, [O]), y(() => {
    L && v && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, Yr.onMouseOver, v)));
  }, [v]), y(() => {
    L && w && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(L, Yr.onClick, w)));
  }, [w]), y(() => {
    L && S && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(L, Yr.onClusteringBegin, S)));
  }, [S]), y(() => {
    L && E && (J !== null && google.maps.event.removeListener(J), Z(google.maps.event.addListener(L, Yr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && L !== null && It.averageCenter(L, r);
  }, [L, r]), y(() => {
    typeof o < "u" && L !== null && It.batchSizeIE(L, o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && It.calculator(L, i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && It.clusterClass(L, s);
  }, [L, s]), y(() => {
    typeof a < "u" && L !== null && It.enableRetinaIcons(L, a);
  }, [L, a]), y(() => {
    typeof l < "u" && L !== null && It.gridSize(L, l);
  }, [L, l]), y(() => {
    typeof u < "u" && L !== null && It.ignoreHidden(L, u);
  }, [L, u]), y(() => {
    typeof c < "u" && L !== null && It.imageExtension(L, c);
  }, [L, c]), y(() => {
    typeof p < "u" && L !== null && It.imagePath(L, p);
  }, [L, p]), y(() => {
    typeof d < "u" && L !== null && It.imageSizes(L, d);
  }, [L, d]), y(() => {
    typeof m < "u" && L !== null && It.maxZoom(L, m);
  }, [L, m]), y(() => {
    typeof f < "u" && L !== null && It.minimumClusterSize(L, f);
  }, [L, f]), y(() => {
    typeof g < "u" && L !== null && It.styles(L, g);
  }, [L, g]), y(() => {
    typeof h < "u" && L !== null && It.title(L, h);
  }, [L, h]), y(() => {
    typeof C < "u" && L !== null && It.zoomOnClick(L, C);
  }, [L, C]), y(() => {
    if (A) {
      var K = lX({}, n || uX), M = new Y_(A, [], K);
      return r && It.averageCenter(M, r), o && It.batchSizeIE(M, o), i && It.calculator(M, i), s && It.clusterClass(M, s), a && It.enableRetinaIcons(M, a), l && It.gridSize(M, l), u && It.ignoreHidden(M, u), c && It.imageExtension(M, c), p && It.imagePath(M, p), d && It.imageSizes(M, d), m && It.maxZoom(M, m), f && It.minimumClusterSize(M, f), g && It.styles(M, g), h && It.title(M, h), C && It.zoomOnClick(M, C), O && ee(google.maps.event.addListener(M, Yr.onMouseOut, O)), v && _(google.maps.event.addListener(M, Yr.onMouseOver, v)), w && V(google.maps.event.addListener(M, Yr.onClick, w)), S && Z(google.maps.event.addListener(M, Yr.onClusteringBegin, S)), E && Y(google.maps.event.addListener(M, Yr.onClusteringEnd, E)), N(M), P && P(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ke(cX);
class pX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      markerClusterer: null
    }), ge(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Y_(this.context, [], this.props.options);
      this.registeredEvents = Pt({
        updaterMap: It,
        eventMap: Yr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: It,
      eventMap: Yr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), _t(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ge(pX, "contextType", at);
function PL(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var X_ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || PL(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, PL));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), dX = ["position"], fX = ["position"];
function kL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SL = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, ML = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, hX = {};
function gX(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = De(at), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), N = Ye(null);
  return y(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var A = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(A);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (m) {
      var A = r || hX, {
        position: z
      } = A, V = Yy(A, dX), $;
      z && !(z instanceof google.maps.LatLng) && ($ = new google.maps.LatLng(z.lat, z.lng));
      var Z = new X_(wp(wp({}, V), $ ? {
        position: $
      } : {}));
      N.current = document.createElement("div"), g(Z), s && C(google.maps.event.addListener(Z, "closeclick", s)), a && S(google.maps.event.addListener(Z, "domready", a)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(m, n) : Z.getPosition() ? Z.open(m) : Qn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? pr(Ct.only(t), N.current) : null;
}
ke(gX);
class mX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", null), ge(this, "state", {
      infoBox: null
    }), ge(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Qn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ge(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Yy(t, fX), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new X_(wp(wp({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Pt({
      updaterMap: ML,
      eventMap: SL,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: ML,
      eventMap: SL,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), _t(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? pr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
ge(mX, "contextType", at);
var TL, jL;
function vX() {
  return jL || (jL = 1, TL = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), TL;
}
var yX = vX(), _L = /* @__PURE__ */ V_(yX), AL = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Wh = 1, ha = 8;
class Xy {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Wh)
      throw new Error("Got v".concat(o, " data when expected v").concat(Wh, "."));
    var i = AL[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Xy(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = AL.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ha, t), this.coords = new this.ArrayType(this.data, ha + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ha + s + a + l), this.ids = new this.IndexArrayType(this.data, ha, t), this.coords = new this.ArrayType(this.data, ha + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Wh << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Dm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          BL(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      BL(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Dm(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    J_(e, t, s, r, o, i), Dm(e, t, n, r, s - 1, 1 - i), Dm(e, t, n, s + 1, o, 1 - i);
  }
}
function J_(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      J_(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (ga(e, t, r, n), t[2 * o + i] > m && ga(e, t, r, o); f < g; ) {
      for (ga(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? ga(e, t, r, g) : (g++, ga(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function ga(e, t, n, r) {
  Vh(e, n, r), Vh(t, 2 * n, 2 * r), Vh(t, 2 * n + 1, 2 * r + 1);
}
function Vh(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function BL(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var bX = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, IL = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Wi = 2, oi = 3, Hh = 4, ei = 5, Q_ = 6;
class wX {
  constructor(t) {
    this.options = Object.assign(Object.create(bX), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = IL(Zu(u)), d = IL(Ku(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Zu(r), Ku(s), Zu(i), Ku(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + ei] > 1 ? RL(p, f, this.clusterProps) : this.points[p[f + oi]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + Hh] === t && p.push(s[m + ei] > 1 ? RL(s, m, this.clusterProps) : this.points[s[m + oi]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Xy(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + ei] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = eA(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + oi]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = Zu(f), d = Ku(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + oi] : C = this.points[n[l + oi]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Wi] <= n)) {
        l[p + Wi] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + ei], h = g;
        for (var C of f) {
          var w = C * c;
          l[w + Wi] > n && (h += l[w + ei]);
        }
        if (h > g && h >= s) {
          var S = d * g, E = m * g, v = void 0, O = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + Wi] <= n)) {
              l[L + Wi] = n;
              var N = l[L + ei];
              S += l[L] * N, E += l[L + 1] * N, l[L + Hh] = P, i && (v || (v = this._map(l, p, !0), O = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + Hh] = P, u.push(S / h, E / h, 1 / 0, P, -1, h), i && u.push(O);
        } else {
          for (var A = 0; A < c; A++) u.push(l[p + A]);
          if (h > 1)
            for (var z of f) {
              var V = z * c;
              if (!(l[V + Wi] <= n)) {
                l[V + Wi] = n;
                for (var $ = 0; $ < c; $++) u.push(l[V + $]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ei] > 1) {
      var o = this.clusterProps[t[n + Q_]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + oi]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function RL(e, t, n) {
  return {
    type: "Feature",
    id: e[t + oi],
    properties: eA(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [CX(e[t]), OX(e[t + 1])]
    }
  };
}
function eA(e, t, n) {
  var r = e[t + ei], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Q_], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + oi],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Zu(e) {
  return e / 360 + 0.5;
}
function Ku(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function CX(e) {
  return (e - 0.5) * 360;
}
function OX(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function EX(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Rr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Pm {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Rr.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Rr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Rr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class xX {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return LX(n);
  }
}
var LX = (e) => {
  var t = e.map((n) => new Pm({
    position: Rr.getPosition(n),
    markers: [n]
  }));
  return t;
};
class DX extends xX {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = EX(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new wX(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!_L(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = Rr.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !_L(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Pm({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Pm({
      markers: [i],
      position: Rr.getPosition(i)
    });
  }
}
class PX {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class kX {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Rr.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function SX(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Jy {
  constructor() {
    SX(Jy, google.maps.OverlayView);
  }
}
var Ua;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Ua || (Ua = {}));
var MX = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class TX extends Jy {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new DX(o),
      renderer: s = new kX(),
      onClusterClick: a = MX
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Rr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Ua.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Rr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => Rr.setMap(l, null)));
      }
      google.maps.event.trigger(this, Ua.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Rr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new PX(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Rr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Ua.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Rr.setMap(r.marker, n);
    });
  }
}
function NL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function jX(e) {
  var t = MY(), [n, r] = D(null);
  return y(() => {
    if (t && n === null) {
      var o = new TX(FL(FL({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function _X(e) {
  var {
    children: t,
    options: n
  } = e, r = jX(n);
  return r !== null ? t(r) : null;
}
ke(_X);
var zL = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, $L = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function AX(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = De(at), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), N = Ye(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var A = new google.maps.InfoWindow(r);
    return g(A), N.current = document.createElement("div"), s && C(google.maps.event.addListener(A, "closeclick", s)), a && S(google.maps.event.addListener(A, "domready", a)), l && v(google.maps.event.addListener(A, "content_changed", l)), u && P(google.maps.event.addListener(A, "position_changed", u)), c && L(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(N.current), o && A.setPosition(o), i && A.setZIndex(i), n ? A.open(m, n) : A.getPosition() ? A.open(m) : Qn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(A), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), d && d(A), A.close();
    };
  }, []), N.current ? pr(Ct.only(t), N.current) : null;
}
ke(AX);
class BX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", null), ge(this, "state", {
      infoWindow: null
    }), ge(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Qn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ge(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Pt({
      updaterMap: $L,
      eventMap: zL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: $L,
      eventMap: zL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (_t(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? pr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
ge(BX, "contextType", at);
function UL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WL = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, VL = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, IX = {};
function RX(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, S = De(at), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null);
  return y(() => {
    E !== null && E.setMap(S);
  }, [S]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && p && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(E, "mouseout", p)));
  }, [p]), y(() => {
    E && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(E, "mouseover", d)));
  }, [d]), y(() => {
    E && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(E, "mouseup", m)));
  }, [m]), y(() => {
    E && f && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && g && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && h && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var j = new google.maps.Polyline(Cp(Cp({}, t || IX), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && P(google.maps.event.addListener(j, "dblclick", s)), a && L(google.maps.event.addListener(j, "dragend", a)), l && A(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && Z(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), m && _(google.maps.event.addListener(j, "mouseup", m)), f && M(google.maps.event.addListener(j, "rightclick", f)), g && x(google.maps.event.addListener(j, "click", g)), h && F(google.maps.event.addListener(j, "drag", h)), v(j), C && C(j), () => {
      O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(RX);
class NX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      polyline: null
    }), ge(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Cp(Cp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pt({
      updaterMap: VL,
      eventMap: WL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: VL,
      eventMap: WL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), _t(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ge(NX, "contextType", at);
function HL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZL = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, KL = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function FX(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: S,
    onEdit: E
  } = e, v = De(at), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null);
  return y(() => {
    O !== null && O.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof s < "u" && O !== null && O.setPaths(s);
  }, [O, s]), y(() => {
    O && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof p == "function" && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(O, "mousemove", p)));
  }, [p]), y(() => {
    O && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseout", d)));
  }, [d]), y(() => {
    O && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(O, "mouseover", m)));
  }, [m]), y(() => {
    O && typeof f == "function" && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(O, "mouseup", f)));
  }, [f]), y(() => {
    O && typeof g == "function" && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(O, "click", h)));
  }, [h]), y(() => {
    O && typeof C == "function" && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(O, "drag", C)));
  }, [C]), y(() => {
    var B = new google.maps.Polygon(qL(qL({}, t), {}, {
      map: v
    }));
    return i && B.setPath(i), s && B.setPaths(s), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), a && L(google.maps.event.addListener(B, "dblclick", a)), l && A(google.maps.event.addListener(B, "dragend", l)), u && V(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && Y(google.maps.event.addListener(B, "mousemove", p)), d && ee(google.maps.event.addListener(B, "mouseout", d)), m && _(google.maps.event.addListener(B, "mouseover", m)), f && M(google.maps.event.addListener(B, "mouseup", f)), g && x(google.maps.event.addListener(B, "rightclick", g)), h && F(google.maps.event.addListener(B, "click", h)), C && H(google.maps.event.addListener(B, "drag", C)), P(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), T !== null && google.maps.event.removeListener(T), S && S(B), B.setMap(null);
    };
  }, []), null;
}
ke(FX);
class zX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = Pt({
      updaterMap: KL,
      eventMap: ZL,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: KL,
      eventMap: ZL,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), _t(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ge(zX, "contextType", at);
function GL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Op(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YL = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, XL = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function $X(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: S
  } = e, E = De(at), [v, O] = D(null), [P, U] = D(null), [L, N] = D(null), [A, z] = D(null), [V, $] = D(null), [Z, J] = D(null), [Y, te] = D(null), [ee, k] = D(null), [_, K] = D(null), [M, G] = D(null), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (P !== null && google.maps.event.removeListener(P), U(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (A !== null && google.maps.event.removeListener(A), z(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), J(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), te(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), y(() => {
    v && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), y(() => {
    v && m && (_ !== null && google.maps.event.removeListener(_), K(google.maps.event.addListener(v, "mouseup", m)));
  }, [m]), y(() => {
    v && f && (M !== null && google.maps.event.removeListener(M), G(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && g && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(v, "click", g)));
  }, [g]), y(() => {
    v && h && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var Q = new google.maps.Rectangle(Op(Op({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && N(google.maps.event.addListener(Q, "dragend", a)), l && z(google.maps.event.addListener(Q, "dragstart", l)), u && $(google.maps.event.addListener(Q, "mousedown", u)), c && J(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && K(google.maps.event.addListener(Q, "mouseup", m)), f && G(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && j(google.maps.event.addListener(Q, "drag", h)), C && B(google.maps.event.addListener(Q, "bounds_changed", C)), O(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), x !== null && google.maps.event.removeListener(x), F !== null && google.maps.event.removeListener(F), H !== null && google.maps.event.removeListener(H), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke($X);
class UX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      rectangle: null
    }), ge(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Op(Op({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pt({
      updaterMap: XL,
      eventMap: YL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: XL,
      eventMap: YL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), _t(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ge(UX, "contextType", at);
function JL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ep(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JL(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QL = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, eD = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, WX = {};
function VX(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: E,
    onUnmount: v
  } = e, O = De(at), [P, U] = D(null), [L, N] = D(null), [A, z] = D(null), [V, $] = D(null), [Z, J] = D(null), [Y, te] = D(null), [ee, k] = D(null), [_, K] = D(null), [M, G] = D(null), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null), [Q, W] = D(null), [ue, ye] = D(null);
  return y(() => {
    P !== null && P.setMap(O);
  }, [O]), y(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), y(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), y(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), y(() => {
    typeof s < "u" && P !== null && P.setVisible(s);
  }, [P, s]), y(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), y(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), y(() => {
    P && a && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", a)));
  }, [a]), y(() => {
    P && l && (A !== null && google.maps.event.removeListener(A), z(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), y(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), y(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), J(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), y(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), y(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), y(() => {
    P && m && (_ !== null && google.maps.event.removeListener(_), K(google.maps.event.addListener(P, "mouseover", m)));
  }, [m]), y(() => {
    P && f && (M !== null && google.maps.event.removeListener(M), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), y(() => {
    P && g && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(P, "rightclick", g)));
  }, [g]), y(() => {
    P && h && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), y(() => {
    P && C && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(P, "drag", C)));
  }, [C]), y(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), W(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), y(() => {
    P && S && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), y(() => {
    var oe = new google.maps.Circle(Ep(Ep({}, t || WX), {}, {
      map: O
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && N(google.maps.event.addListener(oe, "dblclick", a)), l && z(google.maps.event.addListener(oe, "dragend", l)), u && $(google.maps.event.addListener(oe, "dragstart", u)), c && J(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && K(google.maps.event.addListener(oe, "mouseover", m)), f && G(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && j(google.maps.event.addListener(oe, "click", h)), C && B(google.maps.event.addListener(oe, "drag", C)), w && W(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), U(oe), E && E(oe), () => {
      L !== null && google.maps.event.removeListener(L), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), x !== null && google.maps.event.removeListener(x), F !== null && google.maps.event.removeListener(F), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(VX);
class HX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      circle: null
    }), ge(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Ep(Ep({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pt({
      updaterMap: eD,
      eventMap: QL,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: eD,
      eventMap: QL,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), _t(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ge(HX, "contextType", at);
function tD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tD(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nD = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, rD = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function qX(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, C = De(at), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && p && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), y(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), y(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), y(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var B = new google.maps.Data(xp(xp({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(B, "dblclick", r)), o && P(google.maps.event.addListener(B, "mousedown", o)), i && L(google.maps.event.addListener(B, "mousemove", i)), s && A(google.maps.event.addListener(B, "mouseout", s)), a && V(google.maps.event.addListener(B, "mouseover", a)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && Y(google.maps.event.addListener(B, "rightclick", u)), n && ee(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && x(google.maps.event.addListener(B, "removeproperty", d)), m && F(google.maps.event.addListener(B, "setgeometry", m)), f && H(google.maps.event.addListener(B, "setproperty", f)), S(B), g && g(B);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(qX);
class ZX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      data: null
    }), ge(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(xp(xp({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Pt({
        updaterMap: rD,
        eventMap: nD,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: rD,
      eventMap: nD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), _t(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ge(ZX, "contextType", at);
function oD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oD(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sD = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, aD = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class KX extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      kmlLayer: null
    }), ge(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(iD(iD({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pt({
      updaterMap: aD,
      eventMap: sD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: aD,
      eventMap: sD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), _t(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(KX, "contextType", at);
function tA(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function GX(e, t) {
  return new t(e.lat, e.lng);
}
function YX(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function XX(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function JX(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function QX(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function eJ(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function nA(e, t, n, r) {
  return n !== void 0 ? QX(e, t, JX(n, google.maps.LatLngBounds, YX)) : eJ(e, t, XX(r, google.maps.LatLng, GX));
}
function tJ(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function lD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lD(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function rJ(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = nJ({}, this.container ? tA(this.container, o) : {
        x: 0,
        y: 0
      }), u = nA(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function uD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uD(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function cD(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function pD(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function iJ(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = De(at), c = Gn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Gn(() => rJ(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ke(iJ);
class Gs extends Oe {
  constructor(t) {
    super(t), ge(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ge(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Qn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ge(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ge(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = oJ({
        x: 0,
        y: 0
      }, this.containerRef.current ? tA(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = nA(r, o, this.props.bounds, this.props.position);
      if (!tJ(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ge(this, "draw", () => {
      this.onPositionElement();
    }), ge(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = cr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = cD(t.position), r = cD(this.props.position), o = pD(t.bounds), i = pD(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(Xt.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ct.only(this.props.children)
    }), t) : null;
  }
}
ge(Gs, "FLOAT_PANE", "floatPane");
ge(Gs, "MAP_PANE", "mapPane");
ge(Gs, "MARKER_LAYER", "markerLayer");
ge(Gs, "OVERLAY_LAYER", "overlayLayer");
ge(Gs, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ge(Gs, "contextType", at);
function sJ() {
}
function dD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dD(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hD = {
  onDblClick: "dblclick",
  onClick: "click"
}, gD = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function aJ(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = De(at), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Gn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
ke(aJ);
class rA extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      groundOverlay: null
    }), ge(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Qn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, fD(fD({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Pt({
      updaterMap: gD,
      eventMap: hD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: gD,
      eventMap: hD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ge(rA, "defaultProps", {
  onLoad: sJ
});
ge(rA, "contextType", at);
function mD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mD(Object(n), !0).forEach(function(r) {
      ge(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vD = {}, yD = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function lJ(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = De(at), [s, a] = D(null);
  return y(() => {
    google.maps.visualization || Qn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Qn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(Lp(Lp({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
ke(lJ);
class uJ extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      heatmapLayer: null
    }), ge(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Qn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Qn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Lp(Lp({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Pt({
      updaterMap: yD,
      eventMap: vD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    _t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: yD,
      eventMap: vD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), _t(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(uJ, "contextType", at);
var bD = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, wD = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class cJ extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      streetViewPanorama: null
    }), ge(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = Pt({
      updaterMap: wD,
      eventMap: bD,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: wD,
      eventMap: bD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), _t(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ge(cJ, "contextType", at);
class pJ extends Oe {
  constructor() {
    super(...arguments), ge(this, "state", {
      streetViewService: null
    }), ge(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ge(pJ, "contextType", at);
var CD = {
  onDirectionsChanged: "directions_changed"
}, OD = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class dJ extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "state", {
      directionsRenderer: null
    }), ge(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Pt({
      updaterMap: OD,
      eventMap: CD,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: OD,
      eventMap: CD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), _t(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ge(dJ, "contextType", at);
var ED = {
  onPlacesChanged: "places_changed"
}, xD = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class fJ extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", cr()), ge(this, "state", {
      searchBox: null
    }), ge(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Qn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = Pt({
          updaterMap: xD,
          eventMap: ED,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (_t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: xD,
      eventMap: ED,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), _t(this.registeredEvents));
  }
  render() {
    return Xt.jsx("div", {
      ref: this.containerElement,
      children: Ct.only(this.props.children)
    });
  }
}
ge(fJ, "contextType", at);
var LD = {
  onPlaceChanged: "place_changed"
}, DD = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class oA extends Oe {
  constructor() {
    super(...arguments), ge(this, "registeredEvents", []), ge(this, "containerElement", cr()), ge(this, "state", {
      autocomplete: null
    }), ge(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Qn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Pt({
        updaterMap: DD,
        eventMap: LD,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    _t(this.registeredEvents), this.registeredEvents = Pt({
      updaterMap: DD,
      eventMap: LD,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && _t(this.registeredEvents);
  }
  render() {
    return Xt.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ct.only(this.props.children)
    });
  }
}
ge(oA, "defaultProps", {
  className: ""
});
ge(oA, "contextType", at);
let hJ = { data: "" }, gJ = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || hJ, mJ = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, vJ = /\/\*[^]*?\*\/|  +/g, PD = /\n+/g, ci = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ci(s, i) : i + "{" + ci(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ci(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ci.p ? ci.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, ko = {}, iA = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + iA(e[n]);
    return t;
  }
  return e;
}, yJ = (e, t, n, r, o) => {
  let i = iA(e), s = ko[i] || (ko[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!ko[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = mJ.exec(u.replace(vJ, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(PD, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(PD, " ").trim();
      return d[0];
    })(e);
    ko[s] = ci(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && ko.g ? ko.g : null;
  return n && (ko.g = ko[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(ko[s], t, r, a), s;
}, bJ = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ci(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function lf(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return yJ(n.unshift ? n.raw ? bJ(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, gJ(t.target), t.g, t.o, t.k);
}
let sA, km, Sm;
lf.bind({ g: 1 });
let Ro = lf.bind({ k: 1 });
function wJ(e, t, n, r) {
  ci.p = t, sA = e, km = n, Sm = r;
}
function Si(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: km && km() }, a), n.o = / *go\d+/.test(l), a.className = lf.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Sm && u[0] && Sm(a), sA(u, a);
    }
    return o;
  };
}
var CJ = (e) => typeof e == "function", OJ = (e, t) => CJ(e) ? e(t) : e, EJ = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), xJ = Ro`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, LJ = Ro`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, DJ = Ro`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, PJ = Si("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${xJ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${LJ} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${DJ} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, kJ = Ro`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, SJ = Si("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${kJ} 1s linear infinite;
`, MJ = Ro`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, TJ = Ro`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, jJ = Si("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${MJ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${TJ} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, _J = Si("div")`
  position: absolute;
`, AJ = Si("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, BJ = Ro`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, IJ = Si("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${BJ} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, RJ = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? We.createElement(IJ, null, t) : t : n === "blank" ? null : We.createElement(AJ, null, We.createElement(SJ, { ...r }), n !== "loading" && We.createElement(_J, null, n === "error" ? We.createElement(PJ, { ...r }) : We.createElement(jJ, { ...r })));
}, NJ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, FJ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, zJ = "0%{opacity:0;} 100%{opacity:1;}", $J = "0%{opacity:1;} 100%{opacity:0;}", UJ = Si("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, WJ = Si("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, VJ = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = EJ() ? [zJ, $J] : [NJ(n), FJ(n)];
  return { animation: t ? `${Ro(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Ro(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
We.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? VJ(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = We.createElement(RJ, { toast: e }), s = We.createElement(WJ, { ...e.ariaProps }, OJ(e.message, e));
  return We.createElement(UJ, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : We.createElement(We.Fragment, null, i, s));
});
wJ(We.createElement);
lf`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function HJ(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function qJ(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ q.jsx("strong", { className: o.trim(), children: t });
}
function ZJ(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, s] = D(!1), a = Ye(null), l = () => {
    s(!0);
  }, u = () => {
    s(!1);
  }, c = (f) => {
    if (r || !i || !a.current) return;
    const g = a.current.getBoundingClientRect(), h = f.clientX - g.left, C = Math.min(Math.max(h / g.width * 100, 0), 100);
    t(C);
  }, p = (f) => {
    if (!a.current) return;
    const g = a.current.getBoundingClientRect(), h = f.clientX - g.left, C = Math.min(Math.max(h / g.width * 100, 0), 100);
    t(C);
  };
  y(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const m = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ q.jsxs(
    "div",
    {
      className: m,
      ref: a,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ q.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ q.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function KJ(e) {
  var P, U, L, N;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: s,
    changeAudioButtonText: a
  } = e, [l, u] = D(0), c = Ye(null), [p, d] = D(!1), [m, f] = D(!1);
  y(() => {
    const A = c.current;
    if (!A) return;
    const z = () => {
      const V = A.duration, Z = A.currentTime / V * 100;
      u(Z);
    };
    return A.addEventListener("timeupdate", z), () => {
      A.removeEventListener("timeupdate", z);
    };
  }, []);
  function g(A) {
    const z = c.current;
    if (!z) return;
    const V = z.duration, $ = A / 100 * V;
    z.currentTime = $;
  }
  function h() {
    var A;
    (A = c.current) == null || A.play(), f(!0);
  }
  function C() {
    var A;
    (A = c.current) == null || A.pause(), f(!1);
  }
  function w() {
    m ? C() : h();
  }
  const S = (P = c.current) == null ? void 0 : P.currentTime, E = (U = c.current) == null ? void 0 : U.duration;
  function v(A) {
    if (!A) return "00:00";
    const z = Math.floor(A / 60), V = Math.floor(A % 60), $ = String(z).padStart(2, "0"), Z = String(V).padStart(2, "0");
    return `${$}:${Z}`;
  }
  p || !m ? (L = c.current) == null || L.pause() : m && ((N = c.current) == null || N.play());
  function O() {
    if (n) return;
    const A = document.createElement("input");
    A.type = "file", A.accept = r, A.onchange = (z) => {
      var $;
      const V = ($ = z.target.files) == null ? void 0 : $[0];
      V && o(V);
    }, A.click();
  }
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ q.jsx("audio", { ref: c, src: t, onEnded: C }),
    /* @__PURE__ */ q.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ q.jsxs("button", { type: "button", onClick: w, children: [
        m && /* @__PURE__ */ q.jsx(JB, {}),
        !m && /* @__PURE__ */ q.jsx(QB, {})
      ] }),
      /* @__PURE__ */ q.jsx("p", { children: v(S) }),
      /* @__PURE__ */ q.jsx(
        ZJ,
        {
          value: l,
          onChange: g,
          onDragging: d
        }
      ),
      /* @__PURE__ */ q.jsx("p", { children: v(E) })
    ] }),
    /* @__PURE__ */ q.jsx(Rz, {}),
    /* @__PURE__ */ q.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ q.jsx(MZ, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ q.jsx(
        SZ,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: s,
          icon: vS,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ q.jsx(
        h_,
        {
          isLoading: i,
          onClick: O,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: a
        }
      )
    ] })
  ] });
}
function GJ(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ q.jsxs("div", { onDrop: a, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ q.jsx(
      h_,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ q.jsx("p", { children: t })
  ] });
}
function lle(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: s = "url",
    selectAudioButtonText: a = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: m = !1,
    disabled: f = !1
  } = e, h = kZ()[t], [C, w] = D(d), [S, E] = D(""), [v, O] = D(null), [P, U] = D(d), [L, N] = D(!1);
  async function A(Y) {
    if (f) return;
    N(!0), O(Y), E("");
    const te = new FormData();
    te.append(r, Y), await fetch(p, { method: o, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? E(ee.error) : w(ee == null ? void 0 : ee[s]), i && i(ee == null ? void 0 : ee[s]);
    }).catch((ee) => {
      console.error(ee), E("Erro ao enviar audio");
    }).finally(() => N(!1));
  }
  function z(Y) {
    if (!f) {
      if (console.log(Y.type), Y.type.indexOf("audio") === -1) {
        E("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      U(URL.createObjectURL(Y)), A(Y);
    }
  }
  const V = h || S, J = `arkynAudioUpload ${V ? "hasError" : "noHasError"} ${P ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ q.jsx(qJ, { label: n, showAsterisk: m }),
    /* @__PURE__ */ q.jsxs("div", { className: J, children: [
      /* @__PURE__ */ q.jsx("input", { type: "hidden", name: t, value: C || "" }),
      !P && /* @__PURE__ */ q.jsx(
        GJ,
        {
          disabled: f,
          isLoading: L,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: z,
          selectAudioButtonText: a
        }
      ),
      P && /* @__PURE__ */ q.jsx(
        KJ,
        {
          filePath: P,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: z,
          isLoading: L,
          reSendAudio: V && v ? () => A(v) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ q.jsx(HJ, { error: V })
  ] });
}
function Dp(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, m = { xs: 12, sm: 16, md: 20, lg: 24 }[i], h = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ q.jsxs("button", { className: h, disabled: l || t, ...p, children: [
    /* @__PURE__ */ q.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ q.jsx(vo, { size: m, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ q.jsxs("div", { className: "arkynButtonContent", children: [
      Lc(m, s),
      c,
      Lc(m, a)
    ] })
  ] });
}
function aA() {
  const e = Xm(), t = wS(), n = CS(), [r, o] = D(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  y(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), y(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const lA = qe({});
function kD(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = aA(), s = Ye(null), a = ((p = s.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[a]) || null, u = ZB(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ q.jsx(lA.Provider, { value: { error: l, id: u, inputRef: s }, children: /* @__PURE__ */ q.jsx(
    "section",
    {
      id: r || a || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function Tr() {
  return De(lA);
}
function ule(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: s = null,
    onCheck: a,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = Tr(), m = o || !!d, [f, g] = D(i || !1), h = typeof s == "boolean" ? s : f, S = `arkynCheckbox ${r} ${m ? "errorTrue" : "errorFalse"} ${h ? "checkedTrue" : "checkedFalse"} ${n}`;
  function E() {
    const v = f;
    g(!v), a && a(v ? "" : l || "checked");
  }
  return /* @__PURE__ */ q.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: S,
      onClick: E,
      ...u,
      children: [
        /* @__PURE__ */ q.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: h ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ q.jsx(Gm, {})
      ]
    }
  );
}
function cle(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = Tr();
  return t ? /* @__PURE__ */ q.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ q.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function SD(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = Tr(), s = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ q.jsx("label", { className: s.trim(), htmlFor: o, ...r });
}
function YJ(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ q.jsxs(
    "button",
    {
      disabled: s || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ q.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ q.jsx(vo, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ q.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ q.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function XJ(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ q.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ q.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function JJ(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: s,
    reSendImage: a
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && s(p);
    }, u.click();
  }
  return /* @__PURE__ */ q.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        a && /* @__PURE__ */ q.jsx(XJ, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ q.jsx(
          YJ,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: a,
            icon: vS,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ q.jsx(
          Dp,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function QJ(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function eQ(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ q.jsx("strong", { className: o.trim(), children: t });
}
function tQ(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ q.jsxs("div", { onDrop: a, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ q.jsx(
      Dp,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ q.jsx("p", { children: t })
  ] });
}
function nQ(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: s = "file",
    method: a = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: m,
    disabled: f = !1
  } = e, h = aA()[t], [C, w] = D(n), [S, E] = D(""), [v, O] = D(null), [P, U] = D(n), [L, N] = D(!1);
  async function A(Y) {
    if (f) return;
    N(!0), O(Y), E("");
    const te = new FormData();
    te.append(s, Y), await fetch(i, { method: a, body: te }).then(async (ee) => await ee.json()).then((ee) => {
      ee != null && ee.error ? E(ee.error) : w(ee == null ? void 0 : ee[u]), m && m(ee == null ? void 0 : ee[u]);
    }).catch((ee) => {
      console.error(ee), E("Erro ao enviar imagem");
    }).finally(() => N(!1));
  }
  function z(Y) {
    f || (U(URL.createObjectURL(Y)), A(Y));
  }
  const V = h || S, J = `arkynImageUpload ${V ? "hasError" : "noHasError"} ${P ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ q.jsx(eQ, { label: r, showAsterisk: o }),
    /* @__PURE__ */ q.jsxs("div", { className: J, children: [
      /* @__PURE__ */ q.jsx("input", { type: "hidden", name: t, value: C || "" }),
      !P && /* @__PURE__ */ q.jsx(
        tQ,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: z,
          selectImageButtonText: p
        }
      ),
      P && /* @__PURE__ */ q.jsx(
        JJ,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          filePath: P,
          handleSelectFile: z,
          changeImageButtonText: c,
          reSendImage: V && v ? () => A(v) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ q.jsx(QJ, { error: V })
  ] });
}
function hi(e, t, n) {
  if (!e) return /* @__PURE__ */ q.jsx(q.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ q.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ q.jsx("p", { className: n, children: /* @__PURE__ */ q.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function Qy(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function uA(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function cA(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const eb = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, pA = Qy(eb.CNPJ).length;
function rQ(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: m,
    onFocus: f,
    onBlur: g,
    title: h,
    style: C,
    onChange: w,
    ...S
  } = e;
  function E($) {
    let Z = Qy($);
    const J = cA(Z);
    if (!(Z.length > pA))
      return Z = uA(Z, eb[J]), Z;
  }
  const v = c ? "right" : "left", A = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || m || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: A,
    prefix: hi(a, V, "prefix"),
    sufix: hi(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: E(d || ""),
    disabled: p,
    readOnly: m,
    onFocus: f,
    onBlur: g,
    title: h,
    style: C,
    onChange: w,
    loadingPosition: v,
    iconSize: V,
    Spinner: /* @__PURE__ */ q.jsx(vo, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...S
  };
}
function oQ(e) {
  const [t, n] = D(!1), r = Ye(null), { inputRef: o, id: i, error: s } = Tr(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: S,
    onFocus: E,
    onBlur: v,
    RightIcon: O,
    Spinner: P,
    onChange: U,
    value: L,
    defaultValue: N,
    ...A
  } = rQ({ ...e, id: i, isError: l }, t), [z, V] = D(N), $ = w && !C, Z = O && !C, J = h === "left" && C, Y = h === "right" && C;
  function te() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function ee(K) {
    let M = Qy(K.target.value);
    const G = cA(M);
    M.length > pA || (M = uA(M, eb[G]), K.target.value = M, V(M), U && U(K));
  }
  function k(K) {
    n(!0), E && E(K);
  }
  function _(K) {
    n(!1), v && v(K);
  }
  return /* @__PURE__ */ q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: te,
      className: d,
      children: [
        m,
        J && P,
        $ && /* @__PURE__ */ q.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsx(
          "input",
          {
            disabled: u || C,
            readOnly: S,
            ref: a,
            value: L || z,
            onFocus: k,
            onChange: ee,
            onBlur: _,
            ...A
          }
        ),
        Z && /* @__PURE__ */ q.jsx(O, { size: g, strokeWidth: 2.5 }),
        Y && P,
        f
      ]
    }
  );
}
const iQ = 3, sQ = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? iQ : 0), Gu = 2, MD = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), Mm = (e) => {
  let t = e;
  return typeof e == "string" ? (t = MD(e), t % 1 !== 0 && (t = t.toFixed(Gu))) : t = Number.isInteger(e) ? Number(e) * 10 ** Gu : e.toFixed(Gu), MD(t) / 10 ** Gu;
}, TD = (e, t, n) => {
  if (!t) return [0, ""];
  const r = Mm(t), o = sQ(e, r, n);
  return [r, o];
};
function aQ(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    // showCents = false,
    max: C = 1e9,
    locale: w = "pt-BR",
    currency: S = "BRL",
    ...E
  } = e, v = c ? "right" : "left", A = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: A,
    prefix: hi(a, V, "prefix"),
    sufix: hi(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: S,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    max: C,
    // showCents,
    loadingPosition: v,
    iconSize: V,
    Spinner: /* @__PURE__ */ q.jsx(vo, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...E
  };
}
function lQ(e) {
  const [t, n] = D(!1), [r, o] = D("0"), i = Ye(null), { inputRef: s, id: a, error: l } = Tr(), u = s || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: m,
    className: f,
    prefix: g,
    sufix: h,
    iconSize: C,
    loadingPosition: w,
    isLoading: S,
    LeftIcon: E,
    readOnly: v,
    onFocus: O,
    onBlur: P,
    RightIcon: U,
    Spinner: L,
    value: N,
    max: A,
    onChangeValue: z,
    onKeyPress: V,
    currency: $,
    locale: Z,
    name: J,
    defaultValue: Y,
    ...te
  } = aQ({ ...e, id: a, isError: c }, t), ee = E && !S, k = U && !S, _ = w === "left" && S, K = w === "right" && S;
  function M() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function G(H) {
    n(!0), O && O(H);
  }
  function x(H) {
    n(!1), P && P(H);
  }
  const T = (H) => {
    const [B, Q] = TD(
      Z,
      H,
      $
    );
    return !A || B <= A ? (o(Q), [B, Q]) : [Mm(r), r];
  }, F = (H) => {
    H.preventDefault();
    const [B, Q] = T(H.target.value);
    z && z(H, String(B), String(Q));
  }, j = (H) => V && V(H, H.key, H.key);
  return y(() => {
    const H = N || +Y || void 0, [, B] = TD(Z, H, $);
    o(B);
  }, [$, Y, N]), /* @__PURE__ */ q.jsxs(
    "section",
    {
      title: d,
      style: m,
      onClick: M,
      className: f,
      children: [
        g,
        _ && L,
        ee && /* @__PURE__ */ q.jsx(E, { size: C, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsx(
          "input",
          {
            value: r,
            onChange: F,
            onBlur: x,
            onFocus: G,
            onKeyUp: j,
            disabled: p || S,
            readOnly: v,
            ...te
          }
        ),
        /* @__PURE__ */ q.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: J,
            value: Mm(r)
          }
        ),
        K && L,
        k && /* @__PURE__ */ q.jsx(U, { size: C, strokeWidth: 2.5 }),
        h
      ]
    }
  );
}
function uQ(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: C,
    showMask: w = !1,
    type: S,
    ...E
  } = e, v = c ? "right" : "left", A = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: A,
    prefix: hi(a, V, "prefix"),
    sufix: hi(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: C,
    loadingPosition: v,
    iconSize: V,
    showMask: w,
    Spinner: /* @__PURE__ */ q.jsx(vo, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...E
  };
}
const cQ = Fs((e, t) => /* @__PURE__ */ q.jsx("input", { ref: t, ...e }));
function pQ(e) {
  const [t, n] = D(!1), r = Ye(null), { inputRef: o, id: i, error: s } = Tr(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: S,
    onFocus: E,
    onBlur: v,
    RightIcon: O,
    Spinner: P,
    ...U
  } = uQ({ ...e, id: i, isError: l }, t), L = w && !C, N = O && !C, A = h === "left" && C, z = h === "right" && C;
  function V() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function $(J) {
    n(!0), E && E(J);
  }
  function Z(J) {
    n(!1), v && v(J);
  }
  return /* @__PURE__ */ q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: V,
      className: d,
      children: [
        m,
        A && P,
        L && /* @__PURE__ */ q.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsx(
          gI,
          {
            component: cQ,
            ref: a,
            onFocus: $,
            onBlur: Z,
            disabled: u,
            ...U
          }
        ),
        N && /* @__PURE__ */ q.jsx(O, { size: g, strokeWidth: 2.5 }),
        z && P,
        f
      ]
    }
  );
}
function dQ(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: C,
    ...w
  } = e, S = c ? "right" : "left", L = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, A = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: L,
    prefix: hi(a, A, "prefix"),
    sufix: hi(l, A, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: C,
    loadingPosition: S,
    iconSize: A,
    Spinner: /* @__PURE__ */ q.jsx(vo, { className: "spinner", size: A, strokeWidth: 2.5 }),
    ...w
  };
}
function fQ(e) {
  const [t, n] = D(!1), r = Ye(null), { inputRef: o, id: i, error: s } = Tr(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: S,
    onFocus: E,
    onBlur: v,
    RightIcon: O,
    type: P,
    Spinner: U,
    ...L
  } = dQ({ ...e, id: i, isError: l }, t), N = w && !C, A = O && !C, z = h === "left" && C, V = h === "right" && C;
  function $() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function Z(Y) {
    n(!0), E && E(Y);
  }
  function J(Y) {
    n(!1), v && v(Y);
  }
  return P === "hidden" ? /* @__PURE__ */ q.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: a,
      ...L
    }
  ) : /* @__PURE__ */ q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: $,
      className: d,
      children: [
        m,
        z && U,
        N && /* @__PURE__ */ q.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsx(
          "input",
          {
            disabled: u || C,
            readOnly: S,
            ref: a,
            onFocus: Z,
            onBlur: J,
            type: P,
            ...L
          }
        ),
        A && /* @__PURE__ */ q.jsx(O, { size: g, strokeWidth: 2.5 }),
        V && U,
        f
      ]
    }
  );
}
function uf(e) {
  return e.type === "currency" ? /* @__PURE__ */ q.jsx(lQ, { ...e }) : e.type === "masked" ? /* @__PURE__ */ q.jsx(pQ, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ q.jsx(oQ, { ...e }) : /* @__PURE__ */ q.jsx(fQ, { ...e });
}
function hQ(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ q.jsx(q.Fragment, {}) : /* @__PURE__ */ q.jsx(yS, { className: l, size: t, strokeWidth: 2.5 });
}
function gQ(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: s,
    className: a,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, m = d ? "hasPrefix" : "", f = o ? "errored" : "", g = r || l || i ? "opacity" : "", h = s ? "focused" : "";
  return /* @__PURE__ */ q.jsx(
    "section",
    {
      onClick: n,
      id: p,
      className: `arkynMultiSelectContainer ${m} ${u} ${c} ${g} ${f} ${h} ${a}`,
      children: t
    }
  );
}
function mQ(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ q.jsx("div", { className: r, children: t });
}
function vQ(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ q.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ q.jsx(Ym, {})
      }
    )
  ] });
}
function yQ(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, s = n(o) ? "active" : "", a = `arkynMultiSelectOption ${i} ${s}`;
  return /* @__PURE__ */ q.jsxs("div", { onClick: () => r(o), className: a, children: [
    t,
    " ",
    /* @__PURE__ */ q.jsx(Gm, {})
  ] });
}
function bQ(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(s) {
    r && o(s.target.value);
  }
  return n ? /* @__PURE__ */ q.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ q.jsx(
      uf,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: bS,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function wQ(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ q.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function CQ(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ q.jsx(
    vo,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function ple(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: s = [],
    isError: a,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: m,
    onBlur: f,
    notFoundText: g = "Sem opções disponíveis",
    onFocus: h,
    disabled: C = !1,
    prefix: w,
    size: S = "md",
    value: E,
    variant: v = "solid"
  } = e, O = Tr(), P = Ye(null), U = O.inputRef || P, L = O.id, N = a || !!O.error, z = { md: 20, lg: 20 }[S], V = nM(w, z, "prefix"), [$, Z] = D(""), [J, Y] = D(!1), [te, ee] = D(s), k = E || te;
  function _(j) {
    return k.includes(j);
  }
  function K(j) {
    const H = n.find((B) => B.value === j);
    return (H == null ? void 0 : H.label) || "";
  }
  function M() {
    C || !(U != null && U.current) || J || (Y(!0), U.current.focus(), h && h());
  }
  function G() {
    Y(!1), f && U.current && U.current.blur();
  }
  function x(j) {
    Z(j), d && d(j);
  }
  function T(j) {
    _(j) ? ee(te.filter((H) => H !== j)) : ee([...te, j]), m && m(te), i && G();
  }
  const F = n.filter((j) => !!(e.onSearch || !e.isSearchable || j.label.toLowerCase().includes($.toLowerCase())));
  return /* @__PURE__ */ q.jsxs(
    gQ,
    {
      handleContainerFocus: M,
      disabled: C,
      isError: N,
      isFocused: J,
      isLoading: l,
      readOnly: u,
      size: S,
      variant: v,
      className: r,
      prefixExists: !!w,
      id: L,
      children: [
        /* @__PURE__ */ q.jsx(
          "input",
          {
            ref: U,
            name: t,
            value: JSON.stringify(k),
            type: "hidden"
          }
        ),
        V,
        p && /* @__PURE__ */ q.jsx(p, { size: z, strokeWidth: 2.5 }),
        /* @__PURE__ */ q.jsxs(mQ, { size: S, children: [
          k.map((j) => /* @__PURE__ */ q.jsx(
            vQ,
            {
              label: K(j),
              value: j,
              handleChangeValue: T
            },
            j
          )),
          k.length <= 0 && /* @__PURE__ */ q.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ q.jsxs(
          bQ,
          {
            isFocused: J,
            isSearchable: c,
            onSearch: x,
            children: [
              F.map(({ label: j, value: H }) => /* @__PURE__ */ q.jsx(
                yQ,
                {
                  label: j,
                  value: H,
                  size: S,
                  handleChangeValue: T,
                  optionHasSelected: _
                },
                H
              )),
              F.length <= 0 && /* @__PURE__ */ q.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ q.jsx(
          hQ,
          {
            disabled: C,
            isFocused: J,
            readOnly: u,
            iconSize: z,
            isLoading: l
          }
        ),
        /* @__PURE__ */ q.jsx(CQ, { iconSize: z, isLoading: l }),
        /* @__PURE__ */ q.jsx(wQ, { handleBlur: G, isFocused: J })
      ]
    }
  );
}
const dA = qe({});
function OQ() {
  return De(dA);
}
function dle(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: s = "",
    ...a
  } = e, [l, u] = D(t || ""), { inputRef: c, id: p } = Tr();
  function d(f) {
    u(f), o && o(f);
  }
  const m = `arkynRadioGroup ${i} ${s}`;
  return /* @__PURE__ */ q.jsxs(
    dA.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ q.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ q.jsx("div", { className: m.trim(), ...a })
      ]
    }
  );
}
function fle(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...s
  } = e, { onChange: a, size: l, value: u } = OQ(), { error: c } = Tr(), g = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ q.jsxs("label", { className: g.trim(), children: [
    /* @__PURE__ */ q.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => a(t),
        onFocus: () => a(t),
        ...s
      }
    ),
    o
  ] });
}
var Uo = {};
Object.defineProperty(Uo, "__esModule", {
  value: !0
});
var EQ = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), qh = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, fA = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: EQ ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, tb = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Yu = 1; Yu < 20; Yu++)
  tb["f" + Yu] = 111 + Yu;
function cf(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return hA(s, t);
  }), o = function(a) {
    return r.some(function(l) {
      return gA(l, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function xQ(e, t) {
  return cf(e, t);
}
function LQ(e, t) {
  return cf(e, { byKey: !0 }, t);
}
function hA(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in qh)
    r[qh[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, m = d.endsWith("?") && d.length > 1;
      m && (d = d.slice(0, -1));
      var f = nb(d), g = qh[f];
      if (d.length > 1 && !g && !fA[d] && !tb[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = mA(d)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function gA(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function mA(e) {
  e = nb(e);
  var t = tb[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function nb(e) {
  return e = e.toLowerCase(), e = fA[e] || e, e;
}
var DQ = Uo.default = cf, Zh = Uo.isHotkey = cf;
Uo.isCodeHotkey = xQ;
Uo.isKeyHotkey = LQ;
Uo.parseHotkey = hA;
Uo.compareHotkey = gA;
Uo.toKeyCode = mA;
Uo.toKeyName = nb;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function jD(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function PQ(e) {
  var t, n;
  return jD(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(jD(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var kQ = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return PQ(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || di.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || di.isOperationList(e.undos[0].operations));
  }
}, Kh = /* @__PURE__ */ new WeakMap(), ma = /* @__PURE__ */ new WeakMap(), is = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return kQ.isHistory(e.history) && I.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return ma.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return Kh.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = is.isMerging(e);
    ma.set(e, !0), t(), ma.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = is.isMerging(e);
    ma.set(e, !1), t(), ma.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = is.isSaving(e);
    Kh.set(e, !1), t(), Kh.set(e, n);
  }
}, SQ = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && ve.setSelection(t, i.selectionBefore), is.withoutSaving(t, () => {
        I.withoutNormalizing(t, () => {
          for (var s of i.operations)
            t.apply(s);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      is.withoutSaving(t, () => {
        I.withoutNormalizing(t, () => {
          var s = i.operations.map(di.inverse).reverse();
          for (var a of s)
            t.apply(a);
          i.selectionBefore && ve.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: s
    } = i, a = s[s.length - 1], l = a && a.operations[a.operations.length - 1], u = is.isSaving(t), c = is.isMerging(t);
    if (u == null && (u = TQ(r)), u) {
      if (c == null && (a == null ? c = !1 : o.length !== 0 ? c = !0 : c = MQ(r, l)), a && c)
        a.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; s.length > 100; )
        s.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, MQ = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && ne.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && ne.equals(e.path, t.path)), TQ = (e, t) => e.type !== "set_selection", jQ = BQ, vA = "֑-߿יִ-﷽ﹰ-ﻼ", yA = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", _Q = new RegExp("^[^" + yA + "]*[" + vA + "]"), AQ = new RegExp("^[^" + vA + "]*[" + yA + "]");
function BQ(e) {
  return e = String(e || ""), _Q.test(e) ? "rtl" : AQ.test(e) ? "ltr" : "neutral";
}
const bA = /* @__PURE__ */ zp(jQ);
function IQ(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var rb = IQ, RQ = typeof tn == "object" && tn && tn.Object === Object && tn, NQ = RQ, FQ = NQ, zQ = typeof self == "object" && self && self.Object === Object && self, $Q = FQ || zQ || Function("return this")(), wA = $Q, UQ = wA, WQ = function() {
  return UQ.Date.now();
}, VQ = WQ, HQ = /\s/;
function qQ(e) {
  for (var t = e.length; t-- && HQ.test(e.charAt(t)); )
    ;
  return t;
}
var ZQ = qQ, KQ = ZQ, GQ = /^\s+/;
function YQ(e) {
  return e && e.slice(0, KQ(e) + 1).replace(GQ, "");
}
var XQ = YQ, JQ = wA, QQ = JQ.Symbol, CA = QQ, _D = CA, OA = Object.prototype, eee = OA.hasOwnProperty, tee = OA.toString, va = _D ? _D.toStringTag : void 0;
function nee(e) {
  var t = eee.call(e, va), n = e[va];
  try {
    e[va] = void 0;
    var r = !0;
  } catch {
  }
  var o = tee.call(e);
  return r && (t ? e[va] = n : delete e[va]), o;
}
var ree = nee, oee = Object.prototype, iee = oee.toString;
function see(e) {
  return iee.call(e);
}
var aee = see, AD = CA, lee = ree, uee = aee, cee = "[object Null]", pee = "[object Undefined]", BD = AD ? AD.toStringTag : void 0;
function dee(e) {
  return e == null ? e === void 0 ? pee : cee : BD && BD in Object(e) ? lee(e) : uee(e);
}
var fee = dee;
function hee(e) {
  return e != null && typeof e == "object";
}
var gee = hee, mee = fee, vee = gee, yee = "[object Symbol]";
function bee(e) {
  return typeof e == "symbol" || vee(e) && mee(e) == yee;
}
var wee = bee, Cee = XQ, ID = rb, Oee = wee, RD = NaN, Eee = /^[-+]0x[0-9a-f]+$/i, xee = /^0b[01]+$/i, Lee = /^0o[0-7]+$/i, Dee = parseInt;
function Pee(e) {
  if (typeof e == "number")
    return e;
  if (Oee(e))
    return RD;
  if (ID(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = ID(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Cee(e);
  var n = xee.test(e);
  return n || Lee.test(e) ? Dee(e.slice(2), n ? 2 : 8) : Eee.test(e) ? RD : +e;
}
var kee = Pee, See = rb, Gh = VQ, ND = kee, Mee = "Expected a function", Tee = Math.max, jee = Math.min;
function _ee(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Mee);
  t = ND(t) || 0, See(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Tee(ND(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(O) {
    var P = r, U = o;
    return r = o = void 0, u = O, s = e.apply(U, P), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var P = O - l, U = O - u, L = t - P;
    return p ? jee(L, i - U) : L;
  }
  function h(O) {
    var P = O - l, U = O - u;
    return l === void 0 || P >= t || P < 0 || p && U >= i;
  }
  function C() {
    var O = Gh();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, d && r ? m(O) : (r = o = void 0, s);
  }
  function S() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(Gh());
  }
  function v() {
    var O = Gh(), P = h(O);
    if (r = arguments, o = this, l = O, P) {
      if (a === void 0)
        return f(l);
      if (p)
        return clearTimeout(a), a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = S, v.flush = E, v;
}
var EA = _ee;
const Aee = /* @__PURE__ */ zp(EA);
var Bee = EA, Iee = rb, Ree = "Expected a function";
function Nee(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Ree);
  return Iee(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Bee(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var Fee = Nee;
const zee = /* @__PURE__ */ zp(Fee), FD = (e) => typeof e == "object" && e != null && e.nodeType === 1, zD = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", Yh = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return zD(n.overflowY, t) || zD(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, Xu = (e, t, n, r, o, i, s, a) => i < e && s > t || i > e && s < t ? 0 : i <= e && a <= n || s >= t && a >= n ? i - e - r : s > t && a < n || i < e && a > n ? s - t + o : 0, $ee = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, $D = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: s, block: a, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (J) => J !== u;
  if (!FD(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, m = [];
  let f = e;
  for (; FD(f) && p(f); ) {
    if (f = $ee(f), f === d) {
      m.push(f);
      break;
    }
    f != null && f === document.body && Yh(f) && !Yh(document.documentElement) || f != null && Yh(f, c) && m.push(f);
  }
  const g = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, h = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: C, scrollY: w } = window, { height: S, width: E, top: v, right: O, bottom: P, left: U } = e.getBoundingClientRect(), { top: L, right: N, bottom: A, left: z } = ((J) => {
    const Y = window.getComputedStyle(J);
    return { top: parseFloat(Y.scrollMarginTop) || 0, right: parseFloat(Y.scrollMarginRight) || 0, bottom: parseFloat(Y.scrollMarginBottom) || 0, left: parseFloat(Y.scrollMarginLeft) || 0 };
  })(e);
  let V = a === "start" || a === "nearest" ? v - L : a === "end" ? P + A : v + S / 2 - L + A, $ = l === "center" ? U + E / 2 - z + N : l === "end" ? O + N : U - z;
  const Z = [];
  for (let J = 0; J < m.length; J++) {
    const Y = m[J], { height: te, width: ee, top: k, right: _, bottom: K, left: M } = Y.getBoundingClientRect();
    if (s === "if-needed" && v >= 0 && U >= 0 && P <= h && O <= g && v >= k && P <= K && U >= M && O <= _) return Z;
    const G = getComputedStyle(Y), x = parseInt(G.borderLeftWidth, 10), T = parseInt(G.borderTopWidth, 10), F = parseInt(G.borderRightWidth, 10), j = parseInt(G.borderBottomWidth, 10);
    let H = 0, B = 0;
    const Q = "offsetWidth" in Y ? Y.offsetWidth - Y.clientWidth - x - F : 0, W = "offsetHeight" in Y ? Y.offsetHeight - Y.clientHeight - T - j : 0, ue = "offsetWidth" in Y ? Y.offsetWidth === 0 ? 0 : ee / Y.offsetWidth : 0, ye = "offsetHeight" in Y ? Y.offsetHeight === 0 ? 0 : te / Y.offsetHeight : 0;
    if (d === Y) H = a === "start" ? V : a === "end" ? V - h : a === "nearest" ? Xu(w, w + h, h, T, j, w + V, w + V + S, S) : V - h / 2, B = l === "start" ? $ : l === "center" ? $ - g / 2 : l === "end" ? $ - g : Xu(C, C + g, g, x, F, C + $, C + $ + E, E), H = Math.max(0, H + w), B = Math.max(0, B + C);
    else {
      H = a === "start" ? V - k - T : a === "end" ? V - K + j + W : a === "nearest" ? Xu(k, K, te, T, j + W, V, V + S, S) : V - (k + te / 2) + W / 2, B = l === "start" ? $ - M - x : l === "center" ? $ - (M + ee / 2) + Q / 2 : l === "end" ? $ - _ + F + Q : Xu(M, _, ee, x, F + Q, $, $ + E, E);
      const { scrollLeft: oe, scrollTop: _e } = Y;
      H = ye === 0 ? 0 : Math.max(0, Math.min(_e + H / ye, Y.scrollHeight - te / ye + W)), B = ue === 0 ? 0 : Math.max(0, Math.min(oe + B / ue, Y.scrollWidth - ee / ue + Q)), V += _e - H, $ += oe - B;
    }
    Z.push({ el: Y, top: H, left: B });
  }
  return Z;
}, Uee = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function Wee(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior($D(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: s } of $D(e, Uee(t))) {
    const a = i - n.top + n.bottom, l = s - n.left + n.right;
    o.scroll({ top: a, left: l, behavior: r });
  }
}
var ls = [], Vee = function() {
  return ls.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Hee = function() {
  return ls.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, UD = "ResizeObserver loop completed with undelivered notifications.", qee = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: UD
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = UD), window.dispatchEvent(e);
}, gl;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(gl || (gl = {}));
var us = function(e) {
  return Object.freeze(e);
}, Zee = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, us(this);
  }
  return e;
}(), xA = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, us(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), ob = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, LA = function(e) {
  if (ob(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, WD = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, Kee = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Wa = typeof window < "u" ? window : {}, Ju = /* @__PURE__ */ new WeakMap(), VD = /auto|scroll/, Gee = /^tb|vertical/, Yee = /msie|trident/i.test(Wa.navigator && Wa.navigator.userAgent), ao = function(e) {
  return parseFloat(e || "0");
}, Ms = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Zee((n ? t : e) || 0, (n ? e : t) || 0);
}, HD = us({
  devicePixelContentBoxSize: Ms(),
  borderBoxSize: Ms(),
  contentBoxSize: Ms(),
  contentRect: new xA(0, 0, 0, 0)
}), DA = function(e, t) {
  if (t === void 0 && (t = !1), Ju.has(e) && !t)
    return Ju.get(e);
  if (LA(e))
    return Ju.set(e, HD), HD;
  var n = getComputedStyle(e), r = ob(e) && e.ownerSVGElement && e.getBBox(), o = !Yee && n.boxSizing === "border-box", i = Gee.test(n.writingMode || ""), s = !r && VD.test(n.overflowY || ""), a = !r && VD.test(n.overflowX || ""), l = r ? 0 : ao(n.paddingTop), u = r ? 0 : ao(n.paddingRight), c = r ? 0 : ao(n.paddingBottom), p = r ? 0 : ao(n.paddingLeft), d = r ? 0 : ao(n.borderTopWidth), m = r ? 0 : ao(n.borderRightWidth), f = r ? 0 : ao(n.borderBottomWidth), g = r ? 0 : ao(n.borderLeftWidth), h = p + u, C = l + c, w = g + m, S = d + f, E = a ? e.offsetHeight - S - e.clientHeight : 0, v = s ? e.offsetWidth - w - e.clientWidth : 0, O = o ? h + w : 0, P = o ? C + S : 0, U = r ? r.width : ao(n.width) - O - v, L = r ? r.height : ao(n.height) - P - E, N = U + h + v + w, A = L + C + E + S, z = us({
    devicePixelContentBoxSize: Ms(Math.round(U * devicePixelRatio), Math.round(L * devicePixelRatio), i),
    borderBoxSize: Ms(N, A, i),
    contentBoxSize: Ms(U, L, i),
    contentRect: new xA(p, l, U, L)
  });
  return Ju.set(e, z), z;
}, PA = function(e, t, n) {
  var r = DA(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case gl.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case gl.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, Xee = /* @__PURE__ */ function() {
  function e(t) {
    var n = DA(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = us([n.borderBoxSize]), this.contentBoxSize = us([n.contentBoxSize]), this.devicePixelContentBoxSize = us([n.devicePixelContentBoxSize]);
  }
  return e;
}(), kA = function(e) {
  if (LA(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, Jee = function() {
  var e = 1 / 0, t = [];
  ls.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new Xee(u.target), p = kA(u.target);
        a.push(c), u.lastReportedSize = PA(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, qD = function(e) {
  ls.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (kA(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, Qee = function() {
  var e = 0;
  for (qD(e); Vee(); )
    e = Jee(), qD(e);
  return Hee() && qee(), e > 0;
}, Xh, SA = [], ete = function() {
  return SA.splice(0).forEach(function(e) {
    return e();
  });
}, tte = function(e) {
  if (!Xh) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return ete();
    }).observe(n, r), Xh = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  SA.push(e), Xh();
}, nte = function(e) {
  tte(function() {
    requestAnimationFrame(e);
  });
}, vc = 0, rte = function() {
  return !!vc;
}, ote = 250, ite = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, ZD = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], KD = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Jh = !1, ste = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = ote), !Jh) {
      Jh = !0;
      var r = KD(t);
      nte(function() {
        var o = !1;
        try {
          o = Qee();
        } finally {
          if (Jh = !1, t = r - KD(), !rte())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, ite);
    };
    document.body ? n() : Wa.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), ZD.forEach(function(n) {
      return Wa.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), ZD.forEach(function(n) {
      return Wa.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), Tm = new ste(), GD = function(e) {
  !vc && e > 0 && Tm.start(), vc += e, !vc && Tm.stop();
}, ate = function(e) {
  return !ob(e) && !Kee(e) && getComputedStyle(e).display === "inline";
}, lte = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || gl.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = PA(this.target, this.observedBox, !0);
    return ate(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), ute = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Qu = /* @__PURE__ */ new WeakMap(), YD = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, ec = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new ute(t, n);
    Qu.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = Qu.get(t), i = o.observationTargets.length === 0;
    YD(o.observationTargets, n) < 0 && (i && ls.push(o), o.observationTargets.push(new lte(n, r && r.box)), GD(1), Tm.schedule());
  }, e.unobserve = function(t, n) {
    var r = Qu.get(t), o = YD(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && ls.splice(ls.indexOf(r), 1), r.observationTargets.splice(o, 1), GD(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Qu.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), cte = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    ec.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!WD(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ec.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!WD(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ec.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    ec.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function pte(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Rs(e, t) {
  if (e == null) return {};
  var n = pte(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function ml(e) {
  "@babel/helpers - typeof";
  return ml = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ml(e);
}
function dte(e, t) {
  if (ml(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ml(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function fte(e) {
  var t = dte(e, "string");
  return ml(t) === "symbol" ? t : String(t);
}
function Qr(e, t, n) {
  return t = fte(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var ib = /* @__PURE__ */ qe(null), Mi = () => {
  var e = De(ib);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, Qh, eg, MA = parseInt(xe.version.split(".")[0], 10), TA = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, XD = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), hr = typeof navigator < "u" && /Android/.test(navigator.userAgent), Ds = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Xi = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), hte = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), jA = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), gte = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), mte = hr && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), vte = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), yte = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), bte = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), yc = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((Qh = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Qh !== void 0 && Qh[1] && parseInt((eg = navigator.userAgent.match(/Version\/(\d+)/)) === null || eg === void 0 ? void 0 : eg[1], 10) < 17);
var Go = (!gte || !mte) && !hte && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", Ts = /* @__PURE__ */ new WeakMap(), sb = /* @__PURE__ */ new WeakMap(), ab = /* @__PURE__ */ new WeakMap(), _A = /* @__PURE__ */ new WeakMap(), bc = /* @__PURE__ */ new WeakMap(), jm = /* @__PURE__ */ new WeakMap(), vl = /* @__PURE__ */ new WeakMap(), cs = /* @__PURE__ */ new WeakMap(), Pp = /* @__PURE__ */ new WeakMap(), pf = /* @__PURE__ */ new WeakMap(), _m = /* @__PURE__ */ new WeakMap(), fi = /* @__PURE__ */ new WeakMap(), ss = /* @__PURE__ */ new WeakMap(), Va = /* @__PURE__ */ new WeakMap(), Am = /* @__PURE__ */ new WeakMap(), lb = /* @__PURE__ */ new WeakMap(), no = /* @__PURE__ */ new WeakMap(), _o = /* @__PURE__ */ new WeakMap(), wr = /* @__PURE__ */ new WeakMap(), ii = /* @__PURE__ */ new WeakMap(), si = /* @__PURE__ */ new WeakMap(), AA = /* @__PURE__ */ new WeakMap(), Ns = Symbol("placeholder"), BA = Symbol("mark-placeholder"), IA = globalThis.Node, wte = globalThis.Text, ub = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Cte = (e) => gi(e) && e.nodeType === 8, Jr = (e) => gi(e) && e.nodeType === 1, gi = (e) => {
  var t = ub(e);
  return !!t && e instanceof t.Node;
}, Bm = (e) => {
  var t = e && e.anchorNode && ub(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, RA = (e) => gi(e) && e.nodeType === 3, Ote = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, Ete = (e) => {
  var [t, n] = e;
  if (Jr(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = NA(t, o, r ? "backward" : "forward"), r = o < n; Jr(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Lte(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, xte = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, NA = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (Cte(o) || Jr(o) && o.childNodes.length === 0 || Jr(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Lte = (e, t, n) => {
  var [r] = NA(e, t, n);
  return r;
}, FA = (e) => {
  var t = "";
  if (RA(e) && e.nodeValue)
    return e.nodeValue;
  if (Jr(e)) {
    for (var n of Array.from(e.childNodes))
      t += FA(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, Dte = /data-slate-fragment="(.+?)"/m, Pte = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(Dte) || [];
  return n;
}, Ha = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), cb = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Jr(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = de.getWindow(e);
  if (o.contains(r))
    return de.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : cb(e, i, n);
}, kte = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, JD = (e, t) => !!(e.compareDocumentPosition(t) & IA.DOCUMENT_POSITION_PRECEDING), Ste = (e, t) => !!(e.compareDocumentPosition(t) & IA.DOCUMENT_POSITION_FOLLOWING), Mte = 0;
class Tte {
  constructor() {
    Qr(this, "id", void 0), this.id = "".concat(Mte++);
  }
}
var de = {
  androidPendingDiffs: (e) => wr.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = lb.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = de.toDOMNode(e, e), n = de.findDocumentOrShadowRoot(e);
    fi.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = de.findDocumentOrShadowRoot(e), r = Ha(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && ve.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = de.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = de.toSlateNode(e, t.target), s = de.findPath(e, i);
    if (Ae.isElement(i) && I.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = I.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? I.before(e, u) : I.after(e, u);
      if (c) {
        var p = I.range(e, c);
        return p;
      }
    }
    var d, {
      document: m
    } = de.getWindow(e);
    if (m.caretRangeFromPoint)
      d = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (d = m.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = de.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = Pp.get(t);
    return n || (n = new Tte(), Pp.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = ab.get(r);
      if (o == null) {
        if (I.isEditor(r))
          return n;
        break;
      }
      var i = sb.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(tr.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!fi.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          de.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = de.toDOMNode(t, t), o = de.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Ha(o), s = de.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(s);
        }
        t.selection || ve.select(t, I.start(t, [])), fi.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = _A.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = de.toDOMNode(t, t), s;
    try {
      s = Jr(n) ? n : n.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return s ? s.closest("[data-slate-editor]") === i && (!o || s.isContentEditable ? !0 : typeof s.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    s.closest('[contenteditable="false"]') === i || !!s.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => gi(t) && de.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return I.hasPath(e, n.path) && I.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => de.hasEditableTarget(e, t) || de.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => gi(t) && de.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!ss.get(e),
  isFocused: (e) => !!fi.get(e),
  isReadOnly: (e) => !!_m.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (_m.get(e)) return !1;
    var n = de.hasTarget(e, t) && de.toSlateNode(e, t);
    return Ae.isElement(n) && I.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = pf.get(e), r = I.isEditor(t) ? bc.get(e) : n == null ? void 0 : n.get(de.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(tr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = I.node(e, t.path), r = de.toDOMNode(e, n), o;
    I.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), m = d == null ? p : parseInt(d, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof wte ? C : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(tr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ae.isBackward(t), i = de.toDOMPoint(e, n), s = ae.isCollapsed(t) ? i : de.toDOMPoint(e, r), a = de.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, m = Jr(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = Jr(p) ? p : p.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Jr(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? vl.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : Ete(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, m = de.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), S = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = de.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var O = v.cloneContents(), P = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          P.forEach((M) => {
            if (hr && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = O.textContent.length, S = u;
        }
      } else if (g) {
        for (var U = g.querySelectorAll("[data-slate-leaf]"), L = 0; L < U.length; L++) {
          var N = U[L];
          if (de.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), S = w, c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (C) {
        var A = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], z = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, $ = [...A(z), ...A(z == null ? void 0 : z.nextElementSibling)];
          w = (V = $.find((M) => Ste(C, M))) !== null && V !== void 0 ? V : null;
        } else {
          var Z, J = [...A(z == null ? void 0 : z.previousElementSibling), ...A(z)];
          w = (Z = J.findLast((M) => JD(C, M))) !== null && Z !== void 0 ? Z : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), S = w, i === "forward" ? c = 0 : (c = S.textContent.length, S.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      S && c === S.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      hr && S.getAttribute("data-slate-zero-width") === "z" && (p = S.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Ds && (d = S.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (hr && !u && !r) {
      var Y = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (Y && de.hasDOMNode(e, Y, {
        editable: !0
      })) {
        var te = de.toSlateNode(e, Y), {
          path: ee,
          offset: k
        } = I.start(e, de.findPath(e, te));
        return Y.querySelector("[data-slate-leaf]") || (k = a), {
          path: ee,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = de.toSlateNode(e, u), K = de.findPath(e, _);
    return {
      path: K,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = Bm(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (Bm(t)) {
        if (Ds && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let O = function(P) {
              return P.childElementCount > 0 ? O(P.children[0]) : P;
            };
            var f = d.startContainer, g = m.startContainer, h = O(f.children[d.startOffset]), C = O(g.children[m.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        jA && xte(a) || Ds ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Ds && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = de.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var S = JD(a, u) || a === u && c < l, E = p ? w : de.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: S ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return ae.isExpanded(v) && ae.isForward(v) && Jr(u) && I.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = I.unhangRange(e, v, {
      voids: !0
    })), v;
  }
};
function jte(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!I.hasPath(e, n))
    return !1;
  var o = Ee.get(e, n);
  if (!Be.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = ne.next(n);
  if (!I.hasPath(e, i))
    return !1;
  var s = Ee.get(e, i);
  return Be.isText(s) && s.text.startsWith(r.text);
}
function zA(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function _te(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function Ate(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function $A(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), s = _te(i, o), a = Math.min(i.length - s, o.length - s), l = Ate(i, o, a), u = {
    start: n + s,
    end: r - l,
    text: o.slice(s, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function Bte(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = zA(e, t, n), s = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), a = i.slice(r, s), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return $A(e, {
    start: r,
    end: l,
    text: a
  });
}
function Ite(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function Im(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!I.hasPath(e, n))
    return null;
  var o = Ee.get(e, n);
  if (!Be.isText(o))
    return null;
  var i = I.above(e, {
    match: (a) => Ae.isElement(a) && I.isBlock(e, a),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var s = I.next(e, {
      at: n,
      match: Be.isText
    });
    if (!s || !ne.isDescendant(s[1], i[1]))
      return null;
    r -= o.text.length, o = s[0], n = s[1];
  }
  return {
    path: n,
    offset: r
  };
}
function QD(e, t) {
  var n = Im(e, t.anchor);
  if (!n)
    return null;
  if (ae.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = Im(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function Rm(e, t, n) {
  var r = wr.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return ne.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return ct.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var s = {
      path: t.path,
      offset: i.start
    }, a = ct.transform(s, n, {
      affinity: "backward"
    });
    return a ? {
      path: a.path,
      offset: a.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = ct.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && ne.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function eP(e, t, n) {
  var r = Rm(e, t.anchor, n);
  if (!r)
    return null;
  if (ae.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = Rm(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function Rte(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !ne.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !ne.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !ne.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: ne.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: ne.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return ne.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: ne.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: ne.transform(n, t)
      };
  }
  var i = ne.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function tP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tP(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nte = 25, Fte = 200, zte = function() {
}, $te = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function Ute(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, s = null, a = null, l = 0, u = !1, c = () => {
    var z = si.get(t);
    if (si.delete(t), z) {
      var {
        selection: V
      } = t, $ = QD(t, z);
      $ && (!V || !ae.equals($, V)) && ve.select(t, $);
    }
  }, p = () => {
    var z = ii.get(t);
    if (ii.delete(t), !!z) {
      if (z.at) {
        var V = ct.isPoint(z.at) ? Im(t, z.at) : QD(t, z.at);
        if (!V)
          return;
        var $ = I.range(t, V);
        (!t.selection || !ae.equals(t.selection, $)) && ve.select(t, V);
      }
      z.run();
    }
  }, d = () => {
    if (s && (clearTimeout(s), s = null), a && (clearTimeout(a), a = null), !E() && !S()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), S() && (o = "action");
    var z = t.selection && I.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    _o.set(t, t.marks), zte("flush", ii.get(t), wr.get(t));
    for (var V = E(), $; $ = (Z = wr.get(t)) === null || Z === void 0 ? void 0 : Z[0]; ) {
      var Z, J, Y = no.get(t);
      Y !== void 0 && (no.delete(t), t.marks = Y), Y && u === !1 && (u = null);
      var te = Ite($);
      (!t.selection || !ae.equals(t.selection, te)) && ve.select(t, te), $.diff.text ? I.insertText(t, $.diff.text) : I.deleteFragment(t), wr.set(t, (J = wr.get(t)) === null || J === void 0 ? void 0 : J.filter((_) => {
        var {
          id: K
        } = _;
        return K !== $.id;
      })), jte(t, $) || (V = !1, ii.delete(t), _o.delete(t), o = "action", si.delete(t), n.cancel(), r.cancel(), z == null || z.unref());
    }
    var ee = z == null ? void 0 : z.unref();
    if (ee && !si.get(t) && (!t.selection || !ae.equals(ee, t.selection)) && ve.select(t, ee), S()) {
      p();
      return;
    }
    V && n(), n.flush(), r.flush(), c();
    var k = _o.get(t);
    _o.delete(t), k !== void 0 && (t.marks = k, t.onChange());
  }, m = (z) => {
    i && clearTimeout(i), i = setTimeout(() => {
      ss.set(t, !1), d();
    }, Nte);
  }, f = (z) => {
    ss.set(t, !0), i && (clearTimeout(i), i = null);
  }, g = function() {
    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, $ = jm.get(t);
    if ($) {
      if (E() || V) {
        $.style.display = "none";
        return;
      }
      $.style.removeProperty("display");
    }
  }, h = (z, V) => {
    var $, Z = ($ = wr.get(t)) !== null && $ !== void 0 ? $ : [];
    wr.set(t, Z);
    var J = Ee.leaf(t, z), Y = Z.findIndex((k) => ne.equals(k.path, z));
    if (Y < 0) {
      var te = $A(J.text, V);
      te && Z.push({
        path: z,
        diff: V,
        id: l++
      }), g();
      return;
    }
    var ee = Bte(J.text, Z[Y].diff, V);
    if (!ee) {
      Z.splice(Y, 1), g();
      return;
    }
    Z[Y] = tc(tc({}, Z[Y]), {}, {
      diff: ee
    });
  }, C = function(V) {
    var {
      at: $
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, si.delete(t), n.cancel(), r.cancel(), S() && d(), ii.set(t, {
      at: $,
      run: V
    }), a = setTimeout(d);
  }, w = (z) => {
    var V;
    if (s && (clearTimeout(s), s = null), !Ts.get(t)) {
      var {
        inputType: $
      } = z, Z = null, J = z.dataTransfer || z.data || void 0;
      u !== !1 && $ !== "insertText" && $ !== "insertCompositionText" && (u = !1);
      var [Y] = z.getTargetRanges();
      Y && (Z = de.toSlateRange(t, Y, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var te = de.getWindow(t), ee = te.getSelection();
      if (!Z && ee && (Y = ee, Z = de.toSlateRange(t, ee, {
        exactMatch: !1,
        suppressThrow: !0
      })), Z = (V = Z) !== null && V !== void 0 ? V : t.selection, !!Z) {
        var k = !0;
        if ($.startsWith("delete")) {
          if (ae.isExpanded(Z)) {
            var [_, K] = ae.edges(Z), M = Ee.leaf(t, _.path);
            if (M.text.length === _.offset && K.offset === 0) {
              var G = I.next(t, {
                at: _.path,
                match: Be.isText
              });
              G && ne.equals(G[1], K.path) && (Z = {
                anchor: K,
                focus: K
              });
            }
          }
          var x = $.endsWith("Backward") ? "backward" : "forward", [T, F] = ae.edges(Z), [j, H] = I.leaf(t, T.path), B = {
            text: "",
            start: T.offset,
            end: F.offset
          }, Q = wr.get(t), W = Q == null ? void 0 : Q.find((Ve) => ne.equals(Ve.path, H)), ue = W ? [W.diff, B] : [B], ye = zA(j.text, ...ue);
          if (ye.length === 0 && (k = !1), ae.isExpanded(Z)) {
            if (k && ne.equals(Z.anchor.path, Z.focus.path)) {
              var oe = {
                path: Z.anchor.path,
                offset: T.offset
              }, _e = I.range(t, oe, oe);
              return P(_e), h(Z.anchor.path, {
                text: "",
                end: F.offset,
                start: T.offset
              });
            }
            return C(() => I.deleteFragment(t, {
              direction: x
            }), {
              at: Z
            });
          }
        }
        switch ($) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return C(() => I.deleteFragment(t), {
              at: Z
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: Fe
            } = Z;
            if (k && ae.isCollapsed(Z)) {
              var ze = Ee.leaf(t, Fe.path);
              if (Fe.offset < ze.text.length)
                return h(Fe.path, {
                  text: "",
                  start: Fe.offset,
                  end: Fe.offset + 1
                });
            }
            return C(() => I.deleteForward(t), {
              at: Z
            });
          }
          case "deleteContentBackward": {
            var Re, {
              anchor: Ge
            } = Z, Ze = Bm(Y) ? Y.isCollapsed : !!((Re = Y) !== null && Re !== void 0 && Re.collapsed);
            return k && Ze && ae.isCollapsed(Z) && Ge.offset > 0 ? h(Ge.path, {
              text: "",
              start: Ge.offset - 1,
              end: Ge.offset
            }) : C(() => I.deleteBackward(t), {
              at: Z
            });
          }
          case "deleteEntireSoftLine":
            return C(() => {
              I.deleteBackward(t, {
                unit: "line"
              }), I.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: Z
            });
          case "deleteHardLineBackward":
            return C(() => I.deleteBackward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineBackward":
            return C(() => I.deleteBackward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteHardLineForward":
            return C(() => I.deleteForward(t, {
              unit: "block"
            }), {
              at: Z
            });
          case "deleteSoftLineForward":
            return C(() => I.deleteForward(t, {
              unit: "line"
            }), {
              at: Z
            });
          case "deleteWordBackward":
            return C(() => I.deleteBackward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "deleteWordForward":
            return C(() => I.deleteForward(t, {
              unit: "word"
            }), {
              at: Z
            });
          case "insertLineBreak":
            return C(() => I.insertSoftBreak(t), {
              at: Z
            });
          case "insertParagraph":
            return C(() => I.insertBreak(t), {
              at: Z
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if ($te(J))
              return C(() => de.insertData(t, J), {
                at: Z
              });
            var Me = J ?? "";
            if (no.get(t) && (Me = Me.replace("\uFEFF", "")), $ === "insertText" && /.*\n.*\n$/.test(Me) && (Me = Me.slice(0, -1)), Me.includes(`
`))
              return C(() => {
                var Ve = Me.split(`
`);
                Ve.forEach((Ue, ot) => {
                  Ue && I.insertText(t, Ue), ot !== Ve.length - 1 && I.insertSoftBreak(t);
                });
              }, {
                at: Z
              });
            if (ne.equals(Z.anchor.path, Z.focus.path)) {
              var [Ke, rt] = ae.edges(Z), Se = {
                start: Ke.offset,
                end: rt.offset,
                text: Me
              };
              if (Me && u && $ === "insertCompositionText") {
                var je = u.start + u.text.search(/\S|$/), Ne = Se.start + Se.text.search(/\S|$/);
                Ne === je + 1 && Se.end === u.start + u.text.length ? (Se.start -= 1, u = null, N()) : u = !1;
              } else $ === "insertText" ? u === null ? u = Se : u && ae.isCollapsed(Z) && u.end + u.text.length === Ke.offset ? u = tc(tc({}, u), {}, {
                text: u.text + Me
              }) : u = !1 : u = !1;
              if (k) {
                h(Ke.path, Se);
                return;
              }
            }
            return C(() => I.insertText(t, Me), {
              at: Z
            });
          }
        }
      }
    }
  }, S = () => !!ii.get(t), E = () => {
    var z;
    return !!((z = wr.get(t)) !== null && z !== void 0 && z.length);
  }, v = () => S() || E(), O = () => o, P = (z) => {
    si.set(t, z), s && (clearTimeout(s), s = null);
    var {
      selection: V
    } = t;
    if (z) {
      var $ = !V || !ne.equals(V.anchor.path, z.anchor.path), Z = !V || !ne.equals(V.anchor.path.slice(0, -1), z.anchor.path.slice(0, -1));
      ($ && u || Z) && (u = !1), ($ || E()) && (s = setTimeout(d, Fte));
    }
  }, U = () => {
    (S() || !E()) && d();
  }, L = (z) => {
    E() || (g(!0), setTimeout(g));
  }, N = () => {
    S() || (a = setTimeout(d));
  }, A = (z) => {
    if (!(E() || S()) && z.some(($) => cb(t, $, z))) {
      var V;
      (V = AA.get(t)) === null || V === void 0 || V();
    }
  };
  return {
    flush: d,
    scheduleFlush: N,
    hasPendingDiffs: E,
    hasPendingAction: S,
    hasPendingChanges: v,
    isFlushing: O,
    handleUserSelect: P,
    handleCompositionEnd: m,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: L,
    handleDomMutations: A,
    handleInput: U
  };
}
function Wte() {
  var e = Ye(!1);
  return y(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var yl = yc ? GB : y;
function Vte(e, t, n) {
  var [r] = D(() => new MutationObserver(t));
  yl(() => {
    r.takeRecords();
  }), y(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var Hte = ["node"];
function nP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qte(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nP(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zte = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, Kte = hr ? (e) => {
  var {
    node: t
  } = e, n = Rs(e, Hte);
  if (!hr)
    return null;
  var r = Mi(), o = Wte(), [i] = D(() => Ute(qte({
    editor: r
  }, n)));
  return Vte(t, i.handleDomMutations, Zte), lb.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, Gte = ["anchor", "focus"], Yte = ["anchor", "focus"], Xte = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), UA = (e, t) => {
  var n = Rs(e, Gte), r = Rs(t, Yte);
  return e[Ns] === t[Ns] && Xte(n, r);
}, Jte = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!ae.equals(r, o) || !UA(r, o))
      return !1;
  }
  return !0;
}, Qte = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !UA(r, o))
      return !1;
  }
  return !0;
};
function rP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ene(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rP(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tne = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = Mi(), s = de.findPath(i, o), a = ne.parent(s), l = !!n[BA];
  return i.isVoid(r) ? /* @__PURE__ */ xe.createElement(tg, {
    length: Ee.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && I.string(i, a) === "" ? /* @__PURE__ */ xe.createElement(tg, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ xe.createElement(tg, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ xe.createElement(oP, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ xe.createElement(oP, {
    text: n.text
  });
}, oP = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = Ye(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = D(o);
  return yl(() => {
    var s = o();
    r.current && r.current.textContent !== s && (r.current.textContent = s);
  }), /* @__PURE__ */ xe.createElement(nne, {
    ref: r
  }, i);
}, nne = /* @__PURE__ */ ke(/* @__PURE__ */ Fs((e, t) => /* @__PURE__ */ xe.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), tg = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ xe.createElement("span", ene({}, o), !(hr || TA) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ xe.createElement("br", null) : null);
};
function iP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iP(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rne = hr ? 300 : 0;
function one(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function sP(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var ine = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: s = (w) => /* @__PURE__ */ xe.createElement(ane, WA({}, w))
  } = e, a = Mi(), l = Ye(null), u = Ye(null), [c, p] = D(!1), d = Ye(null), m = qt((w) => {
    if (one(l, w == null), w == null) {
      var S;
      jm.delete(a), (S = t.onPlaceholderResize) === null || S === void 0 || S.call(t, null);
    } else {
      if (jm.set(a, w), !l.current) {
        var E = window.ResizeObserver || cte;
        l.current = new E(() => {
          var v;
          (v = t.onPlaceholderResize) === null || v === void 0 || v.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, a]), f = /* @__PURE__ */ xe.createElement(tne, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), g = !!t[Ns];
  if (y(() => (g ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, rne)) : (sP(d), p(!1)), () => sP(d)), [g, p]), g && c) {
    var h = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: Xi ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: m
      }
    };
    f = /* @__PURE__ */ xe.createElement(xe.Fragment, null, i(h), f);
  }
  var C = {
    "data-slate-leaf": !0
  };
  return s({
    attributes: C,
    children: f,
    leaf: t,
    text: r
  });
}, sne = /* @__PURE__ */ xe.memo(ine, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Be.equals(t.leaf, e.leaf) && t.leaf[Ns] === e.leaf[Ns]), ane = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ xe.createElement("span", WA({}, t), n);
}, lne = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: s
  } = e, a = Mi(), l = Ye(null), u = Be.decorations(s, t), c = de.findKey(a, s), p = [], d = 0; d < u.length; d++) {
    var m = u[d];
    p.push(/* @__PURE__ */ xe.createElement(sne, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: m,
      text: s,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = qt((g) => {
    var h = pf.get(a);
    g ? (h == null || h.set(c, g), cs.set(s, g), vl.set(g, s)) : (h == null || h.delete(c), cs.delete(s), l.current && vl.delete(l.current)), l.current = g;
  }, [l, a, c, s]);
  return /* @__PURE__ */ xe.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, VA = /* @__PURE__ */ xe.memo(lne, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && Qte(t.decorations, e.decorations));
function aP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aP(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var une = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ xe.createElement(pne, Nm({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = Mi(), l = hne(), u = a.isInline(n), c = de.findKey(a, n), p = qt((w) => {
    var S = pf.get(a);
    w ? (S == null || S.set(c, w), cs.set(n, w), vl.set(w, n)) : (S == null || S.delete(c), cs.delete(n));
  }, [a, c, n]), d = qA({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  }), m = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (m["data-slate-inline"] = !0), !u && I.hasInlines(a, n)) {
    var f = Ee.string(n), g = bA(f);
    g === "rtl" && (m.dir = g);
  }
  if (I.isVoid(a, n)) {
    m["data-slate-void"] = !0, !l && u && (m.contentEditable = !1);
    var h = u ? "span" : "div", [[C]] = Ee.texts(n);
    d = /* @__PURE__ */ xe.createElement(h, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ xe.createElement(VA, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: C
    })), sb.set(C, 0), ab.set(C, n);
  }
  return r({
    attributes: m,
    children: d,
    element: n
  });
}, cne = /* @__PURE__ */ xe.memo(une, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && Jte(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && ae.equals(e.selection, t.selection))), pne = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = Mi(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ xe.createElement(i, Nm(Nm({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, HA = /* @__PURE__ */ qe(() => []), dne = () => De(HA), fne = /* @__PURE__ */ qe(!1), qA = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = dne(), l = Mi();
  Ts.set(l, !1);
  for (var u = de.findPath(l, n), c = [], p = Ae.isElement(n) && !l.isInline(n) && I.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var m = u.concat(d), f = n.children[d], g = de.findKey(l, f), h = I.range(l, m), C = s && ae.intersection(h, s), w = a([f, m]);
    for (var S of t) {
      var E = ae.intersection(S, h);
      E && w.push(E);
    }
    Ae.isElement(f) ? c.push(/* @__PURE__ */ xe.createElement(fne.Provider, {
      key: "provider-".concat(g.id),
      value: !!C
    }, /* @__PURE__ */ xe.createElement(cne, {
      decorations: w,
      element: f,
      key: g.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: C
    }))) : c.push(/* @__PURE__ */ xe.createElement(VA, {
      decorations: w,
      key: g.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), sb.set(f, d), ab.set(f, n);
  }
  return c;
}, ZA = /* @__PURE__ */ qe(!1), hne = () => De(ZA), KA = /* @__PURE__ */ qe(null), df = () => {
  var e = De(KA);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function gne() {
  var e = Mi(), t = Ye(!1), n = Ye(0), r = qt(() => {
    if (!t.current) {
      t.current = !0;
      var o = de.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return y(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var mne = 3, vne = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, yne = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, bne = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, kn = (e) => {
  var t = vne[e], n = yne[e], r = bne[e], o = t && Zh(t), i = n && Zh(n), s = r && Zh(r);
  return (a) => !!(o && o(a) || XD && i && i(a) || !XD && s && s(a));
}, _n = {
  isBold: kn("bold"),
  isCompose: kn("compose"),
  isMoveBackward: kn("moveBackward"),
  isMoveForward: kn("moveForward"),
  isDeleteBackward: kn("deleteBackward"),
  isDeleteForward: kn("deleteForward"),
  isDeleteLineBackward: kn("deleteLineBackward"),
  isDeleteLineForward: kn("deleteLineForward"),
  isDeleteWordBackward: kn("deleteWordBackward"),
  isDeleteWordForward: kn("deleteWordForward"),
  isExtendBackward: kn("extendBackward"),
  isExtendForward: kn("extendForward"),
  isExtendLineBackward: kn("extendLineBackward"),
  isExtendLineForward: kn("extendLineForward"),
  isItalic: kn("italic"),
  isMoveLineBackward: kn("moveLineBackward"),
  isMoveLineForward: kn("moveLineForward"),
  isMoveWordBackward: kn("moveWordBackward"),
  isMoveWordForward: kn("moveWordForward"),
  isRedo: kn("redo"),
  isSoftBreak: kn("insertSoftBreak"),
  isSplitBlock: kn("splitBlock"),
  isTransposeCharacter: kn("transposeCharacter"),
  isUndo: kn("undo")
}, wne = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => cb(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Cne = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class GA extends Fp {
  constructor() {
    super(...arguments), Qr(this, "context", null), Qr(this, "manager", null), Qr(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Cne);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = wne(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Qr(GA, "contextType", ib);
var One = hr ? GA : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ xe.createElement(xe.Fragment, null, t);
}, Ene = /* @__PURE__ */ qe(!1), xne = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], Lne = ["text"];
function lP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lP(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Dne = (e) => /* @__PURE__ */ xe.createElement(xe.Fragment, null, qA(e)), Pne = /* @__PURE__ */ Fs((e, t) => {
  var n = qt((T) => /* @__PURE__ */ xe.createElement(kne, lo({}, T)), []), {
    autoFocus: r,
    decorate: o = Sne,
    onDOMBeforeInput: i,
    placeholder: s,
    readOnly: a = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = Mne,
    style: d = {},
    as: m = "div",
    disableDefaultStyles: f = !1
  } = e, g = Rs(e, xne), h = df(), [C, w] = D(!1), S = Ye(null), E = Ye([]), [v, O] = D(), P = Ye(!1), {
    onUserInput: U,
    receivedUserInput: L
  } = gne(), [, N] = KB((T) => T + 1, 0);
  AA.set(h, N), _m.set(h, a);
  var A = Gn(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  y(() => {
    S.current && r && S.current.focus();
  }, [r]);
  var z = Ye(), V = Gn(() => zee(() => {
    if (Ts.get(h)) {
      V();
      return;
    }
    var T = de.toDOMNode(h, h), F = T.getRootNode();
    if (!P.current && Xi && F instanceof ShadowRoot) {
      P.current = !0;
      var j = kte();
      j ? document.execCommand("indent") : ve.deselect(h), P.current = !1;
      return;
    }
    var H = z.current;
    if ((hr || !de.isComposing(h)) && (!A.isUpdatingSelection || H != null && H.isFlushing()) && !A.isDraggingInternally) {
      var B = de.findDocumentOrShadowRoot(h), {
        activeElement: Q
      } = B, W = de.toDOMNode(h, h), ue = Ha(B);
      if (Q === W ? (A.latestElement = Q, fi.set(h, !0)) : fi.delete(h), !ue)
        return ve.deselect(h);
      var {
        anchorNode: ye,
        focusNode: oe
      } = ue, _e = de.hasEditableTarget(h, ye) || de.isTargetInsideNonReadonlyVoid(h, ye), Fe = de.hasTarget(h, oe);
      if (_e && Fe) {
        var ze = de.toSlateRange(h, ue, {
          exactMatch: !1,
          suppressThrow: !0
        });
        ze && (!de.isComposing(h) && !(H != null && H.hasPendingChanges()) && !(H != null && H.isFlushing()) ? ve.select(h, ze) : H == null || H.handleUserSelect(ze));
      }
      a && (!_e || !Fe) && ve.deselect(h);
    }
  }, 100), [h, a, A]), $ = Gn(() => Aee(V, 0), [V]);
  z.current = Kte({
    node: S,
    onDOMSelectionChange: V,
    scheduleOnDOMSelectionChange: $
  }), yl(() => {
    var T, F, j;
    S.current && (j = ub(S.current)) ? (_A.set(h, j), bc.set(h, S.current), cs.set(h, S.current), vl.set(S.current, h)) : cs.delete(h);
    var {
      selection: H
    } = h, B = de.findDocumentOrShadowRoot(h), Q = Ha(B);
    if (!(!Q || !de.isFocused(h) || (T = z.current) !== null && T !== void 0 && T.hasPendingAction())) {
      var W = (_e) => {
        var Fe = Q.type !== "None";
        if (!(!H && !Fe)) {
          var ze = Q.focusNode, Re;
          if (Ds && Q.rangeCount > 1) {
            var Ge = Q.getRangeAt(0), Ze = Q.getRangeAt(Q.rangeCount - 1);
            Ge.startContainer === ze ? Re = Ze.endContainer : Re = Ge.startContainer;
          } else
            Re = Q.anchorNode;
          var Me = bc.get(h), Ke = !1;
          if (Me.contains(Re) && Me.contains(ze) && (Ke = !0), Fe && Ke && H && !_e) {
            var rt = de.toSlateRange(h, Q, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (rt && ae.equals(rt, H)) {
              var Se;
              if (!A.hasMarkPlaceholder || (Se = Re) !== null && Se !== void 0 && (Se = Se.parentElement) !== null && Se !== void 0 && Se.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (H && !de.hasRange(h, H)) {
            h.selection = de.toSlateRange(h, Q, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          A.isUpdatingSelection = !0;
          var je = H && de.toDOMRange(h, H);
          return je ? (de.isComposing(h) && !hr ? Q.collapseToEnd() : ae.isBackward(H) ? Q.setBaseAndExtent(je.endContainer, je.endOffset, je.startContainer, je.startOffset) : Q.setBaseAndExtent(je.startContainer, je.startOffset, je.endContainer, je.endOffset), p(h, je)) : Q.removeAllRanges(), je;
        }
      };
      Q.rangeCount <= 1 && W();
      var ue = ((F = z.current) === null || F === void 0 ? void 0 : F.isFlushing()) === "action";
      if (!hr || !ue) {
        setTimeout(() => {
          A.isUpdatingSelection = !1;
        });
        return;
      }
      var ye = null, oe = requestAnimationFrame(() => {
        if (ue) {
          var _e = (Fe) => {
            try {
              var ze = de.toDOMNode(h, h);
              ze.focus(), W(Fe);
            } catch {
            }
          };
          _e(), ye = setTimeout(() => {
            _e(!0), A.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), ye && clearTimeout(ye);
      };
    }
  });
  var Z = qt((T) => {
    var F = de.toDOMNode(h, h), j = F.getRootNode();
    if (P != null && P.current && Xi && j instanceof ShadowRoot) {
      var H = T.getTargetRanges(), B = H[0], Q = new window.Range();
      Q.setStart(B.startContainer, B.startOffset), Q.setEnd(B.endContainer, B.endOffset);
      var W = de.toSlateRange(h, Q, {
        exactMatch: !1,
        suppressThrow: !1
      });
      ve.select(h, W), T.preventDefault(), T.stopImmediatePropagation();
      return;
    }
    if (U(), !a && de.hasEditableTarget(h, T.target) && !Tne(T, i)) {
      var ue;
      if (z.current)
        return z.current.handleDOMBeforeInput(T);
      $.flush(), V.flush();
      var {
        selection: ye
      } = h, {
        inputType: oe
      } = T, _e = T.dataTransfer || T.data || void 0, Fe = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if (Fe && de.isComposing(h))
        return;
      var ze = !1;
      if (oe === "insertText" && ye && ae.isCollapsed(ye) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      T.data && T.data.length === 1 && /[a-z ]/i.test(T.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      ye.anchor.offset !== 0 && (ze = !0, h.marks && (ze = !1), !Ts.get(h))) {
        var Re, Ge, {
          anchor: Ze
        } = ye, [Me, Ke] = de.toDOMPoint(h, Ze), rt = (Re = Me.parentElement) === null || Re === void 0 ? void 0 : Re.closest("a"), Se = de.getWindow(h);
        if (ze && rt && de.hasDOMNode(h, rt)) {
          var je, Ne = Se == null ? void 0 : Se.document.createTreeWalker(rt, NodeFilter.SHOW_TEXT).lastChild();
          Ne === Me && ((je = Ne.textContent) === null || je === void 0 ? void 0 : je.length) === Ke && (ze = !1);
        }
        if (ze && Me.parentElement && (Se == null || (Ge = Se.getComputedStyle(Me.parentElement)) === null || Ge === void 0 ? void 0 : Ge.whiteSpace) === "pre") {
          var Ve = I.above(h, {
            at: Ze.path,
            match: (ht) => Ae.isElement(ht) && I.isBlock(h, ht)
          });
          Ve && Ee.string(Ve[0]).includes("	") && (ze = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !Ts.get(h)) {
        var [Ue] = T.getTargetRanges();
        if (Ue) {
          var ot = de.toSlateRange(h, Ue, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!ye || !ae.equals(ye, ot)) {
            ze = !1;
            var Te = !Fe && h.selection && I.rangeRef(h, h.selection);
            ve.select(h, ot), Te && Va.set(h, Te);
          }
        }
      }
      if (Fe)
        return;
      if (ze || T.preventDefault(), ye && ae.isExpanded(ye) && oe.startsWith("delete")) {
        var Zt = oe.endsWith("Backward") ? "backward" : "forward";
        I.deleteFragment(h, {
          direction: Zt
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          I.deleteFragment(h);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          I.deleteForward(h);
          break;
        }
        case "deleteContentBackward": {
          I.deleteBackward(h);
          break;
        }
        case "deleteEntireSoftLine": {
          I.deleteBackward(h, {
            unit: "line"
          }), I.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          I.deleteBackward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          I.deleteBackward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          I.deleteForward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          I.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          I.deleteBackward(h, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          I.deleteForward(h, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          I.insertSoftBreak(h);
          break;
        case "insertParagraph": {
          I.insertBreak(h);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && de.isComposing(h) && (w(!1), ss.set(h, !1)), (_e == null ? void 0 : _e.constructor.name) === "DataTransfer" ? de.insertData(h, _e) : typeof _e == "string" && (ze ? E.current.push(() => I.insertText(h, _e)) : I.insertText(h, _e));
          break;
        }
      }
      var lt = (ue = Va.get(h)) === null || ue === void 0 ? void 0 : ue.unref();
      Va.delete(h), lt && (!h.selection || !ae.equals(h.selection, lt)) && ve.select(h, lt);
    }
  }, [h, V, U, i, a, $]), J = qt((T) => {
    T == null ? (V.cancel(), $.cancel(), bc.delete(h), cs.delete(h), S.current && Go && S.current.removeEventListener("beforeinput", Z)) : Go && T.addEventListener("beforeinput", Z), S.current = T, typeof t == "function" ? t(T) : t && (t.current = T);
  }, [V, $, h, Z, t]);
  yl(() => {
    var T = de.getWindow(h);
    T.document.addEventListener("selectionchange", $);
    var F = () => {
      A.isDraggingInternally = !1;
    };
    return T.document.addEventListener("dragend", F), T.document.addEventListener("drop", F), () => {
      T.document.removeEventListener("selectionchange", $), T.document.removeEventListener("dragend", F), T.document.removeEventListener("drop", F);
    };
  }, [$, A]);
  var Y = o([h, []]), te = s && h.children.length === 1 && Array.from(Ee.texts(h)).length === 1 && Ee.string(h) === "" && !C, ee = qt((T) => {
    if (T && te) {
      var F;
      O((F = T.getBoundingClientRect()) === null || F === void 0 ? void 0 : F.height);
    } else
      O(void 0);
  }, [te]);
  if (te) {
    var k = I.start(h, []);
    Y.push({
      [Ns]: !0,
      placeholder: s,
      onPlaceholderResize: ee,
      anchor: k,
      focus: k
    });
  }
  var {
    marks: _
  } = h;
  if (A.hasMarkPlaceholder = !1, h.selection && ae.isCollapsed(h.selection) && _) {
    var {
      anchor: K
    } = h.selection, M = Ee.leaf(h, K.path), G = Rs(M, Lne);
    if (!Be.equals(M, _, {
      loose: !0
    })) {
      A.hasMarkPlaceholder = !0;
      var x = Object.fromEntries(Object.keys(G).map((T) => [T, null]));
      Y.push(lo(lo(lo({
        [BA]: !0
      }, x), _), {}, {
        anchor: K,
        focus: K
      }));
    }
  }
  return y(() => {
    setTimeout(() => {
      var {
        selection: T
      } = h;
      if (T) {
        var {
          anchor: F
        } = T, j = Ee.leaf(h, F.path);
        if (_ && !Be.equals(j, _, {
          loose: !0
        })) {
          no.set(h, _);
          return;
        }
      }
      no.delete(h);
    });
  }), /* @__PURE__ */ xe.createElement(ZA.Provider, {
    value: a
  }, /* @__PURE__ */ xe.createElement(Ene.Provider, {
    value: C
  }, /* @__PURE__ */ xe.createElement(HA.Provider, {
    value: o
  }, /* @__PURE__ */ xe.createElement(One, {
    node: S,
    receivedUserInput: L
  }, /* @__PURE__ */ xe.createElement(m, lo(lo({
    role: a ? void 0 : "textbox",
    "aria-multiline": a ? void 0 : !0
  }, g), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Go || !yc ? g.spellCheck : !1,
    autoCorrect: Go || !yc ? g.autoCorrect : "false",
    autoCapitalize: Go || !yc ? g.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !a,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: J,
    style: lo(lo({}, f ? {} : lo({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, v ? {
      minHeight: v
    } : {})), d),
    onBeforeInput: qt((T) => {
      if (!Go && !a && !fr(T, g.onBeforeInput) && de.hasSelectableTarget(h, T.target) && (T.preventDefault(), !de.isComposing(h))) {
        var F = T.data;
        I.insertText(h, F);
      }
    }, [g.onBeforeInput, h, a]),
    onInput: qt((T) => {
      if (!fr(T, g.onInput)) {
        if (z.current) {
          z.current.handleInput();
          return;
        }
        for (var F of E.current)
          F();
        if (E.current = [], !de.isFocused(h)) {
          var j = T.nativeEvent, H = h;
          if (j.inputType === "historyUndo" && typeof H.undo == "function") {
            H.undo();
            return;
          }
          if (j.inputType === "historyRedo" && typeof H.redo == "function") {
            H.redo();
            return;
          }
        }
      }
    }, [g.onInput, h]),
    onBlur: qt((T) => {
      if (!(a || A.isUpdatingSelection || !de.hasSelectableTarget(h, T.target) || fr(T, g.onBlur))) {
        var F = de.findDocumentOrShadowRoot(h);
        if (A.latestElement !== F.activeElement) {
          var {
            relatedTarget: j
          } = T, H = de.toDOMNode(h, h);
          if (j !== H && !(Jr(j) && j.hasAttribute("data-slate-spacer"))) {
            if (j != null && gi(j) && de.hasDOMNode(h, j)) {
              var B = de.toSlateNode(h, j);
              if (Ae.isElement(B) && !h.isVoid(B))
                return;
            }
            if (Xi) {
              var Q = Ha(F);
              Q == null || Q.removeAllRanges();
            }
            fi.delete(h);
          }
        }
      }
    }, [a, A.isUpdatingSelection, A.latestElement, h, g.onBlur]),
    onClick: qt((T) => {
      if (de.hasTarget(h, T.target) && !fr(T, g.onClick) && gi(T.target)) {
        var F = de.toSlateNode(h, T.target), j = de.findPath(h, F);
        if (!I.hasPath(h, j) || Ee.get(h, j) !== F)
          return;
        if (T.detail === mne && j.length >= 1) {
          var H = j;
          if (!(Ae.isElement(F) && I.isBlock(h, F))) {
            var B, Q = I.above(h, {
              match: (ze) => Ae.isElement(ze) && I.isBlock(h, ze),
              at: j
            });
            H = (B = Q == null ? void 0 : Q[1]) !== null && B !== void 0 ? B : j.slice(0, 1);
          }
          var W = I.range(h, H);
          ve.select(h, W);
          return;
        }
        if (a)
          return;
        var ue = I.start(h, j), ye = I.end(h, j), oe = I.void(h, {
          at: ue
        }), _e = I.void(h, {
          at: ye
        });
        if (oe && _e && ne.equals(oe[1], _e[1])) {
          var Fe = I.range(h, ue);
          ve.select(h, Fe);
        }
      }
    }, [h, g.onClick, a]),
    onCompositionEnd: qt((T) => {
      if (de.hasSelectableTarget(h, T.target)) {
        var F;
        if (de.isComposing(h) && Promise.resolve().then(() => {
          w(!1), ss.set(h, !1);
        }), (F = z.current) === null || F === void 0 || F.handleCompositionEnd(T), fr(T, g.onCompositionEnd) || hr)
          return;
        if (!Xi && !vte && !TA && !bte && !yte && T.data) {
          var j = no.get(h);
          no.delete(h), j !== void 0 && (_o.set(h, h.marks), h.marks = j), I.insertText(h, T.data);
          var H = _o.get(h);
          _o.delete(h), H !== void 0 && (h.marks = H);
        }
      }
    }, [g.onCompositionEnd, h]),
    onCompositionUpdate: qt((T) => {
      de.hasSelectableTarget(h, T.target) && !fr(T, g.onCompositionUpdate) && (de.isComposing(h) || (w(!0), ss.set(h, !0)));
    }, [g.onCompositionUpdate, h]),
    onCompositionStart: qt((T) => {
      if (de.hasSelectableTarget(h, T.target)) {
        var F;
        if ((F = z.current) === null || F === void 0 || F.handleCompositionStart(T), fr(T, g.onCompositionStart) || hr)
          return;
        w(!0);
        var {
          selection: j
        } = h;
        if (j && ae.isExpanded(j)) {
          I.deleteFragment(h);
          return;
        }
      }
    }, [g.onCompositionStart, h]),
    onCopy: qt((T) => {
      de.hasSelectableTarget(h, T.target) && !fr(T, g.onCopy) && !uP(T) && (T.preventDefault(), de.setFragmentData(h, T.clipboardData, "copy"));
    }, [g.onCopy, h]),
    onCut: qt((T) => {
      if (!a && de.hasSelectableTarget(h, T.target) && !fr(T, g.onCut) && !uP(T)) {
        T.preventDefault(), de.setFragmentData(h, T.clipboardData, "cut");
        var {
          selection: F
        } = h;
        if (F)
          if (ae.isExpanded(F))
            I.deleteFragment(h);
          else {
            var j = Ee.parent(h, F.anchor.path);
            I.isVoid(h, j) && ve.delete(h);
          }
      }
    }, [a, h, g.onCut]),
    onDragOver: qt((T) => {
      if (de.hasTarget(h, T.target) && !fr(T, g.onDragOver)) {
        var F = de.toSlateNode(h, T.target);
        Ae.isElement(F) && I.isVoid(h, F) && T.preventDefault();
      }
    }, [g.onDragOver, h]),
    onDragStart: qt((T) => {
      if (!a && de.hasTarget(h, T.target) && !fr(T, g.onDragStart)) {
        var F = de.toSlateNode(h, T.target), j = de.findPath(h, F), H = Ae.isElement(F) && I.isVoid(h, F) || I.void(h, {
          at: j,
          voids: !0
        });
        if (H) {
          var B = I.range(h, j);
          ve.select(h, B);
        }
        A.isDraggingInternally = !0, de.setFragmentData(h, T.dataTransfer, "drag");
      }
    }, [a, h, g.onDragStart, A]),
    onDrop: qt((T) => {
      if (!a && de.hasTarget(h, T.target) && !fr(T, g.onDrop)) {
        T.preventDefault();
        var F = h.selection, j = de.findEventRange(h, T), H = T.dataTransfer;
        ve.select(h, j), A.isDraggingInternally && F && !ae.equals(F, j) && !I.void(h, {
          at: j,
          voids: !0
        }) && ve.delete(h, {
          at: F
        }), de.insertData(h, H), de.isFocused(h) || de.focus(h);
      }
    }, [a, h, g.onDrop, A]),
    onDragEnd: qt((T) => {
      !a && A.isDraggingInternally && g.onDragEnd && de.hasTarget(h, T.target) && g.onDragEnd(T);
    }, [a, A, g, h]),
    onFocus: qt((T) => {
      if (!a && !A.isUpdatingSelection && de.hasEditableTarget(h, T.target) && !fr(T, g.onFocus)) {
        var F = de.toDOMNode(h, h), j = de.findDocumentOrShadowRoot(h);
        if (A.latestElement = j.activeElement, Ds && T.target !== F) {
          F.focus();
          return;
        }
        fi.set(h, !0);
      }
    }, [a, A, h, g.onFocus]),
    onKeyDown: qt((T) => {
      if (!a && de.hasEditableTarget(h, T.target)) {
        var F;
        (F = z.current) === null || F === void 0 || F.handleKeyDown(T);
        var {
          nativeEvent: j
        } = T;
        if (de.isComposing(h) && j.isComposing === !1 && (ss.set(h, !1), w(!1)), fr(T, g.onKeyDown) || de.isComposing(h))
          return;
        var {
          selection: H
        } = h, B = h.children[H !== null ? H.focus.path[0] : 0], Q = bA(Ee.string(B)) === "rtl";
        if (_n.isRedo(j)) {
          T.preventDefault();
          var W = h;
          typeof W.redo == "function" && W.redo();
          return;
        }
        if (_n.isUndo(j)) {
          T.preventDefault();
          var ue = h;
          typeof ue.undo == "function" && ue.undo();
          return;
        }
        if (_n.isMoveLineBackward(j)) {
          T.preventDefault(), ve.move(h, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (_n.isMoveLineForward(j)) {
          T.preventDefault(), ve.move(h, {
            unit: "line"
          });
          return;
        }
        if (_n.isExtendLineBackward(j)) {
          T.preventDefault(), ve.move(h, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (_n.isExtendLineForward(j)) {
          T.preventDefault(), ve.move(h, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (_n.isMoveBackward(j)) {
          T.preventDefault(), H && ae.isCollapsed(H) ? ve.move(h, {
            reverse: !Q
          }) : ve.collapse(h, {
            edge: Q ? "end" : "start"
          });
          return;
        }
        if (_n.isMoveForward(j)) {
          T.preventDefault(), H && ae.isCollapsed(H) ? ve.move(h, {
            reverse: Q
          }) : ve.collapse(h, {
            edge: Q ? "start" : "end"
          });
          return;
        }
        if (_n.isMoveWordBackward(j)) {
          T.preventDefault(), H && ae.isExpanded(H) && ve.collapse(h, {
            edge: "focus"
          }), ve.move(h, {
            unit: "word",
            reverse: !Q
          });
          return;
        }
        if (_n.isMoveWordForward(j)) {
          T.preventDefault(), H && ae.isExpanded(H) && ve.collapse(h, {
            edge: "focus"
          }), ve.move(h, {
            unit: "word",
            reverse: Q
          });
          return;
        }
        if (Go) {
          if ((jA || Xi) && H && (_n.isDeleteBackward(j) || _n.isDeleteForward(j)) && ae.isCollapsed(H)) {
            var ye = Ee.parent(h, H.anchor.path);
            if (Ae.isElement(ye) && I.isVoid(h, ye) && (I.isInline(h, ye) || I.isBlock(h, ye))) {
              T.preventDefault(), I.deleteBackward(h, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (_n.isBold(j) || _n.isItalic(j) || _n.isTransposeCharacter(j)) {
            T.preventDefault();
            return;
          }
          if (_n.isSoftBreak(j)) {
            T.preventDefault(), I.insertSoftBreak(h);
            return;
          }
          if (_n.isSplitBlock(j)) {
            T.preventDefault(), I.insertBreak(h);
            return;
          }
          if (_n.isDeleteBackward(j)) {
            T.preventDefault(), H && ae.isExpanded(H) ? I.deleteFragment(h, {
              direction: "backward"
            }) : I.deleteBackward(h);
            return;
          }
          if (_n.isDeleteForward(j)) {
            T.preventDefault(), H && ae.isExpanded(H) ? I.deleteFragment(h, {
              direction: "forward"
            }) : I.deleteForward(h);
            return;
          }
          if (_n.isDeleteLineBackward(j)) {
            T.preventDefault(), H && ae.isExpanded(H) ? I.deleteFragment(h, {
              direction: "backward"
            }) : I.deleteBackward(h, {
              unit: "line"
            });
            return;
          }
          if (_n.isDeleteLineForward(j)) {
            T.preventDefault(), H && ae.isExpanded(H) ? I.deleteFragment(h, {
              direction: "forward"
            }) : I.deleteForward(h, {
              unit: "line"
            });
            return;
          }
          if (_n.isDeleteWordBackward(j)) {
            T.preventDefault(), H && ae.isExpanded(H) ? I.deleteFragment(h, {
              direction: "backward"
            }) : I.deleteBackward(h, {
              unit: "word"
            });
            return;
          }
          if (_n.isDeleteWordForward(j)) {
            T.preventDefault(), H && ae.isExpanded(H) ? I.deleteFragment(h, {
              direction: "forward"
            }) : I.deleteForward(h, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [a, h, g.onKeyDown]),
    onPaste: qt((T) => {
      !a && de.hasEditableTarget(h, T.target) && !fr(T, g.onPaste) && (!Go || Ote(T.nativeEvent) || Xi) && (T.preventDefault(), de.insertData(h, T.clipboardData));
    }, [a, h, g.onPaste])
  }), /* @__PURE__ */ xe.createElement(Dne, {
    decorations: Y,
    node: h,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: h.selection
  }))))));
}), kne = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ xe.createElement("span", lo({}, t), n, hr && /* @__PURE__ */ xe.createElement("br", null))
  );
}, Sne = () => [], Mne = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && ae.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), Wee(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, fr = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, uP = (e) => gi(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), Tne = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, jne = /* @__PURE__ */ qe(!1), _ne = /* @__PURE__ */ qe({});
function Ane(e) {
  var t = Ye([]).current, n = Ye({
    editor: e
  }).current, r = qt((i) => {
    n.editor = i, t.forEach((s) => s(i));
  }, [t, n]), o = Gn(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var Bne = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], Ine = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: s
  } = e, a = Rs(e, Bne), [l, u] = xe.useState(() => {
    if (!Ee.isNodeList(s))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(tr.stringify(s)));
    if (!I.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(tr.stringify(t)));
    return t.children = s, Object.assign(t, a), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = Ane(t), d = qt((g) => {
    var h;
    switch (r && r(t.children), g == null || (h = g.operation) === null || h === void 0 ? void 0 : h.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((C) => ({
      v: C.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  y(() => (Am.set(t, d), () => {
    Am.set(t, () => {
    });
  }), [t, d]);
  var [m, f] = D(de.isFocused(t));
  return y(() => {
    f(de.isFocused(t));
  }, [t]), yl(() => {
    var g = () => f(de.isFocused(t));
    return MA >= 17 ? (document.addEventListener("focusin", g), document.addEventListener("focusout", g), () => {
      document.removeEventListener("focusin", g), document.removeEventListener("focusout", g);
    }) : (document.addEventListener("focus", g, !0), document.addEventListener("blur", g, !0), () => {
      document.removeEventListener("focus", g, !0), document.removeEventListener("blur", g, !0);
    });
  }, []), /* @__PURE__ */ xe.createElement(_ne.Provider, {
    value: c
  }, /* @__PURE__ */ xe.createElement(KA.Provider, {
    value: l
  }, /* @__PURE__ */ xe.createElement(ib.Provider, {
    value: l.editor
  }, /* @__PURE__ */ xe.createElement(jne.Provider, {
    value: m
  }, n))));
}, cP = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, pP = (e, t, n) => {
  var r = de.toDOMRange(e, t).getBoundingClientRect(), o = de.toDOMRange(e, n).getBoundingClientRect();
  return cP(r, o) && cP(o, r);
}, Rne = (e, t) => {
  var n = I.range(e, ae.end(t)), r = Array.from(I.positions(e, {
    at: t
  })), o = 0, i = r.length, s = Math.floor(i / 2);
  if (pP(e, I.range(e, r[o]), n))
    return I.range(e, r[o], n);
  if (r.length < 2)
    return I.range(e, r[r.length - 1], n);
  for (; s !== r.length && s !== o; )
    pP(e, I.range(e, r[s]), n) ? i = s : o = s, s = Math.floor((o + i) / 2);
  return I.range(e, r[i], n);
};
function dP(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fP(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dP(Object(n), !0).forEach(function(r) {
      Qr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dP(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nne = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: s,
    addMark: a,
    removeMark: l
  } = r;
  return pf.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = lb.get(r)) === null || p === void 0 || p(), !no.get(r) && (d = wr.get(r)) !== null && d !== void 0 && d.length && no.set(r, null), _o.delete(r), a(u, c);
  }, r.removeMark = (u) => {
    var c;
    !no.get(r) && (c = wr.get(r)) !== null && c !== void 0 && c.length && no.set(r, null), _o.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return s(u);
    if (r.selection && ae.isCollapsed(r.selection)) {
      var c = I.above(r, {
        match: (f) => Ae.isElement(f) && I.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = I.range(r, p, r.selection.anchor), m = Rne(r, d);
        ae.isCollapsed(m) || ve.delete(r, {
          at: m
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = wr.get(r);
    if (d != null && d.length) {
      var m = d.map(($) => Rte($, u)).filter(Boolean);
      wr.set(r, m);
    }
    var f = si.get(r);
    f && si.set(r, eP(r, f, u));
    var g = ii.get(r);
    if (g != null && g.at) {
      var h = ct.isPoint(g == null ? void 0 : g.at) ? Rm(r, g.at, u) : eP(r, g.at, u);
      ii.set(r, h ? fP(fP({}, g), {}, {
        at: h
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...xs(r, u.path));
        break;
      }
      case "set_selection": {
        var C;
        (C = Va.get(r)) === null || C === void 0 || C.unref(), Va.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...xs(r, ne.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = ne.previous(u.path);
        c.push(...xs(r, w));
        break;
      }
      case "move_node": {
        var S = ne.common(ne.parent(u.path), ne.parent(u.newPath));
        c.push(...xs(r, S));
        var E;
        ne.isBefore(u.path, u.newPath) ? (c.push(...xs(r, ne.parent(u.path))), E = u.newPath) : (c.push(...xs(r, ne.parent(u.newPath))), E = u.path);
        var v = Ee.get(t, ne.parent(E)), O = de.findKey(r, v), P = I.pathRef(r, ne.parent(E));
        p.push([P, O]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        Ts.set(r, !0);
    }
    for (var [U, L] of c) {
      var [N] = I.node(r, U);
      Pp.set(N, L);
    }
    for (var [A, z] of p) {
      if (A.current) {
        var [V] = I.node(r, A.current);
        Pp.set(V, z);
      }
      A.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = ae.edges(c), m = I.void(r, {
        at: p.path
      }), f = I.void(r, {
        at: d.path
      });
      if (!(ae.isCollapsed(c) && !m)) {
        var g = de.toDOMRange(r, c), h = g.cloneContents(), C = h.childNodes[0];
        if (h.childNodes.forEach((N) => {
          N.textContent && N.textContent.trim() !== "" && (C = N);
        }), f) {
          var [w] = f, S = g.cloneRange(), E = de.toDOMNode(r, w);
          S.setEndAfter(E), h = S.cloneContents();
        }
        if (m && (C = h.querySelector("[data-slate-spacer]")), Array.from(h.querySelectorAll("[data-slate-zero-width]")).forEach((N) => {
          var A = N.getAttribute("data-slate-zero-width") === "n";
          N.textContent = A ? `
` : "";
        }), RA(C)) {
          var v = C.ownerDocument.createElement("span");
          v.style.whiteSpace = "pre", v.appendChild(C), h.appendChild(v), C = v;
        }
        var O = r.getFragment(), P = JSON.stringify(O), U = window.btoa(encodeURIComponent(P));
        C.setAttribute("data-slate-fragment", U), u.setData("application/".concat(n), U);
        var L = h.ownerDocument.createElement("div");
        return L.appendChild(h), L.setAttribute("hidden", "true"), h.ownerDocument.body.appendChild(L), u.setData("text/html", L.innerHTML), u.setData("text/plain", FA(L)), h.ownerDocument.body.removeChild(L), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || Pte(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var m of p)
        d && ve.splitNodes(r, {
          always: !0
        }), r.insertText(m), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = MA < 18 ? wl.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = Am.get(r);
      p && p(u), i(u);
    });
  }, r;
}, xs = (e, t) => {
  var n = [];
  for (var [r, o] of I.levels(e, {
    at: t
  })) {
    var i = de.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function YA(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    I.nodes(e, {
      at: I.unhangRange(e, r),
      match: (i) => !I.isEditor(i) && Ae.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const hP = ["listItem", "numberedList"], wc = ["left", "center", "right", "justify"];
function Fne(e, t) {
  const n = wc.includes(t) ? "align" : "type", r = YA(e, t, n), o = hP.includes(t);
  ve.unwrapNodes(e, {
    match: (s) => !I.isEditor(s) && Ae.isElement(s) && hP.includes(s.type) && !wc.includes(t),
    split: !0
  });
  let i;
  if (wc.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, ve.setNodes(e, i), !r && o) {
    const s = { type: t, children: [] };
    ve.wrapNodes(e, s);
  }
}
function Vi({ format: e, icon: t }) {
  const n = df(), r = wc.includes(e) ? "align" : "type", i = YA(n, e, r) ? "activeTrue" : "activeFalse";
  function s(a) {
    a.preventDefault(), Fne(n, e);
  }
  return /* @__PURE__ */ q.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: s,
      children: /* @__PURE__ */ q.jsx(t, {})
    }
  );
}
function zne({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ q.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ q.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ q.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ q.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ q.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ q.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ q.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ q.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ q.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const XA = qe({});
function $ne(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, a = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ q.jsx(XA.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ q.jsx(ES, { children: t && /* @__PURE__ */ q.jsxs("aside", { className: a.trim(), ...i, children: [
    /* @__PURE__ */ q.jsx(
      Za.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ q.jsx(
      Za.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function Une(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ q.jsx("footer", { className: o.trim(), ...r });
}
function Wne(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = De(XA), s = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ q.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ q.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ q.jsx(Ym, { size: 24 })
      }
    )
  ] });
}
const Fm = qe({});
function Vne() {
  if (!Fm)
    throw new Error("useTabContext must be used within a TabProvider");
  return De(Fm);
}
function Hne(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [s, a] = D(r || ""), [l, u] = D(!0), c = Ye(null), p = `arkynTabContainer ${o || ""}`, [d, m] = D({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (h, C) => {
    const w = h.getBoundingClientRect(), S = c.current.getBoundingClientRect(), E = C ? void 0 : "none";
    u(!1), m({
      transition: E,
      width: `${w.width}px`,
      left: `${w.left - S.left}px`
    });
  };
  y(() => {
    const h = c.current;
    if (!h) return;
    let C = null;
    C = h.querySelector("button.activeTrue"), C && f(C);
  }, []);
  const g = (h) => {
    const C = h.target;
    C && (a(C.value), C.classList.add("activeTrue"), f(C, !0), n && n(C.value));
  };
  return /* @__PURE__ */ q.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ q.jsx(Fm.Provider, { value: { handleTabClick: g, showInitialTab: l, value: s }, children: t }),
    /* @__PURE__ */ q.jsx("div", { className: "activeLine", style: d })
  ] });
}
function gP(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: s, handleTabClick: a } = Vne(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && s ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    a(d), r && r(d);
  }
  return /* @__PURE__ */ q.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function qne(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: s = "URL da imagem:",
    modalTitle: a = "Inserir imagem"
  } = e, l = df(), [u, c] = D(!1), [p, d] = D(""), [m, f] = D("url");
  function g(h) {
    h.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
    /* @__PURE__ */ q.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ q.jsx(eI, {})
      }
    ),
    /* @__PURE__ */ q.jsxs(
      $ne,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ q.jsx(Wne, { children: a }),
          /* @__PURE__ */ q.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ q.jsxs(Hne, { defaultActive: m, onClick: f, children: [
              /* @__PURE__ */ q.jsx(gP, { value: "url", children: n[0] }),
              /* @__PURE__ */ q.jsx(gP, { value: "file", children: n[1] })
            ] }),
            m === "url" && /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
              /* @__PURE__ */ q.jsxs(kD, { children: [
                /* @__PURE__ */ q.jsx(SD, { children: s }),
                /* @__PURE__ */ q.jsx(
                  uf,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (h) => d(h.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ q.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            m === "file" && /* @__PURE__ */ q.jsxs(kD, { children: [
              /* @__PURE__ */ q.jsx(SD, { children: i }),
              /* @__PURE__ */ q.jsx(
                nQ,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (h) => d(h || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ q.jsxs(Une, { children: [
            /* @__PURE__ */ q.jsx(
              Dp,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ q.jsx(Dp, { type: "button", onClick: g, children: o })
          ] })
        ]
      }
    )
  ] });
}
function Zne({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ q.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ q.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ q.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ q.jsx("u", { children: t })), /* @__PURE__ */ q.jsx("span", { ...e, children: t });
}
function JA(e, t) {
  const n = I.marks(e);
  return n ? n[t] === !0 : !1;
}
function QA(e, t) {
  JA(e, t) ? I.removeMark(e, t) : I.addMark(e, t, !0);
}
function nc({ format: e, icon: t }) {
  const n = df(), o = JA(n, e) ? "activeTrue" : "activeFalse";
  function i(s) {
    s.preventDefault(), QA(n, e);
  }
  return /* @__PURE__ */ q.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ q.jsx(t, {})
    }
  );
}
function Kne({ children: e }) {
  return /* @__PURE__ */ q.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function mP(e) {
  return e.map((t) => Ee.string(t)).join("");
}
const vP = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, rc = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function hle(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: s,
    maxLimit: a = 2e3,
    onChange: l,
    isError: u
  } = e, c = Gn(() => SQ(Nne(XN())), []), { id: p, inputRef: d, error: m } = Tr(), f = Ye(null);
  function g() {
    try {
      const Y = JSON.parse(o);
      return !Array.isArray(Y) || Y.length <= 0 ? rc : Y.every(
        (ee) => typeof ee == "object" && ee !== null && "type" in ee && "children" in ee
      ) ? Y : rc;
    } catch {
      return rc;
    }
  }
  const h = mP(g()), [C, w] = D(h.length), [S, E] = D(
    JSON.stringify(g()) || "[]"
  ), [v, O] = D(!1), P = d || f, U = u || !!m, L = qt(Zne, []), N = qt(zne, []);
  function A(Y) {
    const te = mP(Y);
    w(te.length), s && s(te.length), !(i && te.length >= a) && (E(JSON.stringify(Y)), l && l(Y), c.children = Y, ve.setNodes(c, { children: Y }));
  }
  const z = v ? "focusTrue" : "focusFalse", $ = `arkynRichText ${U || a < C ? "errorTrue" : "errorFalse"} ${z}`, Z = a - C;
  function J(Y) {
    return !(n != null && n.includes(Y));
  }
  return /* @__PURE__ */ q.jsxs(
    Ine,
    {
      editor: c,
      initialValue: g(),
      onChange: A,
      onValueChange: A,
      children: [
        /* @__PURE__ */ q.jsxs("div", { className: $, children: [
          /* @__PURE__ */ q.jsxs(Kne, { children: [
            J("headingOne") && /* @__PURE__ */ q.jsx(Vi, { format: "headingOne", icon: tI }),
            J("headingTwo") && /* @__PURE__ */ q.jsx(Vi, { format: "headingTwo", icon: nI }),
            J("blockQuote") && /* @__PURE__ */ q.jsx(Vi, { format: "blockQuote", icon: rI }),
            J("bold") && /* @__PURE__ */ q.jsx(nc, { format: "bold", icon: oI }),
            J("italic") && /* @__PURE__ */ q.jsx(nc, { format: "italic", icon: iI }),
            J("underline") && /* @__PURE__ */ q.jsx(nc, { format: "underline", icon: sI }),
            J("code") && /* @__PURE__ */ q.jsx(nc, { format: "code", icon: aI }),
            J("left") && /* @__PURE__ */ q.jsx(Vi, { format: "left", icon: lI }),
            J("right") && /* @__PURE__ */ q.jsx(Vi, { format: "right", icon: uI }),
            J("center") && /* @__PURE__ */ q.jsx(Vi, { format: "center", icon: cI }),
            J("justify") && /* @__PURE__ */ q.jsx(Vi, { format: "justify", icon: pI }),
            r && J("image") && /* @__PURE__ */ q.jsx(qne, { ...r })
          ] }),
          /* @__PURE__ */ q.jsx(
            Pne,
            {
              className: "editorContainer",
              renderElement: N,
              renderLeaf: L,
              spellCheck: !0,
              id: p,
              onFocus: () => O(!0),
              onBlur: () => O(!1),
              onKeyDown: (Y) => {
                for (const te in vP)
                  if (DQ(te, Y)) {
                    Y.preventDefault();
                    const ee = vP[te];
                    QA(c, ee);
                  }
              }
            }
          ),
          Z < 0 && /* @__PURE__ */ q.jsx("div", { className: "restatesCharacters", children: Z })
        ] }),
        /* @__PURE__ */ q.jsx("input", { type: "hidden", ref: P, name: t, value: S }),
        /* @__PURE__ */ q.jsx("input", { type: "hidden", name: `${t}Count`, value: C })
      ]
    }
  );
}
function Gne(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: m,
    style: f,
    closeOnSelect: g = !0,
    ...h
  } = e, v = `arkyn_select ${a ? "hasPrefix" : ""} ${s} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, P = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: v,
    prefix: nM(a, P, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: m,
    closeOnSelect: g,
    style: f,
    iconSize: P,
    Spinner: /* @__PURE__ */ q.jsx(vo, { className: "spinner", size: P, strokeWidth: 2.5 }),
    ...h
  };
}
function gle(e) {
  var T;
  const [t, n] = D(""), [r, o] = D(!1), { inputRef: i, id: s, error: a } = Tr(), l = Ye(null), u = i || l, c = e.isError || !!a, {
    disabled: p,
    title: d,
    style: m,
    className: f,
    prefix: g,
    iconSize: h,
    isLoading: C,
    LeftIcon: w,
    value: S = null,
    defaultValue: E = "",
    onFocus: v,
    onBlur: O,
    Spinner: P,
    name: U,
    placeholder: L,
    onSelect: N,
    options: A,
    optionMaxHeight: z,
    closeOnSelect: V,
    isSearchable: $,
    onSearch: Z,
    ...J
  } = Gne({ ...e, id: s, isError: c }, r), [Y, te] = D(E);
  function ee() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function k(F) {
    r || (o(!0), v && v(F));
  }
  function _() {
    o(!1), O && u.current && u.current.blur();
  }
  function K(F) {
    const { label: j, value: H } = F;
    te(Y !== H ? H : ""), N && N({ label: j, value: H }), V && _();
  }
  const M = typeof S == "string" ? S : Y, G = ((T = A.find((F) => F.value === M)) == null ? void 0 : T.label) || "", x = () => {
    if (!r && G) return !0;
    if (!r && !G) return !1;
    if (r && G) return !0;
    if (r && !G) return !1;
  };
  return /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
    /* @__PURE__ */ q.jsxs(
      "section",
      {
        title: d,
        style: m,
        onClick: ee,
        className: `${f} placeholder_dark_${x()}`,
        children: [
          g,
          w && /* @__PURE__ */ q.jsx(w, { size: h, strokeWidth: 2.5 }),
          /* @__PURE__ */ q.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: G || L,
              onFocus: k,
              ...J
            }
          ),
          /* @__PURE__ */ q.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: U,
              value: M || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ q.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: z },
              children: [
                $ && /* @__PURE__ */ q.jsx(
                  uf,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: bS,
                    onChange: (F) => n(F.target.value)
                  }
                ),
                A.filter((F) => !!(e.onSearch || !e.isSearchable || F.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: F, value: j }) => /* @__PURE__ */ q.jsxs(
                  "div",
                  {
                    onClick: () => K({ label: F, value: j }),
                    className: M === j ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      F,
                      " ",
                      /* @__PURE__ */ q.jsx(Gm, {})
                    ]
                  },
                  j
                )),
                A.length <= 0 && /* @__PURE__ */ q.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !C && /* @__PURE__ */ q.jsx(
            yS,
            {
              className: "arkyn_select_arrow",
              size: h,
              strokeWidth: 2.5
            }
          ),
          C && P
        ]
      }
    ),
    r && /* @__PURE__ */ q.jsx("aside", { className: "arkyn_select_overlay", onClick: _ })
  ] });
}
function mle(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: s,
    className: a = "",
    onCheck: l,
    ...u
  } = e, [c, p] = D(n), { id: d, inputRef: m } = Tr(), f = typeof r == "boolean" ? r : c;
  function g() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const C = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${a}`;
  return /* @__PURE__ */ q.jsx("button", { type: "button", onClick: g, className: C, ...u, children: /* @__PURE__ */ q.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: s,
      ref: m,
      onClick: g,
      value: f ? o || "checked" : i
    }
  ) });
}
function vle(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: s,
    onBlur: a,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = D(!1), { inputRef: m, id: f, error: g } = Tr(), h = Ye(null), C = m || h, S = e.isError || !!g ? "errorTrue" : "errorFalse", O = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${S} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function P() {
    o || !(C != null && C.current) || (d(!0), C.current.focus());
  }
  function U(N) {
    d(!0), s && s(N);
  }
  function L(N) {
    d(!1), a && a(N);
  }
  return /* @__PURE__ */ q.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: P,
      className: O,
      children: /* @__PURE__ */ q.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: C,
          onFocus: U,
          onBlur: L,
          ...c
        }
      )
    }
  );
}
function yle(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ q.jsx("nav", { className: r, ...n });
}
function ble(e) {
  const { pathname: t } = Jm(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...s
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ q.jsxs("p", { className: l, children: [
    /* @__PURE__ */ q.jsx(yg, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ q.jsxs(hI, { to: i, className: l, ...s, children: [
    /* @__PURE__ */ q.jsx(yg, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function eB(e = "") {
  const t = Jm(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([s, a]) => {
      a === void 0 ? n.delete(`${r}${s}`) : n.set(`${r}${s}`, String(a));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let s = n.toString();
      return s && (s = "?" + s), s;
    }
  };
}
function yP(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function wle(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: s = 1,
    registerPerPage: a = 20,
    ...l
  } = e, u = OS(), { getParam: c, getScopedSearch: p } = eB(t), d = Number(c("page")) || s, m = Number(c("per_page")) || a, f = Math.ceil(n / m), g = d > 1 ? yP(d - 1 - i, d - 1) : [], h = d < f ? yP(
    d,
    Math.min(d + i, f)
  ) : [];
  function C(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ q.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ q.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => C(d - 1),
        children: /* @__PURE__ */ q.jsx(dI, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
      /* @__PURE__ */ q.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => C(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ q.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ q.jsx(xb, {}) })
    ] }),
    g.length > 0 && g.map((w, S) => /* @__PURE__ */ q.jsx(
      "button",
      {
        onClick: () => C(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      S
    )),
    /* @__PURE__ */ q.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    h.length > 0 && h.map((w, S) => /* @__PURE__ */ q.jsx(
      "button",
      {
        onClick: () => C(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      S
    )),
    d + i < f && /* @__PURE__ */ q.jsxs(q.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ q.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ q.jsx(xb, {}) }),
      /* @__PURE__ */ q.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => C(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ q.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => C(d + 1),
        children: /* @__PURE__ */ q.jsx(yg, {})
      }
    )
  ] });
}
const tB = qe({});
function Cle(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...s
  } = e, a = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ q.jsx(tB.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ q.jsx(ES, { children: t && /* @__PURE__ */ q.jsxs("aside", { className: u.trim(), ...s, children: [
    /* @__PURE__ */ q.jsx(
      Za.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ q.jsx(
      Za.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${a})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${a})` },
        children: o
      }
    )
  ] }) }) });
}
function Ole(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = De(tB), s = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ q.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ q.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ q.jsx(Ym, { size: 24 })
      }
    )
  ] });
}
function Ele(e) {
  const { children: t, button: n, closeOnClick: r, orientation: o = "bottomLeft" } = e, [i, s] = D(!1), l = `arkynPopover ${o} ${i ? "visibleTrue" : "visibleFalse"}`;
  function u() {
    i || s(!0);
  }
  return /* @__PURE__ */ q.jsxs("div", { className: l, onClick: u, children: [
    n,
    /* @__PURE__ */ q.jsx(
      Za.div,
      {
        style: { visibility: i ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: i ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    i && /* @__PURE__ */ q.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function xle(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ q.jsx(mS, {});
      case "danger":
        return /* @__PURE__ */ q.jsx(gS, {});
      default:
        return /* @__PURE__ */ q.jsx(hS, {});
    }
  }
  return /* @__PURE__ */ q.jsxs("div", { className: r, children: [
    /* @__PURE__ */ q.jsxs("div", { children: [
      /* @__PURE__ */ q.jsx("div", { className: "bg" }),
      /* @__PURE__ */ q.jsx(o, {})
    ] }),
    /* @__PURE__ */ q.jsx("p", { children: /* @__PURE__ */ q.jsx("span", { children: t }) })
  ] });
}
var Kn = {}, pb = {}, Ul = {}, Wl = {}, nB = "Expected a function", bP = NaN, Yne = "[object Symbol]", Xne = /^\s+|\s+$/g, Jne = /^[-+]0x[0-9a-f]+$/i, Qne = /^0b[01]+$/i, ere = /^0o[0-7]+$/i, tre = parseInt, nre = typeof tn == "object" && tn && tn.Object === Object && tn, rre = typeof self == "object" && self && self.Object === Object && self, ore = nre || rre || Function("return this")(), ire = Object.prototype, sre = ire.toString, are = Math.max, lre = Math.min, ng = function() {
  return ore.Date.now();
};
function ure(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(nB);
  t = wP(t) || 0, kp(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? are(wP(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function m(O) {
    var P = r, U = o;
    return r = o = void 0, u = O, s = e.apply(U, P), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var P = O - l, U = O - u, L = t - P;
    return p ? lre(L, i - U) : L;
  }
  function h(O) {
    var P = O - l, U = O - u;
    return l === void 0 || P >= t || P < 0 || p && U >= i;
  }
  function C() {
    var O = ng();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, d && r ? m(O) : (r = o = void 0, s);
  }
  function S() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(ng());
  }
  function v() {
    var O = ng(), P = h(O);
    if (r = arguments, o = this, l = O, P) {
      if (a === void 0)
        return f(l);
      if (p)
        return a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = S, v.flush = E, v;
}
function cre(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(nB);
  return kp(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), ure(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function kp(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function pre(e) {
  return !!e && typeof e == "object";
}
function dre(e) {
  return typeof e == "symbol" || pre(e) && sre.call(e) == Yne;
}
function wP(e) {
  if (typeof e == "number")
    return e;
  if (dre(e))
    return bP;
  if (kp(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = kp(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Xne, "");
  var n = Qne.test(e);
  return n || ere.test(e) ? tre(e.slice(2), n ? 2 : 8) : Jne.test(e) ? bP : +e;
}
var fre = cre, Vl = {};
Object.defineProperty(Vl, "__esModule", {
  value: !0
});
Vl.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), Cc.has(n) || Cc.set(n, /* @__PURE__ */ new Set());
  var i = Cc.get(n);
  if (!i.has(o)) {
    var s = function() {
      var a = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return a;
    }();
    t.addEventListener(n, r, s ? { passive: !0 } : !1), i.add(o);
  }
};
Vl.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), Cc.get(n).delete(r.name || n);
};
var Cc = /* @__PURE__ */ new Map();
Object.defineProperty(Wl, "__esModule", {
  value: !0
});
var hre = fre, gre = vre(hre), mre = Vl;
function vre(e) {
  return e && e.__esModule ? e : { default: e };
}
var yre = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, gre.default)(t, n);
}, Rn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = yre(function(o) {
        Rn.scrollHandler(t);
      }, n);
      Rn.scrollSpyContainers.push(t), (0, mre.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return Rn.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = Rn.scrollSpyContainers[Rn.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(Rn.currentPositionX(t), Rn.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    Rn.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = Rn.scrollSpyContainers[Rn.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(Rn.currentPositionX(n), Rn.currentPositionY(n));
  },
  updateStates: function() {
    Rn.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    Rn.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), Rn.spySetState && Rn.spySetState.length && Rn.spySetState.indexOf(t) > -1 && Rn.spySetState.splice(Rn.spySetState.indexOf(t), 1), document.removeEventListener("scroll", Rn.scrollHandler);
  },
  update: function() {
    return Rn.scrollSpyContainers.forEach(function(t) {
      return Rn.scrollHandler(t);
    });
  }
};
Wl.default = Rn;
var Ys = {}, Hl = {};
Object.defineProperty(Hl, "__esModule", {
  value: !0
});
var bre = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, s = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", s) : history.replaceState(history.state, "", s);
}, wre = function() {
  return window.location.hash.replace(/^#/, "");
}, Cre = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, Ore = function(t) {
  return getComputedStyle(t).position !== "static";
}, rg = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, Ere = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Ore(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = rg(n, o), s = i.offsetTop, a = i.offsetParent;
      if (a !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return s;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return rg(n, l).offsetTop - rg(t, l).offsetTop;
};
Hl.default = {
  updateHash: bre,
  getHash: wre,
  filterElementInContainer: Cre,
  scrollOffset: Ere
};
var ff = {}, db = {};
Object.defineProperty(db, "__esModule", {
  value: !0
});
db.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var fb = {};
Object.defineProperty(fb, "__esModule", {
  value: !0
});
var xre = Vl, Lre = ["mousedown", "mousewheel", "touchmove", "keydown"];
fb.default = {
  subscribe: function(t) {
    return typeof document < "u" && Lre.forEach(function(n) {
      return (0, xre.addPassiveEventListener)(document, n, t);
    });
  }
};
var ql = {};
Object.defineProperty(ql, "__esModule", {
  value: !0
});
var zm = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      zm.registered[t] = n;
    },
    remove: function(t) {
      zm.registered[t] = null;
    }
  }
};
ql.default = zm;
Object.defineProperty(ff, "__esModule", {
  value: !0
});
var Dre = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Pre = Hl;
hf(Pre);
var kre = db, CP = hf(kre), Sre = fb, Mre = hf(Sre), Tre = ql, fo = hf(Tre);
function hf(e) {
  return e && e.__esModule ? e : { default: e };
}
var rB = function(t) {
  return CP.default[t.smooth] || CP.default.defaultEasing;
}, jre = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, _re = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, $m = function() {
  return _re() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), oB = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, iB = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, sB = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, Are = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, Bre = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, Ire = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    fo.default.registered.end && fo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    $m.call(window, i);
    return;
  }
  fo.default.registered.end && fo.default.registered.end(o.to, o.target, o.currentPosition);
}, hb = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, Zl = function(t, n, r, o) {
  n.data = n.data || oB(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (Mre.default.subscribe(i), hb(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? iB(n) : sB(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    fo.default.registered.end && fo.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = jre(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var s = rB(n), a = Ire.bind(null, s, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      fo.default.registered.begin && fo.default.registered.begin(n.data.to, n.data.target), $m.call(window, a);
    }, n.delay);
    return;
  }
  fo.default.registered.begin && fo.default.registered.begin(n.data.to, n.data.target), $m.call(window, a);
}, gf = function(t) {
  return t = Dre({}, t), t.data = t.data || oB(), t.absolute = !0, t;
}, Rre = function(t) {
  Zl(0, gf(t));
}, Nre = function(t, n) {
  Zl(t, gf(n));
}, Fre = function(t) {
  t = gf(t), hb(t), Zl(t.horizontal ? Are(t) : Bre(t), t);
}, zre = function(t, n) {
  n = gf(n), hb(n);
  var r = n.horizontal ? iB(n) : sB(n);
  Zl(t + r, n);
};
ff.default = {
  animateTopScroll: Zl,
  getAnimationType: rB,
  scrollToTop: Rre,
  scrollToBottom: Fre,
  scrollTo: Nre,
  scrollMore: zre
};
Object.defineProperty(Ys, "__esModule", {
  value: !0
});
var $re = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ure = Hl, Wre = gb(Ure), Vre = ff, Hre = gb(Vre), qre = ql, oc = gb(qre);
function gb(e) {
  return e && e.__esModule ? e : { default: e };
}
var ic = {}, OP = void 0;
Ys.default = {
  unmount: function() {
    ic = {};
  },
  register: function(t, n) {
    ic[t] = n;
  },
  unregister: function(t) {
    delete ic[t];
  },
  get: function(t) {
    return ic[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return OP = t;
  },
  getActiveLink: function() {
    return OP;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = $re({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, s = void 0;
    o ? s = document.getElementById(o) : i && i.nodeType ? s = i : s = document, n.absolute = !0;
    var a = n.horizontal, l = Wre.default.scrollOffset(s, r, a) + (n.offset || 0);
    if (!n.smooth) {
      oc.default.registered.begin && oc.default.registered.begin(t, r), s === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : s.scrollTop = l, oc.default.registered.end && oc.default.registered.end(t, r);
      return;
    }
    Hre.default.animateTopScroll(l, n, t, r);
  }
};
var Um = { exports: {} }, sc = { exports: {} }, Vt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EP;
function Zre() {
  if (EP) return Vt;
  EP = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function S(v) {
    if (typeof v == "object" && v !== null) {
      var O = v.$$typeof;
      switch (O) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return v;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(v) {
    return S(v) === u;
  }
  return Vt.AsyncMode = l, Vt.ConcurrentMode = u, Vt.ContextConsumer = a, Vt.ContextProvider = s, Vt.Element = t, Vt.ForwardRef = c, Vt.Fragment = r, Vt.Lazy = f, Vt.Memo = m, Vt.Portal = n, Vt.Profiler = i, Vt.StrictMode = o, Vt.Suspense = p, Vt.isAsyncMode = function(v) {
    return E(v) || S(v) === l;
  }, Vt.isConcurrentMode = E, Vt.isContextConsumer = function(v) {
    return S(v) === a;
  }, Vt.isContextProvider = function(v) {
    return S(v) === s;
  }, Vt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Vt.isForwardRef = function(v) {
    return S(v) === c;
  }, Vt.isFragment = function(v) {
    return S(v) === r;
  }, Vt.isLazy = function(v) {
    return S(v) === f;
  }, Vt.isMemo = function(v) {
    return S(v) === m;
  }, Vt.isPortal = function(v) {
    return S(v) === n;
  }, Vt.isProfiler = function(v) {
    return S(v) === i;
  }, Vt.isStrictMode = function(v) {
    return S(v) === o;
  }, Vt.isSuspense = function(v) {
    return S(v) === p;
  }, Vt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === p || v === d || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === m || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === g);
  }, Vt.typeOf = S, Vt;
}
var Ht = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xP;
function Kre() {
  return xP || (xP = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function S(W) {
      return typeof W == "string" || typeof W == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      W === r || W === u || W === i || W === o || W === p || W === d || typeof W == "object" && W !== null && (W.$$typeof === f || W.$$typeof === m || W.$$typeof === s || W.$$typeof === a || W.$$typeof === c || W.$$typeof === h || W.$$typeof === C || W.$$typeof === w || W.$$typeof === g);
    }
    function E(W) {
      if (typeof W == "object" && W !== null) {
        var ue = W.$$typeof;
        switch (ue) {
          case t:
            var ye = W.type;
            switch (ye) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ye;
              default:
                var oe = ye && ye.$$typeof;
                switch (oe) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var v = l, O = u, P = a, U = s, L = t, N = c, A = r, z = f, V = m, $ = n, Z = i, J = o, Y = p, te = !1;
    function ee(W) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(W) || E(W) === l;
    }
    function k(W) {
      return E(W) === u;
    }
    function _(W) {
      return E(W) === a;
    }
    function K(W) {
      return E(W) === s;
    }
    function M(W) {
      return typeof W == "object" && W !== null && W.$$typeof === t;
    }
    function G(W) {
      return E(W) === c;
    }
    function x(W) {
      return E(W) === r;
    }
    function T(W) {
      return E(W) === f;
    }
    function F(W) {
      return E(W) === m;
    }
    function j(W) {
      return E(W) === n;
    }
    function H(W) {
      return E(W) === i;
    }
    function B(W) {
      return E(W) === o;
    }
    function Q(W) {
      return E(W) === p;
    }
    Ht.AsyncMode = v, Ht.ConcurrentMode = O, Ht.ContextConsumer = P, Ht.ContextProvider = U, Ht.Element = L, Ht.ForwardRef = N, Ht.Fragment = A, Ht.Lazy = z, Ht.Memo = V, Ht.Portal = $, Ht.Profiler = Z, Ht.StrictMode = J, Ht.Suspense = Y, Ht.isAsyncMode = ee, Ht.isConcurrentMode = k, Ht.isContextConsumer = _, Ht.isContextProvider = K, Ht.isElement = M, Ht.isForwardRef = G, Ht.isFragment = x, Ht.isLazy = T, Ht.isMemo = F, Ht.isPortal = j, Ht.isProfiler = H, Ht.isStrictMode = B, Ht.isSuspense = Q, Ht.isValidElementType = S, Ht.typeOf = E;
  }()), Ht;
}
var LP;
function aB() {
  return LP || (LP = 1, process.env.NODE_ENV === "production" ? sc.exports = Zre() : sc.exports = Kre()), sc.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var og, DP;
function Gre() {
  if (DP) return og;
  DP = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return og = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, og;
}
var ig, PP;
function mb() {
  if (PP) return ig;
  PP = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ig = e, ig;
}
var sg, kP;
function lB() {
  return kP || (kP = 1, sg = Function.call.bind(Object.prototype.hasOwnProperty)), sg;
}
var ag, SP;
function Yre() {
  if (SP) return ag;
  SP = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = mb(), n = {}, r = lB();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, ag = o, ag;
}
var lg, MP;
function Xre() {
  if (MP) return lg;
  MP = 1;
  var e = aB(), t = Gre(), n = mb(), r = lB(), o = Yre(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return lg = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", m = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: S,
      element: E(),
      elementType: v(),
      instanceOf: O,
      node: N(),
      objectOf: U,
      oneOf: P,
      oneOfType: L,
      shape: z,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function g(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, K = 0;
      function M(x, T, F, j, H, B, Q) {
        if (j = j || d, B = B || F, Q !== n) {
          if (l) {
            var W = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw W.name = "Invariant Violation", W;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = j + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            K < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + B + "` prop on `" + j + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, K++);
          }
        }
        return T[F] == null ? x ? T[F] === null ? new g("The " + H + " `" + B + "` is marked as required " + ("in `" + j + "`, but its value is `null`.")) : new g("The " + H + " `" + B + "` is marked as required in " + ("`" + j + "`, but its value is `undefined`.")) : null : k(T, F, j, H, B);
      }
      var G = M.bind(null, !1);
      return G.isRequired = M.bind(null, !0), G;
    }
    function C(k) {
      function _(K, M, G, x, T, F) {
        var j = K[M], H = J(j);
        if (H !== k) {
          var B = Y(j);
          return new g(
            "Invalid " + x + " `" + T + "` of type " + ("`" + B + "` supplied to `" + G + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return h(_);
    }
    function w() {
      return h(s);
    }
    function S(k) {
      function _(K, M, G, x, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + G + "` has invalid PropType notation inside arrayOf.");
        var F = K[M];
        if (!Array.isArray(F)) {
          var j = J(F);
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an array."));
        }
        for (var H = 0; H < F.length; H++) {
          var B = k(F, H, G, x, T + "[" + H + "]", n);
          if (B instanceof Error)
            return B;
        }
        return null;
      }
      return h(_);
    }
    function E() {
      function k(_, K, M, G, x) {
        var T = _[K];
        if (!a(T)) {
          var F = J(T);
          return new g("Invalid " + G + " `" + x + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(k);
    }
    function v() {
      function k(_, K, M, G, x) {
        var T = _[K];
        if (!e.isValidElementType(T)) {
          var F = J(T);
          return new g("Invalid " + G + " `" + x + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(k);
    }
    function O(k) {
      function _(K, M, G, x, T) {
        if (!(K[M] instanceof k)) {
          var F = k.name || d, j = ee(K[M]);
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return h(_);
    }
    function P(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function _(K, M, G, x, T) {
        for (var F = K[M], j = 0; j < k.length; j++)
          if (f(F, k[j]))
            return null;
        var H = JSON.stringify(k, function(Q, W) {
          var ue = Y(W);
          return ue === "symbol" ? String(W) : W;
        });
        return new g("Invalid " + x + " `" + T + "` of value `" + String(F) + "` " + ("supplied to `" + G + "`, expected one of " + H + "."));
      }
      return h(_);
    }
    function U(k) {
      function _(K, M, G, x, T) {
        if (typeof k != "function")
          return new g("Property `" + T + "` of component `" + G + "` has invalid PropType notation inside objectOf.");
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type " + ("`" + j + "` supplied to `" + G + "`, expected an object."));
        for (var H in F)
          if (r(F, H)) {
            var B = k(F, H, G, x, T + "." + H, n);
            if (B instanceof Error)
              return B;
          }
        return null;
      }
      return h(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var _ = 0; _ < k.length; _++) {
        var K = k[_];
        if (typeof K != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(K) + " at index " + _ + "."
          ), s;
      }
      function M(G, x, T, F, j) {
        for (var H = [], B = 0; B < k.length; B++) {
          var Q = k[B], W = Q(G, x, T, F, j, n);
          if (W == null)
            return null;
          W.data && r(W.data, "expectedType") && H.push(W.data.expectedType);
        }
        var ue = H.length > 0 ? ", expected one of type [" + H.join(", ") + "]" : "";
        return new g("Invalid " + F + " `" + j + "` supplied to " + ("`" + T + "`" + ue + "."));
      }
      return h(M);
    }
    function N() {
      function k(_, K, M, G, x) {
        return $(_[K]) ? null : new g("Invalid " + G + " `" + x + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return h(k);
    }
    function A(k, _, K, M, G) {
      return new g(
        (k || "React class") + ": " + _ + " type `" + K + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + G + "`."
      );
    }
    function z(k) {
      function _(K, M, G, x, T) {
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        for (var H in k) {
          var B = k[H];
          if (typeof B != "function")
            return A(G, x, T, H, Y(B));
          var Q = B(F, H, G, x, T + "." + H, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return h(_);
    }
    function V(k) {
      function _(K, M, G, x, T) {
        var F = K[M], j = J(F);
        if (j !== "object")
          return new g("Invalid " + x + " `" + T + "` of type `" + j + "` " + ("supplied to `" + G + "`, expected `object`."));
        var H = t({}, K[M], k);
        for (var B in H) {
          var Q = k[B];
          if (r(k, B) && typeof Q != "function")
            return A(G, x, T, B, Y(Q));
          if (!Q)
            return new g(
              "Invalid " + x + " `" + T + "` key `" + B + "` supplied to `" + G + "`.\nBad object: " + JSON.stringify(K[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var W = Q(F, B, G, x, T + "." + B, n);
          if (W)
            return W;
        }
        return null;
      }
      return h(_);
    }
    function $(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every($);
          if (k === null || a(k))
            return !0;
          var _ = p(k);
          if (_) {
            var K = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = K.next()).done; )
                if (!$(M.value))
                  return !1;
            } else
              for (; !(M = K.next()).done; ) {
                var G = M.value;
                if (G && !$(G[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function Z(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function J(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : Z(_, k) ? "symbol" : _;
    }
    function Y(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = J(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function te(k) {
      var _ = Y(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function ee(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, lg;
}
var ug, TP;
function Jre() {
  if (TP) return ug;
  TP = 1;
  var e = mb();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, ug = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, ug;
}
if (process.env.NODE_ENV !== "production") {
  var Qre = aB(), eoe = !0;
  Um.exports = Xre()(Qre.isElement, eoe);
} else
  Um.exports = Jre()();
var mf = Um.exports, vf = {};
Object.defineProperty(vf, "__esModule", {
  value: !0
});
var toe = Hl, cg = noe(toe);
function noe(e) {
  return e && e.__esModule ? e : { default: e };
}
var roe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return cg.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && cg.default.getHash() !== t && cg.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
vf.default = roe;
Object.defineProperty(Ul, "__esModule", {
  value: !0
});
var ac = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ooe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ioe = xe, jP = Kl(ioe), soe = Wl, lc = Kl(soe), aoe = Ys, loe = Kl(aoe), uoe = mf, Sn = Kl(uoe), coe = vf, Yo = Kl(coe);
function Kl(e) {
  return e && e.__esModule ? e : { default: e };
}
function poe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function doe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function foe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _P = {
  to: Sn.default.string.isRequired,
  containerId: Sn.default.string,
  container: Sn.default.object,
  activeClass: Sn.default.string,
  activeStyle: Sn.default.object,
  spy: Sn.default.bool,
  horizontal: Sn.default.bool,
  smooth: Sn.default.oneOfType([Sn.default.bool, Sn.default.string]),
  offset: Sn.default.number,
  delay: Sn.default.number,
  isDynamic: Sn.default.bool,
  onClick: Sn.default.func,
  duration: Sn.default.oneOfType([Sn.default.number, Sn.default.func]),
  absolute: Sn.default.bool,
  onSetActive: Sn.default.func,
  onSetInactive: Sn.default.func,
  ignoreCancelEvents: Sn.default.bool,
  hashSpy: Sn.default.bool,
  saveHashHistory: Sn.default.bool,
  spyThrottle: Sn.default.number
};
Ul.default = function(e, t) {
  var n = t || loe.default, r = function(i) {
    foe(s, i);
    function s(a) {
      poe(this, s);
      var l = doe(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return ooe(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          lc.default.isMounted(l) || lc.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (Yo.default.isMounted() || Yo.default.mount(n), Yo.default.mapContainer(this.props.to, l)), lc.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        lc.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = ac({}, this.props.style, this.props.activeStyle) : u = ac({}, this.props.style);
        var c = ac({}, this.props);
        for (var p in _P)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, jP.default.createElement(e, c);
      }
    }]), s;
  }(jP.default.PureComponent), o = function() {
    var s = this;
    this.scrollTo = function(a, l) {
      n.scrollTo(a, ac({}, s.state, l));
    }, this.handleClick = function(a) {
      s.props.onClick && s.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), s.scrollTo(s.props.to, s.props);
    }, this.spyHandler = function(a, l) {
      var u = s.getScrollSpyContainer();
      if (!(Yo.default.isMounted() && !Yo.default.isInitialized())) {
        var c = s.props.horizontal, p = s.props.to, d = null, m = void 0, f = void 0;
        if (c) {
          var g = 0, h = 0, C = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            C = w.left;
          }
          if (!d || s.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var S = d.getBoundingClientRect();
            g = S.left - C + a, h = g + S.width;
          }
          var E = a - s.props.offset;
          m = E >= Math.floor(g) && E < Math.floor(h), f = E < Math.floor(g) || E >= Math.floor(h);
        } else {
          var v = 0, O = 0, P = 0;
          if (u.getBoundingClientRect) {
            var U = u.getBoundingClientRect();
            P = U.top;
          }
          if (!d || s.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var L = d.getBoundingClientRect();
            v = L.top - P + l, O = v + L.height;
          }
          var N = l - s.props.offset;
          m = N >= Math.floor(v) && N < Math.floor(O), f = N < Math.floor(v) || N >= Math.floor(O);
        }
        var A = n.getActiveLink();
        if (f) {
          if (p === A && n.setActiveLink(void 0), s.props.hashSpy && Yo.default.getHash() === p) {
            var z = s.props.saveHashHistory, V = z === void 0 ? !1 : z;
            Yo.default.changeHash("", V);
          }
          s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive(p, d));
        }
        if (m && (A !== p || s.state.active === !1)) {
          n.setActiveLink(p);
          var $ = s.props.saveHashHistory, Z = $ === void 0 ? !1 : $;
          s.props.hashSpy && Yo.default.changeHash(p, Z), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = _P, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(pb, "__esModule", {
  value: !0
});
var hoe = xe, AP = uB(hoe), goe = Ul, moe = uB(goe);
function uB(e) {
  return e && e.__esModule ? e : { default: e };
}
function voe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function BP(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yoe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var boe = function(e) {
  yoe(t, e);
  function t() {
    var n, r, o, i;
    voe(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = BP(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return AP.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), BP(o, i);
  }
  return t;
}(AP.default.Component);
pb.default = (0, moe.default)(boe);
var vb = {};
Object.defineProperty(vb, "__esModule", {
  value: !0
});
var woe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Coe = xe, IP = cB(Coe), Ooe = Ul, Eoe = cB(Ooe);
function cB(e) {
  return e && e.__esModule ? e : { default: e };
}
function xoe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Loe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Doe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Poe = function(e) {
  Doe(t, e);
  function t() {
    return xoe(this, t), Loe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return woe(t, [{
    key: "render",
    value: function() {
      return IP.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(IP.default.Component);
vb.default = (0, Eoe.default)(Poe);
var yb = {}, yf = {};
Object.defineProperty(yf, "__esModule", {
  value: !0
});
var koe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Soe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Moe = xe, RP = bf(Moe), Toe = wl;
bf(Toe);
var joe = Ys, NP = bf(joe), _oe = mf, FP = bf(_oe);
function bf(e) {
  return e && e.__esModule ? e : { default: e };
}
function Aoe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Boe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Ioe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
yf.default = function(e) {
  var t = function(n) {
    Ioe(r, n);
    function r(o) {
      Aoe(this, r);
      var i = Boe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Soe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        NP.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        NP.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return RP.default.createElement(e, koe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(RP.default.Component);
  return t.propTypes = {
    name: FP.default.string,
    id: FP.default.string
  }, t;
};
Object.defineProperty(yb, "__esModule", {
  value: !0
});
var zP = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Roe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Noe = xe, $P = bb(Noe), Foe = yf, zoe = bb(Foe), $oe = mf, UP = bb($oe);
function bb(e) {
  return e && e.__esModule ? e : { default: e };
}
function Uoe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Woe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Voe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var pB = function(e) {
  Voe(t, e);
  function t() {
    return Uoe(this, t), Woe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Roe(t, [{
    key: "render",
    value: function() {
      var r = this, o = zP({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, $P.default.createElement(
        "div",
        zP({}, o, { ref: function(s) {
          r.props.parentBindings.domNode = s;
        } }),
        this.props.children
      );
    }
  }]), t;
}($P.default.Component);
pB.propTypes = {
  name: UP.default.string,
  id: UP.default.string
};
yb.default = (0, zoe.default)(pB);
var pg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, WP = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function VP(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HP(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function qP(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var uc = xe, Hi = Wl, dg = Ys, $n = mf, Xo = vf, ZP = {
  to: $n.string.isRequired,
  containerId: $n.string,
  container: $n.object,
  activeClass: $n.string,
  spy: $n.bool,
  smooth: $n.oneOfType([$n.bool, $n.string]),
  offset: $n.number,
  delay: $n.number,
  isDynamic: $n.bool,
  onClick: $n.func,
  duration: $n.oneOfType([$n.number, $n.func]),
  absolute: $n.bool,
  onSetActive: $n.func,
  onSetInactive: $n.func,
  ignoreCancelEvents: $n.bool,
  hashSpy: $n.bool,
  spyThrottle: $n.number
}, Hoe = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || dg, o = function(s) {
      qP(a, s);
      function a(l) {
        VP(this, a);
        var u = HP(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return WP(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Hi.isMounted(u) || Hi.mount(u, this.props.spyThrottle), this.props.hashSpy && (Xo.isMounted() || Xo.mount(r), Xo.mapContainer(this.props.to, u)), this.props.spy && Hi.addStateHandler(this.stateHandler), Hi.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Hi.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = pg({}, this.props);
          for (var p in ZP)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, uc.createElement(t, c);
        }
      }]), a;
    }(uc.Component), i = function() {
      var a = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, pg({}, a.state, u));
      }, this.handleClick = function(l) {
        a.props.onClick && a.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), a.scrollTo(a.props.to, a.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== a.props.to && (a.state !== null && a.state.active && a.props.onSetInactive && a.props.onSetInactive(), a.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = a.getScrollSpyContainer();
        if (!(Xo.isMounted() && !Xo.isInitialized())) {
          var c = a.props.to, p = null, d = 0, m = 0, f = 0;
          if (u.getBoundingClientRect) {
            var g = u.getBoundingClientRect();
            f = g.top;
          }
          if (!p || a.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var h = p.getBoundingClientRect();
            d = h.top - f + l, m = d + h.height;
          }
          var C = l - a.props.offset, w = C >= Math.floor(d) && C < Math.floor(m), S = C < Math.floor(d) || C >= Math.floor(m), E = r.getActiveLink();
          if (S)
            return c === E && r.setActiveLink(void 0), a.props.hashSpy && Xo.getHash() === c && Xo.changeHash(), a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive()), Hi.updateStates();
          if (w && E !== c)
            return r.setActiveLink(c), a.props.hashSpy && Xo.changeHash(c), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(c)), Hi.updateStates();
        }
      };
    };
    return o.propTypes = ZP, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      qP(o, r);
      function o(i) {
        VP(this, o);
        var s = HP(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return s.childBindings = {
          domNode: null
        }, s;
      }
      return WP(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(s) {
          this.props.name !== s.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          dg.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(s) {
          dg.register(s, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return uc.createElement(t, pg({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(uc.Component);
    return n.propTypes = {
      name: $n.string,
      id: $n.string
    }, n;
  }
}, qoe = Hoe;
Object.defineProperty(Kn, "__esModule", {
  value: !0
});
Kn.Helpers = Kn.ScrollElement = Kn.ScrollLink = OB = Kn.animateScroll = Kn.scrollSpy = Kn.Events = Kn.scroller = Kn.Element = Kn.Button = Kn.Link = void 0;
var Zoe = pb, dB = Co(Zoe), Koe = vb, fB = Co(Koe), Goe = yb, hB = Co(Goe), Yoe = Ys, gB = Co(Yoe), Xoe = ql, mB = Co(Xoe), Joe = Wl, vB = Co(Joe), Qoe = ff, yB = Co(Qoe), eie = Ul, bB = Co(eie), tie = yf, wB = Co(tie), nie = qoe, CB = Co(nie);
function Co(e) {
  return e && e.__esModule ? e : { default: e };
}
Kn.Link = dB.default;
Kn.Button = fB.default;
Kn.Element = hB.default;
Kn.scroller = gB.default;
Kn.Events = mB.default;
Kn.scrollSpy = vB.default;
var OB = Kn.animateScroll = yB.default;
Kn.ScrollLink = bB.default;
Kn.ScrollElement = wB.default;
Kn.Helpers = CB.default;
Kn.default = { Link: dB.default, Button: fB.default, Element: hB.default, scroller: gB.default, Events: mB.default, scrollSpy: vB.default, animateScroll: yB.default, ScrollLink: bB.default, ScrollElement: wB.default, Helpers: CB.default };
const wb = qe({}), EB = qe({});
function rie() {
  const e = De(EB);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function KP(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function Lle() {
  const e = Xm(), { closeModal: t, closeAll: n } = De(wb), { showToast: r } = rie(), { getParam: o } = eB(), { pathname: i } = Jm(), s = OS(), a = o("closeAllModals");
  y(() => {
    a === "true" && (n(), s(i));
  }, [a]), y(() => {
    const l = e == null ? void 0 : e.closeModalKey;
    l && t(l);
  }, [e]), y(() => {
    const l = e == null ? void 0 : e.closeAllModals;
    typeof l == "boolean" && l && n();
  }, [e]), y(() => {
    const l = e == null ? void 0 : e.toast, u = e == null ? void 0 : e.message;
    KP(l) && r(l), !KP(l) && u && r({ message: u, type: "danger" });
  }, [e]), y(() => {
    var l, u;
    if (typeof ((l = e == null ? void 0 : e.data) == null ? void 0 : l.scrollTo) == "string") {
      const c = document.getElementById((u = e == null ? void 0 : e.data) == null ? void 0 : u.scrollTo);
      c && OB.scrollTo(c.offsetTop - 200);
    }
  }, [e]);
}
const xB = qe({});
function Dle(e) {
  const t = De(xB);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, s = r(e), a = n(e);
    return { drawerIsOpen: s, drawerData: a, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function oie() {
  return () => {
  };
}
function iie() {
  return YB(
    oie,
    () => !0,
    () => !1
  );
}
function Ple(e) {
  const t = De(wb);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, s = r(e), a = n(e);
    return { modalIsOpen: s, modalData: a, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function kle(e) {
  const { children: t = !1 } = e, [n, r] = D([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function s(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((m) => m.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function a(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ q.jsx(
    xB.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: s, closeDrawer: a },
      children: t
    }
  );
}
function bl(e) {
  "@babel/helpers - typeof";
  return bl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, bl(e);
}
function sie(e, t) {
  if (bl(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (bl(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function aie(e) {
  var t = sie(e, "string");
  return bl(t) == "symbol" ? t : t + "";
}
function ce(e, t, n) {
  return (t = aie(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function LB(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var fg, GP;
function lie() {
  if (GP) return fg;
  GP = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, s, a, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, s, a, l, u, c], m = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[m++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return fg = t, fg;
}
var uie = lie(), er = /* @__PURE__ */ LB(uie), nt = qe(null);
function cie() {
  er(!!De, "useGoogleMap is React hook and requires React version 16.8+");
  var e = De(nt);
  return er(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function pie(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function die(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function fie(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return die(e, i), o;
}
function hie(e, t, n) {
  var r = pie(n, function(i, s, a) {
    return typeof e[a] == "function" && i.push(google.maps.event.addListener(t, s, e[a])), i;
  }, []);
  return r;
}
function gie(e) {
  google.maps.event.removeListener(e);
}
function wt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(gie);
}
function gt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = hie(o, i, n);
  return fie(t, r, o, i), s;
}
var YP = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, XP = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function mie(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: S,
    onUnmount: E
  } = e, [v, O] = D(null), P = Ye(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null), [B, Q] = D(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && p && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(v, "dragstart", p)));
  }, [p]), y(() => {
    v && g && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(v, "mousedown", g)));
  }, [g]), y(() => {
    v && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(v, "mousemove", d)));
  }, [d]), y(() => {
    v && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(v, "mouseout", m)));
  }, [m]), y(() => {
    v && f && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (B !== null && google.maps.event.removeListener(B), Q(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var W = P.current === null ? null : new google.maps.Map(P.current, n);
    return O(W), W !== null && S && S(W), () => {
      W !== null && E && E(W);
    };
  }, []), q.jsx("div", {
    id: r,
    ref: P,
    style: o,
    className: i,
    children: q.jsx(nt.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
ke(mie);
let vie = class extends Oe {
  constructor() {
    super(...arguments), ce(this, "state", {
      map: null
    }), ce(this, "registeredEvents", []), ce(this, "mapRef", null), ce(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), ce(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), ce(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), ce(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = gt({
      updaterMap: XP,
      eventMap: YP,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: XP,
      eventMap: YP,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), wt(this.registeredEvents));
  }
  render() {
    return q.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: q.jsx(nt.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function JP(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function DB(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        JP(i, r, o, s, a, "next", l);
      }
      function a(l) {
        JP(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function PB(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return er(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var as = typeof document < "u";
function kB(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return as ? new Promise(function(i, s) {
    var a = document.getElementById(n), l = window;
    if (a) {
      var u = a.getAttribute("data-state");
      if (a.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = a.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, a.onerror = function(m) {
          p && p(m), s(m);
        };
        return;
      } else
        a.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), s(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function QP(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function SB() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return QP(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return QP(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var ya = !1;
function MB() {
  return q.jsx("div", {
    children: "Loading..."
  });
}
var Wm = {
  id: "script-loader",
  version: "weekly"
};
class TB extends Oe {
  constructor() {
    super(...arguments), ce(this, "check", cr()), ce(this, "state", {
      loaded: !1
    }), ce(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ce(this, "isCleaningUp", /* @__PURE__ */ DB(function* () {
      function t(n) {
        if (!ya)
          n();
        else if (as)
          var r = window.setInterval(function() {
            ya || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ce(this, "cleanup", () => {
      ya = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), ce(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && SB(), er(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: PB(this.props)
      };
      kB(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (as) {
      if (window.google && window.google.maps && !ya) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), as && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (as) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, ya = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return q.jsxs(q.Fragment, {
      children: [q.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || q.jsx(MB, {})]
    });
  }
}
ce(TB, "defaultProps", Wm);
function yie(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Cb(e, t) {
  if (e == null) return {};
  var n, r, o = yie(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var ek;
function bie(e) {
  var {
    id: t = Wm.id,
    version: n = Wm.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, m = Ye(!1), [f, g] = D(!1), [h, C] = D(void 0);
  y(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), y(function() {
    as && u && SB();
  }, [u]), y(function() {
    f && er(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = PB({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  y(function() {
    if (!as)
      return;
    function v() {
      m.current && (g(!0), ek = w);
    }
    if (window.google && window.google.maps && ek === w) {
      v();
      return;
    }
    kB({
      id: t,
      url: w,
      nonce: r
    }).then(v).catch(function(P) {
      m.current && C(P), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(P);
    });
  }, [t, w, r]);
  var S = Ye();
  return y(function() {
    S.current && l !== S.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), S.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var wie = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Cie = q.jsx(MB, {});
function Oie(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = Cb(e, wie), {
    isLoaded: a,
    loadError: l
  } = bie(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || Cie;
}
ke(Oie);
var tk;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(tk || (tk = {}));
function nk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rk = {}, ok = {
  options(e, t) {
    e.setOptions(t);
  }
};
function Eie(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = De(nt), [i, s] = D(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(Sp(Sp({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ke(Eie);
class xie extends Oe {
  constructor() {
    super(...arguments), ce(this, "state", {
      trafficLayer: null
    }), ce(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Sp(Sp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: ok,
      eventMap: rk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: ok,
      eventMap: rk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), wt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(xie, "contextType", nt);
function Lie(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = De(nt), [o, i] = D(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
ke(Lie);
class Die extends Oe {
  constructor() {
    super(...arguments), ce(this, "state", {
      bicyclingLayer: null
    }), ce(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(Die, "contextType", nt);
function Pie(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = De(nt), [o, i] = D(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ke(Pie);
class kie extends Oe {
  constructor() {
    super(...arguments), ce(this, "state", {
      transitLayer: null
    }), ce(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(kie, "contextType", nt);
function ik(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ik(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ik(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sk = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, ak = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Sie(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = De(nt), [d, m] = D(null), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null);
  return y(() => {
    d !== null && d.setMap(p);
  }, [p]), y(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), y(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), y(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), y(() => {
    d && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), y(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), y(() => {
    d && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(d, "polygoncomplete", s)));
  }, [d, s]), y(() => {
    d && a && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(d, "polylinecomplete", a)));
  }, [d, a]), y(() => {
    d && l && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), y(() => {
    er(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(Mp(Mp({}, t), {}, {
      map: p
    }));
    return n && N.setDrawingMode(n), r && g(google.maps.event.addListener(N, "circlecomplete", r)), o && C(google.maps.event.addListener(N, "markercomplete", o)), i && S(google.maps.event.addListener(N, "overlaycomplete", i)), s && v(google.maps.event.addListener(N, "polygoncomplete", s)), a && P(google.maps.event.addListener(N, "polylinecomplete", a)), l && L(google.maps.event.addListener(N, "rectanglecomplete", l)), m(N), u && u(N), () => {
      d !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ke(Sie);
class Mie extends Oe {
  constructor(t) {
    super(t), ce(this, "registeredEvents", []), ce(this, "state", {
      drawingManager: null
    }), ce(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), er(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Mp(Mp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: ak,
      eventMap: sk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: ak,
      eventMap: sk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), wt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ce(Mie, "contextType", nt);
function lk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function js(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uk = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, ck = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Tp = {};
function Tie(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: S,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: O,
    onMouseOver: P,
    onMouseUp: U,
    onMouseDown: L,
    onRightClick: N,
    onClickableChanged: A,
    onCursorChanged: z,
    onAnimationChanged: V,
    onDraggableChanged: $,
    onFlatChanged: Z,
    onIconChanged: J,
    onPositionChanged: Y,
    onShapeChanged: te,
    onTitleChanged: ee,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: K,
    onUnmount: M
  } = e, G = De(nt), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null), [Q, W] = D(null), [ue, ye] = D(null), [oe, _e] = D(null), [Fe, ze] = D(null), [Re, Ge] = D(null), [Ze, Me] = D(null), [Ke, rt] = D(null), [Se, je] = D(null), [Ne, Ve] = D(null), [Ue, ot] = D(null), [Te, Zt] = D(null), [lt, ht] = D(null), [kt, sn] = D(null), [St, an] = D(null), [tt, Nt] = D(null), [ut, ln] = D(null), [Mt, Mn] = D(null), [un, Tn] = D(null), [cn, jn] = D(null);
  y(() => {
    x !== null && x.setMap(G);
  }, [G]), y(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), y(() => {
    typeof s < "u" && x !== null && x.setDraggable(s);
  }, [x, s]), y(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), y(() => {
    typeof a < "u" && x !== null && x.setVisible(a);
  }, [x, a]), y(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), y(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), y(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), y(() => {
    x && p !== void 0 && x.setIcon(p);
  }, [x, p]), y(() => {
    x && d !== void 0 && x.setLabel(d);
  }, [x, d]), y(() => {
    x && m !== void 0 && x.setOpacity(m);
  }, [x, m]), y(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), y(() => {
    x && g !== void 0 && x.setTitle(g);
  }, [x, g]), y(() => {
    x && h !== void 0 && x.setZIndex(h);
  }, [x, h]), y(() => {
    x && w && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), y(() => {
    x && E && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(x, "dragend", E)));
  }, [E]), y(() => {
    x && v && (Q !== null && google.maps.event.removeListener(Q), W(google.maps.event.addListener(x, "dragstart", v)));
  }, [v]), y(() => {
    x && L && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(x, "mousedown", L)));
  }, [L]), y(() => {
    x && O && (oe !== null && google.maps.event.removeListener(oe), _e(google.maps.event.addListener(x, "mouseout", O)));
  }, [O]), y(() => {
    x && P && (Fe !== null && google.maps.event.removeListener(Fe), ze(google.maps.event.addListener(x, "mouseover", P)));
  }, [P]), y(() => {
    x && U && (Re !== null && google.maps.event.removeListener(Re), Ge(google.maps.event.addListener(x, "mouseup", U)));
  }, [U]), y(() => {
    x && N && (Ze !== null && google.maps.event.removeListener(Ze), Me(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), y(() => {
    x && C && (Ke !== null && google.maps.event.removeListener(Ke), rt(google.maps.event.addListener(x, "click", C)));
  }, [C]), y(() => {
    x && S && (Se !== null && google.maps.event.removeListener(Se), je(google.maps.event.addListener(x, "drag", S)));
  }, [S]), y(() => {
    x && A && (Ne !== null && google.maps.event.removeListener(Ne), Ve(google.maps.event.addListener(x, "clickable_changed", A)));
  }, [A]), y(() => {
    x && z && (Ue !== null && google.maps.event.removeListener(Ue), ot(google.maps.event.addListener(x, "cursor_changed", z)));
  }, [z]), y(() => {
    x && V && (Te !== null && google.maps.event.removeListener(Te), Zt(google.maps.event.addListener(x, "animation_changed", V)));
  }, [V]), y(() => {
    x && $ && (lt !== null && google.maps.event.removeListener(lt), ht(google.maps.event.addListener(x, "draggable_changed", $)));
  }, [$]), y(() => {
    x && Z && (kt !== null && google.maps.event.removeListener(kt), sn(google.maps.event.addListener(x, "flat_changed", Z)));
  }, [Z]), y(() => {
    x && J && (St !== null && google.maps.event.removeListener(St), an(google.maps.event.addListener(x, "icon_changed", J)));
  }, [J]), y(() => {
    x && Y && (tt !== null && google.maps.event.removeListener(tt), Nt(google.maps.event.addListener(x, "position_changed", Y)));
  }, [Y]), y(() => {
    x && te && (ut !== null && google.maps.event.removeListener(ut), ln(google.maps.event.addListener(x, "shape_changed", te)));
  }, [te]), y(() => {
    x && ee && (Mt !== null && google.maps.event.removeListener(Mt), Mn(google.maps.event.addListener(x, "title_changed", ee)));
  }, [ee]), y(() => {
    x && k && (un !== null && google.maps.event.removeListener(un), Tn(google.maps.event.addListener(x, "visible_changed", k)));
  }, [k]), y(() => {
    x && _ && (cn !== null && google.maps.event.removeListener(cn), jn(google.maps.event.addListener(x, "zindex_changed", _)));
  }, [_]), y(() => {
    var Ft = js(js(js({}, n || Tp), r ? Tp : {
      map: G
    }), {}, {
      position: t
    }), ie = new google.maps.Marker(Ft);
    return r ? r.addMarker(ie, !!o) : ie.setMap(G), t && ie.setPosition(t), typeof a < "u" && ie.setVisible(a), typeof s < "u" && ie.setDraggable(s), typeof u < "u" && ie.setClickable(u), typeof c == "string" && ie.setCursor(c), p && ie.setIcon(p), typeof d < "u" && ie.setLabel(d), typeof m < "u" && ie.setOpacity(m), f && ie.setShape(f), typeof g == "string" && ie.setTitle(g), typeof h == "number" && ie.setZIndex(h), w && j(google.maps.event.addListener(ie, "dblclick", w)), E && B(google.maps.event.addListener(ie, "dragend", E)), v && W(google.maps.event.addListener(ie, "dragstart", v)), L && ye(google.maps.event.addListener(ie, "mousedown", L)), O && _e(google.maps.event.addListener(ie, "mouseout", O)), P && ze(google.maps.event.addListener(ie, "mouseover", P)), U && Ge(google.maps.event.addListener(ie, "mouseup", U)), N && Me(google.maps.event.addListener(ie, "rightclick", N)), C && rt(google.maps.event.addListener(ie, "click", C)), S && je(google.maps.event.addListener(ie, "drag", S)), A && Ve(google.maps.event.addListener(ie, "clickable_changed", A)), z && ot(google.maps.event.addListener(ie, "cursor_changed", z)), V && Zt(google.maps.event.addListener(ie, "animation_changed", V)), $ && ht(google.maps.event.addListener(ie, "draggable_changed", $)), Z && sn(google.maps.event.addListener(ie, "flat_changed", Z)), J && an(google.maps.event.addListener(ie, "icon_changed", J)), Y && Nt(google.maps.event.addListener(ie, "position_changed", Y)), te && ln(google.maps.event.addListener(ie, "shape_changed", te)), ee && Mn(google.maps.event.addListener(ie, "title_changed", ee)), k && Tn(google.maps.event.addListener(ie, "visible_changed", k)), _ && jn(google.maps.event.addListener(ie, "zindex_changed", _)), T(ie), K && K(ie), () => {
      F !== null && google.maps.event.removeListener(F), H !== null && google.maps.event.removeListener(H), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), Fe !== null && google.maps.event.removeListener(Fe), Re !== null && google.maps.event.removeListener(Re), Ze !== null && google.maps.event.removeListener(Ze), Ke !== null && google.maps.event.removeListener(Ke), Ne !== null && google.maps.event.removeListener(Ne), Ue !== null && google.maps.event.removeListener(Ue), Te !== null && google.maps.event.removeListener(Te), lt !== null && google.maps.event.removeListener(lt), kt !== null && google.maps.event.removeListener(kt), St !== null && google.maps.event.removeListener(St), tt !== null && google.maps.event.removeListener(tt), Mt !== null && google.maps.event.removeListener(Mt), un !== null && google.maps.event.removeListener(un), cn !== null && google.maps.event.removeListener(cn), M && M(ie), r ? r.removeMarker(ie, !!o) : ie && ie.setMap(null);
    };
  }, []);
  var Yn = Gn(() => i ? Ct.map(i, (Ft) => {
    if (!mi(Ft))
      return Ft;
    var ie = Ft;
    return vi(ie, {
      anchor: x
    });
  }) : null, [i, x]);
  return q.jsx(q.Fragment, {
    children: Yn
  }) || null;
}
ke(Tie);
class jB extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return DB(function* () {
      var n = js(js(js({}, t.props.options || Tp), t.props.clusterer ? Tp : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = gt({
        updaterMap: ck,
        eventMap: uk,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: ck,
      eventMap: uk,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), wt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ct.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ce(jB, "contextType", nt);
var jie = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), _ie = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new jie(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Aie(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Bie = 2e3, Iie = 500, Rie = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Nie = "png", Fie = [53, 56, 66, 78, 90], zie = "cluster", _B = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || Rie, this.imageExtension = r.imageExtension || Nie, this.imageSizes = r.imageSizes || Fie, this.calculator = r.calculator || Aie, this.batchSize = r.batchSize || Bie, this.batchSizeIE = r.batchSizeIE || Iie, this.clusterClass = r.clusterClass || zie, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new _ie(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var m = d[p];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var s = i;
          this.prototype[s] = o.prototype[s];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function pk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $ie(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Rt = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Uie = {};
function Wie(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: S,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: O,
    onLoad: P,
    onUnmount: U
  } = e, [L, N] = D(null), A = De(nt), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null);
  return y(() => {
    L && O && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(L, Xr.onMouseOut, O)));
  }, [O]), y(() => {
    L && v && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, Xr.onMouseOver, v)));
  }, [v]), y(() => {
    L && w && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(L, Xr.onClick, w)));
  }, [w]), y(() => {
    L && S && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(L, Xr.onClusteringBegin, S)));
  }, [S]), y(() => {
    L && E && (J !== null && google.maps.event.removeListener(J), Z(google.maps.event.addListener(L, Xr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && L !== null && Rt.averageCenter(L, r);
  }, [L, r]), y(() => {
    typeof o < "u" && L !== null && Rt.batchSizeIE(L, o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && Rt.calculator(L, i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && Rt.clusterClass(L, s);
  }, [L, s]), y(() => {
    typeof a < "u" && L !== null && Rt.enableRetinaIcons(L, a);
  }, [L, a]), y(() => {
    typeof l < "u" && L !== null && Rt.gridSize(L, l);
  }, [L, l]), y(() => {
    typeof u < "u" && L !== null && Rt.ignoreHidden(L, u);
  }, [L, u]), y(() => {
    typeof c < "u" && L !== null && Rt.imageExtension(L, c);
  }, [L, c]), y(() => {
    typeof p < "u" && L !== null && Rt.imagePath(L, p);
  }, [L, p]), y(() => {
    typeof d < "u" && L !== null && Rt.imageSizes(L, d);
  }, [L, d]), y(() => {
    typeof m < "u" && L !== null && Rt.maxZoom(L, m);
  }, [L, m]), y(() => {
    typeof f < "u" && L !== null && Rt.minimumClusterSize(L, f);
  }, [L, f]), y(() => {
    typeof g < "u" && L !== null && Rt.styles(L, g);
  }, [L, g]), y(() => {
    typeof h < "u" && L !== null && Rt.title(L, h);
  }, [L, h]), y(() => {
    typeof C < "u" && L !== null && Rt.zoomOnClick(L, C);
  }, [L, C]), y(() => {
    if (A) {
      var K = $ie({}, n || Uie), M = new _B(A, [], K);
      return r && Rt.averageCenter(M, r), o && Rt.batchSizeIE(M, o), i && Rt.calculator(M, i), s && Rt.clusterClass(M, s), a && Rt.enableRetinaIcons(M, a), l && Rt.gridSize(M, l), u && Rt.ignoreHidden(M, u), c && Rt.imageExtension(M, c), p && Rt.imagePath(M, p), d && Rt.imageSizes(M, d), m && Rt.maxZoom(M, m), f && Rt.minimumClusterSize(M, f), g && Rt.styles(M, g), h && Rt.title(M, h), C && Rt.zoomOnClick(M, C), O && ee(google.maps.event.addListener(M, Xr.onMouseOut, O)), v && _(google.maps.event.addListener(M, Xr.onMouseOver, v)), w && V(google.maps.event.addListener(M, Xr.onClick, w)), S && Z(google.maps.event.addListener(M, Xr.onClusteringBegin, S)), E && Y(google.maps.event.addListener(M, Xr.onClusteringEnd, E)), N(M), P && P(M), () => {
        te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), U && U(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ke(Wie);
class Vie extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      markerClusterer: null
    }), ce(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new _B(this.context, [], this.props.options);
      this.registeredEvents = gt({
        updaterMap: Rt,
        eventMap: Xr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: Rt,
      eventMap: Xr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), wt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ce(Vie, "contextType", nt);
function dk(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var AB = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || dk(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, dk));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + p + u + m > a && (r = h.x + p + u + m - a), this.alignBottom ? h.y < -c + f + d ? o = h.y + c - f - d : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + d + c + f > l && (o = h.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Hie = ["position"], qie = ["position"];
function fk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hk = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, gk = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Zie = {};
function Kie(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = De(nt), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), N = Ye(null);
  return y(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var A = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(A);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (m) {
      var A = r || Zie, {
        position: z
      } = A, V = Cb(A, Hie), $;
      z && !(z instanceof google.maps.LatLng) && ($ = new google.maps.LatLng(z.lat, z.lng));
      var Z = new AB(jp(jp({}, V), $ ? {
        position: $
      } : {}));
      N.current = document.createElement("div"), g(Z), s && C(google.maps.event.addListener(Z, "closeclick", s)), a && S(google.maps.event.addListener(Z, "domready", a)), l && v(google.maps.event.addListener(Z, "content_changed", l)), u && P(google.maps.event.addListener(Z, "position_changed", u)), c && L(google.maps.event.addListener(Z, "zindex_changed", c)), Z.setContent(N.current), n ? Z.open(m, n) : Z.getPosition() ? Z.open(m) : er(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(Z);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), d && d(f), f.close());
    };
  }, []), N.current ? pr(Ct.only(t), N.current) : null;
}
ke(Kie);
class Gie extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "containerElement", null), ce(this, "state", {
      infoBox: null
    }), ce(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : er(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ce(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Cb(t, qie), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new AB(jp(jp({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = gt({
      updaterMap: gk,
      eventMap: hk,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: gk,
      eventMap: hk,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), wt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? pr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
ce(Gie, "contextType", nt);
var hg, mk;
function Yie() {
  return mk || (mk = 1, hg = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), hg;
}
var Xie = Yie(), vk = /* @__PURE__ */ LB(Xie), yk = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], gg = 1, ba = 8;
class Ob {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== gg)
      throw new Error("Got v".concat(o, " data when expected v").concat(gg, "."));
    var i = yk[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Ob(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = yk.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ba, t), this.coords = new this.ArrayType(this.data, ba + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ba + s + a + l), this.ids = new this.IndexArrayType(this.data, ba, t), this.coords = new this.ArrayType(this.data, ba + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (gg << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return Vm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (var m = d; m <= p; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = d + p >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(d), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (var m = d; m <= p; m++)
          bk(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = d + p >> 1, g = i[2 * f], h = i[2 * f + 1];
      bk(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(d), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Vm(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    BB(e, t, s, r, o, i), Vm(e, t, n, r, s - 1, 1 - i), Vm(e, t, n, s + 1, o, 1 - i);
  }
}
function BB(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - a * u / s + c)), d = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      BB(e, t, n, p, d, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (wa(e, t, r, n), t[2 * o + i] > m && wa(e, t, r, o); f < g; ) {
      for (wa(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? wa(e, t, r, g) : (g++, wa(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function wa(e, t, n, r) {
  mg(e, n, r), mg(t, 2 * n, 2 * r), mg(t, 2 * n + 1, 2 * r + 1);
}
function mg(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function bk(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Jie = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, wk = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), qi = 2, ai = 3, vg = 4, ti = 5, IB = 6;
class Qie {
  constructor(t) {
    this.options = Object.assign(Object.create(Jie), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = wk(cc(u)), d = wk(pc(c));
        s.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(cc(r), pc(s), cc(i), pc(o)), p = u.data, d = [];
    for (var m of c) {
      var f = this.stride * m;
      d.push(p[f + ti] > 1 ? Ck(p, f, this.clusterProps) : this.points[p[f + ai]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (var d of c) {
      var m = d * this.stride;
      s[m + vg] === t && p.push(s[m + ti] > 1 ? Ck(s, m, this.clusterProps) : this.points[s[m + ai]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Ob(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + ti] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = RB(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var m = this.points[n[l + ai]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        p = cc(f), d = pc(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + ai] : C = this.points[n[l + ai]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + qi] <= n)) {
        l[p + qi] = n;
        var d = l[p], m = l[p + 1], f = t.within(l[p], l[p + 1], a), g = l[p + ti], h = g;
        for (var C of f) {
          var w = C * c;
          l[w + qi] > n && (h += l[w + ti]);
        }
        if (h > g && h >= s) {
          var S = d * g, E = m * g, v = void 0, O = -1, P = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var U of f) {
            var L = U * c;
            if (!(l[L + qi] <= n)) {
              l[L + qi] = n;
              var N = l[L + ti];
              S += l[L] * N, E += l[L + 1] * N, l[L + vg] = P, i && (v || (v = this._map(l, p, !0), O = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, L)));
            }
          }
          l[p + vg] = P, u.push(S / h, E / h, 1 / 0, P, -1, h), i && u.push(O);
        } else {
          for (var A = 0; A < c; A++) u.push(l[p + A]);
          if (h > 1)
            for (var z of f) {
              var V = z * c;
              if (!(l[V + qi] <= n)) {
                l[V + qi] = n;
                for (var $ = 0; $ < c; $++) u.push(l[V + $]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ti] > 1) {
      var o = this.clusterProps[t[n + IB]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + ai]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function Ck(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ai],
    properties: RB(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [ese(e[t]), tse(e[t + 1])]
    }
  };
}
function RB(e, t, n) {
  var r = e[t + ti], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + IB], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ai],
    point_count: r,
    point_count_abbreviated: o
  });
}
function cc(e) {
  return e / 360 + 0.5;
}
function pc(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function ese(e) {
  return (e - 0.5) * 360;
}
function tse(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function nse(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Nr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Hm {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Nr.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Nr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Nr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class rse {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return ose(n);
  }
}
var ose = (e) => {
  var t = e.map((n) => new Hm({
    position: Nr.getPosition(n),
    markers: [n]
  }));
  return t;
};
class ise extends rse {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = nse(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Qie(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!vk(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = Nr.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !vk(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Hm({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Hm({
      markers: [i],
      position: Nr.getPosition(i)
    });
  }
}
class sse {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class ase {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Nr.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(a, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function lse(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Eb {
  constructor() {
    lse(Eb, google.maps.OverlayView);
  }
}
var qa;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(qa || (qa = {}));
var use = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class cse extends Eb {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new ise(o),
      renderer: s = new ase(),
      onClusterClick: a = use
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Nr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, qa.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || Nr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => Nr.setMap(l, null)));
      }
      google.maps.event.trigger(this, qa.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Nr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new sse(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Nr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, qa.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Nr.setMap(r.marker, n);
    });
  }
}
function Ok(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ek(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ok(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ok(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function pse(e) {
  var t = cie(), [n, r] = D(null);
  return y(() => {
    if (t && n === null) {
      var o = new cse(Ek(Ek({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function dse(e) {
  var {
    children: t,
    options: n
  } = e, r = pse(n);
  return r !== null ? t(r) : null;
}
ke(dse);
var xk = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Lk = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function fse(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, m = De(nt), [f, g] = D(null), [h, C] = D(null), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), N = Ye(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), S(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var A = new google.maps.InfoWindow(r);
    return g(A), N.current = document.createElement("div"), s && C(google.maps.event.addListener(A, "closeclick", s)), a && S(google.maps.event.addListener(A, "domready", a)), l && v(google.maps.event.addListener(A, "content_changed", l)), u && P(google.maps.event.addListener(A, "position_changed", u)), c && L(google.maps.event.addListener(A, "zindex_changed", c)), A.setContent(N.current), o && A.setPosition(o), i && A.setZIndex(i), n ? A.open(m, n) : A.getPosition() ? A.open(m) : er(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(A), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), U && google.maps.event.removeListener(U), d && d(A), A.close();
    };
  }, []), N.current ? pr(Ct.only(t), N.current) : null;
}
ke(fse);
class hse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "containerElement", null), ce(this, "state", {
      infoWindow: null
    }), ce(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : er(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ce(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = gt({
      updaterMap: Lk,
      eventMap: xk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: Lk,
      eventMap: xk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (wt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? pr(Ct.only(this.props.children), this.containerElement) : null;
  }
}
ce(hse, "contextType", nt);
function Dk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _p(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Dk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Dk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pk = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, kk = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, gse = {};
function mse(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, S = De(nt), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null);
  return y(() => {
    E !== null && E.setMap(S);
  }, [S]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && p && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(E, "mouseout", p)));
  }, [p]), y(() => {
    E && d && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(E, "mouseover", d)));
  }, [d]), y(() => {
    E && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(E, "mouseup", m)));
  }, [m]), y(() => {
    E && f && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && g && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && h && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var j = new google.maps.Polyline(_p(_p({}, t || gse), {}, {
      map: S
    }));
    return i && j.setPath(i), typeof o < "u" && j.setVisible(o), typeof r < "u" && j.setEditable(r), typeof n < "u" && j.setDraggable(n), s && P(google.maps.event.addListener(j, "dblclick", s)), a && L(google.maps.event.addListener(j, "dragend", a)), l && A(google.maps.event.addListener(j, "dragstart", l)), u && V(google.maps.event.addListener(j, "mousedown", u)), c && Z(google.maps.event.addListener(j, "mousemove", c)), p && Y(google.maps.event.addListener(j, "mouseout", p)), d && ee(google.maps.event.addListener(j, "mouseover", d)), m && _(google.maps.event.addListener(j, "mouseup", m)), f && M(google.maps.event.addListener(j, "rightclick", f)), g && x(google.maps.event.addListener(j, "click", g)), h && F(google.maps.event.addListener(j, "drag", h)), v(j), C && C(j), () => {
      O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), w && w(j), j.setMap(null);
    };
  }, []), null;
}
ke(mse);
class vse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      polyline: null
    }), ce(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(_p(_p({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: kk,
      eventMap: Pk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: kk,
      eventMap: Pk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), wt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ce(vse, "contextType", nt);
function Sk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tk = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, jk = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function yse(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: S,
    onEdit: E
  } = e, v = De(nt), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null);
  return y(() => {
    O !== null && O.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof s < "u" && O !== null && O.setPaths(s);
  }, [O, s]), y(() => {
    O && typeof a == "function" && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof p == "function" && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(O, "mousemove", p)));
  }, [p]), y(() => {
    O && typeof d == "function" && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(O, "mouseout", d)));
  }, [d]), y(() => {
    O && typeof m == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(O, "mouseover", m)));
  }, [m]), y(() => {
    O && typeof f == "function" && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(O, "mouseup", f)));
  }, [f]), y(() => {
    O && typeof g == "function" && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof h == "function" && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(O, "click", h)));
  }, [h]), y(() => {
    O && typeof C == "function" && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(O, "drag", C)));
  }, [C]), y(() => {
    var B = new google.maps.Polygon(Mk(Mk({}, t), {}, {
      map: v
    }));
    return i && B.setPath(i), s && B.setPaths(s), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), a && L(google.maps.event.addListener(B, "dblclick", a)), l && A(google.maps.event.addListener(B, "dragend", l)), u && V(google.maps.event.addListener(B, "dragstart", u)), c && Z(google.maps.event.addListener(B, "mousedown", c)), p && Y(google.maps.event.addListener(B, "mousemove", p)), d && ee(google.maps.event.addListener(B, "mouseout", d)), m && _(google.maps.event.addListener(B, "mouseover", m)), f && M(google.maps.event.addListener(B, "mouseup", f)), g && x(google.maps.event.addListener(B, "rightclick", g)), h && F(google.maps.event.addListener(B, "click", h)), C && H(google.maps.event.addListener(B, "drag", C)), P(B), w && w(B), () => {
      U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), T !== null && google.maps.event.removeListener(T), S && S(B), B.setMap(null);
    };
  }, []), null;
}
ke(yse);
class bse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = gt({
      updaterMap: jk,
      eventMap: Tk,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: jk,
      eventMap: Tk,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), wt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ce(bse, "contextType", nt);
function _k(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ap(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _k(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _k(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ak = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Bk = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function wse(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: S
  } = e, E = De(nt), [v, O] = D(null), [P, U] = D(null), [L, N] = D(null), [A, z] = D(null), [V, $] = D(null), [Z, J] = D(null), [Y, te] = D(null), [ee, k] = D(null), [_, K] = D(null), [M, G] = D(null), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (P !== null && google.maps.event.removeListener(P), U(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (A !== null && google.maps.event.removeListener(A), z(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (Z !== null && google.maps.event.removeListener(Z), J(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && p && (Y !== null && google.maps.event.removeListener(Y), te(google.maps.event.addListener(v, "mouseout", p)));
  }, [p]), y(() => {
    v && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(v, "mouseover", d)));
  }, [d]), y(() => {
    v && m && (_ !== null && google.maps.event.removeListener(_), K(google.maps.event.addListener(v, "mouseup", m)));
  }, [m]), y(() => {
    v && f && (M !== null && google.maps.event.removeListener(M), G(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && g && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(v, "click", g)));
  }, [g]), y(() => {
    v && h && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var Q = new google.maps.Rectangle(Ap(Ap({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && Q.setVisible(i), typeof o < "u" && Q.setEditable(o), typeof r < "u" && Q.setDraggable(r), typeof n < "u" && Q.setBounds(n), s && U(google.maps.event.addListener(Q, "dblclick", s)), a && N(google.maps.event.addListener(Q, "dragend", a)), l && z(google.maps.event.addListener(Q, "dragstart", l)), u && $(google.maps.event.addListener(Q, "mousedown", u)), c && J(google.maps.event.addListener(Q, "mousemove", c)), p && te(google.maps.event.addListener(Q, "mouseout", p)), d && k(google.maps.event.addListener(Q, "mouseover", d)), m && K(google.maps.event.addListener(Q, "mouseup", m)), f && G(google.maps.event.addListener(Q, "rightclick", f)), g && T(google.maps.event.addListener(Q, "click", g)), h && j(google.maps.event.addListener(Q, "drag", h)), C && B(google.maps.event.addListener(Q, "bounds_changed", C)), O(Q), w && w(Q), () => {
      P !== null && google.maps.event.removeListener(P), L !== null && google.maps.event.removeListener(L), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), x !== null && google.maps.event.removeListener(x), F !== null && google.maps.event.removeListener(F), H !== null && google.maps.event.removeListener(H), S && S(Q), Q.setMap(null);
    };
  }, []), null;
}
ke(wse);
class Cse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      rectangle: null
    }), ce(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Ap(Ap({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: Bk,
      eventMap: Ak,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: Bk,
      eventMap: Ak,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), wt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ce(Cse, "contextType", nt);
function Ik(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ik(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ik(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rk = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Nk = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Ose = {};
function Ese(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: S,
    onLoad: E,
    onUnmount: v
  } = e, O = De(nt), [P, U] = D(null), [L, N] = D(null), [A, z] = D(null), [V, $] = D(null), [Z, J] = D(null), [Y, te] = D(null), [ee, k] = D(null), [_, K] = D(null), [M, G] = D(null), [x, T] = D(null), [F, j] = D(null), [H, B] = D(null), [Q, W] = D(null), [ue, ye] = D(null);
  return y(() => {
    P !== null && P.setMap(O);
  }, [O]), y(() => {
    typeof t < "u" && P !== null && P.setOptions(t);
  }, [P, t]), y(() => {
    typeof o < "u" && P !== null && P.setDraggable(o);
  }, [P, o]), y(() => {
    typeof i < "u" && P !== null && P.setEditable(i);
  }, [P, i]), y(() => {
    typeof s < "u" && P !== null && P.setVisible(s);
  }, [P, s]), y(() => {
    typeof r == "number" && P !== null && P.setRadius(r);
  }, [P, r]), y(() => {
    typeof n < "u" && P !== null && P.setCenter(n);
  }, [P, n]), y(() => {
    P && a && (L !== null && google.maps.event.removeListener(L), N(google.maps.event.addListener(P, "dblclick", a)));
  }, [a]), y(() => {
    P && l && (A !== null && google.maps.event.removeListener(A), z(google.maps.event.addListener(P, "dragend", l)));
  }, [l]), y(() => {
    P && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(P, "dragstart", u)));
  }, [u]), y(() => {
    P && c && (Z !== null && google.maps.event.removeListener(Z), J(google.maps.event.addListener(P, "mousedown", c)));
  }, [c]), y(() => {
    P && p && (Y !== null && google.maps.event.removeListener(Y), te(google.maps.event.addListener(P, "mousemove", p)));
  }, [p]), y(() => {
    P && d && (ee !== null && google.maps.event.removeListener(ee), k(google.maps.event.addListener(P, "mouseout", d)));
  }, [d]), y(() => {
    P && m && (_ !== null && google.maps.event.removeListener(_), K(google.maps.event.addListener(P, "mouseover", m)));
  }, [m]), y(() => {
    P && f && (M !== null && google.maps.event.removeListener(M), G(google.maps.event.addListener(P, "mouseup", f)));
  }, [f]), y(() => {
    P && g && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(P, "rightclick", g)));
  }, [g]), y(() => {
    P && h && (F !== null && google.maps.event.removeListener(F), j(google.maps.event.addListener(P, "click", h)));
  }, [h]), y(() => {
    P && C && (H !== null && google.maps.event.removeListener(H), B(google.maps.event.addListener(P, "drag", C)));
  }, [C]), y(() => {
    P && w && (Q !== null && google.maps.event.removeListener(Q), W(google.maps.event.addListener(P, "center_changed", w)));
  }, [h]), y(() => {
    P && S && (ue !== null && google.maps.event.removeListener(ue), ye(google.maps.event.addListener(P, "radius_changed", S)));
  }, [S]), y(() => {
    var oe = new google.maps.Circle(Bp(Bp({}, t || Ose), {}, {
      map: O
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof s < "u" && oe.setVisible(s), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), a && N(google.maps.event.addListener(oe, "dblclick", a)), l && z(google.maps.event.addListener(oe, "dragend", l)), u && $(google.maps.event.addListener(oe, "dragstart", u)), c && J(google.maps.event.addListener(oe, "mousedown", c)), p && te(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), m && K(google.maps.event.addListener(oe, "mouseover", m)), f && G(google.maps.event.addListener(oe, "mouseup", f)), g && T(google.maps.event.addListener(oe, "rightclick", g)), h && j(google.maps.event.addListener(oe, "click", h)), C && B(google.maps.event.addListener(oe, "drag", C)), w && W(google.maps.event.addListener(oe, "center_changed", w)), S && ye(google.maps.event.addListener(oe, "radius_changed", S)), U(oe), E && E(oe), () => {
      L !== null && google.maps.event.removeListener(L), A !== null && google.maps.event.removeListener(A), V !== null && google.maps.event.removeListener(V), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), x !== null && google.maps.event.removeListener(x), F !== null && google.maps.event.removeListener(F), Q !== null && google.maps.event.removeListener(Q), ue !== null && google.maps.event.removeListener(ue), v && v(oe), oe.setMap(null);
    };
  }, []), null;
}
ke(Ese);
class xse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      circle: null
    }), ce(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Bp(Bp({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: Nk,
      eventMap: Rk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: Nk,
      eventMap: Rk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), wt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ce(xse, "contextType", nt);
function Fk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ip(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zk = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, $k = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Lse(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, C = De(nt), [w, S] = D(null), [E, v] = D(null), [O, P] = D(null), [U, L] = D(null), [N, A] = D(null), [z, V] = D(null), [$, Z] = D(null), [J, Y] = D(null), [te, ee] = D(null), [k, _] = D(null), [K, M] = D(null), [G, x] = D(null), [T, F] = D(null), [j, H] = D(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (O !== null && google.maps.event.removeListener(O), P(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (U !== null && google.maps.event.removeListener(U), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (N !== null && google.maps.event.removeListener(N), A(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (z !== null && google.maps.event.removeListener(z), V(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && ($ !== null && google.maps.event.removeListener($), Z(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (J !== null && google.maps.event.removeListener(J), Y(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (te !== null && google.maps.event.removeListener(te), ee(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && p && (K !== null && google.maps.event.removeListener(K), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), y(() => {
    w && d && (G !== null && google.maps.event.removeListener(G), x(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), y(() => {
    w && m && (T !== null && google.maps.event.removeListener(T), F(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), y(() => {
    w && f && (j !== null && google.maps.event.removeListener(j), H(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var B = new google.maps.Data(Ip(Ip({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(B, "dblclick", r)), o && P(google.maps.event.addListener(B, "mousedown", o)), i && L(google.maps.event.addListener(B, "mousemove", i)), s && A(google.maps.event.addListener(B, "mouseout", s)), a && V(google.maps.event.addListener(B, "mouseover", a)), l && Z(google.maps.event.addListener(B, "mouseup", l)), u && Y(google.maps.event.addListener(B, "rightclick", u)), n && ee(google.maps.event.addListener(B, "click", n)), c && _(google.maps.event.addListener(B, "addfeature", c)), p && M(google.maps.event.addListener(B, "removefeature", p)), d && x(google.maps.event.addListener(B, "removeproperty", d)), m && F(google.maps.event.addListener(B, "setgeometry", m)), f && H(google.maps.event.addListener(B, "setproperty", f)), S(B), g && g(B);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), U !== null && google.maps.event.removeListener(U), N !== null && google.maps.event.removeListener(N), z !== null && google.maps.event.removeListener(z), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), k !== null && google.maps.event.removeListener(k), K !== null && google.maps.event.removeListener(K), G !== null && google.maps.event.removeListener(G), T !== null && google.maps.event.removeListener(T), j !== null && google.maps.event.removeListener(j), h && h(w), w.setMap(null));
    };
  }, []), null;
}
ke(Lse);
class Dse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      data: null
    }), ce(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Ip(Ip({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = gt({
        updaterMap: $k,
        eventMap: zk,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: $k,
      eventMap: zk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), wt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ce(Dse, "contextType", nt);
function Uk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Uk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Uk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vk = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Hk = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Pse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      kmlLayer: null
    }), ce(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(Wk(Wk({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: Hk,
      eventMap: Vk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: Hk,
      eventMap: Vk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), wt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(Pse, "contextType", nt);
function NB(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function kse(e, t) {
  return new t(e.lat, e.lng);
}
function Sse(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Mse(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Tse(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function jse(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function _se(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function FB(e, t, n, r) {
  return n !== void 0 ? jse(e, t, Tse(n, google.maps.LatLngBounds, Sse)) : _se(e, t, Mse(r, google.maps.LatLng, kse));
}
function Ase(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function qk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bse(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Ise(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = Bse({}, this.container ? NB(this.container, o) : {
        x: 0,
        y: 0
      }), u = FB(a, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Zk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rse(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Zk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Zk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Kk(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Gk(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Nse(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = De(nt), c = Gn(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = Gn(() => Ise(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(p), p == null || p.setMap(u), () => {
    s == null || s(p), p == null || p.setMap(null);
  }), [u, p]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ke(Nse);
class Xs extends Oe {
  constructor(t) {
    super(t), ce(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ce(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      er(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ce(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ce(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Rse({
        x: 0,
        y: 0
      }, this.containerRef.current ? NB(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = FB(r, o, this.props.bounds, this.props.position);
      if (!Ase(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ce(this, "draw", () => {
      this.onPositionElement();
    }), ce(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = cr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = Kk(t.position), r = Kk(this.props.position), o = Gk(t.bounds), i = Gk(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(q.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ct.only(this.props.children)
    }), t) : null;
  }
}
ce(Xs, "FLOAT_PANE", "floatPane");
ce(Xs, "MAP_PANE", "mapPane");
ce(Xs, "MARKER_LAYER", "markerLayer");
ce(Xs, "OVERLAY_LAYER", "overlayLayer");
ce(Xs, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ce(Xs, "contextType", nt);
function Fse() {
}
function Yk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yk(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Jk = {
  onDblClick: "dblclick",
  onClick: "click"
}, Qk = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function zse(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = De(nt), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Gn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
ke(zse);
class zB extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      groundOverlay: null
    }), ce(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    er(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Xk(Xk({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: Qk,
      eventMap: Jk,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: Qk,
      eventMap: Jk,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ce(zB, "defaultProps", {
  onLoad: Fse
});
ce(zB, "contextType", nt);
function eS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eS(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tS = {}, nS = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function $se(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = De(nt), [s, a] = D(null);
  return y(() => {
    google.maps.visualization || er(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    er(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(Rp(Rp({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
ke($se);
class Use extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      heatmapLayer: null
    }), ce(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    er(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), er(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Rp(Rp({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = gt({
      updaterMap: nS,
      eventMap: tS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: nS,
      eventMap: tS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), wt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(Use, "contextType", nt);
var rS = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, oS = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Wse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      streetViewPanorama: null
    }), ce(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = gt({
      updaterMap: oS,
      eventMap: rS,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: oS,
      eventMap: rS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), wt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ce(Wse, "contextType", nt);
class Vse extends Oe {
  constructor() {
    super(...arguments), ce(this, "state", {
      streetViewService: null
    }), ce(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ce(Vse, "contextType", nt);
var iS = {
  onDirectionsChanged: "directions_changed"
}, sS = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Hse extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      directionsRenderer: null
    }), ce(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = gt({
      updaterMap: sS,
      eventMap: iS,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: sS,
      eventMap: iS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), wt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(Hse, "contextType", nt);
var aS = {
  onPlacesChanged: "places_changed"
}, lS = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class $B extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "containerElement", cr()), ce(this, "state", {
      searchBox: null
    }), ce(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (er(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = gt({
          updaterMap: lS,
          eventMap: aS,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: lS,
      eventMap: aS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), wt(this.registeredEvents));
  }
  render() {
    return q.jsx("div", {
      ref: this.containerElement,
      children: Ct.only(this.props.children)
    });
  }
}
ce($B, "contextType", nt);
var uS = {
  onPlaceChanged: "place_changed"
}, cS = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class UB extends Oe {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "containerElement", cr()), ce(this, "state", {
      autocomplete: null
    }), ce(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    er(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = gt({
        updaterMap: cS,
        eventMap: uS,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    wt(this.registeredEvents), this.registeredEvents = gt({
      updaterMap: cS,
      eventMap: uS,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && wt(this.registeredEvents);
  }
  render() {
    return q.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ct.only(this.props.children)
    });
  }
}
ce(UB, "defaultProps", {
  className: ""
});
ce(UB, "contextType", nt);
function Mle({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ q.jsx(
    TB,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function Tle(e) {
  const { children: t = !1 } = e, [n, r] = D([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function s(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function a(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ q.jsx(
    wb.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: s, closeModal: a, closeAll: l },
      children: t
    }
  );
}
let qse = { data: "" }, Zse = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || qse, Kse = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Gse = /\/\*[^]*?\*\/|  +/g, pS = /\n+/g, pi = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? pi(s, i) : i + "{" + pi(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += pi(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += pi.p ? pi.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, So = {}, WB = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + WB(e[n]);
    return t;
  }
  return e;
}, Yse = (e, t, n, r, o) => {
  let i = WB(e), s = So[i] || (So[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!So[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Kse.exec(u.replace(Gse, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(pS, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(pS, " ").trim();
      return d[0];
    })(e);
    So[s] = pi(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && So.g ? So.g : null;
  return n && (So.g = So[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(So[s], t, r, a), s;
}, Xse = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : pi(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function wf(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Yse(n.unshift ? n.raw ? Xse(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Zse(t.target), t.g, t.o, t.k);
}
let VB, qm, Zm;
wf.bind({ g: 1 });
let No = wf.bind({ k: 1 });
function Jse(e, t, n, r) {
  pi.p = t, VB = e, qm = n, Zm = r;
}
function Ti(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: qm && qm() }, a), n.o = / *go\d+/.test(l), a.className = wf.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Zm && u[0] && Zm(a), VB(u, a);
    }
    return o;
  };
}
var Qse = (e) => typeof e == "function", Np = (e, t) => Qse(e) ? e(t) : e, eae = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), HB = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), tae = 20, Oc = /* @__PURE__ */ new Map(), nae = 1e3, dS = (e) => {
  if (Oc.has(e)) return;
  let t = setTimeout(() => {
    Oc.delete(e), Es({ type: 4, toastId: e });
  }, nae);
  Oc.set(e, t);
}, rae = (e) => {
  let t = Oc.get(e);
  t && clearTimeout(t);
}, Km = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, tae) };
    case 1:
      return t.toast.id && rae(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? Km(e, { type: 1, toast: n }) : Km(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? dS(r) : e.toasts.forEach((i) => {
        dS(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, Ec = [], xc = { toasts: [], pausedAt: void 0 }, Es = (e) => {
  xc = Km(xc, e), Ec.forEach((t) => {
    t(xc);
  });
}, oae = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, iae = (e = {}) => {
  let [t, n] = D(xc);
  y(() => (Ec.push(n), () => {
    let o = Ec.indexOf(n);
    o > -1 && Ec.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, s;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || oae[o.type], style: { ...e.style, ...(s = e[o.type]) == null ? void 0 : s.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, sae = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || eae() }), Gl = (e) => (t, n) => {
  let r = sae(t, e, n);
  return Es({ type: 2, toast: r }), r.id;
}, Fr = (e, t) => Gl("blank")(e, t);
Fr.error = Gl("error");
Fr.success = Gl("success");
Fr.loading = Gl("loading");
Fr.custom = Gl("custom");
Fr.dismiss = (e) => {
  Es({ type: 3, toastId: e });
};
Fr.remove = (e) => Es({ type: 4, toastId: e });
Fr.promise = (e, t, n) => {
  let r = Fr.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (Fr.success(Np(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    Fr.error(Np(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var aae = (e, t) => {
  Es({ type: 1, toast: { id: e, height: t } });
}, lae = () => {
  Es({ type: 5, time: Date.now() });
}, uae = (e) => {
  let { toasts: t, pausedAt: n } = iae(e);
  y(() => {
    if (n) return;
    let i = Date.now(), s = t.map((a) => {
      if (a.duration === 1 / 0) return;
      let l = (a.duration || 0) + a.pauseDuration - (i - a.createdAt);
      if (l < 0) {
        a.visible && Fr.dismiss(a.id);
        return;
      }
      return setTimeout(() => Fr.dismiss(a.id), l);
    });
    return () => {
      s.forEach((a) => a && clearTimeout(a));
    };
  }, [t, n]);
  let r = qt(() => {
    n && Es({ type: 6, time: Date.now() });
  }, [n]), o = qt((i, s) => {
    let { reverseOrder: a = !1, gutter: l = 8, defaultPosition: u } = s || {}, c = t.filter((m) => (m.position || u) === (i.position || u) && m.height), p = c.findIndex((m) => m.id === i.id), d = c.filter((m, f) => f < p && m.visible).length;
    return c.filter((m) => m.visible).slice(...a ? [d + 1] : [0, d]).reduce((m, f) => m + (f.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: aae, startPause: lae, endPause: r, calculateOffset: o } };
}, cae = No`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, pae = No`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, dae = No`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, fae = Ti("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${cae} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${pae} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${dae} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, hae = No`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, gae = Ti("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${hae} 1s linear infinite;
`, mae = No`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, vae = No`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, yae = Ti("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${mae} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${vae} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, bae = Ti("div")`
  position: absolute;
`, wae = Ti("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Cae = No`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Oae = Ti("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Cae} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Eae = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? We.createElement(Oae, null, t) : t : n === "blank" ? null : We.createElement(wae, null, We.createElement(gae, { ...r }), n !== "loading" && We.createElement(bae, null, n === "error" ? We.createElement(fae, { ...r }) : We.createElement(yae, { ...r })));
}, xae = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, Lae = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Dae = "0%{opacity:0;} 100%{opacity:1;}", Pae = "0%{opacity:1;} 100%{opacity:0;}", kae = Ti("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Sae = Ti("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Mae = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = HB() ? [Dae, Pae] : [xae(n), Lae(n)];
  return { animation: t ? `${No(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${No(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, Tae = We.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Mae(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = We.createElement(Eae, { toast: e }), s = We.createElement(Sae, { ...e.ariaProps }, Np(e.message, e));
  return We.createElement(kae, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : We.createElement(We.Fragment, null, i, s));
});
Jse(We.createElement);
var jae = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = We.useCallback((s) => {
    if (s) {
      let a = () => {
        let l = s.getBoundingClientRect().height;
        r(e, l);
      };
      a(), new MutationObserver(a).observe(s, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return We.createElement("div", { ref: i, className: t, style: n }, o);
}, _ae = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: HB() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, Aae = wf`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, dc = 16, Bae = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: s }) => {
  let { toasts: a, handlers: l } = uae(n);
  return We.createElement("div", { style: { position: "fixed", zIndex: 9999, top: dc, left: dc, right: dc, bottom: dc, pointerEvents: "none", ...i }, className: s, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, a.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = _ae(c, p);
    return We.createElement(jae, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? Aae : "", style: d }, u.type === "custom" ? Np(u.message, u) : o ? o(u) : We.createElement(Tae, { toast: u, position: c }));
  }));
}, fS = Fr;
function jle({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return fS.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return fS.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ q.jsxs(EB.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ q.jsx(
      Bae,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function Iae({ children: e, fallback: t = null }) {
  return iie() ? /* @__PURE__ */ q.jsx(q.Fragment, { children: e() }) : /* @__PURE__ */ q.jsx(q.Fragment, { children: t });
}
function _le({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ q.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ q.jsx(
    vie,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ q.jsx(jB, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ q.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ q.jsx(fI, {}) });
}
function Ale({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = D(null), s = (l) => i(l), a = () => {
    var m, f, g, h;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(C) {
      const w = c.find((S) => S.types[0] === C);
      return w ? w.long_name : "";
    }
    function d(C) {
      const w = c.find((S) => S.types[0] === C);
      return w ? w.short_name : "";
    }
    if (u) {
      const C = p("route"), w = p("street_number"), S = p("sublocality_level_1"), E = p("administrative_area_level_2"), v = p("administrative_area_level_1"), O = d("administrative_area_level_1"), P = p("postal_code"), U = (f = (m = u.geometry) == null ? void 0 : m.location) == null ? void 0 : f.lat(), L = (h = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : h.lng();
      t && t({
        street: C,
        city: E,
        state: v,
        district: S,
        cep: P,
        streetNumber: w,
        stateShortName: O,
        coordinates: { lat: U, lng: L }
      });
    }
  };
  return /* @__PURE__ */ q.jsx(
    $B,
    {
      onLoad: s,
      onPlacesChanged: a,
      options: n,
      children: /* @__PURE__ */ q.jsx(uf, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function qB(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function Rae(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: s } = e, a = `&gtm_auth=${s}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${a}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${a}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = qB({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let Nae = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = Rae(t), r = () => {
      const s = document.createElement("noscript");
      return s.innerHTML = n.iframe, s;
    }, o = () => {
      const s = document.createElement("script");
      return s.innerHTML = n.script, s;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = qB({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: s = "",
      dataLayerName: a = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: a,
      auth: i,
      preview: s
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function Fae(e) {
  return new Nae().initialize(e), /* @__PURE__ */ q.jsx(q.Fragment, {});
}
function Ile(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: s = {}
  } = e;
  return /* @__PURE__ */ q.jsx(Iae, { children: () => /* @__PURE__ */ q.jsx(
    Fae,
    {
      auth: n,
      dataLayer: s,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  qae as AlertContainer,
  Zae as AlertContent,
  Kae as AlertDescription,
  Gae as AlertIcon,
  yI as AlertTitle,
  lle as AudioUpload,
  Qae as Badge,
  yle as BreadcrumbContainer,
  ble as BreadcrumbLink,
  Dp as Button,
  ele as Card,
  ule as Checkbox,
  Iae as ClientOnly,
  tle as Divider,
  Cle as DrawerContainer,
  Ole as DrawerHeader,
  kle as DrawerProvider,
  kD as FormController,
  cle as FormError,
  SD as FormLabel,
  _le as GoogleMap,
  Mle as GoogleProvider,
  Ale as GoogleSearchPlaces,
  Ile as GoogleTagManager,
  YJ as IconButton,
  nQ as ImageUpload,
  uf as Input,
  $ne as ModalContainer,
  Une as ModalFooter,
  Wne as ModalHeader,
  Tle as ModalProvider,
  ple as MultiSelect,
  wle as Pagination,
  Ele as Popover,
  fle as RadioBox,
  dle as RadioGroup,
  hle as RichText,
  gle as Select,
  nle as Skeleton,
  ZJ as Slider,
  mle as Switch,
  gP as TabButton,
  Hne as TabContainer,
  rle as TableBody,
  ole as TableCaption,
  ile as TableContainer,
  sle as TableFooter,
  ale as TableHeader,
  vle as Textarea,
  xle as Toast,
  jle as ToastProvider,
  XJ as Tooltip,
  Yae as getHtmlFromRichTextValue,
  Xae as getRichTextValueFromHtml,
  Jae as isHtml,
  nM as morpheme,
  Lle as useAutomation,
  Dle as useDrawer,
  aA as useFieldErrors,
  Tr as useFormController,
  iie as useHydrated,
  Ple as useModal,
  eB as useScopedParams,
  rie as useToast
};
